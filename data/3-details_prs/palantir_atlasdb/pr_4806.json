{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzOTAyMzE1", "number": 4806, "title": "[LW] Client side event cache", "bodyText": "This PR depends on #4811 and should not be merged before.\nGoals (and why):\nProvide a means for the client to get a mapping from start timestamp to version for a batch of transactions. Contains all the underlying implementation associated with this - client side\nmapping from timestamp to known version for that timestamp, client side mapping from version to event that occurred at that version, and client side snapshot updater.\nImplementation Description (bullets):\n\nProvided a concrete implementation for LockWatchEventCache interface; this uses two main data structures: a TreeMap to store mapping from start timestamp to version, commit timestamp, commit-time version, and commit lock token (the last three provided when the commit update is processed), and a TreeMultimap which contains a mapping from version to all timestamps with that version\nThe multimap allows us to easily keep track of the oldest still in-flight version; this is passed down to the ClientLockWatchEventLog to tell it to age out old entries (which are used to update the snapshot).\nClientLockWatchEventLog contains the mapping from version to event, using a TreeMap to allow for easy range lookups. Old entries are passed to the snapshotter to update, then are deleted.\nTransactionsLockWatchEvents has been reworked - no longer requires a visitor, as a snapshot just sets the first element to a LockWatchCreatedEvent which is sufficient to re-seed the cache on the atlasdb-proxy side.\n\nTesting (What was existing testing like?  What have you done to improve it?):\nUnit tests added for each concrete implementation.\nConcerns (what feedback would you like?):\n\nDo we leave ourselves open to any race conditions? Everything is synchronised, so I do not think so.\nAre there any ways that we can have a memory leak?\nDoes this expose the necessary operations that we will need? Are there methods that are missing?\nWill this be performant enough?\nLockWatchEventCacheImpl is pretty beefy; any thoughts as to how or if we should reduce its size?\n\nWhere should we start reviewing?:\n\nLockWatchEventCacheImpl\nClientLockWatchEventLogImpl\nClientLockWatchSnapshotUpdaterImpl\n\nPriority (whenever / two weeks / yesterday):\nThis week (beginning 01/06).", "createdAt": "2020-05-27T14:43:16Z", "url": "https://github.com/palantir/atlasdb/pull/4806", "merged": true, "mergeCommit": {"oid": "4f949bb68f78f4a53a0a2df4984bad6977c71b98"}, "closed": true, "closedAt": "2020-06-22T14:19:34Z", "author": {"login": "Jolyon-S"}, "timelineItems": {"totalCount": 198, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnTuwsAH2gAyNDIzOTAyMzE1OjE2NmQxZTVhMDgxY2I4MDBkN2YyYmUwMTBhZDc5NmU2MGU0ZWZhNWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABctxcf4gH2gAyNDIzOTAyMzE1OjFhMjZkOTE3NDRiYTUyMDcwN2Y2MTRmYzk1NWMwZmQzYWVmMzY5MGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/166d1e5a081cb800d7f2be010ad796e60e4efa5c", "committedDate": "2020-06-02T12:08:24Z", "message": "even more synchreo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjEwNzkw", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422610790", "createdAt": "2020-06-02T12:09:13Z", "commit": {"oid": "b37f0b3357c7717268efec75c15489a0f74be40a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjowOToxM1rOGduq-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjowOToxM1rOGduq-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyNjU1Mw==", "bodyText": "I think this needs a fix, for in-memory: you need to put dummy values into startTsToSequence for the passed transactions. Otherwise, atlasdb-proxy will start throwing.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433826553", "createdAt": "2020-06-02T12:09:13Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -19,15 +19,13 @@\n import java.util.Collection;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.UUID;\n-\n-import com.google.common.collect.ImmutableSet;\n \n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n+    private static final TransactionsLockWatchEvents NONE = ImmutableTransactionsLockWatchEvents.builder()\n+            .clearCache(true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37f0b3357c7717268efec75c15489a0f74be40a"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjEzNzgw", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422613780", "createdAt": "2020-06-02T12:13:23Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoxMzoyM1rOGduzug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoxMzoyM1rOGduzug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyODc5NA==", "bodyText": "The return type here feels wrong: why are you returning a builder?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433828794", "createdAt": "2020-06-02T12:13:23Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -16,17 +16,12 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n import java.util.Optional;\n-import java.util.Set;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+public interface ClientLockWatchEventLog {\n+    ImmutableTransactionsLockWatchEvents.Builder getEventsBetweenVersions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjE1Njg4", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422615688", "createdAt": "2020-06-02T12:16:10Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoxNjoxMFrOGdu5Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoxNjoxMFrOGdu5Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMDIwNw==", "bodyText": "Going to read through these later, but given my gut feeling that these 2 classes will be rather coupled, would be good to have a single integration test that tests it end to end.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433830207", "createdAt": "2020-06-02T12:16:10Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/test/java/com/palantir/lock/watch/ClientLockWatchEventLogImplTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.v2.LockToken;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class ClientLockWatchEventLogImplTest {\n+    private static final UUID LEADER = UUID.randomUUID();\n+    private static final IdentifiedVersion VERSION_1 = IdentifiedVersion.of(LEADER, 17L);\n+    private static final IdentifiedVersion VERSION_2 = IdentifiedVersion.of(LEADER, 25L);\n+    private static final LockWatchEvent EVENT_1 =\n+            LockEvent.builder(ImmutableSet.of(), LockToken.of(UUID.randomUUID())).build(17L);\n+    private static final LockWatchEvent EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(), LockToken.of(UUID.randomUUID())).build(25L);\n+    private static final LockWatchStateUpdate.Snapshot SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(VERSION_1.id(), VERSION_1.version(), ImmutableSet.of(), ImmutableSet.of());\n+    private static final LockWatchStateUpdate.Success SUCCESS =\n+            LockWatchStateUpdate.success(VERSION_2.id(), VERSION_2.version(), ImmutableList.of(EVENT_1, EVENT_2));\n+    private static final LockWatchStateUpdate.Failed FAILED =\n+            LockWatchStateUpdate.failed(LEADER);\n+\n+    @Mock\n+    private ClientLockWatchSnapshotUpdater snapshotUpdater;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjE5NDcx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422619471", "createdAt": "2020-06-02T12:21:21Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoyMToyMVrOGdvEEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoyMToyMVrOGdvEEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzMjk3Nw==", "bodyText": "So I understand that you added this in response to @j-baker comment, but I think as it is it's not really adding much value, beyond detecting a failure and not letting yourself continue to get corrupted. I quite like the defensiveness here in case we have bugs, but I think you need to finish the stroke and switch to a NoOpCache at runtime.\nAlso, I would argue this will be implemented cleaner as FailureCheckingLockWatchEventCache, as a proxy.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433832977", "createdAt": "2020-06-02T12:21:21Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            final ProcessingVisitor visitor;\n+            if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+                visitor = new NewLeaderVisitor();\n+            } else {\n+                visitor = new ProcessingVisitor();\n+            }\n+            update.accept(visitor);\n+        });\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        ensureNotFailed(() -> {\n+            Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                    eventMap.headMap(earliestVersion.version()).entrySet();\n+            snapshotUpdater.processEvents(\n+                    eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+            eventsToBeRemoved.clear();\n+        });\n+    }\n+\n+    /**\n+     * @param startVersion latest version that the client knows about; should be before timestamps in the mapping;\n+     * @param endVersion   mapping from timestamp to identified version from client-side event cache;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized ImmutableTransactionsLockWatchEvents.Builder getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        checkNotFailed();\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ImmutableTransactionsLockWatchEvents.Builder eventBuilder = ImmutableTransactionsLockWatchEvents.builder();\n+        List<LockWatchEvent> events = new ArrayList<>();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            events.add(LockWatchCreatedEvent.fromSnapshot(snapshotUpdater.getSnapshot(currentVersion)));\n+            fromSequence = eventMap.firstKey();\n+            eventBuilder.clearCache(true);\n+        } else {\n+            fromSequence = versionInclusive.get().version();\n+            eventBuilder.clearCache(false);\n+        }\n+\n+        events.addAll(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.events(events);\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        checkNotFailed();\n+        return latestVersion;\n+    }\n+\n+    private synchronized void ensureNotFailed(Runnable runnable) {\n+        checkNotFailed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjIxMDk2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422621096", "createdAt": "2020-06-02T12:23:41Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoyMzo0MVrOGdvIsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoyMzo0MVrOGdvIsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzNDE2Mg==", "bodyText": "Similarly to previous comments, you probably want this implemented just once and poison the entire thing.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433834162", "createdAt": "2020-06-02T12:23:41Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjI4MTIy", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422628122", "createdAt": "2020-06-02T12:33:03Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjozMzowM1rOGdvc5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjozMzowM1rOGdvc5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgzOTMzMw==", "bodyText": "I don't feel like this comparator should be here: it's a pretty specific assumption/underlying design decision in your LockWatchEventCacheImpl, so should be implemented there.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433839333", "createdAt": "2020-06-02T12:33:03Z", "author": {"login": "jkozlowski"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    static Comparator<IdentifiedVersion> comparator() {\n+        return (version1, version2) -> {\n+            Preconditions.checkArgument(version1.id().equals(version2.id()), \"Versions do not have same leader id\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjMyMTk0", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422632194", "createdAt": "2020-06-02T12:38:30Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/355f5e2029025c9ee5a89497eab6c6d8c96f7dcb", "committedDate": "2020-06-02T12:46:25Z", "message": "use proxy with event cache instad of implementing with methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjM5MzE5", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422639319", "createdAt": "2020-06-02T12:47:37Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo0NzozN1rOGdv-LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo0NzozN1rOGdv-LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0Nzg1Mw==", "bodyText": "Is this the only case here? I feel like there's a legitimate case of \"leader switched\", in which case you should throw an exception that will cause the transaction to retry.\nPlease review all places that you throw here and probably introduce some custom exceptions that extend TransactionFailedRetriableException.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433847853", "createdAt": "2020-06-02T12:47:37Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(\n+                    version -> startTimestamps.forEach(timestamp -> {\n+                        timestampMap.put(timestamp, MapEntry.of(version));\n+                        aliveVersions.put(version, timestamp);\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(version ->\n+                    transactionUpdates.forEach(transactionUpdate -> {\n+                        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                        Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");\n+                        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                                CommitInfo.of(transactionUpdate.commitTs(),\n+                                        transactionUpdate.writesToken(),\n+                                        version)));\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs) {\n+        checkNotFailed();\n+        MapEntry entry = timestampMap.get(startTs);\n+        Preconditions.checkState(entry.commitInfo().isPresent(), \"Commit timestamp update not yet processed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjQwMzgz", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422640383", "createdAt": "2020-06-02T12:48:58Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo0ODo1OFrOGdwBNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo0ODo1OFrOGdwBNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0ODYzMQ==", "bodyText": "What if this returns null? I feel like there's a legitimate case of \"leader switched therefore I nuked all my state\", in which case you should throw an exception that will cause the transaction to retry.\nPlease review all places that you throw here and probably introduce some custom exceptions that extend TransactionFailedRetriableException.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433848631", "createdAt": "2020-06-02T12:48:58Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(\n+                    version -> startTimestamps.forEach(timestamp -> {\n+                        timestampMap.put(timestamp, MapEntry.of(version));\n+                        aliveVersions.put(version, timestamp);\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(version ->\n+                    transactionUpdates.forEach(transactionUpdate -> {\n+                        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                        Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");\n+                        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                                CommitInfo.of(transactionUpdate.commitTs(),\n+                                        transactionUpdate.writesToken(),\n+                                        version)));\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs) {\n+        checkNotFailed();\n+        MapEntry entry = timestampMap.get(startTs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjQ0MTcx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422644171", "createdAt": "2020-06-02T12:53:37Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1MzozOFrOGdwMYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1MzozOFrOGdwMYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MTQ4OQ==", "bodyText": "I think you should make this whole class use synchronized on all it's methods, and not bother with synchronized everywhere else, feels to me like unnecessary noise.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433851489", "createdAt": "2020-06-02T12:53:38Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjQ1NDY2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422645466", "createdAt": "2020-06-02T12:55:03Z", "commit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1NTowNFrOGdwPvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1NTowNFrOGdwPvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MjM0OA==", "bodyText": "This should hopefully go away once we get rid of Failure case in the timelock API.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433852348", "createdAt": "2020-06-02T12:55:04Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshotUpdater.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.List;\n+\n+public interface ClientLockWatchSnapshotUpdater {\n+    LockWatchStateUpdate.Snapshot getSnapshot(IdentifiedVersion identifiedVersion);\n+    void processEvents(List<LockWatchEvent> events);\n+    void resetWithSnapshot(LockWatchStateUpdate.Snapshot snapshot);\n+    void reset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "166d1e5a081cb800d7f2be010ad796e60e4efa5c"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjQ2OTY3", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422646967", "createdAt": "2020-06-02T12:56:45Z", "commit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1Njo0NVrOGdwT3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1Njo0NVrOGdwT3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MzQwNg==", "bodyText": "Now that you have this proxy, perhaps you can remove sychronized everywhere else?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433853406", "createdAt": "2020-06-02T12:56:45Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+\n+public final class FailureCheckingLockWatchEventCache extends AbstractInvocationHandler {\n+\n+    public static LockWatchEventCache newProxyInstance(LockWatchEventCache defaultCache) {\n+        return (LockWatchEventCache) Proxy.newProxyInstance(\n+                LockWatchEventCache.class.getClassLoader(),\n+                new Class<?>[] {LockWatchEventCache.class},\n+                new FailureCheckingLockWatchEventCache(defaultCache));\n+    }\n+\n+    private final LockWatchEventCache defaultCache;\n+    private final LockWatchEventCache noOpCache;\n+\n+    @GuardedBy(\"this\")\n+    private boolean hasFailed = false;\n+\n+    private FailureCheckingLockWatchEventCache(LockWatchEventCache defaultCache) {\n+        this.defaultCache = defaultCache;\n+        this.noOpCache = NoOpLockWatchEventCache.INSTANCE;\n+    }\n+\n+    @Override\n+    protected synchronized Object handleInvocation(Object proxy, Method method, Object[] args) throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjQ4Mzc4", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422648378", "createdAt": "2020-06-02T12:58:25Z", "commit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1ODoyNVrOGdwXwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjo1ODoyNVrOGdwXwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDQwMg==", "bodyText": "This constructor should ideally return LockWatchEventCache and be already wrapped in the FailureDetecting thing", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433854402", "createdAt": "2020-06-02T12:58:25Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c1e82d4b57d44af79ca61d308a9c1a4e0a5fb6c", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/3c1e82d4b57d44af79ca61d308a9c1a4e0a5fb6c", "committedDate": "2020-06-02T13:03:10Z", "message": "Remove builder return type"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjUzMDI5", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422653029", "createdAt": "2020-06-02T13:03:41Z", "commit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMzo0MlrOGdwkpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowMzo0MlrOGdwkpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcwMA==", "bodyText": "I feel you might want to have a separate class that manipulates these 2 datastructures in tandem, separate from this class which orchestrates all the datastructures.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433857700", "createdAt": "2020-06-02T13:03:42Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjU0MjUz", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422654253", "createdAt": "2020-06-02T13:05:08Z", "commit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowNTowOFrOGdwoLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzowNTowOFrOGdwoLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1ODYwNQ==", "bodyText": "You probably want:\nOptional.ofNullable(timestampMap.remove(startTimestamp)).ifPresent(entry -> {\n  aliveVersions.remove(...);\n});", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433858605", "createdAt": "2020-06-02T13:05:08Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> {\n+                    timestampMap.put(timestamp, MapEntry.of(version));\n+                    aliveVersions.put(version, timestamp);\n+                }));\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version ->\n+                transactionUpdates.forEach(transactionUpdate -> {\n+                    MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                    Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");\n+                    timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                            CommitInfo.of(transactionUpdate.commitTs(),\n+                                    transactionUpdate.writesToken(),\n+                                    version)));\n+                }));\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs) {\n+        MapEntry entry = timestampMap.get(startTs);\n+        Preconditions.checkState(entry.commitInfo().isPresent(), \"Commit timestamp update not yet processed\");\n+        CommitInfo commitInfo = entry.commitInfo().get();\n+\n+        TransactionsLockWatchEvents update =\n+                eventLog.getEventsBetweenVersions(Optional.of(entry.version()), commitInfo.commitVersion()).build();\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of tranasctions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampToVersionMap(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion)\n+                .startTsToSequence(timestampToVersion)\n+                .build();\n+    }\n+\n+    @Override\n+    public synchronized void removeTransactionStateFromCache(long startTimestamp) {\n+        MapEntry entryToRemove = timestampMap.get(startTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355f5e2029025c9ee5a89497eab6c6d8c96f7dcb"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37e6105ce1cc66439455c08594352de6a0b82387", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/37e6105ce1cc66439455c08594352de6a0b82387", "committedDate": "2020-06-02T13:25:14Z", "message": "change static constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af3bf4993c0801e46809aa0cd75ad9e600f26409", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/af3bf4993c0801e46809aa0cd75ad9e600f26409", "committedDate": "2020-06-02T13:46:21Z", "message": "change to use exceptions instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d43e058bf98284726b0b9f173b8a754d716f9fe8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/d43e058bf98284726b0b9f173b8a754d716f9fe8", "committedDate": "2020-06-02T13:50:49Z", "message": "remove synchro"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6819fae07adc08b1f37d68f9bc7acd3592713c05", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/6819fae07adc08b1f37d68f9bc7acd3592713c05", "committedDate": "2020-06-02T14:11:54Z", "message": "fix up a few more things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69dffcc4114acb33ca3161c7af6ec96bbf2a4a49", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/69dffcc4114acb33ca3161c7af6ec96bbf2a4a49", "committedDate": "2020-06-02T14:32:12Z", "message": "fix exception problem"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06527fbda2ff4e64536443316c30e0c6f1c84e61", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/06527fbda2ff4e64536443316c30e0c6f1c84e61", "committedDate": "2020-06-03T09:28:16Z", "message": "work the integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/4af7d98c71f2340c390ea5aabf71e918bc62f28e", "committedDate": "2020-06-03T09:30:30Z", "message": "fix diff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMzc5ODky", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-423379892", "createdAt": "2020-06-03T09:31:31Z", "commit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTozMTozMVrOGeTzyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTozMTozMVrOGeTzyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw==", "bodyText": "It's a bit awkward, but the only way to properly put these as TransactionFailedRetriableExceptions given the awkward dependency loop.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434435017", "createdAt": "2020-06-03T09:31:31Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -55,12 +57,20 @@ public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n     }\n \n     CommitUpdate getCommitUpdate(long startTs) {\n-        return lockWatchEventCache.getCommitUpdate(startTs);\n+        try {\n+            return lockWatchEventCache.getCommitUpdate(startTs);\n+        } catch (LockWatchFailedException e) {\n+            throw new TransactionLockWatchFailedException(\"Failed to get commit update\", e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMzgzNjQ2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-423383646", "createdAt": "2020-06-03T09:36:15Z", "commit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTozNjoxNVrOGeT_GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTozNjoxNVrOGeT_GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNzkxMg==", "bodyText": "Turns out it makes sense for the snapshot to know the version that it has processed thus far. This version is essentially the latest version that is no longer in the log.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434437912", "createdAt": "2020-06-03T09:36:15Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshotUpdaterImpl.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotUpdaterImpl implements ClientLockWatchSnapshotUpdater {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMzg3MDk2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-423387096", "createdAt": "2020-06-03T09:40:38Z", "commit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo0MDozOVrOGeUKCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo0MDozOVrOGeUKCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MDcxMw==", "bodyText": "Just wondering if perhaps, for the sake of atlasdb-proxy, that we should fall through on this case instead (i.e. return no updates, and an empty map).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434440713", "createdAt": "2020-06-03T09:40:39Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.lock.watch.TimestampToVersionMap.MapEntry;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link FailureCheckingLockWatchEventCache} as a proxy; failure to do so will\n+ * result in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return FailureCheckingLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()));\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> startTimestamps.forEach(timestamp -> timestampMap.put(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.replace(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<MapEntry> maybeEntry = timestampMap.get(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = maybeEntry.flatMap(MapEntry::commitInfo);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent(), \"commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update =\n+                eventLog.getEventsBetweenVersions(Optional.of(maybeEntry.get().version()), commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of tranasctions\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTI5NzUy", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-423529752", "createdAt": "2020-06-03T13:04:17Z", "commit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowNDoxOFrOGea1Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowNDoxOFrOGea1Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExNQ==", "bodyText": "Entries are only ever removed when a certain method is called, which is called on finish. However, we do not guarantee that a user calls finish; as such, there is a potential case where throwaway transactions are created, added to this map, but never deleted.\nHow do we want to go about handling this case? We could implement a retention policy but would that be a problem for long-running transactions (or do we care about those)?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434550115", "createdAt": "2020-06-03T13:04:18Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.lock.watch.TimestampToVersionMap.MapEntry;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link FailureCheckingLockWatchEventCache} as a proxy; failure to do so will\n+ * result in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d27558e5abad40815edc00bdec5ef696636362b", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/2d27558e5abad40815edc00bdec5ef696636362b", "committedDate": "2020-06-03T13:09:09Z", "message": "rename method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/8a2570ed072df9b7adcfa7484adc0f178b4ccb1a", "committedDate": "2020-06-03T13:38:56Z", "message": "Fail to start transaction no longer leaks to LW map"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjIwNzgx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-423620781", "createdAt": "2020-06-03T14:37:46Z", "commit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNzo0NlrOGee-Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNzo0NlrOGee-Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNzkxMQ==", "bodyText": "So this is fine, only because of the way we wire things up: the timelockService above is TimeLockClient, and in there the tryUnlock is non-blocking and does not throw. Ideally we would not rely on that, but I think it's fine here, and you can follow up with a PR to not rely on that later.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434617911", "createdAt": "2020-06-03T14:37:46Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -205,6 +205,8 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n                     responses.stream()\n                             .map(response -> response.immutableTimestamp().getLock())\n                             .collect(Collectors.toSet()));\n+            responses.forEach(response -> lockWatchEventCache.removeTransactionStateFromCache(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7341d3dc89d901986325c8ac143045a3c42d1867", "committedDate": "2020-06-03T15:01:16Z", "message": "Avoid hashmap and tree multimap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjQwMDM3", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-423640037", "createdAt": "2020-06-03T14:56:40Z", "commit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1Njo0MFrOGefz6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyOTozOFrOGehUQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMTY1OQ==", "bodyText": "So I still don't think this is the right place for this. e.g.\n\nin TimestampToVersionMap, your map should be keyed on Long, not IdentifiedVersion. This instance is always cleared on leader election, so it can only ever contain things pertaining to a single leader. So it's weird it then maintain a datastructure keyed based off the whole key", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434631659", "createdAt": "2020-06-03T14:56:40Z", "author": {"login": "jkozlowski"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    static Comparator<IdentifiedVersion> comparator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMjgwOQ==", "bodyText": "This terseness is probably fine, but I'd consider something along the lines of: \"Unable to retrieve information for this transaction; this means there was a leader election and this transaction will be retried\". Similarly below. But up to you", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434632809", "createdAt": "2020-06-03T14:58:09Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -55,12 +57,20 @@ public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n     }\n \n     CommitUpdate getCommitUpdate(long startTs) {\n-        return lockWatchEventCache.getCommitUpdate(startTs);\n+        try {\n+            return lockWatchEventCache.getCommitUpdate(startTs);\n+        } catch (LockWatchFailedException e) {\n+            throw new TransactionLockWatchFailedException(\"Failed to get commit update\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNTIxOA==", "bodyText": "This whole block should be:\nOptional.ofNullable(aliveVersions.keySet().pollFirst())", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434635218", "createdAt": "2020-06-03T15:01:18Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version, startTimestamp);\n+    }\n+\n+    boolean replace(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+        if (previousEntry == null) {\n+            return false;\n+        }\n+\n+        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                CommitInfo.of(transactionUpdate.commitTs(), transactionUpdate.writesToken(), newVersion)));\n+\n+        return true;\n+    }\n+\n+    void remove(long startTimestamp) {\n+        Optional.ofNullable(timestampMap.remove(startTimestamp))\n+                .ifPresent(entry -> aliveVersions.remove(entry.version(), startTimestamp));\n+    }\n+\n+    void clear() {\n+        timestampMap.clear();\n+        aliveVersions.clear();\n+    }\n+\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        if (aliveVersions.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2570ed072df9b7adcfa7484adc0f178b4ccb1a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNzAwOA==", "bodyText": "I think you should throw somewhere in here if this is called twice, i.e. you already have the commit info. Just to be extra defensive.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434637008", "createdAt": "2020-06-03T15:03:46Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version, startTimestamp);\n+    }\n+\n+    boolean replace(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzODI5OA==", "bodyText": "nit: maybe think about different names for put/replace. Maybe putLogVersion and putTransactionUpdate? or onStartTransaction and onCommit or something to indicate when they are called, because there is an encoded state machine here (i.e. you call put and then replace;", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434638298", "createdAt": "2020-06-03T15:05:24Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MDc5MQ==", "bodyText": "nit: this might be a stylistic thing, but similar to how you have put/replace, I've have 2 different getters, so you are not exposing your internal datastructure (MapEntry).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434640791", "createdAt": "2020-06-03T15:08:44Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    void put(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version, startTimestamp);\n+    }\n+\n+    boolean replace(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+        if (previousEntry == null) {\n+            return false;\n+        }\n+\n+        timestampMap.replace(transactionUpdate.startTs(), previousEntry.withCommitInfo(\n+                CommitInfo.of(transactionUpdate.commitTs(), transactionUpdate.writesToken(), newVersion)));\n+\n+        return true;\n+    }\n+\n+    void remove(long startTimestamp) {\n+        Optional.ofNullable(timestampMap.remove(startTimestamp))\n+                .ifPresent(entry -> aliveVersions.remove(entry.version(), startTimestamp));\n+    }\n+\n+    void clear() {\n+        timestampMap.clear();\n+        aliveVersions.clear();\n+    }\n+\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        if (aliveVersions.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(aliveVersions.keySet().first());\n+        }\n+    }\n+\n+    Optional<MapEntry> get(long startTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0Mzc5NQ==", "bodyText": "Nice! For extra safety, I would probably generate a new UUID every time, but I think this will translate to a snapshot and a clear cache for each transaction that starts this way.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434643795", "createdAt": "2020-06-03T15:12:57Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -55,7 +53,11 @@ public CommitUpdate getCommitUpdate(long startTs) {\n     @Override\n     public TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n             Optional<IdentifiedVersion> version) {\n-        return NONE;\n+        return ImmutableTransactionsLockWatchEvents.builder()\n+                .clearCache(true)\n+                .startTsToSequence(\n+                        startTimestamps.stream().collect(Collectors.toMap(startTs -> startTs, $ -> FAKE_VERSION)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0NDAxMQ==", "bodyText": "Let's keep the eventId as -1 here, it indicates the log is empty.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434644011", "createdAt": "2020-06-03T15:13:14Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -20,14 +20,12 @@\n import java.util.Optional;\n import java.util.Set;\n import java.util.UUID;\n-\n-import com.google.common.collect.ImmutableSet;\n+import java.util.stream.Collectors;\n \n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n+    private static final IdentifiedVersion FAKE_VERSION = IdentifiedVersion.of(UUID.randomUUID(), 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDc5NA==", "bodyText": "This is quite clever, but kinda non-trivial to read and also not entirely correct. You are missing not failing on your expected exceptions!\nI would rewrite it to:\nprivate final LockWatchEventCache delegate;\n\nprivate FailureCheckingLockWatchEventCache(LockWatchEventCache defaultCache) {\n        this.delegate = defaultCache;\n}\n\nand then #handleInvocation:\ntry {\n  return method.invoke(noOpCache, args);\n} catch (Throwable e) {\n  if (e instance of TransactionLockWatchFailedException) {\n   throw e;\n  }\n  delegate = NoOpLockWatchEventCache.INSTANCE;\n  // You still don't want to cause an outage, so should make the transaction retry.\n  throw new TransactionLockWatchFailedException(\"Unexpected failure\", e);\n}\n\nOr something to that effect.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434650794", "createdAt": "2020-06-03T15:22:25Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+\n+final class FailureCheckingLockWatchEventCache extends AbstractInvocationHandler {\n+\n+    static LockWatchEventCache newProxyInstance(LockWatchEventCache defaultCache) {\n+        return (LockWatchEventCache) Proxy.newProxyInstance(\n+                LockWatchEventCache.class.getClassLoader(),\n+                new Class<?>[] {LockWatchEventCache.class},\n+                new FailureCheckingLockWatchEventCache(defaultCache));\n+    }\n+\n+    private final LockWatchEventCache defaultCache;\n+    private final LockWatchEventCache noOpCache;\n+\n+    @GuardedBy(\"this\")\n+    private boolean hasFailed = false;\n+\n+    private FailureCheckingLockWatchEventCache(LockWatchEventCache defaultCache) {\n+        this.defaultCache = defaultCache;\n+        this.noOpCache = NoOpLockWatchEventCache.INSTANCE;\n+    }\n+\n+    @Override\n+    protected synchronized Object handleInvocation(Object proxy, Method method, Object[] args) throws Throwable {\n+        if (hasFailed) {\n+            return method.invoke(noOpCache, args);\n+        } else {\n+            hasFailed = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MjA2MA==", "bodyText": "You probably want to just pass the cache you want to fallback to into its constructor. It is weird to rely on this behavior for something you're testing, when there's a simple solution like I described.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434652060", "createdAt": "2020-06-03T15:24:06Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/test/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCacheTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class FailureCheckingLockWatchEventCacheTest {\n+\n+    @Mock\n+    private LockWatchEventCache defaultCache;\n+    private LockWatchEventCache proxyCache;\n+\n+    @Before\n+    public void before() {\n+        proxyCache = FailureCheckingLockWatchEventCache.newProxyInstance(defaultCache);\n+    }\n+\n+    @Test\n+    public void failCausesNoOpCacheToBeUsed() {\n+        RuntimeException runtimeException = new RuntimeException();\n+        when(defaultCache.getCommitUpdate(anyLong())).thenThrow(runtimeException);\n+        assertThatThrownBy(() -> proxyCache.getCommitUpdate(0L)).hasRootCause(runtimeException);\n+\n+        when(defaultCache.lastKnownVersion()).thenReturn(Optional.of(IdentifiedVersion.of(UUID.randomUUID(), 1L)));\n+\n+        // no op cache returns empty on last known version, so this should prove that we delegate there correctly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MzI2MA==", "bodyText": "nit: Maaaybe consider a different name, because we also rely on the synchronized being here for correctness! First thing that came to my mind was \"ResilientLockWatchEventCache\", or \"SynchronizedLockWatchEventCache\".", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434653260", "createdAt": "2020-06-03T15:25:43Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/FailureCheckingLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+\n+final class FailureCheckingLockWatchEventCache extends AbstractInvocationHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDY0NQ==", "bodyText": "That's what I mean, you should probably move the event cache code somewhere else. It feels weird that it's in an *-api subproject, where it clearly is an implementation?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434654645", "createdAt": "2020-06-03T15:27:26Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -55,12 +57,20 @@ public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n     }\n \n     CommitUpdate getCommitUpdate(long startTs) {\n-        return lockWatchEventCache.getCommitUpdate(startTs);\n+        try {\n+            return lockWatchEventCache.getCommitUpdate(startTs);\n+        } catch (LockWatchFailedException e) {\n+            throw new TransactionLockWatchFailedException(\"Failed to get commit update\", e);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNTAxNw=="}, "originalCommit": {"oid": "4af7d98c71f2340c390ea5aabf71e918bc62f28e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NjMyMQ==", "bodyText": "I would consider tests for this, for anything that's hard to test in your integration test. I haven't read through that yet, so unclear if this comment is useful.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r434656321", "createdAt": "2020-06-03T15:29:38Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+\n+final class TimestampToVersionMap {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7341d3dc89d901986325c8ac143045a3c42d1867"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5a4a3ff428f3a2632d33571a8cd9a8e5b43a882", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/c5a4a3ff428f3a2632d33571a8cd9a8e5b43a882", "committedDate": "2020-06-04T08:49:29Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b14885ebc543a81863a87309816f853ba693e5c", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/5b14885ebc543a81863a87309816f853ba693e5c", "committedDate": "2020-06-04T08:53:12Z", "message": "fixup ttvm per comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9a1f47bd790c8a0bdc3cba7bf2e83b9f2c0707d", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/e9a1f47bd790c8a0bdc3cba7bf2e83b9f2c0707d", "committedDate": "2020-06-04T08:54:19Z", "message": "rename methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da2feb533929882178a9344642990b58bcd14ee1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/da2feb533929882178a9344642990b58bcd14ee1", "committedDate": "2020-06-04T09:11:31Z", "message": "tidy commit update a bit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3726bd054af7a1d6ac7bc437a3553bac9f935285", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/3726bd054af7a1d6ac7bc437a3553bac9f935285", "committedDate": "2020-06-04T09:12:19Z", "message": "remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afadfeda7ac29a5e1976ac51a5e07078a08cb6ae", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/afadfeda7ac29a5e1976ac51a5e07078a08cb6ae", "committedDate": "2020-06-04T09:17:00Z", "message": "fix fake version to have different uuid each time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1b0280e1eef2f5713558e13fe6976a4f0d2ee60", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a1b0280e1eef2f5713558e13fe6976a4f0d2ee60", "committedDate": "2020-06-04T09:45:44Z", "message": "modify failure checking cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92038aa2cb79533791037c6c86cbda2e82f00d69", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/92038aa2cb79533791037c6c86cbda2e82f00d69", "committedDate": "2020-06-04T09:55:39Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea5fe626acfb2287ea41e9731ec1753a5f5fdde1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ea5fe626acfb2287ea41e9731ec1753a5f5fdde1", "committedDate": "2020-06-04T10:02:31Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6e3a24459f83e6257fbfc7e60532fc6a850d9a5", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b6e3a24459f83e6257fbfc7e60532fc6a850d9a5", "committedDate": "2020-06-04T10:03:41Z", "message": "rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "969a6620acf65a186e28f95d091f1a38a4d5cb8f", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/969a6620acf65a186e28f95d091f1a38a4d5cb8f", "committedDate": "2020-06-04T10:08:45Z", "message": "Fix typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b786af77c25e622909573f7dadff54ae836d5492", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b786af77c25e622909573f7dadff54ae836d5492", "committedDate": "2020-06-04T10:24:39Z", "message": "add timestamp to version map test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344", "committedDate": "2020-06-04T10:31:16Z", "message": "fix up more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b5c5163688e4a03b23acb148c627c6adacad271", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0b5c5163688e4a03b23acb148c627c6adacad271", "committedDate": "2020-06-04T12:00:27Z", "message": "change type to sortedsetmap and oneline it"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzQ2MjUz", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-424346253", "createdAt": "2020-06-04T11:25:05Z", "commit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMToyNTowNlrOGfBYBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjozNzo0MFrOGfDsyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MTU3Mg==", "bodyText": "At least a logline, but ideally a metric so you can setup some alerts for rollout.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435181572", "createdAt": "2020-06-04T11:25:06Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ResilientLockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import com.google.common.reflect.AbstractInvocationHandler;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+\n+final class ResilientLockWatchEventCache extends AbstractInvocationHandler {\n+\n+    static LockWatchEventCache newProxyInstance(LockWatchEventCache defaultCache, LockWatchEventCache fallbackCache) {\n+        return (LockWatchEventCache) Proxy.newProxyInstance(\n+                LockWatchEventCache.class.getClassLoader(),\n+                new Class<?>[] {LockWatchEventCache.class},\n+                new ResilientLockWatchEventCache(defaultCache, fallbackCache));\n+    }\n+\n+    private final LockWatchEventCache fallbackCache;\n+\n+    @GuardedBy(\"this\")\n+    private LockWatchEventCache delegate;\n+\n+    private ResilientLockWatchEventCache(LockWatchEventCache defaultCache, LockWatchEventCache fallbackCache) {\n+        this.delegate = defaultCache;\n+        this.fallbackCache = fallbackCache;\n+    }\n+\n+    @Override\n+    protected synchronized Object handleInvocation(Object proxy, Method method, Object[] args) {\n+        try {\n+            return method.invoke(delegate, args);\n+        } catch (TransactionLockWatchFailedException e) {\n+            throw e;\n+        } catch (Throwable t) {\n+            delegate = fallbackCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MzIwMg==", "bodyText": "If commit info is present, you should throw right? It's unexpected and indicates a bug?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435183202", "createdAt": "2020-06-04T11:28:24Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")\n+    private final TreeMultimap<Long, Long> aliveVersions = TreeMultimap.create();\n+\n+    void putStartVersion(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));\n+        aliveVersions.put(version.version(), startTimestamp);\n+    }\n+\n+    boolean putCommitUpdate(TransactionUpdate transactionUpdate, IdentifiedVersion newVersion) {\n+        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+        if (previousEntry == null || previousEntry.commitInfo().isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Mzc4Nw==", "bodyText": "nit: This should be something like TransactionStateStore or something. You don't only store versions here, and *Map is also not accurate because 1. it tells you about it's internal implementation. 2. It actually contains multiple maps!", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435183787", "createdAt": "2020-06-04T11:29:39Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NDUwOA==", "bodyText": "I think by convention, cause can be nullable, so you shouldn't need the second constructor.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435184508", "createdAt": "2020-06-04T11:31:07Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionLockWatchFailedException.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.api;\n+\n+public final class TransactionLockWatchFailedException extends TransactionFailedRetriableException {\n+    public TransactionLockWatchFailedException(String message, Throwable cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzQyMQ==", "bodyText": "Same here, I have a feeling you should use putIfAbsent and throw if already present.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435187421", "createdAt": "2020-06-04T11:36:49Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")\n+    private final TreeMultimap<Long, Long> aliveVersions = TreeMultimap.create();\n+\n+    void putStartVersion(long startTimestamp, IdentifiedVersion version) {\n+        timestampMap.put(startTimestamp, MapEntry.of(version));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzU5Mw==", "bodyText": "What does this mean?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435187593", "createdAt": "2020-06-04T11:37:11Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDAyOQ==", "bodyText": "Should take long here, that will probably simplify your upstream code.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435190029", "createdAt": "2020-06-04T11:41:59Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -16,17 +16,12 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n import java.util.Optional;\n-import java.util.Set;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+public interface ClientLockWatchEventLog {\n+    ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion, IdentifiedVersion endVersion);\n+    Optional<IdentifiedVersion> getLatestKnownVersion();\n+    Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update);\n+    void removeOldEntries(IdentifiedVersion earliestVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MTQzNA==", "bodyText": "I feel like you should invert this, you use it as checkConditionOrThrow(! everywhere. And maybe call assertTrue.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435191434", "createdAt": "2020-06-04T11:44:46Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);\n+    }\n+\n+    @VisibleForTesting\n+    Map<Long, IdentifiedVersion> getTimestampMappings(Set<Long> startTimestamps) {\n+        Map<Long, IdentifiedVersion> timestampToVersion = new HashMap<>();\n+        startTimestamps.forEach(timestamp -> {\n+            Optional<IdentifiedVersion> entry = timestampMap.getStartVersion(timestamp);\n+            checkConditionOrThrow(!entry.isPresent(), \"start timestamp missing from map\");\n+            timestampToVersion.put(timestamp, entry.get());\n+        });\n+        return timestampToVersion;\n+    }\n+\n+    @VisibleForTesting\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        return timestampMap.getEarliestVersion().flatMap(sequence ->\n+                currentVersion.map(version -> IdentifiedVersion.of(version.id(), sequence)));\n+    }\n+\n+    private void checkConditionOrThrow(boolean condition, String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MjA2MQ==", "bodyText": "This should be a hard failure, it's a bug?\nActually, it's hard to know, because this is legitimate on a leader switch once we've cleared the cache. Good catch!", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435192061", "createdAt": "2020-06-04T11:46:01Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5Mzk0Ng==", "bodyText": "This looks rather scary here: I would think you'd want the return type of #processUpdate to indicate whether there was an event that should cause everything to be reset?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435193946", "createdAt": "2020-06-04T11:50:12Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);\n+    }\n+\n+    @VisibleForTesting\n+    Map<Long, IdentifiedVersion> getTimestampMappings(Set<Long> startTimestamps) {\n+        Map<Long, IdentifiedVersion> timestampToVersion = new HashMap<>();\n+        startTimestamps.forEach(timestamp -> {\n+            Optional<IdentifiedVersion> entry = timestampMap.getStartVersion(timestamp);\n+            checkConditionOrThrow(!entry.isPresent(), \"start timestamp missing from map\");\n+            timestampToVersion.put(timestamp, entry.get());\n+        });\n+        return timestampToVersion;\n+    }\n+\n+    @VisibleForTesting\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        return timestampMap.getEarliestVersion().flatMap(sequence ->\n+                currentVersion.map(version -> IdentifiedVersion.of(version.id(), sequence)));\n+    }\n+\n+    private void checkConditionOrThrow(boolean condition, String message) {\n+        if (condition) {\n+            throw new TransactionLockWatchFailedException(message);\n+        }\n+    }\n+\n+    private CommitUpdate constructCommitUpdate(CommitInfo commitInfo, List<LockWatchEvent> events) {\n+        LockEventVisitor eventVisitor = new LockEventVisitor(commitInfo.commitLockToken());\n+        Set<LockDescriptor> locksTakenOut = new HashSet<>();\n+        events.forEach(event -> locksTakenOut.addAll(event.accept(eventVisitor)));\n+        return ImmutableInvalidateSome.builder().invalidatedLocks(locksTakenOut).build();\n+    }\n+\n+    private Optional<IdentifiedVersion> processEventLogUpdate(LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        Optional<IdentifiedVersion> latestVersion = eventLog.processUpdate(update);\n+\n+        if (!(latestVersion.isPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NDcwMQ==", "bodyText": "This feels like it's in the wrong place? You should be cleaning up when transactions are removed from the cache, not when they're added right? Otherwise, this will not be prompt.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435194701", "createdAt": "2020-06-04T11:51:42Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NjUzNw==", "bodyText": "Both of these, I feel, should take the Collection/Collection, so the code upstairs doesn't have to iterate by itself.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435196537", "createdAt": "2020-06-04T11:55:30Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/TimestampToVersionMap.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class TimestampToVersionMap {\n+    private final Map<Long, MapEntry> timestampMap = new HashMap<>();\n+    @SuppressWarnings(\"IllegalTypeCheck\")\n+    private final TreeMultimap<Long, Long> aliveVersions = TreeMultimap.create();\n+\n+    void putStartVersion(long startTimestamp, IdentifiedVersion version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a98885bd273bf5e49dc5e7c4d8cd2a129b7b6344"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxNDUzMg==", "bodyText": "nit: createCommitUpdate", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435214532", "createdAt": "2020-06-04T12:29:06Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);\n+    }\n+\n+    @VisibleForTesting\n+    Map<Long, IdentifiedVersion> getTimestampMappings(Set<Long> startTimestamps) {\n+        Map<Long, IdentifiedVersion> timestampToVersion = new HashMap<>();\n+        startTimestamps.forEach(timestamp -> {\n+            Optional<IdentifiedVersion> entry = timestampMap.getStartVersion(timestamp);\n+            checkConditionOrThrow(!entry.isPresent(), \"start timestamp missing from map\");\n+            timestampToVersion.put(timestamp, entry.get());\n+        });\n+        return timestampToVersion;\n+    }\n+\n+    @VisibleForTesting\n+    Optional<IdentifiedVersion> getEarliestVersion() {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        return timestampMap.getEarliestVersion().flatMap(sequence ->\n+                currentVersion.map(version -> IdentifiedVersion.of(version.id(), sequence)));\n+    }\n+\n+    private void checkConditionOrThrow(boolean condition, String message) {\n+        if (condition) {\n+            throw new TransactionLockWatchFailedException(message);\n+        }\n+    }\n+\n+    private CommitUpdate constructCommitUpdate(CommitInfo commitInfo, List<LockWatchEvent> events) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b5c5163688e4a03b23acb148c627c6adacad271"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxNzc4MQ==", "bodyText": "Again, this is where you should clear out your stale events.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435217781", "createdAt": "2020-06-04T12:34:30Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampToVersionMap.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final TimestampToVersionMap timestampMap;\n+\n+    public static LockWatchEventCache create() {\n+        return ResilientLockWatchEventCache.newProxyInstance(\n+                new LockWatchEventCacheImpl(ClientLockWatchEventLogImpl.create()), NoOpLockWatchEventCache.INSTANCE);\n+    }\n+\n+    @VisibleForTesting\n+    LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+        timestampMap = new TimestampToVersionMap();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> timestampMap.putStartVersion(timestamp, version)));\n+\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+    }\n+\n+    @Override\n+    public void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+        latestVersion.ifPresent(version -> transactionUpdates.forEach(\n+                transactionUpdate -> checkConditionOrThrow(!timestampMap.putCommitUpdate(transactionUpdate, version),\n+                        \"start timestamp missing from map\")));\n+    }\n+\n+    @Override\n+    public CommitUpdate getCommitUpdate(long startTs) {\n+        Optional<IdentifiedVersion> startVersion = timestampMap.getStartVersion(startTs);\n+        Optional<CommitInfo> maybeCommitInfo = timestampMap.getCommitInfo(startTs);\n+\n+        checkConditionOrThrow(!maybeCommitInfo.isPresent() || !startVersion.isPresent(),\n+                \"start or commit info not processed for start timestamp\");\n+\n+        CommitInfo commitInfo = maybeCommitInfo.get();\n+\n+        ClientLogEvents update = eventLog.getEventsBetweenVersions(startVersion, commitInfo.commitVersion());\n+\n+        if (update.clearCache()) {\n+            return ImmutableInvalidateAll.builder().build();\n+        }\n+\n+        return constructCommitUpdate(commitInfo, update.events());\n+    }\n+\n+    @Override\n+    public TransactionsLockWatchEvents getEventsForTransactions(\n+            Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> startVersion) {\n+        Preconditions.checkArgument(!startTimestamps.isEmpty(), \"Cannot get events for empty set of transactions\");\n+        Map<Long, IdentifiedVersion> timestampToVersion = getTimestampMappings(startTimestamps);\n+        IdentifiedVersion endVersion = Collections.max(timestampToVersion.values(),\n+                Comparator.comparingLong(IdentifiedVersion::version));\n+        return eventLog.getEventsBetweenVersions(startVersion, endVersion).map(timestampToVersion);\n+    }\n+\n+    @Override\n+    public void removeTransactionStateFromCache(long startTimestamp) {\n+        timestampMap.remove(startTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b5c5163688e4a03b23acb148c627c6adacad271"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxODc3MQ==", "bodyText": "nit: This name is weird and we should change it. My suggestion would actually be to flip things around:\n\nLockWatchEventCache -> LockWatchStateStore\nClientLockWatchEventLog -> LockWatchEventLog\n\nOr something to that effect, but \"Client\" is just not very good.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435218771", "createdAt": "2020-06-04T12:36:11Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b5c5163688e4a03b23acb148c627c6adacad271"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxOTY1OA==", "bodyText": "I would maybe again suggest splitting a small datastructure class that has the API you need here.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r435219658", "createdAt": "2020-06-04T12:37:40Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchEventLog;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b5c5163688e4a03b23acb148c627c6adacad271"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4360b74ead3cad978df7e0467b1266394dbe21d7", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/4360b74ead3cad978df7e0467b1266394dbe21d7", "committedDate": "2020-06-04T13:09:40Z", "message": "add metric to cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9aa1be25d7e446405cd2fb7eaf3bb5e91ad57df8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/9aa1be25d7e446405cd2fb7eaf3bb5e91ad57df8", "committedDate": "2020-06-04T13:11:54Z", "message": "fix bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b89730d02510e22fd91d31add91b21206de0145", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/5b89730d02510e22fd91d31add91b21206de0145", "committedDate": "2020-06-04T13:15:23Z", "message": "rename ttvm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef99edaf3ab20ae8e4ab7fefe05d1924c5e07fd4", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ef99edaf3ab20ae8e4ab7fefe05d1924c5e07fd4", "committedDate": "2020-06-04T13:19:05Z", "message": "put throws on multi put"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed55d088580477bca66717c3cea9b7d18bf1d463", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ed55d088580477bca66717c3cea9b7d18bf1d463", "committedDate": "2020-06-04T13:21:16Z", "message": "more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc664f41566c14ae991c55da9c3b285548cd1153", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/bc664f41566c14ae991c55da9c3b285548cd1153", "committedDate": "2020-06-04T13:22:15Z", "message": "invert check statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372047923a23661196f6ea250eaac6ad317e2795", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/372047923a23661196f6ea250eaac6ad317e2795", "committedDate": "2020-06-04T13:42:45Z", "message": "fix tests and improve flow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7b56694b571956a51edd9d51f602f5e651ec751", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/e7b56694b571956a51edd9d51f602f5e651ec751", "committedDate": "2020-06-04T13:46:10Z", "message": "move remove"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cdaf846364db0ae9c81e02e1bca8b736f6d6302", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0cdaf846364db0ae9c81e02e1bca8b736f6d6302", "committedDate": "2020-06-04T14:13:11Z", "message": "use collections instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4ac9b3e8318dc9c0e2b89e2d1f1039dd4ef5ec", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7d4ac9b3e8318dc9c0e2b89e2d1f1039dd4ef5ec", "committedDate": "2020-06-04T14:58:09Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6484e61ffcf595f6fd2ae4fe71b8ca5eacaffcd1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/6484e61ffcf595f6fd2ae4fe71b8ca5eacaffcd1", "committedDate": "2020-06-04T15:00:17Z", "message": "rename method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beedc8ed0be415e93ce86ec14ab0f1aa769f53c1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/beedc8ed0be415e93ce86ec14ab0f1aa769f53c1", "committedDate": "2020-06-04T16:39:15Z", "message": "rename some things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aed50741f06984b1f7c68b8cf3dd4726dd2d1572", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/aed50741f06984b1f7c68b8cf3dd4726dd2d1572", "committedDate": "2020-06-04T16:45:02Z", "message": "fix last comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b263bde7fc41bafe57d174bff24d2ce4432a55e7", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b263bde7fc41bafe57d174bff24d2ce4432a55e7", "committedDate": "2020-06-09T08:38:26Z", "message": "fix some checkstyle things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/5e65abf7fda4e6435c36ed024f1883ae19ceec65", "committedDate": "2020-06-09T09:14:49Z", "message": "hopefully checkstyle is happy now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "250bf38d6cffb35f8d86bf52c16ceca136d5cbe8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/250bf38d6cffb35f8d86bf52c16ceca136d5cbe8", "committedDate": "2020-06-09T12:15:08Z", "message": "rename updater"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dcd0b2160f8f0280f3c637e9b79ef5f1df5eb01", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/5dcd0b2160f8f0280f3c637e9b79ef5f1df5eb01", "committedDate": "2020-06-09T13:27:50Z", "message": "Merge branch 'develop' into lw-client-cache-ete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8393341804c51af20f5c632da9355c4efef045d4", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/8393341804c51af20f5c632da9355c4efef045d4", "committedDate": "2020-06-09T14:50:08Z", "message": "Merge branch 'develop' into lw-client-cache-ete\n\n# Conflicts:\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java\n#\tlock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshot.java\n#\tlock-api/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eff25d3afa288590c3da71553e1f94d94e7384f9", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/eff25d3afa288590c3da71553e1f94d94e7384f9", "committedDate": "2020-06-09T14:52:53Z", "message": "fix merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcfeabe6d60eef57129a0a4da5c48c1f05878137", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/fcfeabe6d60eef57129a0a4da5c48c1f05878137", "committedDate": "2020-06-09T14:55:17Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/711e9bf5dca4a299e62330f05c3b88d0ceee0962", "committedDate": "2020-06-09T15:21:19Z", "message": "remove empty file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MDYzOTQ4", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-427063948", "createdAt": "2020-06-09T11:57:37Z", "commit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMTo1NzozN1rOGhF0oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzoyNjoxM1rOGh0tGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MTU4NA==", "bodyText": "nit: Maybe \"ClientLockWatchSnapshot\", not sure Updater adds much.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437351584", "createdAt": "2020-06-09T11:57:37Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImpl.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotUpdaterImpl implements ClientLockWatchSnapshotUpdater {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MTc3OQ==", "bodyText": "I don't think you need synchronized here anymore?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437351779", "createdAt": "2020-06-09T11:58:00Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImpl.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotUpdaterImpl implements ClientLockWatchSnapshotUpdater {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshotUpdater create() {\n+        return new ClientLockWatchSnapshotUpdaterImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotUpdaterImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public synchronized LockWatchStateUpdate.Snapshot getSnapshot() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzMwNA==", "bodyText": "Does this interface need to be public here? Can you not keep it next to the implementation? I feel like this is implementation detail", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353304", "createdAt": "2020-06-09T12:00:48Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchSnapshotUpdater.java", "diffHunk": "@@ -16,17 +16,11 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.List;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+public interface ClientLockWatchSnapshotUpdater {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzU2NA==", "bodyText": "Does this interface need to be public here? Can you not keep it next to the implementation? I feel like this is implementation detail", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353564", "createdAt": "2020-06-09T12:01:20Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLogEvents.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ClientLogEvents {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzY4OQ==", "bodyText": "I think this is the only API we need possibly?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353689", "createdAt": "2020-06-09T12:01:36Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public interface LockWatchEventCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1Mzc1Mg==", "bodyText": "Does this interface need to be public here? Can you not keep it next to the implementation? I feel like this is implementation detail", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437353752", "createdAt": "2020-06-09T12:01:44Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventLog.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Optional;\n+\n+public interface LockWatchEventLog {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDA1Nw==", "bodyText": "Where are the mocks?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437354057", "createdAt": "2020-06-09T12:02:20Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImplTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+@RunWith(MockitoJUnitRunner.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDM5OA==", "bodyText": "Test for what happens after a reset?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437354398", "createdAt": "2020-06-09T12:02:55Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImplTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class ClientLockWatchSnapshotUpdaterImplTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2))\n+                    .build(0L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(1L);\n+    private static final LockWatchEvent LOCK_EVENT = LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3),\n+            LockToken.of(UUID.randomUUID())).build(2L);\n+    private static final IdentifiedVersion VERSION = IdentifiedVersion.of(UUID.randomUUID(), 999L);\n+\n+    private ClientLockWatchSnapshotUpdater snapshotUpdater;\n+\n+    @Before\n+    public void before() {\n+        snapshotUpdater = ClientLockWatchSnapshotUpdaterImpl.create();\n+    }\n+\n+    @Test\n+    public void eventsProcessedAsExpected() {\n+        snapshotUpdater.processEvents(ImmutableList.of(WATCH_EVENT), VERSION);\n+        LockWatchStateUpdate.Snapshot snapshot = snapshotUpdater.getSnapshot();\n+        assertThat(snapshot.locked()).containsExactlyInAnyOrder(DESCRIPTOR, DESCRIPTOR_2);\n+        assertThat(snapshot.lockWatches()).containsExactlyInAnyOrder(REFERENCE);\n+\n+        snapshotUpdater.processEvents(ImmutableList.of(UNLOCK_EVENT, LOCK_EVENT), VERSION);\n+        LockWatchStateUpdate.Snapshot snapshot2 = snapshotUpdater.getSnapshot();\n+        assertThat(snapshot2.locked()).containsExactlyInAnyOrder(DESCRIPTOR, DESCRIPTOR_3);\n+        assertThat(snapshot2.lockWatches()).containsExactlyInAnyOrder(REFERENCE);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NDkyMQ==", "bodyText": "You probably want to extract this into a variable that is shared with the WATCH_EVENT", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r437354921", "createdAt": "2020-06-09T12:03:50Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotUpdaterImplTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ClientLockWatchSnapshotUpdater;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class ClientLockWatchSnapshotUpdaterImplTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2))\n+                    .build(0L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(1L);\n+    private static final LockWatchEvent LOCK_EVENT = LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3),\n+            LockToken.of(UUID.randomUUID())).build(2L);\n+    private static final IdentifiedVersion VERSION = IdentifiedVersion.of(UUID.randomUUID(), 999L);\n+\n+    private ClientLockWatchSnapshotUpdater snapshotUpdater;\n+\n+    @Before\n+    public void before() {\n+        snapshotUpdater = ClientLockWatchSnapshotUpdaterImpl.create();\n+    }\n+\n+    @Test\n+    public void eventsProcessedAsExpected() {\n+        snapshotUpdater.processEvents(ImmutableList.of(WATCH_EVENT), VERSION);\n+        LockWatchStateUpdate.Snapshot snapshot = snapshotUpdater.getSnapshot();\n+        assertThat(snapshot.locked()).containsExactlyInAnyOrder(DESCRIPTOR, DESCRIPTOR_2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e65abf7fda4e6435c36ed024f1883ae19ceec65"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5NTEyOA==", "bodyText": "This extends here is really trippy. I'd rather you copy paste some code than use inheritance, for clarity what happens in what state.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438095128", "createdAt": "2020-06-10T12:49:47Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventMap.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventMap.firstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = versionInclusive.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeOldEntries(long earliestSequence) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventMap.headMap(earliestSequence).entrySet();\n+        Optional<Long> latestDeletedVersion = Streams.findLast(eventsToBeRemoved.stream()).map(Map.Entry::getKey);\n+        Optional<IdentifiedVersion> currentVersion = getLatestKnownVersion();\n+\n+        if (eventsToBeRemoved.isEmpty() || !latestDeletedVersion.isPresent() || !currentVersion.isPresent()) {\n+            return;\n+        }\n+\n+        snapshot.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()),\n+                IdentifiedVersion.of(currentVersion.get().id(), latestDeletedVersion.get()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        return latestVersion;\n+    }\n+\n+    private boolean differentLeaderOrTooFarBehind(IdentifiedVersion currentVersion,\n+            IdentifiedVersion startVersion) {\n+        return !startVersion.id().equals(currentVersion.id()) || eventMap.floorKey(startVersion.version()) == null;\n+    }\n+\n+    private IdentifiedVersion createInclusiveVersion(IdentifiedVersion startVersion) {\n+        return IdentifiedVersion.of(startVersion.id(), startVersion.version() + 1);\n+    }\n+\n+    private IdentifiedVersion getLatestVersionAndVerify(IdentifiedVersion endVersion) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        Preconditions.checkArgument(endVersion.version() <= currentVersion.version(),\n+                \"Transactions' view of the world is more up-to-date than the log\");\n+        return currentVersion;\n+    }\n+\n+    private void processSuccess(LockWatchStateUpdate.Success success) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Must have a known version to process successful updates\");\n+\n+        if (success.lastKnownVersion() > latestVersion.get().version()) {\n+            success.events().forEach(event -> eventMap.put(event.sequence(), event));\n+            latestVersion = Optional.of(IdentifiedVersion.of(success.logId(), eventMap.lastKey()));\n+        }\n+    }\n+\n+    private void processSnapshot(LockWatchStateUpdate.Snapshot snapshotUpdate) {\n+        eventMap.clear();\n+        this.snapshot.resetWithSnapshot(snapshotUpdate);\n+        latestVersion = Optional.of(IdentifiedVersion.of(snapshotUpdate.logId(), snapshotUpdate.lastKnownVersion()));\n+    }\n+\n+    private void processFailed() {\n+        eventMap.clear();\n+        snapshot.reset();\n+        latestVersion = Optional.empty();\n+    }\n+\n+    private class ProcessingVisitor implements LockWatchStateUpdate.Visitor<Boolean> {\n+        @Override\n+        public Boolean visit(LockWatchStateUpdate.Failed failed) {\n+            processFailed();\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visit(LockWatchStateUpdate.Success success) {\n+            processSuccess(success);\n+            return true;\n+        }\n+\n+        @Override\n+        public Boolean visit(LockWatchStateUpdate.Snapshot snapshotUpdate) {\n+            processSnapshot(snapshotUpdate);\n+            return false;\n+        }\n+    }\n+\n+    private final class NewLeaderVisitor extends ProcessingVisitor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA5NTYyNw==", "bodyText": "using a boolean to indicate something here is really hard to reason about, and probably easy to screw up. Have an enum ShouldClearCache or something", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438095627", "createdAt": "2020-06-10T12:50:30Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNTQ1NA==", "bodyText": "So I think this is good, because you should not assume that startTransaction requests are processed in a single-threaded way. BUT startTransaction and getCommitTimestamp can run concurrently. And I wonder if we should assume that there can't be more concurrent executions in general.\nI wonder if the below if statement is enough to catch reordered execution between these and therefore I'm wondering if the callers should pass their lastKnown version. So imagine you have:\nThread 1: calls startTransactions on timelock with latestVersion 1\nThread 2: calls getCommitTimestamp with latestVersion 1 (because Thread 1 hasn't returned yet)\nThread 2: returns events [2,3]\nThread 1: returns events [2,3,4]\nIs there some reordering where you would loose events somehow and end up with holes?  Should we have the eventMap also know what the last eventId it has is and know what to expect afterwards, and double check they're coming back in the right order?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438105454", "createdAt": "2020-06-10T13:05:16Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventMap.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventMap.firstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = versionInclusive.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeOldEntries(long earliestSequence) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventMap.headMap(earliestSequence).entrySet();\n+        Optional<Long> latestDeletedVersion = Streams.findLast(eventsToBeRemoved.stream()).map(Map.Entry::getKey);\n+        Optional<IdentifiedVersion> currentVersion = getLatestKnownVersion();\n+\n+        if (eventsToBeRemoved.isEmpty() || !latestDeletedVersion.isPresent() || !currentVersion.isPresent()) {\n+            return;\n+        }\n+\n+        snapshot.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()),\n+                IdentifiedVersion.of(currentVersion.get().id(), latestDeletedVersion.get()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        return latestVersion;\n+    }\n+\n+    private boolean differentLeaderOrTooFarBehind(IdentifiedVersion currentVersion,\n+            IdentifiedVersion startVersion) {\n+        return !startVersion.id().equals(currentVersion.id()) || eventMap.floorKey(startVersion.version()) == null;\n+    }\n+\n+    private IdentifiedVersion createInclusiveVersion(IdentifiedVersion startVersion) {\n+        return IdentifiedVersion.of(startVersion.id(), startVersion.version() + 1);\n+    }\n+\n+    private IdentifiedVersion getLatestVersionAndVerify(IdentifiedVersion endVersion) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        Preconditions.checkArgument(endVersion.version() <= currentVersion.version(),\n+                \"Transactions' view of the world is more up-to-date than the log\");\n+        return currentVersion;\n+    }\n+\n+    private void processSuccess(LockWatchStateUpdate.Success success) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Must have a known version to process successful updates\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNDEwOA==", "bodyText": "This is quite gnarly to read, but I think correct.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438114108", "createdAt": "2020-06-10T13:18:16Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNTYyNw==", "bodyText": "I think you should review your code to make sure this naming is the same everywhere. The name in the API is \"lastKnownVersion\" meaning the client knows of events up to and including this version.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438115627", "createdAt": "2020-06-10T13:20:32Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNjA1Ng==", "bodyText": "This is why the \"inclusiveVersion\" is kinda misleading here: the version is already inclusive, you are trying to compute the next eventId after that.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438116056", "createdAt": "2020-06-10T13:21:11Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNzg0MQ==", "bodyText": "This is more like \"eventIdToKeep\"", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438117841", "createdAt": "2020-06-10T13:23:36Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.ClientLogEvents;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventLog;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public boolean processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        return update.accept(visitor);\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> startVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> versionInclusive = startVersion.map(this::createInclusiveVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventMap.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventMap.firstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = versionInclusive.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventMap.subMap(fromSequence, INCLUSIVE, endVersion.version(), INCLUSIVE).values());\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeOldEntries(long earliestSequence) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExOTcwNQ==", "bodyText": "I don't think it would hurt to be defensive here and check that the events are contiguous and the first event in \"events\" has id that is the next if after your snapshot version.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438119705", "createdAt": "2020-06-10T13:26:13Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotImpl.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.ClientLockWatchSnapshot;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotImpl implements ClientLockWatchSnapshot {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshot create() {\n+        return new ClientLockWatchSnapshotImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public synchronized LockWatchStateUpdate.Snapshot getSnapshot() {\n+        Preconditions.checkState(snapshotVersion.isPresent(),\n+                \"Snapshot was reset on fail and has not been seeded since\");\n+        return LockWatchStateUpdate.snapshot(\n+                snapshotVersion.get().id(),\n+                snapshotVersion.get().version(),\n+                ImmutableSet.copyOf(locked),\n+                ImmutableSet.copyOf(watches));\n+    }\n+\n+    @Override\n+    public void processEvents(List<LockWatchEvent> events, IdentifiedVersion lastVersion) {\n+        events.forEach(event -> event.accept(visitor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "711e9bf5dca4a299e62330f05c3b88d0ceee0962"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14db375a512ddb5f9c1bb3bea9020d9ab9d0c626", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/14db375a512ddb5f9c1bb3bea9020d9ab9d0c626", "committedDate": "2020-06-10T13:54:35Z", "message": "split more things out"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6c1f78898dfedeec445e0690402c56dcd58a719", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/c6c1f78898dfedeec445e0690402c56dcd58a719", "committedDate": "2020-06-10T13:58:19Z", "message": "moved a load of things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd6b3abe1cca4ded6939fdb0e64137afa8d14e61", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/fd6b3abe1cca4ded6939fdb0e64137afa8d14e61", "committedDate": "2020-06-10T14:16:13Z", "message": "more changes per review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e54d0809d038b9f5b0c4f3601f49ba080092d92", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/8e54d0809d038b9f5b0c4f3601f49ba080092d92", "committedDate": "2020-06-10T14:28:50Z", "message": "fixup last tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ade7bca29ba0d396627a3c754950e4033536dade", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ade7bca29ba0d396627a3c754950e4033536dade", "committedDate": "2020-06-10T15:39:21Z", "message": "add store test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a311fcd0f3b3833f664d435b534eb38ad556deae", "committedDate": "2020-06-10T15:41:01Z", "message": "checkstyle hurrah"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MTk2Njg2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-428196686", "createdAt": "2020-06-10T15:51:41Z", "commit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo1MTo0MlrOGh7bpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo1MTo0MlrOGh7bpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyOTkyNQ==", "bodyText": "Dodgy diff, because I moved a load of things", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r438229925", "createdAt": "2020-06-10T15:51:42Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/CacheStatus.java", "diffHunk": "@@ -16,17 +16,17 @@\n \n package com.palantir.lock.watch;\n \n-import java.util.Collection;\n-import java.util.Optional;\n-import java.util.Set;\n+public enum CacheStatus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMzUzMDQ0", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-432353044", "createdAt": "2020-06-17T12:34:08Z", "commit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjozNDowOFrOGlDmaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoxMToyNlrOGlFA7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwOTQ4MQ==", "bodyText": "This should be long putAll(Iterable events), then your code that uses it becomes:\nlatestVersion = Optional.of(IdentifiedVersion.of(success.logId(), eventStore.putAll(success.events())));\n\nAnd you can make #getFirstKey private.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441509481", "createdAt": "2020-06-17T12:34:08Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {\n+        return eventMap.isEmpty();\n+    }\n+\n+    long getFirstKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get first key from empty map\");\n+        return eventMap.firstKey();\n+    }\n+\n+    long getLastKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get last key from empty map\");\n+        return eventMap.lastKey();\n+    }\n+\n+    Collection<LockWatchEvent> getEventsBetweenVersionsInclusive(long startVersion, long endVersion) {\n+        return eventMap.subMap(startVersion, INCLUSIVE, endVersion, INCLUSIVE).values();\n+    }\n+\n+    Set<Map.Entry<Long, LockWatchEvent>> getElementsUpToExclusive(long endVersion) {\n+        return ImmutableSet.copyOf(eventMap.headMap(endVersion).entrySet());\n+    }\n+\n+    void clearElementsUpToExclusive(long endVersion) {\n+        eventMap.headMap(endVersion).entrySet().clear();\n+    }\n+\n+    boolean hasFloorKey(long key) {\n+        return eventMap.floorKey(key) != null;\n+    }\n+\n+    void clear() {\n+        eventMap.clear();\n+    }\n+\n+    void put(long version, LockWatchEvent event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMDEzMw==", "bodyText": "This should be #contains.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441510133", "createdAt": "2020-06-17T12:35:14Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {\n+        return eventMap.isEmpty();\n+    }\n+\n+    long getFirstKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get first key from empty map\");\n+        return eventMap.firstKey();\n+    }\n+\n+    long getLastKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get last key from empty map\");\n+        return eventMap.lastKey();\n+    }\n+\n+    Collection<LockWatchEvent> getEventsBetweenVersionsInclusive(long startVersion, long endVersion) {\n+        return eventMap.subMap(startVersion, INCLUSIVE, endVersion, INCLUSIVE).values();\n+    }\n+\n+    Set<Map.Entry<Long, LockWatchEvent>> getElementsUpToExclusive(long endVersion) {\n+        return ImmutableSet.copyOf(eventMap.headMap(endVersion).entrySet());\n+    }\n+\n+    void clearElementsUpToExclusive(long endVersion) {\n+        eventMap.headMap(endVersion).entrySet().clear();\n+    }\n+\n+    boolean hasFloorKey(long key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMjk2Mw==", "bodyText": "I think this should be something like:\ngetLatestKnownVersion().ifPresent(currentVersion -> {\nSet<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventStore.removeEventsUpToExlusive(earliestSequence);\n  snapshot.processEvents(\n                removedEvents.stream().map(Map.Entry::getValue).collect(Collectors.toList()),\n                IdentifiedVersion.of(currentVersion.get().id(), latestDeletedVersion.get()))\n}) ;\n\nThis should allow you to get rid of VersionedEventStore#getElementsUpToExclusive and generally clean this up.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441512963", "createdAt": "2020-06-17T12:40:01Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final VersionedEventStore eventStore = new VersionedEventStore();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public CacheStatus processUpdate(LockWatchStateUpdate update) {\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            return update.accept(new NewLeaderVisitor());\n+        } else {\n+            return update.accept(new ProcessingVisitor());\n+        }\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> lastKnownVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> startVersion = lastKnownVersion.map(this::createStartVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;\n+\n+        if (!startVersion.isPresent() || differentLeaderOrTooFarBehind(currentVersion, startVersion.get())) {\n+            eventBuilder.addEvents(LockWatchCreatedEvent.fromSnapshot(snapshot.getSnapshot()));\n+            eventBuilder.clearCache(true);\n+            if (eventStore.isEmpty()) {\n+                return eventBuilder.build();\n+            }\n+            fromSequence = eventStore.getFirstKey();\n+        } else {\n+            eventBuilder.clearCache(false);\n+            fromSequence = startVersion.get().version();\n+        }\n+\n+        eventBuilder.addAllEvents(eventStore.getEventsBetweenVersionsInclusive(fromSequence, endVersion.version()));\n+        return eventBuilder.build();\n+    }\n+\n+    @Override\n+    public void removeEventsBefore(long earliestSequence) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved = eventStore.getElementsUpToExclusive(earliestSequence);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMzg5MQ==", "bodyText": "I feel like you could clean this up if this was Optional and then VersionedEventStore#getEventsBetweenVersionsInclusive takes an Optional. And you would get rid of VersionedStore#getFirstKey", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441513891", "createdAt": "2020-06-17T12:41:36Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class LockWatchEventLogImpl implements LockWatchEventLog {\n+    private final ClientLockWatchSnapshot snapshot;\n+    private final VersionedEventStore eventStore = new VersionedEventStore();\n+\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    static LockWatchEventLog create() {\n+        return create(ClientLockWatchSnapshotImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventLog create(ClientLockWatchSnapshot snapshot) {\n+        return new LockWatchEventLogImpl(snapshot);\n+    }\n+\n+    private LockWatchEventLogImpl(ClientLockWatchSnapshot snapshot) {\n+        this.snapshot = snapshot;\n+    }\n+\n+    @Override\n+    public CacheStatus processUpdate(LockWatchStateUpdate update) {\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            return update.accept(new NewLeaderVisitor());\n+        } else {\n+            return update.accept(new ProcessingVisitor());\n+        }\n+    }\n+\n+    @Override\n+    public ClientLogEvents getEventsBetweenVersions(\n+            Optional<IdentifiedVersion> lastKnownVersion,\n+            IdentifiedVersion endVersion) {\n+        Optional<IdentifiedVersion> startVersion = lastKnownVersion.map(this::createStartVersion);\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        ClientLogEvents.Builder eventBuilder = new ClientLogEvents.Builder();\n+        final long fromSequence;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDU2MA==", "bodyText": "Why do you sometimes copy and sometimes not? I feel like you should stick to one, and maybe consider Collections.unmodifiable* wrappers.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441514560", "createdAt": "2020-06-17T12:42:45Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {\n+        return eventMap.isEmpty();\n+    }\n+\n+    long getFirstKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get first key from empty map\");\n+        return eventMap.firstKey();\n+    }\n+\n+    long getLastKey() {\n+        Preconditions.checkState(!eventMap.isEmpty(), \"Cannot get last key from empty map\");\n+        return eventMap.lastKey();\n+    }\n+\n+    Collection<LockWatchEvent> getEventsBetweenVersionsInclusive(long startVersion, long endVersion) {\n+        return eventMap.subMap(startVersion, INCLUSIVE, endVersion, INCLUSIVE).values();\n+    }\n+\n+    Set<Map.Entry<Long, LockWatchEvent>> getElementsUpToExclusive(long endVersion) {\n+        return ImmutableSet.copyOf(eventMap.headMap(endVersion).entrySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNTQxMQ==", "bodyText": "In general I like this more, because reading floorKey etc. is not great in the other class. But you should just make sure you have API on this class that is not just a wrapping of NavigableMap without any renames that make sense. I suggested a few strategies above.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441515411", "createdAt": "2020-06-17T12:44:08Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/VersionedEventStore.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class VersionedEventStore {\n+    private static final boolean INCLUSIVE = true;\n+\n+    private final NavigableMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    boolean isEmpty() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjc2OA==", "bodyText": "nit: contiguous", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441516768", "createdAt": "2020-06-17T12:46:20Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotImpl.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotImpl implements ClientLockWatchSnapshot {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshot create() {\n+        return new ClientLockWatchSnapshotImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public LockWatchStateUpdate.Snapshot getSnapshot() {\n+        Preconditions.checkState(snapshotVersion.isPresent(),\n+                \"Snapshot was reset on fail and has not been seeded since\");\n+        return LockWatchStateUpdate.snapshot(\n+                snapshotVersion.get().id(),\n+                snapshotVersion.get().version(),\n+                ImmutableSet.copyOf(locked),\n+                ImmutableSet.copyOf(watches));\n+    }\n+\n+    @Override\n+    public void processEvents(List<LockWatchEvent> events, IdentifiedVersion lastVersion) {\n+        assertEventsAreContinguous(events);\n+        events.forEach(event -> event.accept(visitor));\n+        snapshotVersion = Optional.of(lastVersion);\n+    }\n+\n+    @Override\n+    public void resetWithSnapshot(LockWatchStateUpdate.Snapshot snapshot) {\n+        reset();\n+        watches.addAll(snapshot.lockWatches());\n+        locked.addAll(snapshot.locked());\n+        snapshotVersion = Optional.of(IdentifiedVersion.of(snapshot.logId(), snapshot.lastKnownVersion()));\n+    }\n+\n+    @Override\n+    public void reset() {\n+        snapshotVersion = Optional.empty();\n+        watches.clear();\n+        locked.clear();\n+    }\n+\n+    private void assertEventsAreContinguous(List<LockWatchEvent> events) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMDI2NQ==", "bodyText": "I have a feeling that this would be much nicer if:\n\nOnce you have my other suggestions about the code in LockWatchEventLogImpl#removeEvents\nclearElementsUpToExclusive actually returns a LockWatchEvents little type.\nprocessEvents in this class accepts that, and only that. It then computes the latest version by getting the last event itself. Basically it feels weird to pass it something that it then needs to trust was computed correctly.\n\nAnd then LockWatchEvents is a small wrapper around a list of events that validates continuity. And then", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441520265", "createdAt": "2020-06-17T12:52:09Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/ClientLockWatchSnapshotImpl.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class ClientLockWatchSnapshotImpl implements ClientLockWatchSnapshot {\n+    private final Set<LockWatchReferences.LockWatchReference> watches;\n+    private final Set<LockDescriptor> locked;\n+    private final EventVisitor visitor;\n+    private Optional<IdentifiedVersion> snapshotVersion;\n+\n+    static ClientLockWatchSnapshot create() {\n+        return new ClientLockWatchSnapshotImpl();\n+    }\n+\n+    private ClientLockWatchSnapshotImpl() {\n+        this.watches = new HashSet<>();\n+        this.locked = new HashSet<>();\n+        this.visitor = new EventVisitor();\n+        this.snapshotVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public LockWatchStateUpdate.Snapshot getSnapshot() {\n+        Preconditions.checkState(snapshotVersion.isPresent(),\n+                \"Snapshot was reset on fail and has not been seeded since\");\n+        return LockWatchStateUpdate.snapshot(\n+                snapshotVersion.get().id(),\n+                snapshotVersion.get().version(),\n+                ImmutableSet.copyOf(locked),\n+                ImmutableSet.copyOf(watches));\n+    }\n+\n+    @Override\n+    public void processEvents(List<LockWatchEvent> events, IdentifiedVersion lastVersion) {\n+        assertEventsAreContinguous(events);\n+        events.forEach(event -> event.accept(visitor));\n+        snapshotVersion = Optional.of(lastVersion);\n+    }\n+\n+    @Override\n+    public void resetWithSnapshot(LockWatchStateUpdate.Snapshot snapshot) {\n+        reset();\n+        watches.addAll(snapshot.lockWatches());\n+        locked.addAll(snapshot.locked());\n+        snapshotVersion = Optional.of(IdentifiedVersion.of(snapshot.logId(), snapshot.lastKnownVersion()));\n+    }\n+\n+    @Override\n+    public void reset() {\n+        snapshotVersion = Optional.empty();\n+        watches.clear();\n+        locked.clear();\n+    }\n+\n+    private void assertEventsAreContinguous(List<LockWatchEvent> events) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzMjY1NQ==", "bodyText": "I will put one comment for LockWatchEventCacheImplTest and LockWatchEventLogImplTest (and kinda LockWattchEventCacheIntegrationTest):\nI feel that the tests in LockWatchEventCacheImplTest and LockWatchEventLogImplTest, where you mock all the datastructures underneath them, are quite fragile in general. What I kinda had in mind is:\n\nLockWatchEventCacheImpl has a package private method called #getSnapshot which returns a Snapshot of all the internal datastructures (so it contains log of events, all the open transactions and their state, and current snapshot). That thing is Json serializable\nYou only have 1 big integration test, that tests a bunch of scenarios where you poke the LockWatchEventCacheImpl, but after each step take a snapshot and compare it to a golden file (and do as many steps as you want).\nThe review is just a matter of: read a test case in LockWAtchEventCacheImplIntegrationTest, understand what it should do to the internal datastructures, and go diff each step and see that the right thing happened.\n\nThis is a bit of extra code that will only be used for tests, however I would argue that the implementation of this cache is the critical piece to all of lock watches (this and the timelock code).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r441532655", "createdAt": "2020-06-17T13:11:26Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImplTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public final class LockWatchEventCacheImplTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a311fcd0f3b3833f664d435b534eb38ad556deae"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00949554e8a2361341bce9ca7d304c9c8b13c789", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/00949554e8a2361341bce9ca7d304c9c8b13c789", "committedDate": "2020-06-17T16:24:07Z", "message": "clean up a load of things; tests are probably broken"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a07e577be9585f14adc62f8e85b5b12c6c22640", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0a07e577be9585f14adc62f8e85b5b12c6c22640", "committedDate": "2020-06-19T13:56:56Z", "message": "bleh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "923b285787e12b3035bf529b86154cc3c8f047ff", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/923b285787e12b3035bf529b86154cc3c8f047ff", "committedDate": "2020-06-22T09:44:26Z", "message": "json test approach"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/752379c0f334106ef69ab5dc8ae04ff2af0e2557", "committedDate": "2020-06-22T09:47:47Z", "message": "remove old tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODA5ODU1", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434809855", "createdAt": "2020-06-22T10:48:14Z", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo0ODoxNFrOGm7fAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo0NjoxMVrOGm9Jig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MzY2Nw==", "bodyText": "I think we discussed that ideally we won't have these directly on this class. Either have a small Snapshot class defined or remove these and it will likely still work (cause Jackson is magic).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443473667", "createdAt": "2020-06-22T10:48:14Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.watch.TimestampStateStore.CommitInfo;\n+import com.palantir.atlasdb.transaction.api.TransactionLockWatchFailedException;\n+import com.palantir.atlasdb.util.MetricsManager;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CacheStatus;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableInvalidateAll;\n+import com.palantir.lock.watch.ImmutableInvalidateSome;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.NoOpLockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This class should only be used through {@link ResilientLockWatchEventCache} as a proxy; failure to do so will result\n+ * in concurrency issues and inconsistency in the cache state.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    @JsonProperty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MTMyNQ==", "bodyText": "All the tests start in exactly the same way, can you refactor this somehow?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443481325", "createdAt": "2020-06-22T11:03:40Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDAzNw==", "bodyText": "So in JSON I believe these will be serialized as base64 or base32; can you make this visible in these constant for ease of reference? So like create the byte[] from base64/32 string.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443494037", "createdAt": "2020-06-22T11:31:07Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5OTczMQ==", "bodyText": "Reviewed, diff make sense.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443499731", "createdAt": "2020-06-22T11:43:48Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwMDkzOA==", "bodyText": "Reviewed, diff makes sense.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443500938", "createdAt": "2020-06-22T11:46:11Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODU5NzU3", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434859757", "createdAt": "2020-06-22T12:07:39Z", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjowNzozOVrOGm9yWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjowNzozOVrOGm9yWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMTM4Nw==", "bodyText": "Reviewed makes sense.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443511387", "createdAt": "2020-06-22T12:07:39Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 156}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODY0NjIx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434864621", "createdAt": "2020-06-22T12:15:08Z", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoxNTowOFrOGm-A9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyNDowOVrOGm-Ttw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNTEyNg==", "bodyText": "So the fact that snapshot is at 6, but current version is 10, and you only have event 10 means, next snapshot computation would fail right? I think you should make sure your tests don't construct wrong situations. This also hints that we should probably put detection around this into the code?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443515126", "createdAt": "2020-06-22T12:15:08Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/resources/lockwatch-event-cache-output/getEventsForTransactionsReturnsSnapshotWithOldEvents/event-cache-2.json", "diffHunk": "@@ -0,0 +1,51 @@\n+{\n+  \"eventLog\" : {\n+    \"snapshot\" : {\n+      \"watches\" : [ {\n+        \"type\" : \"fullTable\",\n+        \"qualifiedTableRef\" : \"table\"\n+      } ],\n+      \"locked\" : [ {\n+        \"bytes\" : \"dGFibGUAAQ==\"\n+      }, {\n+        \"bytes\" : \"dGFibGUAAw==\"\n+      } ],\n+      \"snapshotVersion\" : {\n+        \"id\" : \"470c855e-f77b-44df-b56a-14d3df085dbc\",\n+        \"version\" : 6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjMwNw==", "bodyText": "Why isn't latestVersion set here?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443516307", "createdAt": "2020-06-22T12:17:27Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/resources/lockwatch-event-cache-output/leaderChangeClearsCaches/event-cache-1.json", "diffHunk": "@@ -0,0 +1,17 @@\n+{\n+  \"eventLog\" : {\n+    \"snapshot\" : {\n+      \"watches\" : [ ],\n+      \"locked\" : [ ],\n+      \"snapshotVersion\" : null\n+    },\n+    \"eventStore\" : {\n+      \"eventMap\" : { }\n+    },\n+    \"latestVersion\" : null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzA5NA==", "bodyText": "Actually shouldn't this throw? You have received a success update from timelock by you don't know what the snapshot is.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443517094", "createdAt": "2020-06-22T12:18:58Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzk3OA==", "bodyText": "Ah, I see you handle this. I would just say that this is probably an unexpected state to be in, but maybe possible if leaders switch quickly somehow, and given concurrency between startTransaction and commitTimestamp calls.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443517978", "createdAt": "2020-06-22T12:20:34Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzA5NA=="}, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTQ1NA==", "bodyText": "Reviewed", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519454", "createdAt": "2020-06-22T12:23:11Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTc4NA==", "bodyText": "Yeah, I think this is what I mean: you should throw immediately when you discover a discontinuity, so probably that validation should be pushed up from snapshot to event cache.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519784", "createdAt": "2020-06-22T12:23:52Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxOTkyNw==", "bodyText": "Same here.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443519927", "createdAt": "2020-06-22T12:24:09Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");\n+    }\n+\n+    @Test\n+    public void snapshotMissedEventThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 5L, ImmutableList.of(UNLOCK_EVENT)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(LOCK_EVENT)));\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(16L))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events missing between last snapshot and this batch of events\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 240}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODczMjcx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434873271", "createdAt": "2020-06-22T12:27:17Z", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyNzoxN1rOGm-aZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyNzoxN1rOGm-aZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyMTYzOQ==", "bodyText": "I think I am missing a test where you have at least 2 successful updates.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443521639", "createdAt": "2020-06-22T12:27:17Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODc1MTQy", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434875142", "createdAt": "2020-06-22T12:29:51Z", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyOTo1MlrOGm-f2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoyOTo1MlrOGm-f2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyMzAzMg==", "bodyText": "Let's add a test where you race some updates, to simulate 2 concurrent calls (startTransactions and commitTimestamps): they will both start with the same version being sent to timelock, and let's say return same events, so second update should be no-op.\nSo basically something like:\neventCache.processStartTranscationUpdate(TIMESTAMPS, UPDATE);\neventCache.processStartTransactionUpdate(TIMESTAMPS2, UPDATE);\n\nEvents are the same, so you should remember the new timestamps, but event store should not change.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443523032", "createdAt": "2020-06-22T12:29:52Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");\n+    }\n+\n+    @Test\n+    public void snapshotMissedEventThrows() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODc4MDg2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434878086", "createdAt": "2020-06-22T12:34:04Z", "commit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjozNDowNVrOGm-oXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjozNDowNVrOGm-oXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUyNTIxNQ==", "bodyText": "Another test to simulate concurrent calls: 2 calls come back but one of them has more events then the other. So again, second call with less events is no-op. So something like:\neventCache.processStartTranscationUpdate(TIMESTAMPS, BIG_UPDATE);\neventCache.processStartTranscationUpdate(TIMESTAMPS2, SMALL_UPDATE)\n\nWhere BIG_UPDATE, say, has events [1,2,3,4,5] and SMALL_UPDATE has [1,2,3]. Again, transactions should be remembered, by nothing in the event log should change.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443525215", "createdAt": "2020-06-22T12:34:05Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchEventCacheIntegrationTest.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.TransactionUpdate;\n+import com.palantir.lock.watch.TransactionsLockWatchUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public class LockWatchEventCacheIntegrationTest {\n+    private static final String TABLE = \"table\";\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, new byte[] {1});\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, new byte[] {2});\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, new byte[] {3});\n+    private static final LockWatchReferences.LockWatchReference REFERENCE = LockWatchReferences.entireTable(\"table\");\n+    private static final UUID COMMIT_UUID = UUID.fromString(\"203fcd7a-b3d7-4c2a-9d2c-3d61cde1ba59\");\n+    private static final LockToken COMMIT_TOKEN = LockToken.of(COMMIT_UUID);\n+\n+    private static final LockWatchEvent WATCH_EVENT =\n+            LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE), ImmutableSet.of(DESCRIPTOR)).build(4L);\n+    private static final LockWatchEvent UNLOCK_EVENT = UnlockEvent.builder(ImmutableSet.of(DESCRIPTOR_2)).build(5L);\n+    private static final LockWatchEvent LOCK_EVENT =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR_3), COMMIT_TOKEN).build(6L);\n+    private static final UUID EVENT2_UUID = UUID.fromString(\"888fcd7a-b3d7-4d2a-9d2c-3d61cde1ba44\");\n+    private static final LockWatchEvent LOCK_EVENT_2 =\n+            LockEvent.builder(ImmutableSet.of(DESCRIPTOR), LockToken.of(EVENT2_UUID)).build(10L);\n+\n+    private static final UUID LEADER = UUID.fromString(\"470c855e-f77b-44df-b56a-14d3df085dbc\");\n+    private static final LockWatchStateUpdate SNAPSHOT =\n+            LockWatchStateUpdate.snapshot(LEADER, 3L, ImmutableSet.of(DESCRIPTOR_2), ImmutableSet.of());\n+    private static final LockWatchStateUpdate SUCCESS =\n+            LockWatchStateUpdate.success(LEADER, 6L, ImmutableList.of(WATCH_EVENT, UNLOCK_EVENT, LOCK_EVENT));\n+    private static final long START_TS = 1L;\n+    private static final Set<TransactionUpdate> COMMIT_UPDATE = ImmutableSet.of(\n+            ImmutableTransactionUpdate.builder().startTs(START_TS).commitTs(5L).writesToken(COMMIT_TOKEN).build());\n+    private static final Set<Long> TIMESTAMPS = ImmutableSet.of(START_TS);\n+    private static final Set<Long> TIMESTAMPS_2 = ImmutableSet.of(16L);\n+    private static final String BASE = \"src/test/resources/lockwatch-event-cache-output/\";\n+    private static final Mode MODE = Mode.CI;\n+\n+    private enum Mode {\n+        DEV,\n+        CI;\n+\n+        boolean isDev() {\n+            return this.equals(Mode.DEV);\n+        }\n+\n+    }\n+\n+    private LockWatchEventCache eventCache;\n+    private int part;\n+\n+    @Rule\n+    public TestName name = new TestName();\n+\n+    @Before\n+    public void before() {\n+        eventCache = new LockWatchEventCacheImpl(LockWatchEventLogImpl.create());\n+        part = 1;\n+    }\n+\n+    private void verifyStage() {\n+        ObjectMapper mapper = new ObjectMapper()\n+                .enable(SerializationFeature.INDENT_OUTPUT)\n+                .registerModule(new Jdk8Module())\n+                .registerModule(new GuavaModule());\n+        try {\n+            Path path = Paths.get(BASE + name.getMethodName() + \"/event-cache-\" + part + \".json\");\n+\n+            if (MODE.isDev()) {\n+                mapper.writeValue(path.toFile(), eventCache);\n+            } else {\n+                String ourJson = mapper.writeValueAsString(eventCache);\n+                String theirJson = new String(Files.readAllBytes(path), Charset.defaultCharset());\n+                assertThat(ourJson).isEqualTo(theirJson);\n+            }\n+            part++;\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Test\n+    public void processStartTimestampUpdateOnMultipleBatches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        verifyStage();\n+\n+        Set<Long> secondTimestamps = ImmutableSet.of(5L, 123L);\n+        eventCache.processStartTransactionsUpdate(secondTimestamps, SUCCESS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getCommitUpdateDoesNotContainCommitLocks() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        verifyStage();\n+\n+        CommitUpdate commitUpdate = eventCache.getCommitUpdate(1L);\n+        assertThat(commitUpdate.accept(new CommitUpdateVisitor()))\n+                .containsExactlyInAnyOrder(DESCRIPTOR);\n+    }\n+\n+    @Test\n+    public void cacheClearedOnSnapshotUpdate() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate snapshot2 = LockWatchStateUpdate.snapshot(LEADER, 7L, ImmutableSet.of(DESCRIPTOR),\n+                ImmutableSet.of());\n+        Set<Long> timestamps3 = ImmutableSet.of(123L, 1255L);\n+        eventCache.processStartTransactionsUpdate(timestamps3, snapshot2);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void getEventsForTransactionsReturnsSnapshotWithOldEvents() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processGetCommitTimestampsUpdate(COMMIT_UPDATE, SUCCESS);\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+\n+        LockWatchStateUpdate success2 = LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(LOCK_EVENT_2));\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, success2);\n+        verifyStage();\n+\n+        TransactionsLockWatchUpdate results = eventCache.getUpdateForTransactions(TIMESTAMPS_2, Optional.empty());\n+        assertThat(results.clearCache()).isTrue();\n+        assertThat(results.startTsToSequence()).containsExactlyInAnyOrderEntriesOf(\n+                ImmutableMap.of(16L, IdentifiedVersion.of(LEADER, 10L)));\n+        assertThat(results.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(ImmutableSet.of(REFERENCE),\n+                        ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_3)).build(6L),\n+                LOCK_EVENT_2);\n+    }\n+\n+    @Test\n+    public void failedUpdateClearsAllCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, LockWatchStateUpdate.failed(LEADER));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void leaderChangeClearsCaches() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(EVENT2_UUID, 4L, ImmutableList.of()));\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void removingEntriesRetentionsEventsInLog() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2, SUCCESS);\n+        verifyStage();\n+\n+        eventCache.removeTransactionStateFromCache(START_TS);\n+        verifyStage();\n+    }\n+\n+    @Test\n+    public void nonContiguousEventsThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS_2,\n+                LockWatchStateUpdate.success(LEADER, 10L, ImmutableList.of(WATCH_EVENT, LOCK_EVENT, LOCK_EVENT_2)));\n+        eventCache.processStartTransactionsUpdate(ImmutableSet.of(23L, 55L),\n+                LockWatchStateUpdate.success(LEADER, 20L,\n+                        ImmutableList.of(UnlockEvent.builder(ImmutableSet.of()).build(20L))));\n+        verifyStage();\n+        assertThatThrownBy(() -> eventCache.removeTransactionStateFromCache(START_TS))\n+                .isExactlyInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Events form a non-contiguous sequence\");\n+    }\n+\n+    @Test\n+    public void snapshotMissedEventThrows() {\n+        eventCache.processStartTransactionsUpdate(TIMESTAMPS, SNAPSHOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752379c0f334106ef69ab5dc8ae04ff2af0e2557"}, "originalPosition": 229}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "884a89a9e787d13d43e71c84d66cabf519f695ed", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/884a89a9e787d13d43e71c84d66cabf519f695ed", "committedDate": "2020-06-22T12:54:07Z", "message": "rewrite json testing stuff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODkzODY0", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434893864", "createdAt": "2020-06-22T12:54:59Z", "commit": {"oid": "884a89a9e787d13d43e71c84d66cabf519f695ed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4421c87b1a56ea74fb8c77b57ba581d134a41f3f", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/4421c87b1a56ea74fb8c77b57ba581d134a41f3f", "committedDate": "2020-06-22T12:57:32Z", "message": "remove unused block"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fa9cefff070a08af4a69b65dc57dadd4df1351f", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/6fa9cefff070a08af4a69b65dc57dadd4df1351f", "committedDate": "2020-06-22T12:59:31Z", "message": "remove unused property flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a16aeaab4638238cc0d4415235c11db3d57005a2", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a16aeaab4638238cc0d4415235c11db3d57005a2", "committedDate": "2020-06-22T13:12:16Z", "message": "remove unused json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f18748986c0709df9422558798214a38502733c2", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/f18748986c0709df9422558798214a38502733c2", "committedDate": "2020-06-22T13:25:21Z", "message": "fix bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0OTIwMjk3", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-434920297", "createdAt": "2020-06-22T13:26:34Z", "commit": {"oid": "f18748986c0709df9422558798214a38502733c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzoyNjozNFrOGnAhKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzoyNjozNFrOGnAhKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU1NjEzOQ==", "bodyText": "Wonky diff!", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r443556139", "createdAt": "2020-06-22T13:26:34Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/CacheUpdate.java", "diffHunk": "@@ -14,19 +14,28 @@\n  * limitations under the License.\n  */\n \n-package com.palantir.lock.watch;\n+package com.palantir.atlasdb.keyvalue.api.watch;\n \n-import java.util.Collection;\n import java.util.Optional;\n-import java.util.Set;\n-\n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    void processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processGetCommitTimestampsUpdate(Collection<TransactionUpdate> transactionUpdates,\n-            LockWatchStateUpdate update);\n-    CommitUpdate getCommitUpdate(long startTs);\n-    TransactionsLockWatchUpdate getUpdateForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n-    void removeTransactionStateFromCache(long startTimestamp);\n+\n+import com.palantir.lock.watch.IdentifiedVersion;\n+\n+final class CacheUpdate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f18748986c0709df9422558798214a38502733c2"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24845fb6e22ae2aa554ef931646475dc93887750", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/24845fb6e22ae2aa554ef931646475dc93887750", "committedDate": "2020-06-22T13:57:03Z", "message": "fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a26d91744ba520707f614fc955c0fd3aef3690a", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/1a26d91744ba520707f614fc955c0fd3aef3690a", "committedDate": "2020-06-22T14:09:09Z", "message": "remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3792064e3489c5099deb8905bb44426c3ec6ee56", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/3792064e3489c5099deb8905bb44426c3ec6ee56", "committedDate": "2020-05-19T14:46:33Z", "message": "some move over"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66faf28be1904c08caa9299f48128a585bdf58c5", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/66faf28be1904c08caa9299f48128a585bdf58c5", "committedDate": "2020-05-22T12:53:04Z", "message": "more progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51bec1cc362f2f668841f824e712ac08306820d3", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/51bec1cc362f2f668841f824e712ac08306820d3", "committedDate": "2020-05-26T09:01:34Z", "message": "tidy up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03e002c5cb07c956f89c74731e1c3862b3db89fa", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/03e002c5cb07c956f89c74731e1c3862b3db89fa", "committedDate": "2020-05-26T09:03:45Z", "message": "Merge branch 'develop' into lw-client-lwec\n\n# Conflicts:\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java\n#\tlock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "567f68b7f0d9b8bf14ab2a859e99625269eeebec", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/567f68b7f0d9b8bf14ab2a859e99625269eeebec", "committedDate": "2020-05-26T09:22:33Z", "message": "merge in develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d7484a38c3e5d22856712240a3aa947deb4c305", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/8d7484a38c3e5d22856712240a3aa947deb4c305", "committedDate": "2020-05-26T09:28:06Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47925adc5f220db94b38a18145c13d50b6dccbb6", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/47925adc5f220db94b38a18145c13d50b6dccbb6", "committedDate": "2020-05-26T09:58:01Z", "message": "fix invalidate call"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6f27bf544a44492863e3a7b38e4fa7e0c933547", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/f6f27bf544a44492863e3a7b38e4fa7e0c933547", "committedDate": "2020-05-26T09:58:23Z", "message": "remove extraneous also"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c55c561569c3075c2536b1f59cc53118181bcb45", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/c55c561569c3075c2536b1f59cc53118181bcb45", "committedDate": "2020-05-26T10:27:33Z", "message": "Split line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5937a2ad7c14e565b5885d14331b8ebab52621fe", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/5937a2ad7c14e565b5885d14331b8ebab52621fe", "committedDate": "2020-05-26T10:29:22Z", "message": "tidy javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d5fe6f4d202a4a5f805b2691eb3d806d0891956", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/9d5fe6f4d202a4a5f805b2691eb3d806d0891956", "committedDate": "2020-05-26T12:51:04Z", "message": "reworked to be smoother"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f891fab695f028440d5553506cba4d0cbd89b66", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7f891fab695f028440d5553506cba4d0cbd89b66", "committedDate": "2020-05-26T12:59:59Z", "message": "process events"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2632cfbd358e8340b73471cf3eb0702cdc94abdc", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/2632cfbd358e8340b73471cf3eb0702cdc94abdc", "committedDate": "2020-05-26T13:17:22Z", "message": "implement snapshot thing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2db213804283140b24b243b40a0074bbc2c36c42", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/2db213804283140b24b243b40a0074bbc2c36c42", "committedDate": "2020-05-26T13:17:27Z", "message": "Merge branch 'lw-client-lwel-6' into lw-client-updater"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1491da9efe764685acf51d9f9a349ff0ce282ace", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/1491da9efe764685acf51d9f9a349ff0ce282ace", "committedDate": "2020-05-26T13:23:37Z", "message": "clean some things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "087ef9a0c3434e7c884a0f70032a4aff49200a38", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/087ef9a0c3434e7c884a0f70032a4aff49200a38", "committedDate": "2020-05-26T13:24:27Z", "message": "take updates from lw-client-updater"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783993e7963e1ae7a541824ba146c54ff259305a", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/783993e7963e1ae7a541824ba146c54ff259305a", "committedDate": "2020-05-26T13:25:22Z", "message": "merge in interface change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4e012c815b186c4244cf5dc2b1591eb3145011c", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/d4e012c815b186c4244cf5dc2b1591eb3145011c", "committedDate": "2020-05-26T13:52:53Z", "message": "move to different place and begin writing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88375c23784dd9339c25a110994939db62aaf18c", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/88375c23784dd9339c25a110994939db62aaf18c", "committedDate": "2020-05-26T14:55:25Z", "message": "rework a little"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03f23a5e1cb63023c73f04e7006b194cbf945b99", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/03f23a5e1cb63023c73f04e7006b194cbf945b99", "committedDate": "2020-05-26T14:56:46Z", "message": "remove extraneous if statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2d6ba262e5fea00c5639eff58f926e9030d60db", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b2d6ba262e5fea00c5639eff58f926e9030d60db", "committedDate": "2020-05-26T15:04:41Z", "message": "begin cleaning up tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a10d3c6de85b8dcf6932ca943cada8a4b18e927", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/8a10d3c6de85b8dcf6932ca943cada8a4b18e927", "committedDate": "2020-05-26T15:19:48Z", "message": "fix failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c47e620e892790bc7f2a8f5a46fbd3ffdafd5d2", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7c47e620e892790bc7f2a8f5a46fbd3ffdafd5d2", "committedDate": "2020-05-27T08:28:10Z", "message": "change to use queue for better concurrency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a346359dc71cc7d54649dd2024afbe717e3d7d4b", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a346359dc71cc7d54649dd2024afbe717e3d7d4b", "committedDate": "2020-05-27T08:52:58Z", "message": "fix up tests further"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa21cfa20248b2b92d0dcbf573fb317d456b7ccf", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/aa21cfa20248b2b92d0dcbf573fb317d456b7ccf", "committedDate": "2020-05-27T09:03:08Z", "message": "further tidy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18e55d4e6bb0a139ee5880bf8f3600e6ca5fc5e8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/18e55d4e6bb0a139ee5880bf8f3600e6ca5fc5e8", "committedDate": "2020-05-27T09:04:03Z", "message": "merge in lwec changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbdc66cc44624081d9e7cafa9c89fa083ef0ff49", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/bbdc66cc44624081d9e7cafa9c89fa083ef0ff49", "committedDate": "2020-05-27T09:05:34Z", "message": "move events change to lwec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb814703df2a9eff0ddceb132f5bb80cd6264358", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/fb814703df2a9eff0ddceb132f5bb80cd6264358", "committedDate": "2020-05-27T09:05:48Z", "message": "Merge branch 'lw-client-lwec' into lw-client-lwel-6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0aafe4832366277001208f765d808f73be1b499", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b0aafe4832366277001208f765d808f73be1b499", "committedDate": "2020-05-27T09:30:39Z", "message": "further tidy up and move to proper place"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9799c448b2bce358e7b013337bba832bb4c61934", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/9799c448b2bce358e7b013337bba832bb4c61934", "committedDate": "2020-05-27T09:31:35Z", "message": "merge in earlier in chain entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f590f46ca3fc3354b8beff5e15d9d72c860855b", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/9f590f46ca3fc3354b8beff5e15d9d72c860855b", "committedDate": "2020-05-27T09:36:33Z", "message": "update snapshotter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "439db7c896759e96e5158068a9ac731257976662", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/439db7c896759e96e5158068a9ac731257976662", "committedDate": "2020-05-27T09:37:17Z", "message": "merge from above"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e87b893d6855c81056f2f3c65953248bbeb63917", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/e87b893d6855c81056f2f3c65953248bbeb63917", "committedDate": "2020-05-27T10:19:54Z", "message": "begin writing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7994e4deff7fb0608edfd242e9dfacd1c3fc52d", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/d7994e4deff7fb0608edfd242e9dfacd1c3fc52d", "committedDate": "2020-05-27T10:24:24Z", "message": "further improvement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f0dda9b9f6d9059a1a8a857b4a31488d5bb20c2", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0f0dda9b9f6d9059a1a8a857b4a31488d5bb20c2", "committedDate": "2020-05-27T10:42:52Z", "message": "fix out-by-ones"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be1e98cfe593047cccd121344e79431149cb02d5", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/be1e98cfe593047cccd121344e79431149cb02d5", "committedDate": "2020-05-27T12:04:14Z", "message": "merge in previous branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c396b07a71402745a7973268065627d0979fcc5f", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/c396b07a71402745a7973268065627d0979fcc5f", "committedDate": "2020-05-27T12:10:46Z", "message": "change to return immutable sets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebfc2a36e6a17b858c9bc5a8fb2add1b0c58542a", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ebfc2a36e6a17b858c9bc5a8fb2add1b0c58542a", "committedDate": "2020-05-27T14:39:15Z", "message": "rework tests and tidy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44", "committedDate": "2020-05-27T14:44:21Z", "message": "remove no op implementations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5MzQ1NTEx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-419345511", "createdAt": "2020-05-27T15:31:59Z", "commit": {"oid": "ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTozMTo1OVrOGbQfFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTozMTo1OVrOGbQfFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIzNDgzNw==", "bodyText": "What happens when timestampToVersion is empty?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431234837", "createdAt": "2020-05-27T15:31:59Z", "author": {"login": "jkozlowski"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventLog;\n+    private volatile Optional<IdentifiedVersion> latestVersion;\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return new ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+        this.eventLog = new ConcurrentSkipListMap<>();\n+        this.latestVersion = Optional.empty();\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(\n+            LockWatchStateUpdate update,\n+            Optional<IdentifiedVersion> earliestVersion) {\n+        ProcessingVisitor visitor;\n+        if (newLeader(update)) {\n+            visitor = new NewLeaderVisitor(earliestVersion);\n+        } else {\n+            visitor = new ProcessingVisitor(earliestVersion);\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        Optional<IdentifiedVersion> versionInclusive =\n+                version.map(oldVersion -> IdentifiedVersion.of(oldVersion.id(), oldVersion.version() + 1));\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        /*\n+        There are three cases to consider where we would return a snapshot:\n+            1: they provide an empty version;\n+            2. their version has a different UUID (i.e. refers to the wrong leader);\n+            3. their version is behind our log.\n+        Note that if their version is ahead of our log, or we do not have a version, an exception is thrown instead.\n+         */\n+        if (!versionInclusive.isPresent()\n+                || !versionInclusive.get().id().equals(currentVersion.id())\n+                || eventLog.floorKey(versionInclusive.get().version()) == null) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba284b1ae7e88d796761ec1ae4cb2d5a9439bf44"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eaaa9291c9b2eb3e605f86ae4490d5f2df733a4", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/1eaaa9291c9b2eb3e605f86ae4490d5f2df733a4", "committedDate": "2020-05-27T16:05:35Z", "message": "add preconditions check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df8be797623ce419b38ed47df893db4e8cb1da49", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/df8be797623ce419b38ed47df893db4e8cb1da49", "committedDate": "2020-05-28T09:29:05Z", "message": "tidy lwec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "979a218f7c9365f528ef128429fc9060bc13d621", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/979a218f7c9365f528ef128429fc9060bc13d621", "committedDate": "2020-05-28T09:52:28Z", "message": "rework test for LWEC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "367d7bf92d7119bf06b0920eabc3e9f2bc2f0562", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/367d7bf92d7119bf06b0920eabc3e9f2bc2f0562", "committedDate": "2020-05-28T10:09:56Z", "message": "clean up impls some more"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5911c0293b940aa72c155d142c516cdb68c7f62", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a5911c0293b940aa72c155d142c516cdb68c7f62", "committedDate": "2020-05-28T10:19:27Z", "message": "tidy up lwel tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "587796014b685eec6ee3d289fe8d627a2946e6ae", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/587796014b685eec6ee3d289fe8d627a2946e6ae", "committedDate": "2020-05-28T10:29:19Z", "message": "write snapshotter tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "def4fa47f8b4e3968c7b67575ae4020260ff25d9", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/def4fa47f8b4e3968c7b67575ae4020260ff25d9", "committedDate": "2020-05-28T10:39:23Z", "message": "remove concurrent skip list map from lwec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2aaf8fdb6b6bafcc6accfbd9c61c59ef0a4d7f92", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/2aaf8fdb6b6bafcc6accfbd9c61c59ef0a4d7f92", "committedDate": "2020-05-28T12:26:33Z", "message": "Merge branch 'develop' into lw-client-cache-ete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/38e8dd49dca47ec5460a8c2fa40d079bf463d7c6", "committedDate": "2020-05-28T13:16:28Z", "message": "merge in and add commit update - DOES NOT USE LOCK TOKEN YET"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTMwMDU5", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420130059", "createdAt": "2020-05-28T13:53:35Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1MzozNVrOGb2LdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1MzozNVrOGb2LdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MjQwNQ==", "bodyText": "should this be aware of table references + cells?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431852405", "createdAt": "2020-05-28T13:53:35Z", "author": {"login": "j-baker"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/CommitUpdate.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface CommitUpdate {\n+    long commitTs();\n+\n+    <T> T accept(Visitor<T> visitor);\n+\n+    @Value.Immutable\n+    interface InvalidateAll extends CommitUpdate {\n+        @Override\n+        default <T> T accept(Visitor<T> visitor) {\n+            return visitor.visit(this);\n+        }\n+    }\n+\n+    @Value.Immutable\n+    interface InvalidateSome extends CommitUpdate {\n+        Set<LockDescriptor> invalidatedLocks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTMxNDk1", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420131495", "createdAt": "2020-05-28T13:55:02Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NTowMlrOGb2PuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NTowMlrOGb2PuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzQ5Ng==", "bodyText": "you should probably throw if they're incomparable?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431853496", "createdAt": "2020-05-28T13:55:02Z", "author": {"login": "j-baker"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -21,9 +21,19 @@\n import org.immutables.value.Value;\n \n @Value.Immutable\n-public interface IdentifiedVersion {\n+public interface IdentifiedVersion extends Comparable<IdentifiedVersion> {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    @Override\n+    default int compareTo(IdentifiedVersion otherVersion) {\n+        // Compare on version only; if used for equality, will not consider leader id\n+        return Long.compare(version(), otherVersion.version());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTMyMTY2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420132166", "createdAt": "2020-05-28T13:55:40Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NTo0MFrOGb2Rpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NTo0MFrOGb2Rpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1Mzk5MQ==", "bodyText": "IdentifiedVersion needs to change name", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431853991", "createdAt": "2020-05-28T13:55:40Z", "author": {"login": "j-baker"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -50,7 +50,7 @@ static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n         @Value.Parameter\n         List<LockWatchEvent> events();\n         @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n+        Map<Long, IdentifiedVersion> startTsToSequence();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTMzNjIx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420133621", "createdAt": "2020-05-28T13:57:05Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NzowNVrOGb2WLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NzowNVrOGb2WLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTE1MQ==", "bodyText": "split process update and aging out older entries", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431855151", "createdAt": "2020-05-28T13:57:05Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface ClientLockWatchEventLog {\n+    TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version);\n+    Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion);\n+    Optional<IdentifiedVersion> getLatestKnownVersion();\n+    Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update, Optional<IdentifiedVersion> earliestVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTM0MTc2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420134176", "createdAt": "2020-05-28T13:57:38Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NzozOVrOGb2Xzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1NzozOVrOGb2Xzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTU2Ng==", "bodyText": "remove Concurrent + volatile", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431855566", "createdAt": "2020-05-28T13:57:39Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventMap = new ConcurrentSkipListMap<>();\n+    private volatile Optional<IdentifiedVersion> latestVersion = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTM1NDQ0", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420135444", "createdAt": "2020-05-28T13:58:56Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1ODo1NlrOGb2bYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzo1ODo1NlrOGb2bYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NjQ4Mw==", "bodyText": "either mark final or just factor into separate method createVisitor", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431856483", "createdAt": "2020-05-28T13:58:56Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventMap = new ConcurrentSkipListMap<>();\n+    private volatile Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(\n+            LockWatchStateUpdate update,\n+            Optional<IdentifiedVersion> earliestVersion) {\n+        ProcessingVisitor visitor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTM2OTcz", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420136973", "createdAt": "2020-05-28T14:00:25Z", "commit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDowMDoyNVrOGb2f-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDowMDoyNVrOGb2f-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NzY1Nw==", "bodyText": "boolean providedEmptyVersion = ...\nboolean versionHasDifferentUuid = ...\nboolean tooFarBehindLog =...\nif (providedEmptyVersion || versionHasDifferentUuid || tooFarBehindLog) {\n    return snapshot\n}", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431857657", "createdAt": "2020-05-28T14:00:25Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final ConcurrentSkipListMap<Long, LockWatchEvent> eventMap = new ConcurrentSkipListMap<>();\n+    private volatile Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(\n+            LockWatchStateUpdate update,\n+            Optional<IdentifiedVersion> earliestVersion) {\n+        ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor(earliestVersion);\n+        } else {\n+            visitor = new ProcessingVisitor(earliestVersion);\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::getInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        /*\n+        There are three cases to consider where we would return a snapshot:\n+            1: they provide an empty version;\n+            2. their version has a different UUID (i.e. refers to the wrong leader);\n+            3. their version is behind our log.\n+        Note that if their version is ahead of our log, or we do not have a version, an exception is thrown instead.\n+         */\n+        if (!versionInclusive.isPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e8dd49dca47ec5460a8c2fa40d079bf463d7c6"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94446d78465b0a42c646c0a747d20a45a5d7d561", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/94446d78465b0a42c646c0a747d20a45a5d7d561", "committedDate": "2020-05-28T14:42:52Z", "message": "action some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTg5MzIx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420189321", "createdAt": "2020-05-28T14:47:37Z", "commit": {"oid": "94446d78465b0a42c646c0a747d20a45a5d7d561"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0NzozN1rOGb41sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0NzozN1rOGb41sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTk4NA==", "bodyText": "Maybe I'm missing something here, but I don't see how it is possible to have sufficient information to exclude a set of locks based solely on the LockToken. At the time that this is taken out in the commit flow, we do have access to Set<LockDescriptor> which we register; I wonder if it is worth changing this interface to use that instead - it would certainly be easier and potentially just the right thing to do, but open to suggestions.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431895984", "createdAt": "2020-05-28T14:47:37Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.v2.LockToken;\n+\n+public interface LockWatchEventCache {\n+    /**\n+     * Returns the last known lock watch version for the cache.\n+     */\n+    Optional<IdentifiedVersion> lastKnownVersion();\n+\n+    /**\n+     * Updates the cache with the update, and identifies the given timestamps with that lock watch state.\n+     */\n+    void processTransactionUpdate(Collection<Long> startTimestamps, LockWatchStateUpdate update);\n+\n+    /**\n+     * Updates the cache with the update, and calculates the {@link CommitUpdate} taking into account all changes to\n+     * lock watch state since the start of the transaction, excluding the transaction's own commit locks.\n+     *\n+     * @param startTs          start timestamp of the transaction\n+     * @param commitTs         commit timestamp of the transaction\n+     * @param commitLocksToken lock token for the transactions's commit locks\n+     * @return the commit update for this transaction's precommit condition\n+     */\n+    CommitUpdate getCommitUpdate(long startTs, long commitTs, LockToken commitLocksToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94446d78465b0a42c646c0a747d20a45a5d7d561"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTkwMjE2", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420190216", "createdAt": "2020-05-28T14:48:25Z", "commit": {"oid": "94446d78465b0a42c646c0a747d20a45a5d7d561"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0ODoyNVrOGb44Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0ODoyNVrOGb44Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NjY3OQ==", "bodyText": "Todo - consider how to handle the commitLocksToken - there is a comment above discussing my concern here.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431896679", "createdAt": "2020-05-28T14:48:25Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.TreeMultimap;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * Notes on concurrency: all public methods in this class are synchronised: this removes any concern that the timestamp\n+ * mapping will be modified while also being cleared or read. For processing updates and getting events, this should not\n+ * have a performance impact as these methods will be called in a single-threaded manner anyway (via an autobatcher),\n+ * but the method to remove entries is not necessarily called as such, and may cause some impact on performance.\n+ */\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, IdentifiedVersion> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions = TreeMultimap.create();\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processTransactionUpdate(\n+            Collection<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        Optional<IdentifiedVersion> currentVersion = eventLog.getLatestKnownVersion();\n+        Optional<IdentifiedVersion> latestVersion = eventLog.processUpdate(update);\n+        getEarliestVersion().ifPresent(eventLog::removeOldEntries);\n+\n+        if (!(latestVersion.isPresent()\n+                && currentVersion.isPresent()\n+                && latestVersion.get().id().equals(currentVersion.get().id())\n+                && update.accept(SuccessVisitor.INSTANCE))) {\n+            timestampMap.clear();\n+            aliveVersions.clear();\n+        }\n+\n+        latestVersion.ifPresent(\n+                version -> startTimestamps.forEach(timestamp -> {\n+                    timestampMap.put(timestamp, version);\n+                    aliveVersions.put(version, timestamp);\n+                }));\n+    }\n+\n+    @Override\n+    public synchronized CommitUpdate getCommitUpdate(long startTs, long commitTs, LockToken commitLocksToken) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94446d78465b0a42c646c0a747d20a45a5d7d561"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b77ad44a8337b1b6b663681a532e4270f36f4c2", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/6b77ad44a8337b1b6b663681a532e4270f36f4c2", "committedDate": "2020-05-28T14:57:06Z", "message": "change comparable to comparator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/356c7496ccd0727309e0a17b14881d888af70bb8", "committedDate": "2020-05-28T15:21:17Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjI3MTIy", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420227122", "createdAt": "2020-05-28T15:25:21Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNToyMVrOGb6ikQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNToyMVrOGb6ikQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyMzg1Nw==", "bodyText": "worth having an error message", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431923857", "createdAt": "2020-05-28T15:25:21Z", "author": {"login": "j-baker"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {\n     @Value.Parameter\n     UUID id();\n     @Value.Parameter\n     long version();\n+\n+    static IdentifiedVersion of(UUID id, long version) {\n+        return ImmutableIdentifiedVersion.of(id, version);\n+    }\n+\n+    static Comparator<IdentifiedVersion> comparator() {\n+        return (version1, version2) -> {\n+            Preconditions.checkArgument(version1.id().equals(version2.id()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjI3Mzcx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420227371", "createdAt": "2020-05-28T15:25:36Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNTozN1rOGb6jQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNTozN1rOGb6jQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDAzNQ==", "bodyText": "why is this Optional?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431924035", "createdAt": "2020-05-28T15:25:37Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface ClientLockWatchEventLog {\n+    TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version);\n+    Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjI4MDEx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420228011", "createdAt": "2020-05-28T15:26:13Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNjoxM1rOGb6lAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNjoxM1rOGb6lAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4Mg==", "bodyText": "probably add this annotation to all the fields", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431924482", "createdAt": "2020-05-28T15:26:13Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjMwOTA5", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420230909", "createdAt": "2020-05-28T15:29:02Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyOTowMlrOGb6tjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyOTowMlrOGb6tjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNjY3MQ==", "bodyText": "factor out constants 'INCLUSIVE', so the reader doesn't have to understand what 'true' means. Also, for stuff like this, do ImmutableList.copyOf(", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431926671", "createdAt": "2020-05-28T15:29:02Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                eventMap.headMap(earliestVersion.version()).entrySet();\n+        snapshotUpdater.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::createInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return TransactionsLockWatchEvents.success(ImmutableList.of(), timestampToVersion);\n+        }\n+\n+        IdentifiedVersion fromVersion = versionInclusive.get();\n+\n+        return TransactionsLockWatchEvents.success(\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, toVersion.version(), true).values()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjMzMTU5", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420233159", "createdAt": "2020-05-28T15:31:10Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozMToxMFrOGb60Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozMToxMFrOGb60Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyODM2Nw==", "bodyText": "you should define this method (in as far as it has to be a different method) in terms of the other one. The logic is basically the same. But I don't think should have its own return type, so should basically be the same method.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431928367", "createdAt": "2020-05-28T15:31:10Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                eventMap.headMap(earliestVersion.version()).entrySet();\n+        snapshotUpdater.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::createInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return TransactionsLockWatchEvents.success(ImmutableList.of(), timestampToVersion);\n+        }\n+\n+        IdentifiedVersion fromVersion = versionInclusive.get();\n+\n+        return TransactionsLockWatchEvents.success(\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, toVersion.version(), true).values()),\n+                timestampToVersion);\n+    }\n+\n+    @Override\n+    public synchronized Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion) {\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        IdentifiedVersion fromVersion = createInclusiveVersion(startVersion);\n+\n+        if (differentLeaderOrTooFarBehind(currentVersion, fromVersion)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQwMzAx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420240301", "createdAt": "2020-05-28T15:37:57Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozNzo1N1rOGb7HpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozNzo1N1rOGb7HpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMzM0OA==", "bodyText": "so there's an interesting class of bug with this sort of thing. Basically, you can partially succeed - accept some but not all of the writes, and then fail (e.g. what if resetWithSnapshot fails below for some reason). Then you're in a corrupt state.\nIt's relatively straightforward to cover this. Basically, you have a boolean field 'failed' and before you mutate any state, you set it to true, and then false before you're done. Before your reading methods, you checkState(!failed) and if it fails for any reason you know you have a bug.\nA different thing is to have immutable state which you replace on success (e.g. make transactional), but that changes your code style a fair bit.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431933348", "createdAt": "2020-05-28T15:37:57Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLogImpl.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class ClientLockWatchEventLogImpl implements ClientLockWatchEventLog {\n+    private final ClientLockWatchSnapshotUpdater snapshotUpdater;\n+    private final TreeMap<Long, LockWatchEvent> eventMap = new TreeMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private Optional<IdentifiedVersion> latestVersion = Optional.empty();\n+\n+    public static ClientLockWatchEventLogImpl create() {\n+        return create(ClientLockWatchSnapshotUpdaterImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static ClientLockWatchEventLogImpl create(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        return new ClientLockWatchEventLogImpl(snapshotUpdater);\n+    }\n+\n+    private ClientLockWatchEventLogImpl(ClientLockWatchSnapshotUpdater snapshotUpdater) {\n+        this.snapshotUpdater = snapshotUpdater;\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> processUpdate(LockWatchStateUpdate update) {\n+        final ProcessingVisitor visitor;\n+        if (!latestVersion.isPresent() || !update.logId().equals(latestVersion.get().id())) {\n+            visitor = new NewLeaderVisitor();\n+        } else {\n+            visitor = new ProcessingVisitor();\n+        }\n+        update.accept(visitor);\n+        return latestVersion;\n+    }\n+\n+    @Override\n+    public synchronized void removeOldEntries(IdentifiedVersion earliestVersion) {\n+        Set<Map.Entry<Long, LockWatchEvent>> eventsToBeRemoved =\n+                eventMap.headMap(earliestVersion.version()).entrySet();\n+        snapshotUpdater.processEvents(\n+                eventsToBeRemoved.stream().map(Map.Entry::getValue).collect(Collectors.toList()));\n+        eventsToBeRemoved.clear();\n+    }\n+\n+    /**\n+     * @param timestampToVersion mapping from timestamp to identified version from client-side event cache;\n+     * @param version            latest version that the client knows about; should be before timestamps in the\n+     *                           mapping;\n+     * @return lock watch events that occurred from (exclusive) the provided version, up to (inclusive) the latest\n+     * version in the timestamp to version map.\n+     */\n+    @Override\n+    public synchronized TransactionsLockWatchEvents getEventsForTransactions(\n+            Map<Long, IdentifiedVersion> timestampToVersion,\n+            Optional<IdentifiedVersion> version) {\n+        Optional<IdentifiedVersion> versionInclusive = version.map(this::createInclusiveVersion);\n+        IdentifiedVersion toVersion = Collections.max(timestampToVersion.values(), IdentifiedVersion.comparator());\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(toVersion);\n+\n+        if (!versionInclusive.isPresent() || differentLeaderOrTooFarBehind(currentVersion, versionInclusive.get())) {\n+            return TransactionsLockWatchEvents.failure(snapshotUpdater.getSnapshot(currentVersion));\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return TransactionsLockWatchEvents.success(ImmutableList.of(), timestampToVersion);\n+        }\n+\n+        IdentifiedVersion fromVersion = versionInclusive.get();\n+\n+        return TransactionsLockWatchEvents.success(\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, toVersion.version(), true).values()),\n+                timestampToVersion);\n+    }\n+\n+    @Override\n+    public synchronized Optional<Set<LockDescriptor>> getEventsBetweenVersions(\n+            IdentifiedVersion startVersion,\n+            IdentifiedVersion endVersion) {\n+        IdentifiedVersion currentVersion = getLatestVersionAndVerify(endVersion);\n+        IdentifiedVersion fromVersion = createInclusiveVersion(startVersion);\n+\n+        if (differentLeaderOrTooFarBehind(currentVersion, fromVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        if (eventMap.isEmpty()) {\n+            return Optional.of(ImmutableSet.of());\n+        }\n+\n+        List<LockWatchEvent> events =\n+                new ArrayList<>(eventMap.subMap(fromVersion.version(), true, endVersion.version(), true).values());\n+        Set<LockDescriptor> locksTakenOut = new HashSet<>();\n+        events.forEach(event -> locksTakenOut.addAll(event.accept(LockEventVisitor.INSTANCE)));\n+\n+        return Optional.of(locksTakenOut);\n+    }\n+\n+    @Override\n+    public synchronized Optional<IdentifiedVersion> getLatestKnownVersion() {\n+        return latestVersion;\n+    }\n+\n+    private boolean differentLeaderOrTooFarBehind(IdentifiedVersion currentVersion, IdentifiedVersion startVersion) {\n+        return !startVersion.id().equals(currentVersion.id()) || eventMap.floorKey(startVersion.version()) == null;\n+    }\n+\n+    private IdentifiedVersion createInclusiveVersion(IdentifiedVersion startVersion) {\n+        return IdentifiedVersion.of(startVersion.id(), startVersion.version() + 1);\n+    }\n+\n+    private IdentifiedVersion getLatestVersionAndVerify(IdentifiedVersion endVersion) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Cannot get events when log does not know its version\");\n+        IdentifiedVersion currentVersion = latestVersion.get();\n+        Preconditions.checkArgument(IdentifiedVersion.comparator().compare(endVersion, currentVersion) > -1,\n+                \"Transactions' view of the world is more up-to-date than the log\");\n+        return currentVersion;\n+    }\n+\n+    private void processSuccess(LockWatchStateUpdate.Success success) {\n+        Preconditions.checkState(latestVersion.isPresent(), \"Must have a known version to process successful updates\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQyMTQ0", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420242144", "createdAt": "2020-05-28T15:39:51Z", "commit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozOTo1MVrOGb7MeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozOTo1MVrOGb7MeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDU4NA==", "bodyText": "lower case long. Never use Long where you can avoid it - prefer long which is guaranteed to not be null, or something like OptionalLong most of the time. With generics, you can't avoid it a lot of the time.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r431934584", "createdAt": "2020-05-28T15:39:51Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.palantir.lock.v2.LockToken;\n+\n+public interface LockWatchEventCache {\n+    /**\n+     * Returns the last known lock watch version for the cache.\n+     */\n+    Optional<IdentifiedVersion> lastKnownVersion();\n+\n+    /**\n+     * Updates the cache with the update, and identifies the given timestamps with that lock watch state.\n+     */\n+    void processTransactionUpdate(Collection<Long> startTimestamps, LockWatchStateUpdate update);\n+\n+    /**\n+     * Updates the cache with the update, and calculates the {@link CommitUpdate} taking into account all changes to\n+     * lock watch state since the start of the transaction, excluding the transaction's own commit locks.\n+     *\n+     * @param startTs          start timestamp of the transaction\n+     * @param commitTs         commit timestamp of the transaction\n+     * @param commitLocksToken lock token for the transactions's commit locks\n+     * @return the commit update for this transaction's precommit condition\n+     */\n+    CommitUpdate getCommitUpdate(long startTs, long commitTs, LockToken commitLocksToken);\n+\n+    /**\n+     * Given a set of start timestamps, and a lock watch state version, returns a list of all events that occurred since\n+     * that version, and a map associating each start timestamp with its respective lock watch state version.\n+     */\n+    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> version);\n+\n+    /**\n+     * Removes the given timestamp from the cache. If no timestamps exist for a given version, events before that\n+     * version in the underlying {@link ClientLockWatchEventLog} will be deleted on next update.\n+     */\n+    void removeTimestampFromCache(Long timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356c7496ccd0727309e0a17b14881d888af70bb8"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba530f4e41af46b0894438dbb7016573aad01619", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ba530f4e41af46b0894438dbb7016573aad01619", "committedDate": "2020-05-29T09:07:41Z", "message": "on the path to greatness"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e923ad3393151273089da13078bc02a465634f69", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/e923ad3393151273089da13078bc02a465634f69", "committedDate": "2020-05-29T09:26:49Z", "message": "rework to remove dedupe (somewhat)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "344b178e580d208afac2d63b832aacdce7ca671b", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/344b178e580d208afac2d63b832aacdce7ca671b", "committedDate": "2020-05-29T09:28:03Z", "message": "add exception message to comparator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0556722d983ea5c866863ac93dc91381301226d0", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0556722d983ea5c866863ac93dc91381301226d0", "committedDate": "2020-05-29T09:36:09Z", "message": "even more failed checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1261e59e5b6b4c9c62618285b6276cd7c036781c", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/1261e59e5b6b4c9c62618285b6276cd7c036781c", "committedDate": "2020-05-29T10:11:04Z", "message": "fix commit lock token thing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88836daa2356491bff2fac2096203e69d5385de8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/88836daa2356491bff2fac2096203e69d5385de8", "committedDate": "2020-05-29T13:19:18Z", "message": "beefy changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "835101227becd445d249c49c2c014c99e65a8bd1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/835101227becd445d249c49c2c014c99e65a8bd1", "committedDate": "2020-05-29T13:20:29Z", "message": "remove incorrect json serialisation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "340ba337e8509e174e22a0c4e60692d419ca5de4", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/340ba337e8509e174e22a0c4e60692d419ca5de4", "committedDate": "2020-05-29T13:26:01Z", "message": "more cleanup throughout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "284148ab7122d3c7363d3ad9373882cd59d6c1f1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/284148ab7122d3c7363d3ad9373882cd59d6c1f1", "committedDate": "2020-05-29T13:47:53Z", "message": "resolve build errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c44d324231b65e9def980db96cd2740f86e8f13", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7c44d324231b65e9def980db96cd2740f86e8f13", "committedDate": "2020-05-29T14:10:06Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1d4b59b0627bc567dae341d6672d02013bab272", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/c1d4b59b0627bc567dae341d6672d02013bab272", "committedDate": "2020-05-29T14:10:32Z", "message": "remove unused line"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwOTg5NDQ1", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-420989445", "createdAt": "2020-05-29T14:11:29Z", "commit": {"oid": "c1d4b59b0627bc567dae341d6672d02013bab272"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDoxMToyOVrOGceOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDoxMToyOVrOGceOuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwODYwMw==", "bodyText": "This is a dodgy diff, as I moved the location of some of these files (lock-api-objects doesn't have tests, whereas lock-api does).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r432508603", "createdAt": "2020-05-29T14:11:29Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/ClientLockWatchEventLog.java", "diffHunk": "@@ -19,10 +19,12 @@\n import java.util.Optional;\n import java.util.Set;\n \n-public interface LockWatchEventCache {\n-    Optional<IdentifiedVersion> lastKnownVersion();\n-    IdentifiedVersion processStartTransactionsUpdate(Set<Long> startTimestamps, LockWatchStateUpdate update);\n-    void processUpdate(LockWatchStateUpdate update);\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> version);\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface ClientLockWatchEventLog {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d4b59b0627bc567dae341d6672d02013bab272"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a73341d3312e837debe4147c49b0b954e43de9a7", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a73341d3312e837debe4147c49b0b954e43de9a7", "committedDate": "2020-05-29T14:13:02Z", "message": "slight refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e9c87fce5fc64267d88def40a2eb95409554be0", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/6e9c87fce5fc64267d88def40a2eb95409554be0", "committedDate": "2020-05-29T14:42:32Z", "message": "change to google error prone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dc51f725e1b0c63252579b16432b8e6c0f6874f", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/4dc51f725e1b0c63252579b16432b8e6c0f6874f", "committedDate": "2020-05-29T15:28:08Z", "message": "slap synchronised on everything"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNjkwOTAx", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-421690901", "createdAt": "2020-06-01T08:55:33Z", "commit": {"oid": "4dc51f725e1b0c63252579b16432b8e6c0f6874f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwODo1NTozM1rOGdDcNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwODo1NTozM1rOGdDcNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExODI2Mg==", "bodyText": "I'm just wondering if this map should actually be on both results of this class, or if we even need a union here, and here is why:\nThe client of Atlas may receive a snapshot because their version is too old, but the version that each transaction holds is definitely not too old (by the definition of our cache system). Therefore, it surely makes sense that we can return a snapshot that resets the cache state, along with all the events that have happened between that snapshot and the latest version in the timestamp map. This would mean that the only difference between success and failure is that failure contains a snapshot also. Since a snapshot is essentially just a LockWatchCreatedEvent, this would mean that we could condense this interface to have a single return type, but with a boolean flag of whether the cache needs to be reset or not.\n@jkozlowski @j-baker thoughts? This would make more sense with the Atlasdb-proxy implementation too (simplifying the types and so forth).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433118262", "createdAt": "2020-06-01T08:55:33Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -50,7 +50,7 @@ static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n         @Value.Parameter\n         List<LockWatchEvent> events();\n         @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n+        Map<Long, IdentifiedVersion> startTsToSequence();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dc51f725e1b0c63252579b16432b8e6c0f6874f"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efe1d31a1a9c216c0356abee6c0aa7625d11cbd2", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/efe1d31a1a9c216c0356abee6c0aa7625d11cbd2", "committedDate": "2020-06-01T09:53:10Z", "message": "rework to use non-union type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6849606524d53a774c1f5eba200f2b19432f059d", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/6849606524d53a774c1f5eba200f2b19432f059d", "committedDate": "2020-06-01T09:57:10Z", "message": "fix tests and remove unused type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1ff70c3cf945302f53751102fc57788d4ac0d87", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/d1ff70c3cf945302f53751102fc57788d4ac0d87", "committedDate": "2020-06-02T09:36:49Z", "message": "initial merge with dev"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a5bb751dc1cd22f3de3e54d4d4f7b957c3e2ed7", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/1a5bb751dc1cd22f3de3e54d4d4f7b957c3e2ed7", "committedDate": "2020-06-02T09:44:19Z", "message": "more cleanup of diff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56f1b254872e82c4bb06fb57be30046727261d8e", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/56f1b254872e82c4bb06fb57be30046727261d8e", "committedDate": "2020-06-02T09:46:03Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b48150debb67cfd5d28a2d740ee5ec8edf928913", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b48150debb67cfd5d28a2d740ee5ec8edf928913", "committedDate": "2020-06-02T09:46:03Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTE4MTIw", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422518120", "createdAt": "2020-06-02T09:49:26Z", "commit": {"oid": "b48150debb67cfd5d28a2d740ee5ec8edf928913"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo0OToyNlrOGdqWKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo0OToyNlrOGdqWKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTY4OQ==", "bodyText": "As per James' comment, would like to rename this (in this PR or another).\nAny thoughts to a good name?", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433755689", "createdAt": "2020-06-02T09:49:26Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/IdentifiedVersion.java", "diffHunk": "@@ -16,14 +16,28 @@\n \n package com.palantir.lock.watch;\n \n+import java.util.Comparator;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.palantir.logsafe.Preconditions;\n+\n @Value.Immutable\n public interface IdentifiedVersion {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b48150debb67cfd5d28a2d740ee5ec8edf928913"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0361d428227311875d543d2e51269de0868faf83", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0361d428227311875d543d2e51269de0868faf83", "committedDate": "2020-06-02T09:50:57Z", "message": "remove extraneous guarded by annotations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTIxNjM1", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422521635", "createdAt": "2020-06-02T09:54:05Z", "commit": {"oid": "b48150debb67cfd5d28a2d740ee5ec8edf928913"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo1NDowNVrOGdqgYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo1NDowNVrOGdqgYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1ODMwNQ==", "bodyText": "Diff is strange - should be same as previous LockWatchEventCache (with added javadoc)", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433758305", "createdAt": "2020-06-02T09:54:05Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCache.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public interface LockWatchEventCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b48150debb67cfd5d28a2d740ee5ec8edf928913"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf1a4862768ee204515b8992c7b727f4c66695cc", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/cf1a4862768ee204515b8992c7b727f4c66695cc", "committedDate": "2020-06-02T09:54:32Z", "message": "remove notes on concurrency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/dad59559662a1f18b8ad05e3c8bb21d059d6f8cf", "committedDate": "2020-06-02T09:54:40Z", "message": "Merge branch 'lw-client-cache-ete' of github.com:palantir/atlasdb into lw-client-cache-ete"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTI0MTQ5", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422524149", "createdAt": "2020-06-02T09:57:32Z", "commit": {"oid": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo1NzozMlrOGdqn9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo1NzozMlrOGdqn9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MDI0NA==", "bodyText": "Will only be empty on case of failure as an update.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433760244", "createdAt": "2020-06-02T09:57:32Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTI4Mzc3", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422528377", "createdAt": "2020-06-02T10:03:23Z", "commit": {"oid": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDowMzoyM1rOGdq0qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDowMzoyM1rOGdq0qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MzQ5OA==", "bodyText": "This, getCommitUpdate, and getEventsForTransactions can all fail (and indeed, throw) if a leader election occurs between the start and end of the transaction. Presumably, this is the correct behaviour, but that does require the callers to catch these cases.\nOpen to ideas for alternatives. getCommitUpdate should probably invalidateAll, this method should maybe not fail (it's only used for getCommitUpdate), but not sure about what we should do for getEventsForTransactions, given that it is intended to be called outside Atlas.", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433763498", "createdAt": "2020-06-02T10:03:23Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchEventCacheImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.logsafe.Preconditions;\n+\n+public final class LockWatchEventCacheImpl implements LockWatchEventCache {\n+    private final ClientLockWatchEventLog eventLog;\n+    private final HashMap<Long, MapEntry> timestampMap = new HashMap<>();\n+    private final TreeMultimap<IdentifiedVersion, Long> aliveVersions =\n+            TreeMultimap.create(IdentifiedVersion.comparator(), Ordering.natural());\n+\n+    @GuardedBy(\"this\")\n+    private boolean failed = false;\n+\n+\n+    private LockWatchEventCacheImpl(ClientLockWatchEventLog eventLog) {\n+        this.eventLog = eventLog;\n+    }\n+\n+    public static LockWatchEventCacheImpl create() {\n+        return create(ClientLockWatchEventLogImpl.create());\n+    }\n+\n+    @VisibleForTesting\n+    static LockWatchEventCacheImpl create(ClientLockWatchEventLog eventLog) {\n+        return new LockWatchEventCacheImpl(eventLog);\n+    }\n+\n+    @Override\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return eventLog.getLatestKnownVersion();\n+    }\n+\n+    @Override\n+    public synchronized void processStartTransactionsUpdate(\n+            Set<Long> startTimestamps,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(\n+                    version -> startTimestamps.forEach(timestamp -> {\n+                        timestampMap.put(timestamp, MapEntry.of(version));\n+                        aliveVersions.put(version, timestamp);\n+                    }));\n+        });\n+    }\n+\n+    @Override\n+    public synchronized void processGetCommitTimestampsUpdate(\n+            Collection<TransactionUpdate> transactionUpdates,\n+            LockWatchStateUpdate update) {\n+        ensureNotFailed(() -> {\n+            Optional<IdentifiedVersion> latestVersion = processEventLogUpdate(update);\n+\n+            latestVersion.ifPresent(version ->\n+                    transactionUpdates.forEach(transactionUpdate -> {\n+                        MapEntry previousEntry = timestampMap.get(transactionUpdate.startTs());\n+                        Preconditions.checkNotNull(previousEntry, \"Start timestamp missing from cache\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad59559662a1f18b8ad05e3c8bb21d059d6f8cf"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b13d3a412d3216057ab2f180bc4ce1806dc117e5", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b13d3a412d3216057ab2f180bc4ce1806dc117e5", "committedDate": "2020-06-02T10:04:28Z", "message": "rename method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b37f0b3357c7717268efec75c15489a0f74be40a", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b37f0b3357c7717268efec75c15489a0f74be40a", "committedDate": "2020-06-02T10:09:20Z", "message": "wire in cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTMzNTM1", "url": "https://github.com/palantir/atlasdb/pull/4806#pullrequestreview-422533535", "createdAt": "2020-06-02T10:10:24Z", "commit": {"oid": "b37f0b3357c7717268efec75c15489a0f74be40a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDoxMDoyNVrOGdrDxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDoxMDoyNVrOGdrDxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2NzM2NA==", "bodyText": "Sanity check: This should be the only place where we need to wire in the real cache over the NoOp one (I checked this by looking at where LockWatchManagerImpl is created, and it appears the only real one is here).", "url": "https://github.com/palantir/atlasdb/pull/4806#discussion_r433767364", "createdAt": "2020-06-02T10:10:25Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -1077,7 +1078,7 @@ private static LockAndTimestampServices getLockAndTimestampServices(\n         NamespacedConjureTimelockService namespacedConjureTimelockService\n                 = new NamespacedConjureTimelockService(withDiagnosticsConjureTimelockService, timelockNamespace);\n \n-        LockWatchEventCache lockWatchEventCache = NoOpLockWatchEventCache.INSTANCE;\n+        LockWatchEventCache lockWatchEventCache = LockWatchEventCacheImpl.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b37f0b3357c7717268efec75c15489a0f74be40a"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2893, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}