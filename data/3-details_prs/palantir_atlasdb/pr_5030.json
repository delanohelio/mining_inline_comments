{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMjc5OTY4", "number": 5030, "title": "[DB TimeLock] 3C.3 - getAllNamespaces() / MultiSequenceTimestampSeriesProvider", "bodyText": "Goals (and why):\n\nSupport getAllNamespaces() in db timelock; more generally, db timelock should be as similar to normal timelock as possible\n\nImplementation Description (bullets):\n\nImplement MultiSequenceTimestampSeriesProvider\n\nTesting (What was existing testing like?  What have you done to improve it?):\nConcerns (what feedback would you like?):\n\nSome breaking changes to Derive4J algebraic types: I don't believe these are ever serialized, but could be worth a sanity check.\nI'm not fully settled on the level at which assumptions made by DB TimeLock in specific should be held (e.g. whether they should be part of the DbTimeLockFactory.) General rule is that dbkvs should not reference the constant DB_TIMELOCK_TIMESTAMP_TABLE anywhere.\n\nWhere should we start reviewing?: MultiSequenceTimestampSeriesProvider\nPriority (whenever / two weeks / yesterday): today; if not tomorrow would be good", "createdAt": "2020-10-14T10:43:00Z", "url": "https://github.com/palantir/atlasdb/pull/5030", "merged": true, "mergeCommit": {"oid": "1ac7d96bfd5c6d28b35cf04e92b67e6964e0db03"}, "closed": true, "closedAt": "2020-10-15T12:58:12Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdShHp5AFqTUwODU2NzE3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSvUHfgFqTUwOTI0MDk1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NTY3MTcw", "url": "https://github.com/palantir/atlasdb/pull/5030#pullrequestreview-508567170", "createdAt": "2020-10-14T17:20:24Z", "commit": {"oid": "faafc8e388b437e69bf1aca07a67ed20a38406c1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNzoyMDoyNFrOHhdUkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNzo1MjoxOFrOHhee6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NTQ1Ng==", "bodyText": "Can we add tests for both these conditions above?", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504845456", "createdAt": "2020-10-14T17:20:24Z", "author": {"login": "sudiksha27"}, "path": "timelock-agent/src/main/java/com/palantir/timelock/ServiceDiscoveringDatabaseTimeLockSupplier.java", "diffHunk": "@@ -64,10 +68,21 @@ public void close() {\n     }\n \n     public synchronized ManagedTimestampService getManagedTimestampService(DbTimestampCreationSetting setting) {\n+        Preconditions.checkState(\n+                DbTimestampCreationSettings.caseOf(setting)\n+                .multipleSeries((tableReference, series) ->\n+                        tableReference.equals(AtlasDbConstants.DB_TIMELOCK_TIMESTAMP_TABLE))\n+                .otherwise_(false),\n+                \"Attempted to create a managed timestamp service in db timelock that was not the normal db timelock\"\n+                        + \" timestamp table! This is unexpected, and we are prohibiting this creation for safety.\",\n+                SafeArg.of(\"setting\", setting));\n         return timestampServiceFactory.apply(setting);\n     }\n \n-    public synchronized TimestampSeriesProvider getTimestampSeriesProvider() {\n-        return timestampSeriesProvider;\n+    public synchronized TimestampSeriesProvider getTimestampSeriesProvider(TableReference tableReference) {\n+        Preconditions.checkState(tableReference.equals(AtlasDbConstants.DB_TIMELOCK_TIMESTAMP_TABLE),\n+                \"Attempted to create a timestamp series provider in db timelock that was not the normal db timelock\"\n+                        + \" timestamp table! This is unexpected, and we are prohibiting this creation for safety.\");\n+        return timestampSeriesProvider.apply(tableReference);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafc8e388b437e69bf1aca07a67ed20a38406c1"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1NDg5OQ==", "bodyText": "Might be hard to write but would be good to have tests for this.", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504854899", "createdAt": "2020-10-14T17:36:05Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/MultiSequenceTimestampSeriesProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Set;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeries;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeriesProvider;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+\n+/**\n+ * Reads all of the series from a timestamp table written to by timestamp bound stores using the\n+ * {@link MultiSequencePhysicalBoundStoreStrategy} strategy.\n+ */\n+public final class MultiSequenceTimestampSeriesProvider implements TimestampSeriesProvider {\n+    private static final Logger log = LoggerFactory.getLogger(MultiSequenceTimestampSeriesProvider.class);\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+\n+    private MultiSequenceTimestampSeriesProvider(ConnectionManager connManager,\n+            TableReference timestampTable) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+    }\n+\n+    public static TimestampSeriesProvider create(\n+            KeyValueService rawKvs,\n+            TableReference tableReference,\n+            boolean initializeAsync) {\n+        if (initializeAsync) {\n+            log.warn(\"Asynchronous initialization not implemented, will initialize synchronously.\");\n+        }\n+\n+        Preconditions.checkArgument(rawKvs instanceof ConnectionManagerAwareDbKvs,\n+                \"DbAtlasDbFactory expects a raw kvs of type ConnectionManagerAwareDbKvs, found %s\", rawKvs.getClass());\n+        ConnectionManagerAwareDbKvs dbkvs = (ConnectionManagerAwareDbKvs) rawKvs;\n+        return new MultiSequenceTimestampSeriesProvider(dbkvs.getConnectionManager(), tableReference);\n+    }\n+\n+    @Override\n+    public Set<TimestampSeries> getKnownSeries() {\n+        try (Connection connection = connManager.getConnection()) {\n+            String sql = String.format(\"SELECT client FROM %s FOR UPDATE\", timestampTable.getQualifiedName());\n+            QueryRunner runner = new QueryRunner();\n+            return runner.query(connection, sql, rs -> {\n+                ImmutableSet.Builder<TimestampSeries> series = ImmutableSet.builder();\n+                while (rs.next()) {\n+                    series.add(TimestampSeries.of(rs.getString(\"client\")));\n+                }\n+                return series.build();\n+            });\n+        } catch (SQLException e) {\n+            throw PalantirSqlException.create(e);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafc8e388b437e69bf1aca07a67ed20a38406c1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2NDQ4OA==", "bodyText": "Apologies in advance - why is singleSeries needed? As far as I see, dbKvs accepts only multiSeries; otherwise ServiceDiscoveringAtlasSupplier takes Optional creationParameters, so why an assertion that creationParameters should be empty not enough here?", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504864488", "createdAt": "2020-10-14T17:52:18Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/RelationalDbTimeLockFactory.java", "diffHunk": "@@ -59,15 +63,23 @@ public KeyValueService createRawKeyValueService(\n     @Override\n     public ManagedTimestampService createManagedTimestampService(\n             KeyValueService rawKvs,\n-            Optional<DbTimestampCreationSetting> dbTimestampCreationSetting,\n+            DbTimestampCreationSetting dbTimestampCreationSetting,\n             boolean initializeAsync) {\n-        return delegate.createManagedTimestampService(rawKvs, dbTimestampCreationSetting, initializeAsync);\n+        return DbTimestampCreationSettings.caseOf(dbTimestampCreationSetting)\n+                .multipleSeries((un, used) ->\n+                        delegate.createManagedTimestampService(\n+                                rawKvs, Optional.of(dbTimestampCreationSetting), initializeAsync))\n+                .singleSeries(unused -> {\n+                    throw new SafeIllegalStateException(\"DB TimeLock cannot be used with\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faafc8e388b437e69bf1aca07a67ed20a38406c1"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cc784a796b10edc8e47e3c0c87145e8771b5842", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/7cc784a796b10edc8e47e3c0c87145e8771b5842", "committedDate": "2020-10-14T20:49:02Z", "message": "3C.3 - canGetAllNamespaces works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ec8305f32daaa7d33886d7e642b2fa27986c61", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/44ec8305f32daaa7d33886d7e642b2fa27986c61", "committedDate": "2020-10-14T20:49:04Z", "message": "meep"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "faafc8e388b437e69bf1aca07a67ed20a38406c1", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/faafc8e388b437e69bf1aca07a67ed20a38406c1", "committedDate": "2020-10-14T10:43:31Z", "message": "meep"}, "afterCommit": {"oid": "44ec8305f32daaa7d33886d7e642b2fa27986c61", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/44ec8305f32daaa7d33886d7e642b2fa27986c61", "committedDate": "2020-10-14T20:49:04Z", "message": "meep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "199fc9fd0b017e888e72c8f15ecbd76e3475002f", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/199fc9fd0b017e888e72c8f15ecbd76e3475002f", "committedDate": "2020-10-15T09:40:12Z", "message": "Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf2084013476ac924ca288b6a693f0f755ee36e7", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/bf2084013476ac924ca288b6a693f0f755ee36e7", "committedDate": "2020-10-15T10:02:01Z", "message": "Parallel tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "685e1f1cd6173c1c9b28c0e0e7005ba8b46b935d", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/685e1f1cd6173c1c9b28c0e0e7005ba8b46b935d", "committedDate": "2020-10-15T10:24:48Z", "message": "changelog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MjQwOTU3", "url": "https://github.com/palantir/atlasdb/pull/5030#pullrequestreview-509240957", "createdAt": "2020-10-15T10:35:10Z", "commit": {"oid": "199fc9fd0b017e888e72c8f15ecbd76e3475002f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDozNToxMVrOHiBgng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMDozNToxMVrOHiBgng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzODM2Ng==", "bodyText": "Nice! Thanks for adding the tests", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r505438366", "createdAt": "2020-10-15T10:35:11Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/memory/InMemoryDbTimeLockFactory.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.memory;\n+\n+import java.util.Map;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.collect.Maps;\n+import com.palantir.atlasdb.config.DbTimestampCreationSetting;\n+import com.palantir.atlasdb.config.DbTimestampCreationSettings;\n+import com.palantir.atlasdb.config.LeaderConfig;\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeries;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeriesProvider;\n+import com.palantir.atlasdb.keyvalue.impl.InMemoryKeyValueService;\n+import com.palantir.atlasdb.spi.KeyValueServiceConfig;\n+import com.palantir.atlasdb.timestamp.DbTimeLockFactory;\n+import com.palantir.atlasdb.util.MetricsManager;\n+import com.palantir.timestamp.InMemoryTimestampService;\n+import com.palantir.timestamp.ManagedTimestampService;\n+\n+@AutoService(DbTimeLockFactory.class)\n+public class InMemoryDbTimeLockFactory implements DbTimeLockFactory {\n+    private final Map<TimestampSeries, ManagedTimestampService> services = Maps.newHashMap();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "199fc9fd0b017e888e72c8f15ecbd76e3475002f"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2643, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}