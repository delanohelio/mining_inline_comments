{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMzQ0MTIw", "number": 4929, "title": "[PDS-128523] Fewer leader time calls.", "bodyText": "Goals (and why):\nA different take on #4916. Instead of rate limiting calls everywhere, we're just going to ensure that the first batch is not validated.\nSome further thought, I'll make a different issue. But why bother validating at each kvs batch read? Shouldn't we instead validate after every batch that's actually returned to the user i.e. after post filtering and filtering deletes? I don't have any metrics on this, but I imagine this will only affect places where TS is slow and deletes aren't removed, or (guessing here) there are a ton of concurrent writes from different transactions that get returned? Rationale being, if we're validating based on when the user read, we're reading from the kvs in multiple batches in one go to make one batch for a single user read, which feels like we should only validate for that single read. Thoughts?\nImplementation Description (bullets):\n\nExtract the existing iterator into its own class so we can test it\nOn the first batch (saved to a field) we skip validation\nWe also make BatchSizeIncreasingIterator return whether or not a batch is the last.\n\nReason being, the previous implementation would take another iteration and another validation step to decide whether or not to terminate. i.e. if you had n * BATCH_SIZE + k columns where k < n, you would make n + 1 calls as expected, and then you would make a further call to figure out that it's empty and that would incur a validation step. Rather than try to special case it, just make the page feel more like a batch iterator by giving some sort of hasNext functionality.\n\n\n\nTesting (What was existing testing like?  What have you done to improve it?):\nI've just tested this wrapped iterator, do you want something more?\nConcerns (what feedback would you like?):\nIs coverage sufficient.\nWhere should we start reviewing?:\nAnywhere. Half of it is tests however and there is a bit of bloat there.\nPriority (whenever / two weeks / yesterday):\nASAP, blocking internal product, and also violating SLOs of internal skiing product.", "createdAt": "2020-08-05T12:12:37Z", "url": "https://github.com/palantir/atlasdb/pull/4929", "merged": true, "mergeCommit": {"oid": "b1cdcd9d1bbf625ada9f350434bfb60e9bdc39c1"}, "closed": true, "closedAt": "2020-08-06T16:52:38Z", "author": {"login": "felixdesouza"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc75-RMgH2gAyNDYzMzQ0MTIwOmVmYjU2ZTI3OTdiNDZlZjc1NGRiMjFkYjc1NThiYmU3ZWMyMGY1MTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8SQvhgH2gAyNDYzMzQ0MTIwOjZiMzZmMGE5MWFkODA2MmM0ZmM5ZmE0OTcyMWI5NTFmNzI3OGExMDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "efb56e2797b46ef754db21db7558bbe7ec20f519", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/efb56e2797b46ef754db21db7558bbe7ec20f519", "committedDate": "2020-08-05T12:00:13Z", "message": "Fewer leader time calls."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8316bebd8874212cae7c4961ebd03fe9d8b9b862", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/8316bebd8874212cae7c4961ebd03fe9d8b9b862", "committedDate": "2020-08-05T12:13:55Z", "message": "Checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd8212f5d9b01591c2bf2b1fe4edcb4f84d2af42", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/cd8212f5d9b01591c2bf2b1fe4edcb4f84d2af42", "committedDate": "2020-08-05T12:13:55Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNTUwMTQ4", "url": "https://github.com/palantir/atlasdb/pull/4929#pullrequestreview-462550148", "createdAt": "2020-08-06T14:03:22Z", "commit": {"oid": "cd8212f5d9b01591c2bf2b1fe4edcb4f84d2af42"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDowMzoyMlrOG80_0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDoyOTowNlrOG82Hiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzNjA0OA==", "bodyText": "Might be good to check the ordering here (~we can make a SortedSet copy of this - ~Cell compare is based on the byte order of rows and columns - and then build a List rather than a Map of returnedEntries and check the ordering)", "url": "https://github.com/palantir/atlasdb/pull/4929#discussion_r466436048", "createdAt": "2020-08-06T14:03:22Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/transaction/impl/GetRowsColumnRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Maps;\n+import com.palantir.atlasdb.keyvalue.api.BatchColumnRangeSelection;\n+import com.palantir.atlasdb.keyvalue.api.Cell;\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.RowColumnRangeIterator;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.Value;\n+import com.palantir.atlasdb.keyvalue.impl.InMemoryKeyValueService;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class GetRowsColumnRangeIteratorTest {\n+\n+    private static final TableReference TABLE_REFERENCE = TableReference.createWithEmptyNamespace(\"test\");\n+    private static final byte[] ROW = \"row\".getBytes(StandardCharsets.UTF_8);\n+    private static final int BATCH_SIZE = 10;\n+    public static final BatchColumnRangeSelection COLUMN_RANGE_SELECTION =\n+            BatchColumnRangeSelection.create(null, null, BATCH_SIZE);\n+\n+    private final KeyValueService kvs = new InMemoryKeyValueService(true);\n+    private final ColumnRangeBatchProvider batchProvider = new ColumnRangeBatchProvider(\n+            kvs,\n+            TABLE_REFERENCE,\n+            ROW,\n+            COLUMN_RANGE_SELECTION,\n+            Long.MAX_VALUE);\n+\n+    @Test\n+    public void ifBatchIsEmptyNoValidateCallsAreMade() {\n+        Runnable validationStep = mock(Runnable.class);\n+        Iterator<Map.Entry<Cell, byte[]>> iterator = createIteratorUnderTest(validationStep);\n+\n+        List<Map.Entry<Cell, byte[]>> entries = ImmutableList.copyOf(iterator);\n+\n+        assertThat(entries).isEmpty();\n+        verifyNoInteractions(validationStep);\n+    }\n+\n+    @Test\n+    public void firstBatchHasNoValidation() {\n+        Runnable validationStep = mock(Runnable.class);\n+        Set<Cell> puts = putColumns(BATCH_SIZE + 5);\n+\n+        int limit = BATCH_SIZE - 1;\n+        Iterator<Map.Entry<Cell, byte[]>> iteratorUnderTest = createIteratorUnderTest(validationStep);\n+\n+        // still under the first batch size limit\n+        List<Map.Entry<Cell, byte[]>> firstBatchBarOne =\n+                ImmutableList.copyOf(Iterators.limit(iteratorUnderTest, limit));\n+        verifyNoInteractions(validationStep);\n+\n+        // the last element in the first batch is still on the first batch\n+        Map.Entry<Cell, byte[]> lastInFirstBatch = Iterators.getNext(iteratorUnderTest, null);\n+        assertThat(lastInFirstBatch).isNotNull();\n+        verifyNoInteractions(validationStep);\n+\n+        // consume one more i.e. batch size amount\n+        Map.Entry<Cell, byte[]> firstInSecondBatch = Iterators.getNext(iteratorUnderTest, null);\n+        assertThat(firstInSecondBatch).isNotNull();\n+        verify(validationStep, times(1)).run();\n+\n+        // validation step is called per batch\n+        ImmutableList<Map.Entry<Cell, byte[]>> restOfSecondBatch = ImmutableList.copyOf(iteratorUnderTest);\n+        verifyNoMoreInteractions(validationStep);\n+\n+        Map<Cell, byte[]> returnedEntries = ImmutableMap.<Cell, byte[]>builder()\n+                .putAll(firstBatchBarOne)\n+                .put(lastInFirstBatch)\n+                .put(firstInSecondBatch)\n+                .putAll(restOfSecondBatch)\n+                .build();\n+\n+\n+        assertThat(returnedEntries.keySet())\n+                .as(\"we can read all that we wrote\")\n+                .isEqualTo(puts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd8212f5d9b01591c2bf2b1fe4edcb4f84d2af42"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ1MzcwMw==", "bodyText": "maybe something like\n        List<Cell> cellsReadInOrder = Lists.newArrayList();\n        cellsReadInOrder.addAll(firstBatchBarOne.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n        cellsReadInOrder.add(lastInFirstBatch.getKey());\n        cellsReadInOrder.add(firstInSecondBatch.getKey());\n        cellsReadInOrder.addAll(restOfSecondBatch.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n\n        assertThat(cellsReadInOrder)\n                .as(\"we can read all that we wrote\")\n                .hasSameElementsAs(puts);\n        assertThat(cellsReadInOrder)\n                .as(\"iterator returns cells back in sorted order\")\n                .isSorted();", "url": "https://github.com/palantir/atlasdb/pull/4929#discussion_r466453703", "createdAt": "2020-08-06T14:28:12Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/transaction/impl/GetRowsColumnRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterators;\n+import com.google.common.collect.Maps;\n+import com.palantir.atlasdb.keyvalue.api.BatchColumnRangeSelection;\n+import com.palantir.atlasdb.keyvalue.api.Cell;\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.RowColumnRangeIterator;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.Value;\n+import com.palantir.atlasdb.keyvalue.impl.InMemoryKeyValueService;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class GetRowsColumnRangeIteratorTest {\n+\n+    private static final TableReference TABLE_REFERENCE = TableReference.createWithEmptyNamespace(\"test\");\n+    private static final byte[] ROW = \"row\".getBytes(StandardCharsets.UTF_8);\n+    private static final int BATCH_SIZE = 10;\n+    public static final BatchColumnRangeSelection COLUMN_RANGE_SELECTION =\n+            BatchColumnRangeSelection.create(null, null, BATCH_SIZE);\n+\n+    private final KeyValueService kvs = new InMemoryKeyValueService(true);\n+    private final ColumnRangeBatchProvider batchProvider = new ColumnRangeBatchProvider(\n+            kvs,\n+            TABLE_REFERENCE,\n+            ROW,\n+            COLUMN_RANGE_SELECTION,\n+            Long.MAX_VALUE);\n+\n+    @Test\n+    public void ifBatchIsEmptyNoValidateCallsAreMade() {\n+        Runnable validationStep = mock(Runnable.class);\n+        Iterator<Map.Entry<Cell, byte[]>> iterator = createIteratorUnderTest(validationStep);\n+\n+        List<Map.Entry<Cell, byte[]>> entries = ImmutableList.copyOf(iterator);\n+\n+        assertThat(entries).isEmpty();\n+        verifyNoInteractions(validationStep);\n+    }\n+\n+    @Test\n+    public void firstBatchHasNoValidation() {\n+        Runnable validationStep = mock(Runnable.class);\n+        Set<Cell> puts = putColumns(BATCH_SIZE + 5);\n+\n+        int limit = BATCH_SIZE - 1;\n+        Iterator<Map.Entry<Cell, byte[]>> iteratorUnderTest = createIteratorUnderTest(validationStep);\n+\n+        // still under the first batch size limit\n+        List<Map.Entry<Cell, byte[]>> firstBatchBarOne =\n+                ImmutableList.copyOf(Iterators.limit(iteratorUnderTest, limit));\n+        verifyNoInteractions(validationStep);\n+\n+        // the last element in the first batch is still on the first batch\n+        Map.Entry<Cell, byte[]> lastInFirstBatch = Iterators.getNext(iteratorUnderTest, null);\n+        assertThat(lastInFirstBatch).isNotNull();\n+        verifyNoInteractions(validationStep);\n+\n+        // consume one more i.e. batch size amount\n+        Map.Entry<Cell, byte[]> firstInSecondBatch = Iterators.getNext(iteratorUnderTest, null);\n+        assertThat(firstInSecondBatch).isNotNull();\n+        verify(validationStep, times(1)).run();\n+\n+        // validation step is called per batch\n+        ImmutableList<Map.Entry<Cell, byte[]>> restOfSecondBatch = ImmutableList.copyOf(iteratorUnderTest);\n+        verifyNoMoreInteractions(validationStep);\n+\n+        Map<Cell, byte[]> returnedEntries = ImmutableMap.<Cell, byte[]>builder()\n+                .putAll(firstBatchBarOne)\n+                .put(lastInFirstBatch)\n+                .put(firstInSecondBatch)\n+                .putAll(restOfSecondBatch)\n+                .build();\n+\n+\n+        assertThat(returnedEntries.keySet())\n+                .as(\"we can read all that we wrote\")\n+                .isEqualTo(puts);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzNjA0OA=="}, "originalCommit": {"oid": "cd8212f5d9b01591c2bf2b1fe4edcb4f84d2af42"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ1NDQxMQ==", "bodyText": "nit: when reading the iterator that is returned by getRowsColumnRangeIterator.", "url": "https://github.com/palantir/atlasdb/pull/4929#discussion_r466454411", "createdAt": "2020-08-06T14:29:06Z", "author": {"login": "jeremyk-91"}, "path": "changelog/@unreleased/pr-4929.v2.yml", "diffHunk": "@@ -0,0 +1,5 @@\n+type: fix\n+fix:\n+  description: There are now fewer `getLeaderTime` calls when calling `getRowsColumnRangeIterator`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd8212f5d9b01591c2bf2b1fe4edcb4f84d2af42"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b237ab9a68ddc8a05b43afb1efc5aea698cc460", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/1b237ab9a68ddc8a05b43afb1efc5aea698cc460", "committedDate": "2020-08-06T16:12:54Z", "message": "Fix nit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b36f0a91ad8062c4fc9fa49721b951f7278a100", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/6b36f0a91ad8062c4fc9fa49721b951f7278a100", "committedDate": "2020-08-06T16:18:07Z", "message": "Address test comment."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2768, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}