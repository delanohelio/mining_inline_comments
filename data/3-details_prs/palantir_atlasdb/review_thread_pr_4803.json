{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDM4NjM2", "number": 4803, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyMjoyNlrOEABssQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyNTozMFrOEABw2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDYzMjgxOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyMjoyNlrOGbC9fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0ODo1MlrOGbFnRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA==", "bodyText": "can we have this be more than 1? Say 16?", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013244", "createdAt": "2020-05-27T10:22:26Z", "author": {"login": "j-baker"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzM1Nw==", "bodyText": "Like 1 just seems wrong.", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013357", "createdAt": "2020-05-27T10:22:40Z", "author": {"login": "j-baker"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzg1MQ==", "bodyText": "(and maybe remove the locking mode exclusive pragma if that breaks things)", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013851", "createdAt": "2020-05-27T10:23:34Z", "author": {"login": "j-baker"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNzM1Ng==", "bodyText": "Like, just to be clear here: 1 means that you'll only have one query in flight to SQLite at a time (depending on how sqlite is implemented), which seems strictly worse than shared locking, if that is used.", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431017356", "createdAt": "2020-05-27T10:29:40Z", "author": {"login": "j-baker"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyMTk1OA==", "bodyText": "That's a good point, having more than 1 connection and removing exclusive locking means we can do parallel reads", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431021958", "createdAt": "2020-05-27T10:38:13Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NjcxMA==", "bodyText": "Yeah, in hindsight our tests probably overindexed on writes (which might be fair given that migration specifically has been causing us pain).", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431056710", "createdAt": "2020-05-27T11:48:52Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDYzNzMzOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyMzo0OVrOGbDAaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDozMToxNlrOGbDREA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzk5Mw==", "bodyText": "don't you want EXTRA here?", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013993", "createdAt": "2020-05-27T10:23:49Z", "author": {"login": "j-baker"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxODI1Ng==", "bodyText": "The enum didn't exist in the java driver. I've set it to the string, not sure there's a better solution.", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431018256", "createdAt": "2020-05-27T10:31:16Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzk5Mw=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDY0MjUwOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyNToxNVrOGbDDuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0OTo0N1rOGbFpBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNDg0Mw==", "bodyText": "this seems like a code smell. Why can't the datasource be injected?", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431014843", "createdAt": "2020-05-27T10:25:15Z", "author": {"login": "j-baker"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NzE1Ng==", "bodyText": "Ah, yes this makes sense. We should have been more aggressive about refactoring the structures we hackily built to get the benchmarks green.", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431057156", "createdAt": "2020-05-27T11:49:47Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNDg0Mw=="}, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDY0MzQ1OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyNTozMFrOGbDESA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDoyNTozMFrOGbDESA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNDk4NA==", "bodyText": "This is much better \ud83c\udf89", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431014984", "createdAt": "2020-05-27T10:25:30Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);\n+        return new HikariDataSource(hikariConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2887, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}