{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NjIwMzEw", "number": 4933, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyNDowM1rOEWPEKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTo1MTo0N1rOEW2vUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzUwOTU1OnYy", "diffSide": "RIGHT", "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyNDowM1rOG9b5nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyNDowM1rOG9b5nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MzQzOQ==", "bodyText": "This needs to be slightly less - a client's connect timeout also covers the time timelock takes to deserialize the request, check it is the leader etc.", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r467073439", "createdAt": "2020-08-07T14:24:03Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -46,6 +46,13 @@\n  * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n  */\n final class BlockEnforcingLockService {\n+    /**\n+     * Bound lock acquire timeout by client read timeout because 1. the async request expires before server cancels\n+     * the request thus avoiding {@link java.util.concurrent.CancellationException} and\n+     * 2. this ensures locks are not given out to phantom client.\n+     */\n+    private static final Duration MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT = Duration.ofSeconds(65);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70db92492036b1302afe5351e41e22ad5ca07e88"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDAwODYxOnYy", "diffSide": "RIGHT", "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTo1MTozMFrOG-U3MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTo1MTozMFrOG-U3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwNjcwNA==", "bodyText": "Not sure I understand the separate verifies here.", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r468006704", "createdAt": "2020-08-10T15:51:30Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "diffHunk": "@@ -141,6 +148,33 @@ public void leasedTokenShouldHaveValidLeaseForTheLeasePeriod() {\n         assertValid(lockResponse.getToken());\n     }\n \n+    @Test\n+    public void lockAcquireTimeoutIsBounded() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(1)).lock(any());\n+        verify(timelock)\n+                .lock(argThat(req -> req.getAcquireTimeoutMs()\n+                        == BlockEnforcingLockService.MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT.toMillis()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b96f0a0858adf9f3423e24645da499cf564eab8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDAwOTc2OnYy", "diffSide": "RIGHT", "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNTo1MTo0N1rOG-U34w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjozMjo0MlrOG-WaVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwNjg4Mw==", "bodyText": "Can we have a test for retrying until failure?", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r468006883", "createdAt": "2020-08-10T15:51:47Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "diffHunk": "@@ -141,6 +148,33 @@ public void leasedTokenShouldHaveValidLeaseForTheLeasePeriod() {\n         assertValid(lockResponse.getToken());\n     }\n \n+    @Test\n+    public void lockAcquireTimeoutIsBounded() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(1)).lock(any());\n+        verify(timelock)\n+                .lock(argThat(req -> req.getAcquireTimeoutMs()\n+                        == BlockEnforcingLockService.MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT.toMillis()));\n+    }\n+\n+    @Test\n+    public void lockAcquireTimeoutIsBoundedAndRequestRetried() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenThrow(TIMEOUT_EXCEPTION)\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(2)).lock(any());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b96f0a0858adf9f3423e24645da499cf564eab8"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMjA4NQ==", "bodyText": "Discussed offline: That's hard because it requires you to inject a clock.", "url": "https://github.com/palantir/atlasdb/pull/4933#discussion_r468032085", "createdAt": "2020-08-10T16:32:42Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LockLeaseServiceTest.java", "diffHunk": "@@ -141,6 +148,33 @@ public void leasedTokenShouldHaveValidLeaseForTheLeasePeriod() {\n         assertValid(lockResponse.getToken());\n     }\n \n+    @Test\n+    public void lockAcquireTimeoutIsBounded() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(1)).lock(any());\n+        verify(timelock)\n+                .lock(argThat(req -> req.getAcquireTimeoutMs()\n+                        == BlockEnforcingLockService.MAX_PERMISSIBLE_LOCK_ACQUIRE_TIMEOUT.toMillis()));\n+    }\n+\n+    @Test\n+    public void lockAcquireTimeoutIsBoundedAndRequestRetried() {\n+        when(lockRequest.getAcquireTimeoutMs()).thenReturn(TIMEOUT_GREATER_THAN_MAX_PERMISSIBLE_TIMEOUT.toMillis());\n+        when(timelock.lock(any()))\n+                .thenThrow(TIMEOUT_EXCEPTION)\n+                .thenReturn(ConjureLockResponse.successful(SuccessfulLockResponse.of(LOCK_TOKEN, getLease())));\n+\n+        LockResponse lockResponse = lockLeaseService.lock(lockRequest);\n+        assertValid(lockResponse.getToken());\n+        verify(timelock, times(2)).lock(any());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwNjg4Mw=="}, "originalCommit": {"oid": "7b96f0a0858adf9f3423e24645da499cf564eab8"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2774, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}