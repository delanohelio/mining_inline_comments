{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NTE0OTg3", "number": 4735, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0Njo1MlrOD2yZGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1NDoxOVrOD2ynWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc1MzIxOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0Njo1MlrOGMtNyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0Njo1MlrOGMtNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NjkwNA==", "bodyText": "discussed: This needs to be resilient to null results.", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415976904", "createdAt": "2020-04-27T16:46:52Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        lock.readLock().lock();\n+        try {\n+            byte[] result = currentLog.readRound(seq);\n+            byte[] experimentalResult = experimentalLog.readRound(seq);\n+            if (!Arrays.equals(result, experimentalResult)) {\n+                log.error(\"Mismatch in reading round for sequence number {} between legacy and current \"\n+                        + \"implementations. Legacy result {}, current result {}.\",\n+                        SafeArg.of(\"sequence\", seq),\n+                        UnsafeArg.of(\"legacy\", hydrator.hydrateFromBytes(result)),\n+                        UnsafeArg.of(\"current\", hydrator.hydrateFromBytes(experimentalResult)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc1ODUyOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0ODowOVrOGMtRJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0ODowOVrOGMtRJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3Nzc2Nw==", "bodyText": "This is a bit nasty, but I'd prefer\nlock();\ntry {\n  current.write(seq, round);\n  try {\n    experiment.write(seq, round);\n  } catch (RuntimeException ex) {\n    log.warn(\"I wrote to current but not experimental, please be careful with future errors for sequence number {}\", SafeArg.of(seq), ex);\n     // intentionally succeed, because we don't want to degrade service\n  }\n} finally {\n  unlock();\n}", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415977767", "createdAt": "2020-04-27T16:48:09Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc2Nzg2OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1MDowM1rOGMtWxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1MDowM1rOGMtWxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3OTIwNg==", "bodyText": "similar to above: should we try to maintain service if the experimental log throws stuff?", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415979206", "createdAt": "2020-04-27T16:50:03Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        lock.readLock().lock();\n+        try {\n+            byte[] result = currentLog.readRound(seq);\n+            byte[] experimentalResult = experimentalLog.readRound(seq);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc3Mjg2OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1MDo1OVrOGMtZwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1MDo1OVrOGMtZwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3OTk2OA==", "bodyText": "and here for experimental protection", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415979968", "createdAt": "2020-04-27T16:50:59Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        lock.readLock().lock();\n+        try {\n+            byte[] result = currentLog.readRound(seq);\n+            byte[] experimentalResult = experimentalLog.readRound(seq);\n+            if (!Arrays.equals(result, experimentalResult)) {\n+                log.error(\"Mismatch in reading round for sequence number {} between legacy and current \"\n+                        + \"implementations. Legacy result {}, current result {}.\",\n+                        SafeArg.of(\"sequence\", seq),\n+                        UnsafeArg.of(\"legacy\", hydrator.hydrateFromBytes(result)),\n+                        UnsafeArg.of(\"current\", hydrator.hydrateFromBytes(experimentalResult)));\n+            }\n+            return result;\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return getExtremeLogEntry(PaxosStateLog::getLeastLogEntry);\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return getExtremeLogEntry(PaxosStateLog::getGreatestLogEntry);\n+    }\n+\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        lock.writeLock().lock();\n+        try {\n+            experimentalLog.truncate(toDeleteInclusive);\n+            currentLog.truncate(toDeleteInclusive);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    private long getExtremeLogEntry(Function<PaxosStateLog<V>, Long> extractor) {\n+        lock.readLock().lock();\n+        try {\n+            long result = extractor.apply(currentLog);\n+            long experimentalResult = extractor.apply(experimentalLog);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc4MTMxOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1MjozNlrOGMtepA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1Mzo1MFrOGMtiSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MTIyMA==", "bodyText": "Non-blocking: Consider InOrder?", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415981220", "createdAt": "2020-04-27T16:52:36Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class VerifyingPaxosStateLogTest {\n+    private static final long LEAST_LOG_ENTRY = 3L;\n+    private static final long GREATEST_LOG_ENTRY = 20L;\n+    private static final byte[] CORRECT_VALUE_FOR_ROUND = valueForRound(10L).persistToBytes();\n+    private static final byte[] OTHER_VALUE_FOR_ROUND = valueForRound(5L).persistToBytes();\n+\n+    private final PaxosStateLog<PaxosValue> current = mock(PaxosStateLog.class);\n+    private final PaxosStateLog<PaxosValue> experimental = mock(PaxosStateLog.class);\n+    private final VerifyingPaxosStateLog.Settings<PaxosValue> settings = ImmutableSettings.<PaxosValue>builder()\n+            .currentLog(current)\n+            .experimentalLog(experimental)\n+            .hydrator(PaxosValue.BYTES_HYDRATOR)\n+            .build();\n+\n+    private final PaxosStateLog<PaxosValue> log = new VerifyingPaxosStateLog<>(settings);\n+\n+    @Before\n+    public void setupMocks() throws IOException {\n+        when(current.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY);\n+        when(current.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY);\n+        when(current.readRound(anyLong())).thenReturn(CORRECT_VALUE_FOR_ROUND);\n+\n+        when(experimental.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY + 1L);\n+        when(experimental.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY + 1L);\n+        when(experimental.readRound(anyLong())).thenReturn(OTHER_VALUE_FOR_ROUND);\n+    }\n+\n+    @After\n+    public void noMoreInteractions() {\n+        verifyNoMoreInteractions(current, experimental);\n+    }\n+\n+    @Test\n+    public void writeWritesToBoth() {\n+        long sequence = 15L;\n+        log.writeRound(sequence, valueForRound(sequence));\n+        verify(current).writeRound(sequence, valueForRound(sequence));\n+        verify(experimental).writeRound(sequence, valueForRound(sequence));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MjE1Mg==", "bodyText": "It looks something like\nMockito.inOrder(current, experimental)\n  .verify(current).write(bla);\n  .verify(experimental).write(bla);", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415982152", "createdAt": "2020-04-27T16:53:50Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class VerifyingPaxosStateLogTest {\n+    private static final long LEAST_LOG_ENTRY = 3L;\n+    private static final long GREATEST_LOG_ENTRY = 20L;\n+    private static final byte[] CORRECT_VALUE_FOR_ROUND = valueForRound(10L).persistToBytes();\n+    private static final byte[] OTHER_VALUE_FOR_ROUND = valueForRound(5L).persistToBytes();\n+\n+    private final PaxosStateLog<PaxosValue> current = mock(PaxosStateLog.class);\n+    private final PaxosStateLog<PaxosValue> experimental = mock(PaxosStateLog.class);\n+    private final VerifyingPaxosStateLog.Settings<PaxosValue> settings = ImmutableSettings.<PaxosValue>builder()\n+            .currentLog(current)\n+            .experimentalLog(experimental)\n+            .hydrator(PaxosValue.BYTES_HYDRATOR)\n+            .build();\n+\n+    private final PaxosStateLog<PaxosValue> log = new VerifyingPaxosStateLog<>(settings);\n+\n+    @Before\n+    public void setupMocks() throws IOException {\n+        when(current.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY);\n+        when(current.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY);\n+        when(current.readRound(anyLong())).thenReturn(CORRECT_VALUE_FOR_ROUND);\n+\n+        when(experimental.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY + 1L);\n+        when(experimental.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY + 1L);\n+        when(experimental.readRound(anyLong())).thenReturn(OTHER_VALUE_FOR_ROUND);\n+    }\n+\n+    @After\n+    public void noMoreInteractions() {\n+        verifyNoMoreInteractions(current, experimental);\n+    }\n+\n+    @Test\n+    public void writeWritesToBoth() {\n+        long sequence = 15L;\n+        log.writeRound(sequence, valueForRound(sequence));\n+        verify(current).writeRound(sequence, valueForRound(sequence));\n+        verify(experimental).writeRound(sequence, valueForRound(sequence));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MTIyMA=="}, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc4OTcxOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1NDoxOVrOGMtjmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1NDoxOVrOGMtjmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MjQ4OQ==", "bodyText": "Might want to add a few tests for the exception protection for experimental, once we've implemented that!", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415982489", "createdAt": "2020-04-27T16:54:19Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class VerifyingPaxosStateLogTest {\n+    private static final long LEAST_LOG_ENTRY = 3L;\n+    private static final long GREATEST_LOG_ENTRY = 20L;\n+    private static final byte[] CORRECT_VALUE_FOR_ROUND = valueForRound(10L).persistToBytes();\n+    private static final byte[] OTHER_VALUE_FOR_ROUND = valueForRound(5L).persistToBytes();\n+\n+    private final PaxosStateLog<PaxosValue> current = mock(PaxosStateLog.class);\n+    private final PaxosStateLog<PaxosValue> experimental = mock(PaxosStateLog.class);\n+    private final VerifyingPaxosStateLog.Settings<PaxosValue> settings = ImmutableSettings.<PaxosValue>builder()\n+            .currentLog(current)\n+            .experimentalLog(experimental)\n+            .hydrator(PaxosValue.BYTES_HYDRATOR)\n+            .build();\n+\n+    private final PaxosStateLog<PaxosValue> log = new VerifyingPaxosStateLog<>(settings);\n+\n+    @Before\n+    public void setupMocks() throws IOException {\n+        when(current.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY);\n+        when(current.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY);\n+        when(current.readRound(anyLong())).thenReturn(CORRECT_VALUE_FOR_ROUND);\n+\n+        when(experimental.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY + 1L);\n+        when(experimental.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY + 1L);\n+        when(experimental.readRound(anyLong())).thenReturn(OTHER_VALUE_FOR_ROUND);\n+    }\n+\n+    @After\n+    public void noMoreInteractions() {\n+        verifyNoMoreInteractions(current, experimental);\n+    }\n+\n+    @Test\n+    public void writeWritesToBoth() {\n+        long sequence = 15L;\n+        log.writeRound(sequence, valueForRound(sequence));\n+        verify(current).writeRound(sequence, valueForRound(sequence));\n+        verify(experimental).writeRound(sequence, valueForRound(sequence));\n+    }\n+\n+    @Test\n+    public void readFromBothReturnLegacy() throws IOException {\n+        long sequence = 10L;\n+        assertThat(log.readRound(sequence)).isEqualTo(CORRECT_VALUE_FOR_ROUND);\n+        verify(current).readRound(sequence);\n+        verify(experimental).readRound(sequence);\n+    }\n+\n+    @Test\n+    public void getLeastFromBothReturnLegacy() {\n+        assertThat(log.getLeastLogEntry()).isEqualTo(LEAST_LOG_ENTRY);\n+        verify(current).getLeastLogEntry();\n+        verify(experimental).getLeastLogEntry();\n+    }\n+\n+    @Test\n+    public void getGreatestFromBothReturnLegacy() {\n+        assertThat(log.getGreatestLogEntry()).isEqualTo(GREATEST_LOG_ENTRY);\n+        verify(current).getGreatestLogEntry();\n+        verify(experimental).getGreatestLogEntry();\n+    }\n+\n+    @Test\n+    public void truncateBoth() {\n+        log.truncate(7L);\n+        verify(current).truncate(7L);\n+        verify(experimental).truncate(7L);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3087, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}