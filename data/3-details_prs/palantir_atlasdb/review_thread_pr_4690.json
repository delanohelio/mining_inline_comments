{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NTU5MTIy", "number": 4690, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowMjoxM1rODtRFaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjoxNDozOVrODtgSGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzkyNDI0OnYy", "diffSide": "RIGHT", "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDowMjoxM1rOF-mCow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTozNToxMVrOF-8kbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTI5OQ==", "bodyText": "can we slap a limit on the executor?", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401179299", "createdAt": "2020-03-31T20:02:13Z", "author": {"login": "j-baker"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "diffHunk": "@@ -50,6 +50,12 @@\n         PaxosRemoteClients remoteClients();\n         LocalPaxosComponents components();\n         int quorumSize();\n+\n+        /**\n+         * Caution! The shared executor should only be used for tasks that are expected to complete quickly.\n+         * DO NOT use the shared executor when the concurrency of requests may be very high (e.g. for Paxos round\n+         * verification). This may lead to thread explosion.\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350575b3be8e331245dc48771e34e9d7a3a048cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTM3Ng==", "bodyText": "like, fix it at max 256 threads or sth?", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401179376", "createdAt": "2020-03-31T20:02:22Z", "author": {"login": "j-baker"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "diffHunk": "@@ -50,6 +50,12 @@\n         PaxosRemoteClients remoteClients();\n         LocalPaxosComponents components();\n         int quorumSize();\n+\n+        /**\n+         * Caution! The shared executor should only be used for tasks that are expected to complete quickly.\n+         * DO NOT use the shared executor when the concurrency of requests may be very high (e.g. for Paxos round\n+         * verification). This may lead to thread explosion.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTI5OQ=="}, "originalCommit": {"oid": "350575b3be8e331245dc48771e34e9d7a3a048cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzOTgxNA==", "bodyText": "Yeah, that sounds like a good thing to do", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401539814", "createdAt": "2020-04-01T11:18:25Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "diffHunk": "@@ -50,6 +50,12 @@\n         PaxosRemoteClients remoteClients();\n         LocalPaxosComponents components();\n         int quorumSize();\n+\n+        /**\n+         * Caution! The shared executor should only be used for tasks that are expected to complete quickly.\n+         * DO NOT use the shared executor when the concurrency of requests may be very high (e.g. for Paxos round\n+         * verification). This may lead to thread explosion.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTI5OQ=="}, "originalCommit": {"oid": "350575b3be8e331245dc48771e34e9d7a3a048cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzOTk5NA==", "bodyText": "Since the claim is that it makes sense to share the executors for the other endpoints as they are explicitly not heavily barraged", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401539994", "createdAt": "2020-04-01T11:18:44Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "diffHunk": "@@ -50,6 +50,12 @@\n         PaxosRemoteClients remoteClients();\n         LocalPaxosComponents components();\n         int quorumSize();\n+\n+        /**\n+         * Caution! The shared executor should only be used for tasks that are expected to complete quickly.\n+         * DO NOT use the shared executor when the concurrency of requests may be very high (e.g. for Paxos round\n+         * verification). This may lead to thread explosion.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTI5OQ=="}, "originalCommit": {"oid": "350575b3be8e331245dc48771e34e9d7a3a048cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0MjQ2NQ==", "bodyText": "I'll have a look on internal metrics framework to decide what a good threshold might be (though might still need monitoring further since that will include acceptor activity which is the bulk of the activity).", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401542465", "createdAt": "2020-04-01T11:23:38Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "diffHunk": "@@ -50,6 +50,12 @@\n         PaxosRemoteClients remoteClients();\n         LocalPaxosComponents components();\n         int quorumSize();\n+\n+        /**\n+         * Caution! The shared executor should only be used for tasks that are expected to complete quickly.\n+         * DO NOT use the shared executor when the concurrency of requests may be very high (e.g. for Paxos round\n+         * verification). This may lead to thread explosion.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTI5OQ=="}, "originalCommit": {"oid": "350575b3be8e331245dc48771e34e9d7a3a048cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0ODM5Ng==", "bodyText": "Yeah, internal metrics not super helpful - they do spike above 400+ in asymptomatic operation (and over 1000 on the relevant ticket), but I'm pretty confident a majority of these are acceptor operations.", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401548396", "createdAt": "2020-04-01T11:35:11Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/Dependencies.java", "diffHunk": "@@ -50,6 +50,12 @@\n         PaxosRemoteClients remoteClients();\n         LocalPaxosComponents components();\n         int quorumSize();\n+\n+        /**\n+         * Caution! The shared executor should only be used for tasks that are expected to complete quickly.\n+         * DO NOT use the shared executor when the concurrency of requests may be very high (e.g. for Paxos round\n+         * verification). This may lead to thread explosion.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTI5OQ=="}, "originalCommit": {"oid": "350575b3be8e331245dc48771e34e9d7a3a048cd"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDE2ODMxOnYy", "diffSide": "RIGHT", "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutors.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMDo1NzoxMFrOF-7ZRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNToxODowMlrOF_ForQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyOTE1Nw==", "bodyText": "SINGLE_THREAD_FOR_AUTOBATCHER?", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401529157", "createdAt": "2020-04-01T10:57:10Z", "author": {"login": "gmaretic"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutors.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.codahale.metrics.InstrumentedExecutorService;\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.streams.KeyedStream;\n+\n+final class TimeLockPaxosExecutors {\n+    @VisibleForTesting\n+    static final int MAXIMUM_POOL_SIZE = 100;\n+\n+    private static final Duration THREAD_KEEP_ALIVE = Duration.ofSeconds(5);\n+\n+    private TimeLockPaxosExecutors() {\n+        // no\n+    }\n+\n+    /**\n+     * Creates a mapping of services to {@link ExecutorService}s indicating that tasks oriented towards the relevant\n+     * node should be run on the associated executor.\n+     *\n+     * It is assumed that tasks run on the local node will return quickly (hence the use of the direct executor).\n+     */\n+    static <T> Map<T, ExecutorService> createBoundedExecutors(\n+            MetricRegistry metricRegistry, LocalAndRemotes<T> localAndRemotes, String useCase) {\n+        Map<T, ExecutorService> remoteExecutors = KeyedStream.of(localAndRemotes.remotes())\n+                .map(remote -> createBoundedExecutor(metricRegistry, useCase))\n+                .collectToMap();\n+        remoteExecutors.put(localAndRemotes.local(), MoreExecutors.newDirectExecutorService());\n+        return remoteExecutors;\n+    }\n+\n+    private static ExecutorService createBoundedExecutor(MetricRegistry metricRegistry, String useCase) {\n+        return new InstrumentedExecutorService(\n+                PTExecutors.newThreadPoolExecutor(\n+                        1, // Many operations are autobatched, so under ordinary circumstances 1 thread will do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c65213ea8129f73c14398d9ea3907ce3a52f277"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY5Njk0MQ==", "bodyText": "OK, will do. Yep, makes sense", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401696941", "createdAt": "2020-04-01T15:18:02Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutors.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.codahale.metrics.InstrumentedExecutorService;\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.streams.KeyedStream;\n+\n+final class TimeLockPaxosExecutors {\n+    @VisibleForTesting\n+    static final int MAXIMUM_POOL_SIZE = 100;\n+\n+    private static final Duration THREAD_KEEP_ALIVE = Duration.ofSeconds(5);\n+\n+    private TimeLockPaxosExecutors() {\n+        // no\n+    }\n+\n+    /**\n+     * Creates a mapping of services to {@link ExecutorService}s indicating that tasks oriented towards the relevant\n+     * node should be run on the associated executor.\n+     *\n+     * It is assumed that tasks run on the local node will return quickly (hence the use of the direct executor).\n+     */\n+    static <T> Map<T, ExecutorService> createBoundedExecutors(\n+            MetricRegistry metricRegistry, LocalAndRemotes<T> localAndRemotes, String useCase) {\n+        Map<T, ExecutorService> remoteExecutors = KeyedStream.of(localAndRemotes.remotes())\n+                .map(remote -> createBoundedExecutor(metricRegistry, useCase))\n+                .collectToMap();\n+        remoteExecutors.put(localAndRemotes.local(), MoreExecutors.newDirectExecutorService());\n+        return remoteExecutors;\n+    }\n+\n+    private static ExecutorService createBoundedExecutor(MetricRegistry metricRegistry, String useCase) {\n+        return new InstrumentedExecutorService(\n+                PTExecutors.newThreadPoolExecutor(\n+                        1, // Many operations are autobatched, so under ordinary circumstances 1 thread will do", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyOTE1Nw=="}, "originalCommit": {"oid": "8c65213ea8129f73c14398d9ea3907ce3a52f277"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDE4MDIxOnYy", "diffSide": "RIGHT", "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutors.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTowMDo1MlrOF-7gxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNToxOToyOVrOF_Fs-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMTA3OQ==", "bodyText": "Maybe have a top level comment on the decisions made here to avoid inline comments? Something along the lines of \"This executor is intentionally constrained to prevent OOMs if it gets inundated by tasks\"? Feel free to ignore if you think this is more helpful", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401531079", "createdAt": "2020-04-01T11:00:52Z", "author": {"login": "gmaretic"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutors.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.codahale.metrics.InstrumentedExecutorService;\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.streams.KeyedStream;\n+\n+final class TimeLockPaxosExecutors {\n+    @VisibleForTesting\n+    static final int MAXIMUM_POOL_SIZE = 100;\n+\n+    private static final Duration THREAD_KEEP_ALIVE = Duration.ofSeconds(5);\n+\n+    private TimeLockPaxosExecutors() {\n+        // no\n+    }\n+\n+    /**\n+     * Creates a mapping of services to {@link ExecutorService}s indicating that tasks oriented towards the relevant\n+     * node should be run on the associated executor.\n+     *\n+     * It is assumed that tasks run on the local node will return quickly (hence the use of the direct executor).\n+     */\n+    static <T> Map<T, ExecutorService> createBoundedExecutors(\n+            MetricRegistry metricRegistry, LocalAndRemotes<T> localAndRemotes, String useCase) {\n+        Map<T, ExecutorService> remoteExecutors = KeyedStream.of(localAndRemotes.remotes())\n+                .map(remote -> createBoundedExecutor(metricRegistry, useCase))\n+                .collectToMap();\n+        remoteExecutors.put(localAndRemotes.local(), MoreExecutors.newDirectExecutorService());\n+        return remoteExecutors;\n+    }\n+\n+    private static ExecutorService createBoundedExecutor(MetricRegistry metricRegistry, String useCase) {\n+        return new InstrumentedExecutorService(\n+                PTExecutors.newThreadPoolExecutor(\n+                        1, // Many operations are autobatched, so under ordinary circumstances 1 thread will do\n+                        MAXIMUM_POOL_SIZE, // Want to bound the number of threads that might be stuck", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c65213ea8129f73c14398d9ea3907ce3a52f277"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY5ODA0MQ==", "bodyText": "Yep, I'll move the comments to the top.", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401698041", "createdAt": "2020-04-01T15:19:29Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutors.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.codahale.metrics.InstrumentedExecutorService;\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.streams.KeyedStream;\n+\n+final class TimeLockPaxosExecutors {\n+    @VisibleForTesting\n+    static final int MAXIMUM_POOL_SIZE = 100;\n+\n+    private static final Duration THREAD_KEEP_ALIVE = Duration.ofSeconds(5);\n+\n+    private TimeLockPaxosExecutors() {\n+        // no\n+    }\n+\n+    /**\n+     * Creates a mapping of services to {@link ExecutorService}s indicating that tasks oriented towards the relevant\n+     * node should be run on the associated executor.\n+     *\n+     * It is assumed that tasks run on the local node will return quickly (hence the use of the direct executor).\n+     */\n+    static <T> Map<T, ExecutorService> createBoundedExecutors(\n+            MetricRegistry metricRegistry, LocalAndRemotes<T> localAndRemotes, String useCase) {\n+        Map<T, ExecutorService> remoteExecutors = KeyedStream.of(localAndRemotes.remotes())\n+                .map(remote -> createBoundedExecutor(metricRegistry, useCase))\n+                .collectToMap();\n+        remoteExecutors.put(localAndRemotes.local(), MoreExecutors.newDirectExecutorService());\n+        return remoteExecutors;\n+    }\n+\n+    private static ExecutorService createBoundedExecutor(MetricRegistry metricRegistry, String useCase) {\n+        return new InstrumentedExecutorService(\n+                PTExecutors.newThreadPoolExecutor(\n+                        1, // Many operations are autobatched, so under ordinary circumstances 1 thread will do\n+                        MAXIMUM_POOL_SIZE, // Want to bound the number of threads that might be stuck", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMTA3OQ=="}, "originalCommit": {"oid": "8c65213ea8129f73c14398d9ea3907ce3a52f277"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM0NzQwOnYy", "diffSide": "RIGHT", "path": "timelock-agent/src/test/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutorsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1Mzo0MFrOF-9Ibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTozMDo1NVrOF_GOWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1NzYxNA==", "bodyText": "Wanted to add a test that local is not using the same executor as remotes and is not bounded in the same way, maybe this?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n                @Test\n          \n          \n            \n                public void localExecutorsAreNotBoundedByMaximumPoolSize() {\n          \n          \n            \n                    int numThreads = TimeLockPaxosExecutors.MAXIMUM_POOL_SIZE * 2;\n          \n          \n            \n                    ExecutorService executor = PTExecutors.newFixedThreadPool(numThreads);\n          \n          \n            \n                    List<Future<Integer>> results = IntStream.range(0, numThreads)\n          \n          \n            \n                            .mapToObj(ignore -> executor.submit(this::submitToLocalAndGetUnchecked))\n          \n          \n            \n                            .collect(Collectors.toList());\n          \n          \n            \n                    results.forEach(future -> assertThatCode(() -> AtlasFutures.getUnchecked(future))\n          \n          \n            \n                            .doesNotThrowAnyException());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private Integer submitToLocalAndGetUnchecked() {\n          \n          \n            \n                    return AtlasFutures.getUnchecked(executors.get(local).submit(SLEEP_FOR_ONE_SECOND));\n          \n          \n            \n                }\n          \n          \n            \n            }", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401557614", "createdAt": "2020-04-01T11:53:40Z", "author": {"login": "gmaretic"}, "path": "timelock-agent/src/test/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutorsTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.util.MetricsManagers;\n+\n+public class TimeLockPaxosExecutorsTest {\n+    private static final String TEST = \"test\";\n+    private static final Callable<Integer> SLEEP_FOR_ONE_SECOND = () -> {\n+        Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);\n+        return 42;\n+    };\n+\n+    private final Object local = new Object();\n+    private final Object remote1 = new Object();\n+    private final Object remote2 = new Object();\n+    private final List<Object> remotes = ImmutableList.of(remote1, remote2);\n+\n+    private final LocalAndRemotes<Object> localAndRemotes = LocalAndRemotes.of(local, remotes);\n+\n+    private final Map<Object, ExecutorService> executors = TimeLockPaxosExecutors.createBoundedExecutors(\n+            MetricsManagers.createForTests().getRegistry(),\n+            localAndRemotes,\n+            TEST);\n+\n+    @Test\n+    public void hasKeysCollectivelyMatchingLocalAndRemoteElements() {\n+        assertThat(executors.keySet()).hasSameElementsAs(localAndRemotes.all());\n+    }\n+\n+    @Test\n+    public void remoteExecutorsAreBounded() {\n+        for (int i = 0; i < TimeLockPaxosExecutors.MAXIMUM_POOL_SIZE; i++) {\n+            executors.get(remote1).submit(SLEEP_FOR_ONE_SECOND);\n+        }\n+        assertThatThrownBy(() -> executors.get(remote1).submit(SLEEP_FOR_ONE_SECOND))\n+                .isInstanceOf(RejectedExecutionException.class);\n+    }\n+\n+    @Test\n+    public void remoteExecutorsAreLimitedSeparately() {\n+        for (int i = 0; i < TimeLockPaxosExecutors.MAXIMUM_POOL_SIZE; i++) {\n+            executors.get(remote1).submit(SLEEP_FOR_ONE_SECOND);\n+        }\n+        assertThatCode(() -> executors.get(remote2).submit(SLEEP_FOR_ONE_SECOND))\n+                .doesNotThrowAnyException();\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c65213ea8129f73c14398d9ea3907ce3a52f277"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNjU4NQ==", "bodyText": "Yep, makes sense. I was a bit torn on whether to include this test (it didn't seem like that was necessarily something I was guaranteeing), but fine to have it.", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401706585", "createdAt": "2020-04-01T15:30:55Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/test/java/com/palantir/atlasdb/timelock/paxos/TimeLockPaxosExecutorsTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.util.MetricsManagers;\n+\n+public class TimeLockPaxosExecutorsTest {\n+    private static final String TEST = \"test\";\n+    private static final Callable<Integer> SLEEP_FOR_ONE_SECOND = () -> {\n+        Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);\n+        return 42;\n+    };\n+\n+    private final Object local = new Object();\n+    private final Object remote1 = new Object();\n+    private final Object remote2 = new Object();\n+    private final List<Object> remotes = ImmutableList.of(remote1, remote2);\n+\n+    private final LocalAndRemotes<Object> localAndRemotes = LocalAndRemotes.of(local, remotes);\n+\n+    private final Map<Object, ExecutorService> executors = TimeLockPaxosExecutors.createBoundedExecutors(\n+            MetricsManagers.createForTests().getRegistry(),\n+            localAndRemotes,\n+            TEST);\n+\n+    @Test\n+    public void hasKeysCollectivelyMatchingLocalAndRemoteElements() {\n+        assertThat(executors.keySet()).hasSameElementsAs(localAndRemotes.all());\n+    }\n+\n+    @Test\n+    public void remoteExecutorsAreBounded() {\n+        for (int i = 0; i < TimeLockPaxosExecutors.MAXIMUM_POOL_SIZE; i++) {\n+            executors.get(remote1).submit(SLEEP_FOR_ONE_SECOND);\n+        }\n+        assertThatThrownBy(() -> executors.get(remote1).submit(SLEEP_FOR_ONE_SECOND))\n+                .isInstanceOf(RejectedExecutionException.class);\n+    }\n+\n+    @Test\n+    public void remoteExecutorsAreLimitedSeparately() {\n+        for (int i = 0; i < TimeLockPaxosExecutors.MAXIMUM_POOL_SIZE; i++) {\n+            executors.get(remote1).submit(SLEEP_FOR_ONE_SECOND);\n+        }\n+        assertThatCode(() -> executors.get(remote2).submit(SLEEP_FOR_ONE_SECOND))\n+                .doesNotThrowAnyException();\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1NzYxNA=="}, "originalCommit": {"oid": "8c65213ea8129f73c14398d9ea3907ce3a52f277"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM2NTI4OnYy", "diffSide": "RIGHT", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimeLockAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMTo1OTowOVrOF-9Tag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODozNToyM1rOF_NiKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDQyNg==", "bodyText": "The idea here is that we expect the source of overloading is a few bad actors hammering, so this will effectively throttle them?", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401560426", "createdAt": "2020-04-01T11:59:09Z", "author": {"login": "gmaretic"}, "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimeLockAgent.java", "diffHunk": "@@ -140,11 +147,17 @@ private TimeLockAgent(MetricsManager metricsManager,\n \n     private static ExecutorService createSharedExecutor(MetricsManager metricsManager) {\n         return new InstrumentedExecutorService(\n-                PTExecutors.newCachedThreadPool(\n+                PTExecutors.newThreadPoolExecutor(\n+                        CORE_SHARED_EXECUTOR_THREADS,\n+                        MAX_SHARED_EXECUTOR_THREADS,\n+                        5,\n+                        TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(),\n                         new InstrumentedThreadFactory(new ThreadFactoryBuilder()\n                                 .setNameFormat(\"paxos-timestamp-creator-%d\")\n                                 .setDaemon(true)\n-                                .build(), metricsManager.getRegistry())),\n+                                .build(), metricsManager.getRegistry()),\n+                        new ThreadPoolExecutor.CallerRunsPolicy()), // Be resilient-ish to overloading", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MTE4MA==", "bodyText": "Maybe have a policy that will log or update a metric if this ever happens, so we can detect if this is actually being hit and our choice for the bound is suspicious", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401671180", "createdAt": "2020-04-01T14:44:29Z", "author": {"login": "gmaretic"}, "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimeLockAgent.java", "diffHunk": "@@ -140,11 +147,17 @@ private TimeLockAgent(MetricsManager metricsManager,\n \n     private static ExecutorService createSharedExecutor(MetricsManager metricsManager) {\n         return new InstrumentedExecutorService(\n-                PTExecutors.newCachedThreadPool(\n+                PTExecutors.newThreadPoolExecutor(\n+                        CORE_SHARED_EXECUTOR_THREADS,\n+                        MAX_SHARED_EXECUTOR_THREADS,\n+                        5,\n+                        TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(),\n                         new InstrumentedThreadFactory(new ThreadFactoryBuilder()\n                                 .setNameFormat(\"paxos-timestamp-creator-%d\")\n                                 .setDaemon(true)\n-                                .build(), metricsManager.getRegistry())),\n+                                .build(), metricsManager.getRegistry()),\n+                        new ThreadPoolExecutor.CallerRunsPolicy()), // Be resilient-ish to overloading", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDQyNg=="}, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNjM0NA==", "bodyText": "Yep, added a metric to the execution handler.", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401826344", "createdAt": "2020-04-01T18:35:23Z", "author": {"login": "jeremyk-91"}, "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimeLockAgent.java", "diffHunk": "@@ -140,11 +147,17 @@ private TimeLockAgent(MetricsManager metricsManager,\n \n     private static ExecutorService createSharedExecutor(MetricsManager metricsManager) {\n         return new InstrumentedExecutorService(\n-                PTExecutors.newCachedThreadPool(\n+                PTExecutors.newThreadPoolExecutor(\n+                        CORE_SHARED_EXECUTOR_THREADS,\n+                        MAX_SHARED_EXECUTOR_THREADS,\n+                        5,\n+                        TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(),\n                         new InstrumentedThreadFactory(new ThreadFactoryBuilder()\n                                 .setNameFormat(\"paxos-timestamp-creator-%d\")\n                                 .setDaemon(true)\n-                                .build(), metricsManager.getRegistry())),\n+                                .build(), metricsManager.getRegistry()),\n+                        new ThreadPoolExecutor.CallerRunsPolicy()), // Be resilient-ish to overloading", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MDQyNg=="}, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDM3NjY0OnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/PaxosQuorumCheckingCoalescingFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjowMzowOVrOF-9aog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjowMzowOVrOF-9aog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2MjI3NA==", "bodyText": "We should remove this comment before merging. +1 for keeping the ordering", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401562274", "createdAt": "2020-04-01T12:03:09Z", "author": {"login": "gmaretic"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/PaxosQuorumCheckingCoalescingFunction.java", "diffHunk": "@@ -96,27 +108,28 @@ public PaxosQuorumCheckingCoalescingFunction(\n     public static <REQ, RESP extends PaxosResponse, SERVICE, F extends CoalescingRequestFunction<REQ, RESP>>\n     PaxosQuorumCheckingCoalescingFunction<REQ, RESP, F> wrapWithRemotes(\n             List<SERVICE> services,\n-            ExecutorService executor,\n+            Map<SERVICE, ExecutorService> executors,\n             int quorumSize,\n             Function<SERVICE, F> functionFactory) {\n-        return services.stream()\n-                .map(functionFactory)\n-                .collect(collectingAndThen(\n-                        toList(), functions -> new PaxosQuorumCheckingCoalescingFunction<>(\n-                                functions,\n-                                Maps.toMap(functions, $ -> executor),\n-                                quorumSize)));\n+        // Not 100% sure if ordering is important, but assuming so here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDQxMTgwOnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/PaxosQuorumCheckingCoalescingFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjoxNDowMFrOF-9wrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTozMjowMlrOF_GRkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2NzkxNg==", "bodyText": "I think we went a bit overboard with fanciness to keep it fluent as opposed to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new PaxosQuorumCheckingCoalescingFunction<>(functionsAndExecutors, quorumSize);\n          \n          \n            \n                    List<F> functions = new ArrayList<>(services.size());\n          \n          \n            \n                    Map<F, ExecutorService> executorMap = new HashMap<>(services.size());\n          \n          \n            \n                    for (SERVICE service: services) {\n          \n          \n            \n                        F function = functionFactory.apply(service);\n          \n          \n            \n                        functions.add(function);\n          \n          \n            \n                        executorMap.put(function, executors.get(service));\n          \n          \n            \n                    }\n          \n          \n            \n                    return new PaxosQuorumCheckingCoalescingFunction<>(functions, executorMap, quorumSize);", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401567916", "createdAt": "2020-04-01T12:14:00Z", "author": {"login": "gmaretic"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/PaxosQuorumCheckingCoalescingFunction.java", "diffHunk": "@@ -96,27 +108,28 @@ public PaxosQuorumCheckingCoalescingFunction(\n     public static <REQ, RESP extends PaxosResponse, SERVICE, F extends CoalescingRequestFunction<REQ, RESP>>\n     PaxosQuorumCheckingCoalescingFunction<REQ, RESP, F> wrapWithRemotes(\n             List<SERVICE> services,\n-            ExecutorService executor,\n+            Map<SERVICE, ExecutorService> executors,\n             int quorumSize,\n             Function<SERVICE, F> functionFactory) {\n-        return services.stream()\n-                .map(functionFactory)\n-                .collect(collectingAndThen(\n-                        toList(), functions -> new PaxosQuorumCheckingCoalescingFunction<>(\n-                                functions,\n-                                Maps.toMap(functions, $ -> executor),\n-                                quorumSize)));\n+        // Not 100% sure if ordering is important, but assuming so here\n+        List<FunctionAndExecutor<F>> functionsAndExecutors = KeyedStream.of(services)\n+                .map(executors::get)\n+                .mapKeys(functionFactory)\n+                .entries()\n+                .<FunctionAndExecutor<F>>map(entry -> ImmutableFunctionAndExecutor.of(entry.getKey(), entry.getValue()))\n+                .collect(Collectors.toList());\n+        return new PaxosQuorumCheckingCoalescingFunction<>(functionsAndExecutors, quorumSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNzQxMA==", "bodyText": "Fair enough, when I threaded the needle I (probably wrongly) thought it was clear enough \ud83d\ude05 but agree this version is clearer.", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401707410", "createdAt": "2020-04-01T15:32:02Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/PaxosQuorumCheckingCoalescingFunction.java", "diffHunk": "@@ -96,27 +108,28 @@ public PaxosQuorumCheckingCoalescingFunction(\n     public static <REQ, RESP extends PaxosResponse, SERVICE, F extends CoalescingRequestFunction<REQ, RESP>>\n     PaxosQuorumCheckingCoalescingFunction<REQ, RESP, F> wrapWithRemotes(\n             List<SERVICE> services,\n-            ExecutorService executor,\n+            Map<SERVICE, ExecutorService> executors,\n             int quorumSize,\n             Function<SERVICE, F> functionFactory) {\n-        return services.stream()\n-                .map(functionFactory)\n-                .collect(collectingAndThen(\n-                        toList(), functions -> new PaxosQuorumCheckingCoalescingFunction<>(\n-                                functions,\n-                                Maps.toMap(functions, $ -> executor),\n-                                quorumSize)));\n+        // Not 100% sure if ordering is important, but assuming so here\n+        List<FunctionAndExecutor<F>> functionsAndExecutors = KeyedStream.of(services)\n+                .map(executors::get)\n+                .mapKeys(functionFactory)\n+                .entries()\n+                .<FunctionAndExecutor<F>>map(entry -> ImmutableFunctionAndExecutor.of(entry.getKey(), entry.getValue()))\n+                .collect(Collectors.toList());\n+        return new PaxosQuorumCheckingCoalescingFunction<>(functionsAndExecutors, quorumSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2NzkxNg=="}, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDQxNDM0OnYy", "diffSide": "LEFT", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjoxNDozOVrOF-9yOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjoxNDozOVrOF-9yOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2ODMxMg==", "bodyText": "\ud83c\udf89", "url": "https://github.com/palantir/atlasdb/pull/4690#discussion_r401568312", "createdAt": "2020-04-01T12:14:39Z", "author": {"login": "gmaretic"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -286,7 +285,6 @@ public void multipleLockRequestsWithTheSameIdAreGranted() {\n     }\n \n     @Test\n-    @Ignore // TODO (jkong): Fix this test by reworking the threading model.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251d7ada4b5ccaa2a87955264ee7ba3d57618a80"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3034, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}