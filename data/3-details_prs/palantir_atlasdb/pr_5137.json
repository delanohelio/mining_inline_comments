{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4NzcwNDE5", "number": 5137, "title": "[Productionizing GetSortedColumns] Part 1: Row Column Range Traps", "bodyText": "Goals (and why):\n\nFix long running bugs in AtlasDB around the use of multiple iterators in getRowsColumnRange.\nSee @j-baker's #5092\n\nImplementation Description (bullets):\n\nReplace offending usages of Maps.transformEntries(...) that generate distinct objects.\nAdd tests.\n\nTesting (What was existing testing like?  What have you done to improve it?):\nAll new code is tested\nConcerns (what feedback would you like?):\nNothing much\nWhere should we start reviewing?: SnapTransTest and SerTransTest\nPriority (whenever / two weeks / yesterday): whenever", "createdAt": "2020-11-27T19:57:17Z", "url": "https://github.com/palantir/atlasdb/pull/5137", "merged": true, "mergeCommit": {"oid": "2f746aa3a44e3a0c8913deee264e889dd41b8683"}, "closed": true, "closedAt": "2020-12-14T14:28:21Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgsXJXgH2gAyNTI4NzcwNDE5OjVkZmNlM2Y4MTBiODE4MDFlYzQ4ZDBkOTdjMmVlY2RjNGM5YTM4NmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmF2tBAFqTU1MTM2OTg3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5dfce3f810b81801ec48d0d97c2eecdc4c9a386a", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/5dfce3f810b81801ec48d0d97c2eecdc4c9a386a", "committedDate": "2020-11-27T19:03:55Z", "message": "broken test with iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c80cb4eae8487cf4e8bd39e8a97b979f2e7d679", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/7c80cb4eae8487cf4e8bd39e8a97b979f2e7d679", "committedDate": "2020-11-27T19:14:40Z", "message": "fixes part 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f08db9dcde985cc439c135474ba9250d565d7225", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/f08db9dcde985cc439c135474ba9250d565d7225", "committedDate": "2020-11-27T19:21:53Z", "message": "bv version test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59b098efa895909f76699a6048c3e694e8bf287d", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/59b098efa895909f76699a6048c3e694e8bf287d", "committedDate": "2020-11-27T19:52:45Z", "message": "SnapTrans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c7329cda68904448cc8c5eca426d0e1096ed3da", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/3c7329cda68904448cc8c5eca426d0e1096ed3da", "committedDate": "2020-11-27T20:06:24Z", "message": "updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4c9599a4908217a2ed82a12ab979befbcb3a8be", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/b4c9599a4908217a2ed82a12ab979befbcb3a8be", "committedDate": "2020-11-27T20:06:24Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac47a2047503aea6c05e286ff577a44f0fd7e4d3", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/ac47a2047503aea6c05e286ff577a44f0fd7e4d3", "committedDate": "2020-11-30T17:28:54Z", "message": "fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad34a6bec3b7da2e85d435614fd3b0c10e086e3", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/0ad34a6bec3b7da2e85d435614fd3b0c10e086e3", "committedDate": "2020-11-30T20:22:34Z", "message": "argha2932j h24031"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/8499d5998c787615b8ed82b70a5f5cb25f84c1a7", "committedDate": "2020-11-30T20:37:57Z", "message": "unsignedbytes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MDMxNzE4", "url": "https://github.com/palantir/atlasdb/pull/5137#pullrequestreview-548031718", "createdAt": "2020-12-09T10:16:30Z", "commit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoxNjozMVrOICM7SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyNzoyMlrOICNY5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3OTg0OA==", "bodyText": "[Sanity check]: This collection is consistent with the one in SnapshotTransaction after this PR. I need to validate that this is equivalent before, too.\nIs there a way that we can force this coupling? I.e. what if someone in the future changes one of the collectors and not the other?", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539179848", "createdAt": "2020-12-09T10:16:31Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java", "diffHunk": "@@ -191,23 +193,9 @@ public SerializableTransaction(\n             TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection columnRangeSelection) {\n         Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> ret =\n                 super.getRowsColumnRange(tableRef, rows, columnRangeSelection);\n-        return Maps.transformEntries(ret, (row, visitable) -> new BatchingVisitable<Map.Entry<Cell, byte[]>>() {\n-            @Override\n-            public <K extends Exception> boolean batchAccept(\n-                    int batchSize, AbortingVisitor<? super List<Map.Entry<Cell, byte[]>>, K> visitor) throws K {\n-                boolean hitEnd = visitable.batchAccept(batchSize, items -> {\n-                    if (items.size() < batchSize) {\n-                        reachedEndOfColumnRange(tableRef, row, columnRangeSelection);\n-                    }\n-                    markRowColumnRangeRead(tableRef, row, columnRangeSelection, items);\n-                    return visitor.visit(items);\n-                });\n-                if (hitEnd) {\n-                    reachedEndOfColumnRange(tableRef, row, columnRangeSelection);\n-                }\n-                return hitEnd;\n-            }\n-        });\n+        return KeyedStream.stream(ret)\n+                .map((row, visitable) -> wrapWithColumnRangeChecking(tableRef, columnRangeSelection, row, visitable))\n+                .collectTo(() -> new TreeMap<>(UnsignedBytes.lexicographicalComparator()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4MTcyMQ==", "bodyText": "[Sanity check]: This code is semantically the same as the previous code, right? As far as I can tell, the main change in this class is the use of KeyedStream over Maps.transformEntries?", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539181721", "createdAt": "2020-12-09T10:19:10Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SerializableTransaction.java", "diffHunk": "@@ -865,6 +827,66 @@ private void handleTransactionConflict(TableReference tableRef) {\n                 tableRef, getTimestamp(), System.currentTimeMillis() - timeCreated);\n     }\n \n+    private BatchingVisitable<Map.Entry<Cell, byte[]>> wrapWithColumnRangeChecking(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4Mzg5OA==", "bodyText": "Ah, so the ordering actually comes from getRowsColumnRangeIterator. As mentioned elsewhere, is there any way we can be defensive and make sure that we always use a sorted collector? I guess tests would fail if you just used any random collector?", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539183898", "createdAt": "2020-12-09T10:22:21Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -381,9 +383,9 @@ public void markTableInvolved(TableReference tableRef) {\n     @Override\n     public Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef, Iterable<byte[]> rows, BatchColumnRangeSelection columnRangeSelection) {\n-        return Maps.transformEntries(\n-                getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection),\n-                (row, iterator) -> BatchingVisitableFromIterable.create(iterator));\n+        return KeyedStream.stream(getRowsColumnRangeIterator(tableRef, rows, columnRangeSelection))\n+                .map((row, iterator) -> BatchingVisitableFromIterable.create(iterator))\n+                .collectTo(() -> new TreeMap<>(UnsignedBytes.lexicographicalComparator()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NTg2OQ==", "bodyText": "What happens if you call iterator2.next()?", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539185869", "createdAt": "2020-12-09T10:25:12Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractSerializableTransactionTest.java", "diffHunk": "@@ -1091,6 +1095,68 @@ public void testDisableReadWriteConflictChecking() {\n         t2.commit();\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {\n+        byte[] row = PtBytes.toBytes(\"ryan\");\n+        Cell cell = Cell.create(row, PtBytes.toBytes(\"c\"));\n+        byte[] value = PtBytes.toBytes(\"victor\");\n+\n+        Transaction t1 = startTransaction();\n+        t1.put(TEST_TABLE, ImmutableMap.of(cell, value));\n+        t1.commit();\n+\n+        Transaction t2 = startTransaction();\n+        Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> iterators = t2.getRowsColumnRange(\n+                TEST_TABLE,\n+                ImmutableList.of(row),\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000));\n+\n+        BatchingVisitable<Map.Entry<Cell, byte[]>> visitable1 = iterators.get(row);\n+        List<Map.Entry<Cell, byte[]>> entriesFromVisitable1 = new ArrayList<>();\n+\n+        BatchingVisitable<Map.Entry<Cell, byte[]>> visitable2 = iterators.get(row);\n+\n+        visitable1.batchAccept(10, cells -> {\n+            entriesFromVisitable1.addAll(cells);\n+            return true;\n+        });\n+\n+        assertThatThrownBy(() -> visitable2.batchAccept(10, cells -> true))\n+                .isExactlyInstanceOf(SafeIllegalStateException.class)\n+                .hasMessageContaining(\"This class has already been called once before\");\n+\n+        assertThat(Iterables.getOnlyElement(entriesFromVisitable1)).satisfies(entry -> {\n+            assertThat(entry.getKey()).isEqualTo(cell);\n+            assertThat(Arrays.equals(entry.getValue(), value)).isTrue();\n+        });\n+    }\n+\n+    @Test\n+    public void testGetRowsColumnRangeIteratorMultipleIteratorsWorkSafely() {\n+        byte[] row = PtBytes.toBytes(\"row\");\n+        Cell cell = Cell.create(row, PtBytes.toBytes(\"col\"));\n+        byte[] value = PtBytes.toBytes(\"val\");\n+\n+        Transaction t1 = startTransaction();\n+        t1.put(TEST_TABLE, ImmutableMap.of(cell, value));\n+        t1.commit();\n+\n+        Transaction t2 = startTransaction();\n+        Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> iterators = t2.getRowsColumnRangeIterator(\n+                TEST_TABLE,\n+                ImmutableList.of(row),\n+                BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 1000));\n+\n+        Iterator<Map.Entry<Cell, byte[]>> iterator1 = iterators.get(row);\n+        Iterator<Map.Entry<Cell, byte[]>> iterator2 = iterators.get(row);\n+        assertThat(iterator1.hasNext()).isTrue();\n+        assertThat(iterator2.hasNext()).isTrue();\n+\n+        Map.Entry<Cell, byte[]> entry = iterator1.next();\n+        assertThat(entry.getKey()).isEqualTo(cell);\n+        assertThat(Arrays.equals(entry.getValue(), value)).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NjIzMg==", "bodyText": "Is there a test somewhere in this class that checks the output is correctly ordered? If not, can we add one such test? Even if there is a test in SnapshotTransaction there should be one here too, to confirm that the ordering stays the same.", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539186232", "createdAt": "2020-12-09T10:25:41Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractSerializableTransactionTest.java", "diffHunk": "@@ -1091,6 +1095,68 @@ public void testDisableReadWriteConflictChecking() {\n         t2.commit();\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzE3MQ==", "bodyText": "You added two tests for the SerializableTransaction, why only one here?", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539187171", "createdAt": "2020-12-09T10:27:04Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java", "diffHunk": "@@ -1220,6 +1221,41 @@ public void cleanup() {}\n         assertEquals(ImmutableList.of(firstCell, secondCell), cells);\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzQzMQ==", "bodyText": "Also, similar comment as above - do we test for the right ordering of values read?", "url": "https://github.com/palantir/atlasdb/pull/5137#discussion_r539187431", "createdAt": "2020-12-09T10:27:22Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionTest.java", "diffHunk": "@@ -1220,6 +1221,41 @@ public void cleanup() {}\n         assertEquals(ImmutableList.of(firstCell, secondCell), cells);\n     }\n \n+    @Test\n+    public void testGetRowsColumnRangeMultipleIteratorsWorkSafely() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NzE3MQ=="}, "originalCommit": {"oid": "8499d5998c787615b8ed82b70a5f5cb25f84c1a7"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e80357af20574e173e6d73fcbd3cc75ace63a182", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/e80357af20574e173e6d73fcbd3cc75ace63a182", "committedDate": "2020-12-14T11:09:38Z", "message": "Move AbSTT tests to AbTT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMzY5ODcz", "url": "https://github.com/palantir/atlasdb/pull/5137#pullrequestreview-551369873", "createdAt": "2020-12-14T13:35:38Z", "commit": {"oid": "e80357af20574e173e6d73fcbd3cc75ace63a182"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2528, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}