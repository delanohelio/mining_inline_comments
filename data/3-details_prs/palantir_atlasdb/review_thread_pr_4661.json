{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMzQwMjE1", "number": 4661, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowNzoyMVrODqZIoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyNToyM1rODqZobA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzc4NTkyOnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/AtlasDbMetrics.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowNzoyMVrOF6HADA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDo0MzoxOVrOF6In4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjQyOA==", "bodyText": "This implementation is very nearly identical to the one below - is there a common method that can be extracted?\nAlso, below you factored out String name = MetricRegistry.name(serviceInterface);, but not in this block.", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396476428", "createdAt": "2020-03-23T14:07:21Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/AtlasDbMetrics.java", "diffHunk": "@@ -71,18 +71,27 @@ private AtlasDbMetrics() {}\n         return instrument(metricRegistry, serviceInterface, service, name, instrumentAllMethods());\n     }\n \n+    public static <T, U extends T> T instrumentWithTaggedMetrics(\n+            TaggedMetricRegistry taggedMetrics,\n+            Class<T> serviceInterface,\n+            U service) {\n+        return Instrumentation.builder(serviceInterface, service)\n+                .withHandler(new TaggedMetricsInvocationEventHandler(\n+                        taggedMetrics,\n+                        MetricRegistry.name(serviceInterface)))\n+                .withPerformanceTraceLogging()\n+                .build();\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5ODI2OA==", "bodyText": "can do, not really sure it buys anything though, this is what it looks like:\n    public static <T, U extends T> T instrumentWithTaggedMetrics(\n            TaggedMetricRegistry taggedMetrics,\n            Class<T> serviceInterface,\n            U service) {\n        return buildInstrumentation(\n                serviceInterface,\n                service,\n                new TaggedMetricsInvocationEventHandler(taggedMetrics, MetricRegistry.name(serviceInterface)));\n    }\n\n    public static <T, U extends T> T instrumentWithTaggedMetrics(\n            TaggedMetricRegistry taggedMetrics,\n            Class<T> serviceInterface,\n            U service,\n            Function<InvocationContext, Map<String, String>> tagFunction) {\n        return buildInstrumentation(\n                serviceInterface,\n                service,\n                new TaggedMetricsInvocationEventHandler(\n                        taggedMetrics,\n                        MetricRegistry.name(serviceInterface),\n                        tagFunction));\n    }\n\n    private static <T, U extends T> T buildInstrumentation(\n            Class<T> serviceInterface,\n            U service,\n            TaggedMetricsInvocationEventHandler handler) {\n        return Instrumentation.builder(serviceInterface, service)\n                .withHandler(handler)\n                .withPerformanceTraceLogging()\n                .build();\n    }\nThe factoring was so it would not kill my line count aha.", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396498268", "createdAt": "2020-03-23T14:37:09Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/AtlasDbMetrics.java", "diffHunk": "@@ -71,18 +71,27 @@ private AtlasDbMetrics() {}\n         return instrument(metricRegistry, serviceInterface, service, name, instrumentAllMethods());\n     }\n \n+    public static <T, U extends T> T instrumentWithTaggedMetrics(\n+            TaggedMetricRegistry taggedMetrics,\n+            Class<T> serviceInterface,\n+            U service) {\n+        return Instrumentation.builder(serviceInterface, service)\n+                .withHandler(new TaggedMetricsInvocationEventHandler(\n+                        taggedMetrics,\n+                        MetricRegistry.name(serviceInterface)))\n+                .withPerformanceTraceLogging()\n+                .build();\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjQyOA=="}, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUwMzAxMQ==", "bodyText": "Yeah this isn't particularly pretty. Don't mind either way, so long as you are consistent (i.e. the factoring thing is either done or not done for both.", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396503011", "createdAt": "2020-03-23T14:43:19Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/AtlasDbMetrics.java", "diffHunk": "@@ -71,18 +71,27 @@ private AtlasDbMetrics() {}\n         return instrument(metricRegistry, serviceInterface, service, name, instrumentAllMethods());\n     }\n \n+    public static <T, U extends T> T instrumentWithTaggedMetrics(\n+            TaggedMetricRegistry taggedMetrics,\n+            Class<T> serviceInterface,\n+            U service) {\n+        return Instrumentation.builder(serviceInterface, service)\n+                .withHandler(new TaggedMetricsInvocationEventHandler(\n+                        taggedMetrics,\n+                        MetricRegistry.name(serviceInterface)))\n+                .withPerformanceTraceLogging()\n+                .build();\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjQyOA=="}, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzgwODgwOnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxMjo0MFrOF6HOnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxMjo0MFrOF6HOnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4MDE1Nw==", "bodyText": "Repeated code from below; is there a better way this can be done?", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396480157", "createdAt": "2020-03-23T14:12:40Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "diffHunk": "@@ -48,7 +58,26 @@\n     private final TaggedMetricRegistry taggedMetricRegistry;\n     private final String serviceName;\n \n-    private final Function<InvocationContext, Map<String, String>> tagFunction;\n+    private final Optional<Function<InvocationContext, Map<String, String>>> tagFunction;\n+\n+    @Nullable\n+    private final Function<Method, Timer> onSuccessTimerMappingFunctionUntagged;\n+    private final ConcurrentMap<Method, Timer> untaggedTimerCache = Maps.newConcurrentMap();\n+\n+    @Nullable\n+    private final Function<MethodWithExtraTags, Timer> onSuccessTimerMappingFunctionExtraTags;\n+    private final ConcurrentMap<MethodWithExtraTags, Timer> extraTagsTimerCache = Maps.newConcurrentMap();\n+\n+    public TaggedMetricsInvocationEventHandler(TaggedMetricRegistry taggedMetricRegistry, String serviceName) {\n+        super(InstrumentationUtils.getEnabledSupplier(serviceName));\n+        this.taggedMetricRegistry = Preconditions.checkNotNull(taggedMetricRegistry, \"metricRegistry\");\n+        this.serviceName = Preconditions.checkNotNull(serviceName, \"serviceName\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzgzMzYxOnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxODoxMVrOF6HehA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNTowMjo1N1rOF6JjsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDIyOA==", "bodyText": "It looks like you are casting result from Object to ListenableFuture<?>; can you do this without a check? (It looks to me like the check above is checking context's return type, but I don't know if that is guaranteed to be the same as the type of result).", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396484228", "createdAt": "2020-03-23T14:18:11Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "diffHunk": "@@ -72,12 +106,54 @@ public void onSuccess(@Nullable InvocationContext context, @Nullable Object resu\n             return;\n         }\n \n+        if (result != null && ListenableFuture.class.isAssignableFrom(context.getMethod().getReturnType())) {\n+            Futures.addCallback((ListenableFuture<?>) result, new FutureCallback<Object>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODMyMQ==", "bodyText": "they should be equivalent, I suppose I wanted to adhere to the interface in question as opposed to whatever type we may get back, I can add another check to the object itself.", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396518321", "createdAt": "2020-03-23T15:02:57Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "diffHunk": "@@ -72,12 +106,54 @@ public void onSuccess(@Nullable InvocationContext context, @Nullable Object resu\n             return;\n         }\n \n+        if (result != null && ListenableFuture.class.isAssignableFrom(context.getMethod().getReturnType())) {\n+            Futures.addCallback((ListenableFuture<?>) result, new FutureCallback<Object>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDIyOA=="}, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzg0Njc2OnYy", "diffSide": "LEFT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyMTowMVrOF6Hm7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyMTowMVrOF6Hm7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NjM4Mw==", "bodyText": "nit: unnecessary diff?", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396486383", "createdAt": "2020-03-23T14:21:01Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/util/TaggedMetricsInvocationEventHandler.java", "diffHunk": "@@ -95,7 +171,6 @@ public void onFailure(@Nullable InvocationContext context, @Nonnull Throwable ca\n         taggedMetricRegistry.meter(MetricName.builder().safeName(\n                 MetricRegistry.name(failuresMetricName, cause.getClass().getName())).build())\n                 .mark();\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzg2MTE2OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyNDowMlrOF6Hv4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDo1NzowN1rOF6JR_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4ODY3NA==", "bodyText": "Should there be two of the exact same statement here? If so, please may you leave a comment as to why?\nnit: maybe also group them together w.r.t spacing?", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396488674", "createdAt": "2020-03-23T14:24:02Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "diffHunk": "@@ -91,6 +122,77 @@ public void instrumentWithCustomNameAll() {\n         assertMethodInstrumented(MetricRegistry.name(CUSTOM_METRIC_NAME, PING_NOT_TIMED_METHOD), service::pingNotTimed);\n     }\n \n+    @Test\n+    public void instrumentTaggedAsyncFunction() throws InterruptedException, ExecutionException {\n+        AsyncTestService asyncTestService = AtlasDbMetrics.instrumentWithTaggedMetrics(taggedMetrics,\n+                AsyncTestService.class, this.asyncTestService);\n+\n+        String asyncPingMetricName = MetricRegistry.name(AsyncTestService.class, \"asyncPing\");\n+        assertTimerNotRegistered(asyncPingMetricName);\n+\n+        List<ListenableFuture<String>> futures = IntStream.range(0, 10)\n+                .mapToObj($ -> asyncTestService.asyncPing())\n+                .collect(Collectors.toList());\n+\n+        Instant now = Instant.now();\n+        MetricName metricName = MetricName.builder().safeName(asyncPingMetricName).build();\n+        ListenableFuture<Boolean> done = Futures.whenAllSucceed(futures).call(() -> {\n+            // have to do it this because we can't edit the future we get back and it's only a callback as opposed to a\n+            // transformed future\n+            Awaitility.await()\n+                    .atMost(ASYNC_DURATION_TTL.toMillis(), TimeUnit.MILLISECONDS)\n+                    .until(() -> taggedMetrics.timer(metricName).getSnapshot().size() > 0);\n+            return true;\n+        }, MoreExecutors.directExecutor());\n+\n+        assertThat(done.get()).isEqualTo(true);\n+\n+        assertThat(done.get()).isEqualTo(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxMzc4OQ==", "bodyText": "deleted, can't remember, was likely an accident", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396513789", "createdAt": "2020-03-23T14:57:07Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "diffHunk": "@@ -91,6 +122,77 @@ public void instrumentWithCustomNameAll() {\n         assertMethodInstrumented(MetricRegistry.name(CUSTOM_METRIC_NAME, PING_NOT_TIMED_METHOD), service::pingNotTimed);\n     }\n \n+    @Test\n+    public void instrumentTaggedAsyncFunction() throws InterruptedException, ExecutionException {\n+        AsyncTestService asyncTestService = AtlasDbMetrics.instrumentWithTaggedMetrics(taggedMetrics,\n+                AsyncTestService.class, this.asyncTestService);\n+\n+        String asyncPingMetricName = MetricRegistry.name(AsyncTestService.class, \"asyncPing\");\n+        assertTimerNotRegistered(asyncPingMetricName);\n+\n+        List<ListenableFuture<String>> futures = IntStream.range(0, 10)\n+                .mapToObj($ -> asyncTestService.asyncPing())\n+                .collect(Collectors.toList());\n+\n+        Instant now = Instant.now();\n+        MetricName metricName = MetricName.builder().safeName(asyncPingMetricName).build();\n+        ListenableFuture<Boolean> done = Futures.whenAllSucceed(futures).call(() -> {\n+            // have to do it this because we can't edit the future we get back and it's only a callback as opposed to a\n+            // transformed future\n+            Awaitility.await()\n+                    .atMost(ASYNC_DURATION_TTL.toMillis(), TimeUnit.MILLISECONDS)\n+                    .until(() -> taggedMetrics.timer(metricName).getSnapshot().size() > 0);\n+            return true;\n+        }, MoreExecutors.directExecutor());\n+\n+        assertThat(done.get()).isEqualTo(true);\n+\n+        assertThat(done.get()).isEqualTo(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4ODY3NA=="}, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzg2NzMyOnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyNToyM1rOF6Hzug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNTowMjo1OFrOF6Jjuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4OTY1OA==", "bodyText": "Copied code from above - can a common method be factored out?", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396489658", "createdAt": "2020-03-23T14:25:23Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "diffHunk": "@@ -91,6 +122,77 @@ public void instrumentWithCustomNameAll() {\n         assertMethodInstrumented(MetricRegistry.name(CUSTOM_METRIC_NAME, PING_NOT_TIMED_METHOD), service::pingNotTimed);\n     }\n \n+    @Test\n+    public void instrumentTaggedAsyncFunction() throws InterruptedException, ExecutionException {\n+        AsyncTestService asyncTestService = AtlasDbMetrics.instrumentWithTaggedMetrics(taggedMetrics,\n+                AsyncTestService.class, this.asyncTestService);\n+\n+        String asyncPingMetricName = MetricRegistry.name(AsyncTestService.class, \"asyncPing\");\n+        assertTimerNotRegistered(asyncPingMetricName);\n+\n+        List<ListenableFuture<String>> futures = IntStream.range(0, 10)\n+                .mapToObj($ -> asyncTestService.asyncPing())\n+                .collect(Collectors.toList());\n+\n+        Instant now = Instant.now();\n+        MetricName metricName = MetricName.builder().safeName(asyncPingMetricName).build();\n+        ListenableFuture<Boolean> done = Futures.whenAllSucceed(futures).call(() -> {\n+            // have to do it this because we can't edit the future we get back and it's only a callback as opposed to a\n+            // transformed future\n+            Awaitility.await()\n+                    .atMost(ASYNC_DURATION_TTL.toMillis(), TimeUnit.MILLISECONDS)\n+                    .until(() -> taggedMetrics.timer(metricName).getSnapshot().size() > 0);\n+            return true;\n+        }, MoreExecutors.directExecutor());\n+\n+        assertThat(done.get()).isEqualTo(true);\n+\n+        assertThat(done.get()).isEqualTo(true);\n+        assertThat(Instant.now())\n+                .as(\"in the event of scheduling issues, and despite having 10 concurrent futures, we complete \"\n+                        + \"everything with 2*ttl\")\n+                .isBefore(now.plus(ASYNC_DURATION_TTL.plus(ASYNC_DURATION_TTL)));\n+        Snapshot snapshot = taggedMetrics.timer(metricName).getSnapshot();\n+        assertThat(Duration.ofNanos(snapshot.getMin())).isGreaterThan(ASYNC_DURATION_TTL);\n+        assertThat(snapshot.size()).isEqualTo(10);\n+    }\n+\n+    @Test\n+    public void instrumentTaggedAsyncFunctionWithExtraTags() throws InterruptedException, ExecutionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjMyNg==", "bodyText": "some code can be factored out, I won't go the full length because it's important to see what's actually in the test without having to jump around everywhere.", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396516326", "createdAt": "2020-03-23T15:00:19Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "diffHunk": "@@ -91,6 +122,77 @@ public void instrumentWithCustomNameAll() {\n         assertMethodInstrumented(MetricRegistry.name(CUSTOM_METRIC_NAME, PING_NOT_TIMED_METHOD), service::pingNotTimed);\n     }\n \n+    @Test\n+    public void instrumentTaggedAsyncFunction() throws InterruptedException, ExecutionException {\n+        AsyncTestService asyncTestService = AtlasDbMetrics.instrumentWithTaggedMetrics(taggedMetrics,\n+                AsyncTestService.class, this.asyncTestService);\n+\n+        String asyncPingMetricName = MetricRegistry.name(AsyncTestService.class, \"asyncPing\");\n+        assertTimerNotRegistered(asyncPingMetricName);\n+\n+        List<ListenableFuture<String>> futures = IntStream.range(0, 10)\n+                .mapToObj($ -> asyncTestService.asyncPing())\n+                .collect(Collectors.toList());\n+\n+        Instant now = Instant.now();\n+        MetricName metricName = MetricName.builder().safeName(asyncPingMetricName).build();\n+        ListenableFuture<Boolean> done = Futures.whenAllSucceed(futures).call(() -> {\n+            // have to do it this because we can't edit the future we get back and it's only a callback as opposed to a\n+            // transformed future\n+            Awaitility.await()\n+                    .atMost(ASYNC_DURATION_TTL.toMillis(), TimeUnit.MILLISECONDS)\n+                    .until(() -> taggedMetrics.timer(metricName).getSnapshot().size() > 0);\n+            return true;\n+        }, MoreExecutors.directExecutor());\n+\n+        assertThat(done.get()).isEqualTo(true);\n+\n+        assertThat(done.get()).isEqualTo(true);\n+        assertThat(Instant.now())\n+                .as(\"in the event of scheduling issues, and despite having 10 concurrent futures, we complete \"\n+                        + \"everything with 2*ttl\")\n+                .isBefore(now.plus(ASYNC_DURATION_TTL.plus(ASYNC_DURATION_TTL)));\n+        Snapshot snapshot = taggedMetrics.timer(metricName).getSnapshot();\n+        assertThat(Duration.ofNanos(snapshot.getMin())).isGreaterThan(ASYNC_DURATION_TTL);\n+        assertThat(snapshot.size()).isEqualTo(10);\n+    }\n+\n+    @Test\n+    public void instrumentTaggedAsyncFunctionWithExtraTags() throws InterruptedException, ExecutionException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4OTY1OA=="}, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODMzMQ==", "bodyText": "That's fair, it just seemed that a fair amount was exact copy/paste (but I don't mind things with small variations not being factored out exactly).", "url": "https://github.com/palantir/atlasdb/pull/4661#discussion_r396518331", "createdAt": "2020-03-23T15:02:58Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/util/AtlasDbMetricsTest.java", "diffHunk": "@@ -91,6 +122,77 @@ public void instrumentWithCustomNameAll() {\n         assertMethodInstrumented(MetricRegistry.name(CUSTOM_METRIC_NAME, PING_NOT_TIMED_METHOD), service::pingNotTimed);\n     }\n \n+    @Test\n+    public void instrumentTaggedAsyncFunction() throws InterruptedException, ExecutionException {\n+        AsyncTestService asyncTestService = AtlasDbMetrics.instrumentWithTaggedMetrics(taggedMetrics,\n+                AsyncTestService.class, this.asyncTestService);\n+\n+        String asyncPingMetricName = MetricRegistry.name(AsyncTestService.class, \"asyncPing\");\n+        assertTimerNotRegistered(asyncPingMetricName);\n+\n+        List<ListenableFuture<String>> futures = IntStream.range(0, 10)\n+                .mapToObj($ -> asyncTestService.asyncPing())\n+                .collect(Collectors.toList());\n+\n+        Instant now = Instant.now();\n+        MetricName metricName = MetricName.builder().safeName(asyncPingMetricName).build();\n+        ListenableFuture<Boolean> done = Futures.whenAllSucceed(futures).call(() -> {\n+            // have to do it this because we can't edit the future we get back and it's only a callback as opposed to a\n+            // transformed future\n+            Awaitility.await()\n+                    .atMost(ASYNC_DURATION_TTL.toMillis(), TimeUnit.MILLISECONDS)\n+                    .until(() -> taggedMetrics.timer(metricName).getSnapshot().size() > 0);\n+            return true;\n+        }, MoreExecutors.directExecutor());\n+\n+        assertThat(done.get()).isEqualTo(true);\n+\n+        assertThat(done.get()).isEqualTo(true);\n+        assertThat(Instant.now())\n+                .as(\"in the event of scheduling issues, and despite having 10 concurrent futures, we complete \"\n+                        + \"everything with 2*ttl\")\n+                .isBefore(now.plus(ASYNC_DURATION_TTL.plus(ASYNC_DURATION_TTL)));\n+        Snapshot snapshot = taggedMetrics.timer(metricName).getSnapshot();\n+        assertThat(Duration.ofNanos(snapshot.getMin())).isGreaterThan(ASYNC_DURATION_TTL);\n+        assertThat(snapshot.size()).isEqualTo(10);\n+    }\n+\n+    @Test\n+    public void instrumentTaggedAsyncFunctionWithExtraTags() throws InterruptedException, ExecutionException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4OTY1OA=="}, "originalCommit": {"oid": "fca4191787bb9fbcef87952ed2f02bc163fa2cfb"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2989, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}