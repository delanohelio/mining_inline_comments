{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDU1NjAw", "number": 4490, "title": "Batched off-heap timestamp cache implementation", "bodyText": "Goals (and why):\nImplementation of an off heap cache with write buffering\nImplementation Description (bullets):\n\nusing batching to simplify the concurrency model\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nadded simple integration tests\n\nConcerns (what feedback would you like?):\n\nsomebody calling clear during a write\n\nWhere should we start reviewing?:\n\nOffHeapTimestampCache\n\nPriority (whenever / two weeks / yesterday):\n\nby Wednesday", "createdAt": "2020-01-07T15:59:19Z", "url": "https://github.com/palantir/atlasdb/pull/4490", "merged": true, "mergeCommit": {"oid": "d32d7b50a1d2aea1fc72a87c00840e28fac17039"}, "closed": true, "closedAt": "2020-01-07T17:28:29Z", "author": {"login": "OStevan"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4AiiqgH2gAyMzYwMDU1NjAwOjBjODE1OTk5NjBiZjRhNTEwNDMxNDUwNzA0YTg2OGI0MDIxZDhhYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb4ELMUAFqTMzOTM4NzcyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0c81599960bf4a510431450704a868b4021d8ac2", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/0c81599960bf4a510431450704a868b4021d8ac2", "committedDate": "2020-01-07T13:12:25Z", "message": "Multiput and multiget."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f226f48b4a04797b82113da2f4d9fb92b81f4a5c", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/f226f48b4a04797b82113da2f4d9fb92b81f4a5c", "committedDate": "2020-01-07T15:00:35Z", "message": "Batching timestamp cache."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3a33c8af992ee3c9097777f68d3216f77b6ce43", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/d3a33c8af992ee3c9097777f68d3216f77b6ce43", "committedDate": "2020-01-07T15:22:13Z", "message": "Changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "429d45db40adaf6a5acbd8effba96e5954f96e8d", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/429d45db40adaf6a5acbd8effba96e5954f96e8d", "committedDate": "2020-01-07T15:29:18Z", "message": "Added a clear."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "committedDate": "2020-01-07T15:51:51Z", "message": "Add multi tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58ab580553704d3e7749a825c4b10b7dd5a1899e", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/58ab580553704d3e7749a825c4b10b7dd5a1899e", "committedDate": "2020-01-07T16:20:08Z", "message": "Small refactor."}, "afterCommit": {"oid": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "committedDate": "2020-01-07T16:21:51Z", "message": "Small refactor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/4546457e9bc9068359f771d9ecce8902590300ae", "committedDate": "2020-01-07T16:39:36Z", "message": "Small refactor."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "committedDate": "2020-01-07T16:21:51Z", "message": "Small refactor."}, "afterCommit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/4546457e9bc9068359f771d9ecce8902590300ae", "committedDate": "2020-01-07T16:39:36Z", "message": "Small refactor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5MzQwODg0", "url": "https://github.com/palantir/atlasdb/pull/4490#pullrequestreview-339340884", "createdAt": "2020-01-07T16:13:44Z", "commit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNjoxMzo0NFrOFa-Lxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNjo1Nzo0NFrOFa_hsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjExOA==", "bodyText": "It's probably enough to just return Map<Long, Long>", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826118", "createdAt": "2020-01-07T16:13:44Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -68,6 +78,39 @@ public Long get(StoreNamespace storeNamespace, @Nonnull Long startTs) {\n         return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n     }\n \n+    @Override\n+    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjU4MQ==", "bodyText": "We could refactor this to a separate check?", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826581", "createdAt": "2020-01-07T16:14:42Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -68,6 +78,39 @@ public Long get(StoreNamespace storeNamespace, @Nonnull Long startTs) {\n         return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n     }\n \n+    @Override\n+    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n+        Preconditions.checkArgument(\n+                availableColumnFamilies.containsKey(storeNamespace.uniqueName()),\n+                \"Store namespace does not exist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjg0Mg==", "bodyText": "as above, it may be easier to pass in Map<Long, Long>", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826842", "createdAt": "2020-01-07T16:15:14Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -80,6 +123,13 @@ public void put(StoreNamespace storeNamespace, @Nonnull Long startTs, @Nonnull L\n         putEntry(availableColumnFamilies.get(storeNamespace.uniqueName()), key, value);\n     }\n \n+    @Override\n+    public void multiPut(StoreNamespace storeNamespace, Set<Map.Entry<Long, Long>> toWrite) {\n+        for (Map.Entry<Long, Long> entry : toWrite) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA==", "bodyText": "nit: could we name this with what the autobatcher actually does? i.e. cellPutter or something like that", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363830084", "createdAt": "2020-01-07T16:21:42Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw==", "bodyText": "How does this case arise? Might be worth a comment: it's not obvious how this happens", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363841287", "createdAt": "2020-01-07T16:44:09Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MzU4OQ==", "bodyText": "similar with concurrentHashMap - maybe inflightRequests", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363843589", "createdAt": "2020-01-07T16:48:56Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA=="}, "originalCommit": {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NDgzNA==", "bodyText": "Probably worth defensively logging what the exception is", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363844834", "createdAt": "2020-01-07T16:51:23Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw=="}, "originalCommit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NTc0NA==", "bodyText": "possible race condition here in that concurrentHashMap may have extra entries cleared, but this is OK as this is only used to skip reads for values that are about to be written", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363845744", "createdAt": "2020-01-07T16:53:03Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");\n+            } finally {\n+                offHeapTimestampCache.concurrentHashMap.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjQzNw==", "bodyText": "nit: would suggest renaming, maybe to createNamespaceAndConstructCacheProposal since this has side effects", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363846437", "createdAt": "2020-01-07T16:54:23Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0ODExNQ==", "bodyText": "nit: cacheNukedWhenSizeLimitExceeded", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363848115", "createdAt": "2020-01-07T16:57:44Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.rocksdb.RocksDbPersistentTimestampStore;\n+\n+public final class OffHeapTimestampCacheIntegrationTests {\n+    @ClassRule\n+    public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+    private static final int CACHE_SIZE = 2;\n+\n+    private TimestampCache offHeapTimestampCache;\n+    private PersistentTimestampStore persistentTimestampStore;\n+\n+    @Before\n+    public void before() throws RocksDBException, IOException {\n+        RocksDB rocksDb = RocksDB.open(TEMPORARY_FOLDER.newFolder().getAbsolutePath());\n+\n+        persistentTimestampStore = new RocksDbPersistentTimestampStore(rocksDb);\n+\n+        offHeapTimestampCache = OffHeapTimestampCache.create(persistentTimestampStore, CACHE_SIZE);\n+    }\n+\n+    @After\n+    public void after() throws Exception {\n+        persistentTimestampStore.close();\n+    }\n+\n+    @Test\n+    public void cachedEntry() {\n+        offHeapTimestampCache.putAlreadyCommittedTransaction(1L, 3L);\n+\n+        assertThat(offHeapTimestampCache.getCommitTimestampIfPresent(1L)).isEqualTo(3L);\n+    }\n+\n+    @Test\n+    public void nonCachedEntry() {\n+        assertThat(offHeapTimestampCache.getCommitTimestampIfPresent(1L)).isNull();\n+    }\n+\n+    @Test\n+    public void cacheNuked() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4546457e9bc9068359f771d9ecce8902590300ae"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "251fc3cd16fca086c086b40bee40159a907273a3", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/251fc3cd16fca086c086b40bee40159a907273a3", "committedDate": "2020-01-07T17:09:22Z", "message": "Comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eece8a5d58d4ee46407e7ba904e418ecdeed92a1", "author": {"user": {"login": "OStevan", "name": "Stevan Ognjanovic"}}, "url": "https://github.com/palantir/atlasdb/commit/eece8a5d58d4ee46407e7ba904e418ecdeed92a1", "committedDate": "2020-01-07T17:15:02Z", "message": "Renamed a wrong change."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5Mzg3NzI0", "url": "https://github.com/palantir/atlasdb/pull/4490#pullrequestreview-339387724", "createdAt": "2020-01-07T17:26:32Z", "commit": {"oid": "251fc3cd16fca086c086b40bee40159a907273a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2338, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}