{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxMjM0NTY0", "number": 4975, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMjoyMlrOEhZjCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyOToyNVrOEhZ3zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU3MDM1OnYy", "diffSide": "RIGHT", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMjoyMlrOHOsaSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMjoyMlrOHOsaSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTczOA==", "bodyText": "nit: probably just factor out runSweepIterations(iterations) for ticking INITIAL_DELAY + (iterations - 1) * DELAY", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485169738", "createdAt": "2020-09-08T20:12:22Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.atlasdb.sweep.queue.ScalingSweepTaskScheduler.INITIAL_DELAY;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskSchedulerTest {\n+    private static final SweepIterationResult SUCCESS_HUGE = SweepIterationResults\n+            .success(SweepQueueUtils.SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS_LARGE = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_HIGH_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_MEDIUM = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD + 1);\n+    private static final SweepIterationResult SUCCESS_SMALL = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_TINY = SweepIterationResults\n+            .success(SweepDelay.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final long DELAY = 1L;\n+    private static final long INITIAL_PAUSE = 5L;\n+\n+    private final DeterministicScheduler deterministicScheduler = new DeterministicScheduler();\n+    private final SweepDelay delay = mock(SweepDelay.class);\n+    private final Callable<SweepIterationResult> sweepIteration = mock(Callable.class);\n+    private final AtomicBoolean schedulerEnabled = new AtomicBoolean(true);\n+    private final ScalingSweepTaskScheduler scheduler = createScheduler(Duration.ZERO);\n+\n+    @Before\n+    public void setup() {\n+        when(delay.getInitialPause()).thenReturn(INITIAL_PAUSE);\n+        when(delay.getNextPause(any(SweepIterationResult.class))).thenReturn(DELAY);\n+    }\n+\n+    @Test\n+    public void whenExpectedNumberOfEntriesIsSweptKeepReschedulingAfterDelay() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        scheduler.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 8 * DELAY, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU3NzkzOnYy", "diffSide": "RIGHT", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNDo1M1rOHOsfCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxNDo1M1rOHOsfCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDk1Mw==", "bodyText": "In general for tests like this one, you might want to tick the ticker a bit less, check that it hadn't retriggered yet, and then tick it to the required value", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485170953", "createdAt": "2020-09-08T20:14:53Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.atlasdb.sweep.queue.ScalingSweepTaskScheduler.INITIAL_DELAY;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskSchedulerTest {\n+    private static final SweepIterationResult SUCCESS_HUGE = SweepIterationResults\n+            .success(SweepQueueUtils.SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS_LARGE = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_HIGH_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_MEDIUM = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD + 1);\n+    private static final SweepIterationResult SUCCESS_SMALL = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_TINY = SweepIterationResults\n+            .success(SweepDelay.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final long DELAY = 1L;\n+    private static final long INITIAL_PAUSE = 5L;\n+\n+    private final DeterministicScheduler deterministicScheduler = new DeterministicScheduler();\n+    private final SweepDelay delay = mock(SweepDelay.class);\n+    private final Callable<SweepIterationResult> sweepIteration = mock(Callable.class);\n+    private final AtomicBoolean schedulerEnabled = new AtomicBoolean(true);\n+    private final ScalingSweepTaskScheduler scheduler = createScheduler(Duration.ZERO);\n+\n+    @Before\n+    public void setup() {\n+        when(delay.getInitialPause()).thenReturn(INITIAL_PAUSE);\n+        when(delay.getNextPause(any(SweepIterationResult.class))).thenReturn(DELAY);\n+    }\n+\n+    @Test\n+    public void whenExpectedNumberOfEntriesIsSweptKeepReschedulingAfterDelay() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        scheduler.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 8 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times((1 + 8) * 2)).call();\n+    }\n+\n+    @Test\n+    public void whenScalingDisabledUsesInitialPause() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        schedulerEnabled.set(false);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 7 * INITIAL_PAUSE, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(8 * 10)).call();\n+    }\n+\n+    @Test\n+    public void whenManyEntriesAreSweptNewTaskSpawns() throws Exception {\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_MEDIUM, SUCCESS_MEDIUM,\n+                SUCCESS_LARGE, SUCCESS_MEDIUM);\n+        scheduler.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 2 + 2 + 3 + 3 + 3)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstSpawningNewTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_LARGE);\n+        schedulerWithCoolDown.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesAreSweptTasksAreReduced() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL, SUCCESS_MEDIUM);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(10 + 5 * 9)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesDoNotReduceToZeroTasks() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+        scheduler.start(1);\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstReducingTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+\n+        schedulerWithCoolDown.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(2 + 5 * 2)).call();\n+    }\n+\n+    @Test\n+    public void attemptToIncreaseNumberOfThreadsPreventsReduction() throws Exception {\n+        Duration coolDown = Duration.ofSeconds(1);\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(coolDown);\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_LARGE,\n+                SUCCESS_SMALL);\n+        schedulerWithCoolDown.start(2);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        deterministicScheduler.tick(INITIAL_DELAY, TimeUnit.MILLISECONDS);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        // these will not reduce the number of threads due to the attempt to increase in previous iterations\n+        deterministicScheduler.tick(2 * DELAY, TimeUnit.MILLISECONDS);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        // the first iteration that gets executed will not reschedule\n+        deterministicScheduler.tick(2 * DELAY, TimeUnit.MILLISECONDS);\n+\n+        verify(sweepIteration, times(2 + 2 * 2 + 2 + 1)).call();\n+    }\n+\n+    @Test\n+    public void whenUnableToAcquireShardOnLastTaskRescheduleAfterMaxPause() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithRealDelay = createScheduler(new SweepDelay(1L), Duration.ZERO);\n+        when(sweepIteration.call()).thenReturn(SweepIterationResults.unableToAcquireShard(), SUCCESS_MEDIUM);\n+\n+        schedulerWithRealDelay.start(1);\n+        deterministicScheduler.tick(INITIAL_DELAY + SweepDelay.DEFAULT_MAX_PAUSE_MILLIS + 2, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 3)).call();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDU5OTE0OnYy", "diffSide": "RIGHT", "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyMToxN1rOHOsr2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyMToxN1rOHOsr2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDIzMg==", "bodyText": "We should be able to avoid this: you can pass in a clock or rather Supplier<Instant> to the scheduler", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485174232", "createdAt": "2020-09-08T20:21:17Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/test/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskSchedulerTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.atMost;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.atlasdb.sweep.queue.ScalingSweepTaskScheduler.INITIAL_DELAY;\n+import static com.palantir.logsafe.testing.Assertions.assertThat;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jmock.lib.concurrent.DeterministicScheduler;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskSchedulerTest {\n+    private static final SweepIterationResult SUCCESS_HUGE = SweepIterationResults\n+            .success(SweepQueueUtils.SWEEP_BATCH_SIZE);\n+    private static final SweepIterationResult SUCCESS_LARGE = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_HIGH_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_MEDIUM = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD + 1);\n+    private static final SweepIterationResult SUCCESS_SMALL = SweepIterationResults\n+            .success(ScalingSweepTaskScheduler.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final SweepIterationResult SUCCESS_TINY = SweepIterationResults\n+            .success(SweepDelay.BATCH_CELLS_LOW_THRESHOLD);\n+    private static final long DELAY = 1L;\n+    private static final long INITIAL_PAUSE = 5L;\n+\n+    private final DeterministicScheduler deterministicScheduler = new DeterministicScheduler();\n+    private final SweepDelay delay = mock(SweepDelay.class);\n+    private final Callable<SweepIterationResult> sweepIteration = mock(Callable.class);\n+    private final AtomicBoolean schedulerEnabled = new AtomicBoolean(true);\n+    private final ScalingSweepTaskScheduler scheduler = createScheduler(Duration.ZERO);\n+\n+    @Before\n+    public void setup() {\n+        when(delay.getInitialPause()).thenReturn(INITIAL_PAUSE);\n+        when(delay.getNextPause(any(SweepIterationResult.class))).thenReturn(DELAY);\n+    }\n+\n+    @Test\n+    public void whenExpectedNumberOfEntriesIsSweptKeepReschedulingAfterDelay() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        scheduler.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 8 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times((1 + 8) * 2)).call();\n+    }\n+\n+    @Test\n+    public void whenScalingDisabledUsesInitialPause() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_MEDIUM);\n+        schedulerEnabled.set(false);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 7 * INITIAL_PAUSE, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(8 * 10)).call();\n+    }\n+\n+    @Test\n+    public void whenManyEntriesAreSweptNewTaskSpawns() throws Exception {\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_MEDIUM, SUCCESS_MEDIUM,\n+                SUCCESS_LARGE, SUCCESS_MEDIUM);\n+        scheduler.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 2 + 2 + 3 + 3 + 3)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstSpawningNewTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_LARGE);\n+        schedulerWithCoolDown.start(1);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesAreSweptTasksAreReduced() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL, SUCCESS_MEDIUM);\n+        scheduler.start(10);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(10 + 5 * 9)).call();\n+    }\n+\n+    @Test\n+    public void whenFewEntriesDoNotReduceToZeroTasks() throws Exception {\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+        scheduler.start(1);\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(1 + 5)).call();\n+    }\n+\n+    @Test\n+    public void coolDownProtectsAgainstReducingTasks() throws Exception {\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(Duration.ofDays(1));\n+        when(sweepIteration.call()).thenReturn(SUCCESS_SMALL);\n+\n+        schedulerWithCoolDown.start(2);\n+\n+        deterministicScheduler.tick(INITIAL_DELAY + 5 * DELAY, TimeUnit.MILLISECONDS);\n+        verify(sweepIteration, times(2 + 5 * 2)).call();\n+    }\n+\n+    @Test\n+    public void attemptToIncreaseNumberOfThreadsPreventsReduction() throws Exception {\n+        Duration coolDown = Duration.ofSeconds(1);\n+        ScalingSweepTaskScheduler schedulerWithCoolDown = createScheduler(coolDown);\n+        when(sweepIteration.call()).thenReturn(\n+                SUCCESS_LARGE,\n+                SUCCESS_LARGE,\n+                SUCCESS_SMALL);\n+        schedulerWithCoolDown.start(2);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);\n+        deterministicScheduler.tick(INITIAL_DELAY, TimeUnit.MILLISECONDS);\n+\n+        Uninterruptibles.sleepUninterruptibly(coolDown.toMillis() / 2 + 1, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYwMjU3OnYy", "diffSide": "RIGHT", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyMjoxOVrOHOst5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzo0Nzo0OVrOHPIOCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDc1OQ==", "bodyText": "I would throw a SafeIllegalStateException in this case (unless there's some vagary of the type system I'm missing).", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485174759", "createdAt": "2020-09-08T20:22:19Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskScheduler implements Closeable {\n+    private static final Duration COOL_DOWN = Duration.ofMinutes(5L);\n+    static final int BATCH_CELLS_LOW_THRESHOLD = 1_000;\n+    static final int BATCH_CELLS_HIGH_THRESHOLD = SweepQueueUtils.SWEEP_BATCH_SIZE * 2 / 3;\n+    static final long INITIAL_DELAY = 1_000L;\n+\n+    private final ScheduledExecutorService executorService;\n+    private final SweepDelay delay;\n+    private final Duration coolDown;\n+    private final Callable<SweepIterationResult> singleIteration;\n+    private final BooleanSupplier scalingEnabled;\n+\n+    private int runningTasks = 0;\n+    private Instant lastModification = Instant.now();\n+    private Instant lastIncreaseAttempted = Instant.now();\n+\n+    ScalingSweepTaskScheduler(\n+            ScheduledExecutorService executorService,\n+            SweepDelay delay,\n+            Duration coolDown,\n+            Callable<SweepIterationResult> singleIteration,\n+            BooleanSupplier scalingEnabled) {\n+        this.executorService = executorService;\n+        this.delay = delay;\n+        this.coolDown = coolDown;\n+        this.singleIteration = singleIteration;\n+        this.scalingEnabled = scalingEnabled;\n+    }\n+\n+    /**\n+     * Creates a scheduler for targeted sweep background tasks that dynamically modifies the number of parallel tasks\n+     * based on results. The number of tasks is guaranteed to always be between 1 nad 128, and will only change by one\n+     * in any {@link #COOL_DOWN} period. Furthermore, if conflicting results are observed, increasing the number of\n+     * tasks is prioritised to make sure targeted sweep does not fall behind.\n+     *\n+     * If an iteration of the task is unable to acquire a shard to sweep or sweep is disabled, and there are multiple\n+     * running tasks, the number of tasks will be decreased regardless of {@link #COOL_DOWN} as this indicates the level\n+     * of parallelism is too high to achieve any benefit.\n+     */\n+    public static ScalingSweepTaskScheduler createStarted(\n+            SweepDelay delay,\n+            int initialThreads,\n+            Callable<SweepIterationResult> task,\n+            BooleanSupplier scalingEnabled) {\n+        ScheduledExecutorService  executorService = PTExecutors.newScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"Targeted Sweep\", true));\n+\n+        ScalingSweepTaskScheduler scheduler = new ScalingSweepTaskScheduler(\n+                executorService, delay, COOL_DOWN, task, scalingEnabled);\n+        scheduler.start(initialThreads);\n+        return scheduler;\n+    }\n+\n+    void start(int initialThreads) {\n+        for (int i = 0; i < initialThreads; i++) {\n+            increaseNumberOfTasks(INITIAL_DELAY);\n+        }\n+    }\n+\n+    private synchronized void maybeIncreaseNumberOfTasks(long pause) {\n+        lastIncreaseAttempted = Instant.now();\n+        if (cooldownPassed(lastModification)) {\n+            increaseNumberOfTasks(pause);\n+        }\n+        scheduleAfterDelay(pause);\n+    }\n+\n+    private synchronized void maybeDecreaseNumberOfTasks(long pause) {\n+        if (cooldownPassed(lastModification) && cooldownPassed(lastIncreaseAttempted)) {\n+            decreaseNumberOfTasksOrRescheduleIfLast(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void increaseNumberOfTasks(long pause) {\n+        if (runningTasks < 128) {\n+            runningTasks++;\n+            lastModification = Instant.now();\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasksOrRescheduleIfLast(long pause) {\n+        if (runningTasks == 1) {\n+            scheduleAfterDelay(pause);\n+        } else {\n+            decreaseNumberOfTasks();\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasks() {\n+        runningTasks--;\n+        lastModification = Instant.now();\n+    }\n+\n+    private void scheduleAfterDelay(long pause) {\n+        executorService.schedule(() -> retryingTask(singleIteration), pause, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void retryingTask(Callable<SweepIterationResult> task) {\n+        try {\n+            SweepIterationResult sweepResult = task.call();\n+            if (!scalingEnabled.getAsBoolean()) {\n+                scheduleAfterDelay(delay.getInitialPause());\n+            } else {\n+                long pause = delay.getNextPause(sweepResult);\n+                SweepIterationResults.caseOf(sweepResult)\n+                        .success(numThreads -> determineAction(numThreads, pause))\n+                        .unableToAcquireShard(wrap(() -> decreaseNumberOfTasksOrRescheduleIfLast(pause)))\n+                        .insufficientConsistency(wrap(() -> scheduleAfterDelay(pause)))\n+                        .otherError(wrap(() -> scheduleAfterDelay(pause)))\n+                        .disabled(wrap(() -> decreaseNumberOfTasksOrRescheduleIfLast(pause)));\n+            }\n+        } catch (Exception e) {\n+            scheduleAfterDelay(delay.getMaxPause());\n+        }\n+    }\n+\n+    private Void determineAction(long numThreads, long pause) {\n+        if (numThreads <= BATCH_CELLS_LOW_THRESHOLD) {\n+            maybeDecreaseNumberOfTasks(pause);\n+        } else if (numThreads >= BATCH_CELLS_HIGH_THRESHOLD) {\n+            maybeIncreaseNumberOfTasks(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyNTM1Mg==", "bodyText": "I definitely don't want to throw here, the function has to return Void for the fluent expression above to be happy with typing", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485625352", "createdAt": "2020-09-09T13:47:49Z", "author": {"login": "gmaretic"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskScheduler implements Closeable {\n+    private static final Duration COOL_DOWN = Duration.ofMinutes(5L);\n+    static final int BATCH_CELLS_LOW_THRESHOLD = 1_000;\n+    static final int BATCH_CELLS_HIGH_THRESHOLD = SweepQueueUtils.SWEEP_BATCH_SIZE * 2 / 3;\n+    static final long INITIAL_DELAY = 1_000L;\n+\n+    private final ScheduledExecutorService executorService;\n+    private final SweepDelay delay;\n+    private final Duration coolDown;\n+    private final Callable<SweepIterationResult> singleIteration;\n+    private final BooleanSupplier scalingEnabled;\n+\n+    private int runningTasks = 0;\n+    private Instant lastModification = Instant.now();\n+    private Instant lastIncreaseAttempted = Instant.now();\n+\n+    ScalingSweepTaskScheduler(\n+            ScheduledExecutorService executorService,\n+            SweepDelay delay,\n+            Duration coolDown,\n+            Callable<SweepIterationResult> singleIteration,\n+            BooleanSupplier scalingEnabled) {\n+        this.executorService = executorService;\n+        this.delay = delay;\n+        this.coolDown = coolDown;\n+        this.singleIteration = singleIteration;\n+        this.scalingEnabled = scalingEnabled;\n+    }\n+\n+    /**\n+     * Creates a scheduler for targeted sweep background tasks that dynamically modifies the number of parallel tasks\n+     * based on results. The number of tasks is guaranteed to always be between 1 nad 128, and will only change by one\n+     * in any {@link #COOL_DOWN} period. Furthermore, if conflicting results are observed, increasing the number of\n+     * tasks is prioritised to make sure targeted sweep does not fall behind.\n+     *\n+     * If an iteration of the task is unable to acquire a shard to sweep or sweep is disabled, and there are multiple\n+     * running tasks, the number of tasks will be decreased regardless of {@link #COOL_DOWN} as this indicates the level\n+     * of parallelism is too high to achieve any benefit.\n+     */\n+    public static ScalingSweepTaskScheduler createStarted(\n+            SweepDelay delay,\n+            int initialThreads,\n+            Callable<SweepIterationResult> task,\n+            BooleanSupplier scalingEnabled) {\n+        ScheduledExecutorService  executorService = PTExecutors.newScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"Targeted Sweep\", true));\n+\n+        ScalingSweepTaskScheduler scheduler = new ScalingSweepTaskScheduler(\n+                executorService, delay, COOL_DOWN, task, scalingEnabled);\n+        scheduler.start(initialThreads);\n+        return scheduler;\n+    }\n+\n+    void start(int initialThreads) {\n+        for (int i = 0; i < initialThreads; i++) {\n+            increaseNumberOfTasks(INITIAL_DELAY);\n+        }\n+    }\n+\n+    private synchronized void maybeIncreaseNumberOfTasks(long pause) {\n+        lastIncreaseAttempted = Instant.now();\n+        if (cooldownPassed(lastModification)) {\n+            increaseNumberOfTasks(pause);\n+        }\n+        scheduleAfterDelay(pause);\n+    }\n+\n+    private synchronized void maybeDecreaseNumberOfTasks(long pause) {\n+        if (cooldownPassed(lastModification) && cooldownPassed(lastIncreaseAttempted)) {\n+            decreaseNumberOfTasksOrRescheduleIfLast(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void increaseNumberOfTasks(long pause) {\n+        if (runningTasks < 128) {\n+            runningTasks++;\n+            lastModification = Instant.now();\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasksOrRescheduleIfLast(long pause) {\n+        if (runningTasks == 1) {\n+            scheduleAfterDelay(pause);\n+        } else {\n+            decreaseNumberOfTasks();\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasks() {\n+        runningTasks--;\n+        lastModification = Instant.now();\n+    }\n+\n+    private void scheduleAfterDelay(long pause) {\n+        executorService.schedule(() -> retryingTask(singleIteration), pause, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void retryingTask(Callable<SweepIterationResult> task) {\n+        try {\n+            SweepIterationResult sweepResult = task.call();\n+            if (!scalingEnabled.getAsBoolean()) {\n+                scheduleAfterDelay(delay.getInitialPause());\n+            } else {\n+                long pause = delay.getNextPause(sweepResult);\n+                SweepIterationResults.caseOf(sweepResult)\n+                        .success(numThreads -> determineAction(numThreads, pause))\n+                        .unableToAcquireShard(wrap(() -> decreaseNumberOfTasksOrRescheduleIfLast(pause)))\n+                        .insufficientConsistency(wrap(() -> scheduleAfterDelay(pause)))\n+                        .otherError(wrap(() -> scheduleAfterDelay(pause)))\n+                        .disabled(wrap(() -> decreaseNumberOfTasksOrRescheduleIfLast(pause)));\n+            }\n+        } catch (Exception e) {\n+            scheduleAfterDelay(delay.getMaxPause());\n+        }\n+    }\n+\n+    private Void determineAction(long numThreads, long pause) {\n+        if (numThreads <= BATCH_CELLS_LOW_THRESHOLD) {\n+            maybeDecreaseNumberOfTasks(pause);\n+        } else if (numThreads >= BATCH_CELLS_HIGH_THRESHOLD) {\n+            maybeIncreaseNumberOfTasks(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDc1OQ=="}, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYxMjU2OnYy", "diffSide": "RIGHT", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNTo0MVrOHOs0HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNTo0MVrOHOs0HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjM0OQ==", "bodyText": "nit: runningTasks, for consistency with elsewhere in the class.", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485176349", "createdAt": "2020-09-08T20:25:41Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/sweep/queue/ScalingSweepTaskScheduler.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.sweep.queue;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+\n+public class ScalingSweepTaskScheduler implements Closeable {\n+    private static final Duration COOL_DOWN = Duration.ofMinutes(5L);\n+    static final int BATCH_CELLS_LOW_THRESHOLD = 1_000;\n+    static final int BATCH_CELLS_HIGH_THRESHOLD = SweepQueueUtils.SWEEP_BATCH_SIZE * 2 / 3;\n+    static final long INITIAL_DELAY = 1_000L;\n+\n+    private final ScheduledExecutorService executorService;\n+    private final SweepDelay delay;\n+    private final Duration coolDown;\n+    private final Callable<SweepIterationResult> singleIteration;\n+    private final BooleanSupplier scalingEnabled;\n+\n+    private int runningTasks = 0;\n+    private Instant lastModification = Instant.now();\n+    private Instant lastIncreaseAttempted = Instant.now();\n+\n+    ScalingSweepTaskScheduler(\n+            ScheduledExecutorService executorService,\n+            SweepDelay delay,\n+            Duration coolDown,\n+            Callable<SweepIterationResult> singleIteration,\n+            BooleanSupplier scalingEnabled) {\n+        this.executorService = executorService;\n+        this.delay = delay;\n+        this.coolDown = coolDown;\n+        this.singleIteration = singleIteration;\n+        this.scalingEnabled = scalingEnabled;\n+    }\n+\n+    /**\n+     * Creates a scheduler for targeted sweep background tasks that dynamically modifies the number of parallel tasks\n+     * based on results. The number of tasks is guaranteed to always be between 1 nad 128, and will only change by one\n+     * in any {@link #COOL_DOWN} period. Furthermore, if conflicting results are observed, increasing the number of\n+     * tasks is prioritised to make sure targeted sweep does not fall behind.\n+     *\n+     * If an iteration of the task is unable to acquire a shard to sweep or sweep is disabled, and there are multiple\n+     * running tasks, the number of tasks will be decreased regardless of {@link #COOL_DOWN} as this indicates the level\n+     * of parallelism is too high to achieve any benefit.\n+     */\n+    public static ScalingSweepTaskScheduler createStarted(\n+            SweepDelay delay,\n+            int initialThreads,\n+            Callable<SweepIterationResult> task,\n+            BooleanSupplier scalingEnabled) {\n+        ScheduledExecutorService  executorService = PTExecutors.newScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"Targeted Sweep\", true));\n+\n+        ScalingSweepTaskScheduler scheduler = new ScalingSweepTaskScheduler(\n+                executorService, delay, COOL_DOWN, task, scalingEnabled);\n+        scheduler.start(initialThreads);\n+        return scheduler;\n+    }\n+\n+    void start(int initialThreads) {\n+        for (int i = 0; i < initialThreads; i++) {\n+            increaseNumberOfTasks(INITIAL_DELAY);\n+        }\n+    }\n+\n+    private synchronized void maybeIncreaseNumberOfTasks(long pause) {\n+        lastIncreaseAttempted = Instant.now();\n+        if (cooldownPassed(lastModification)) {\n+            increaseNumberOfTasks(pause);\n+        }\n+        scheduleAfterDelay(pause);\n+    }\n+\n+    private synchronized void maybeDecreaseNumberOfTasks(long pause) {\n+        if (cooldownPassed(lastModification) && cooldownPassed(lastIncreaseAttempted)) {\n+            decreaseNumberOfTasksOrRescheduleIfLast(pause);\n+        } else {\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void increaseNumberOfTasks(long pause) {\n+        if (runningTasks < 128) {\n+            runningTasks++;\n+            lastModification = Instant.now();\n+            scheduleAfterDelay(pause);\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasksOrRescheduleIfLast(long pause) {\n+        if (runningTasks == 1) {\n+            scheduleAfterDelay(pause);\n+        } else {\n+            decreaseNumberOfTasks();\n+        }\n+    }\n+\n+    private synchronized void decreaseNumberOfTasks() {\n+        runningTasks--;\n+        lastModification = Instant.now();\n+    }\n+\n+    private void scheduleAfterDelay(long pause) {\n+        executorService.schedule(() -> retryingTask(singleIteration), pause, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void retryingTask(Callable<SweepIterationResult> task) {\n+        try {\n+            SweepIterationResult sweepResult = task.call();\n+            if (!scalingEnabled.getAsBoolean()) {\n+                scheduleAfterDelay(delay.getInitialPause());\n+            } else {\n+                long pause = delay.getNextPause(sweepResult);\n+                SweepIterationResults.caseOf(sweepResult)\n+                        .success(numThreads -> determineAction(numThreads, pause))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDYyMzUxOnYy", "diffSide": "LEFT", "path": "atlasdb-ete-tests/src/test/java/com/palantir/atlasdb/ete/LockWithoutTimelockEteTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyOToyNVrOHOs69w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNToyMDoxMVrOHPMmCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODEwMw==", "bodyText": "Let's talk about this tomorrow. I don't see how this change would affect behaviour here, but because of large internal product's lock service implementation, we do need to know if the huge requests were broken.", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485178103", "createdAt": "2020-09-08T20:29:25Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-ete-tests/src/test/java/com/palantir/atlasdb/ete/LockWithoutTimelockEteTest.java", "diffHunk": "@@ -1,37 +0,0 @@\n-/*\n- * (c) Copyright 2019 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.atlasdb.ete;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import org.junit.Test;\n-\n-import com.palantir.atlasdb.lock.LockResource;\n-\n-public class LockWithoutTimelockEteTest {\n-    private LockResource lockResource = EteSetup.createClientToSingleNode(LockResource.class);\n-\n-    @Test\n-    public void hugeV1LockSucceeds() throws InterruptedException {\n-        assertThat(lockResource.lockUsingLegacyLockApi(100, 500_000)).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5NzAzMg==", "bodyText": "Reverted the change as discussed", "url": "https://github.com/palantir/atlasdb/pull/4975#discussion_r485697032", "createdAt": "2020-09-09T15:20:11Z", "author": {"login": "gmaretic"}, "path": "atlasdb-ete-tests/src/test/java/com/palantir/atlasdb/ete/LockWithoutTimelockEteTest.java", "diffHunk": "@@ -1,37 +0,0 @@\n-/*\n- * (c) Copyright 2019 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.atlasdb.ete;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import org.junit.Test;\n-\n-import com.palantir.atlasdb.lock.LockResource;\n-\n-public class LockWithoutTimelockEteTest {\n-    private LockResource lockResource = EteSetup.createClientToSingleNode(LockResource.class);\n-\n-    @Test\n-    public void hugeV1LockSucceeds() throws InterruptedException {\n-        assertThat(lockResource.lockUsingLegacyLockApi(100, 500_000)).isTrue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODEwMw=="}, "originalCommit": {"oid": "d16ab2fa420b283a42c3b1a1758cca9c94fbb996"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2557, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}