{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMzgwNjM2", "number": 5119, "title": "[Cross Client Batching - 1d] | Modify leaderTimes api", "bodyText": "Goals (and why):\nModify signature of leaderTimes api\nImplementation Description (bullets):\n\n\nChanged signature of leaderTimes to Map<Namespace, LeaderTime> leaderTimes(AuthHeader authHeader, Set<Namespace> namespaces)\n\n\nRemoving multi getCommitTimestamps endpoint\n\n\nTesting (What was existing testing like?  What have you done to improve it?):\nModified existing tests\nConcerns (what feedback would you like?):\nN/A\nWhere should we start reviewing?:\ntimelock-api.yml, MultiClientConjureTimelockResource.java\nPriority (whenever / two weeks / yesterday):\nTomorrow EOD", "createdAt": "2020-11-18T18:14:04Z", "url": "https://github.com/palantir/atlasdb/pull/5119", "merged": true, "mergeCommit": {"oid": "b7e72e7491be2e18d3b119f3305a1d0df8694375"}, "closed": true, "closedAt": "2020-11-19T18:13:57Z", "author": {"login": "sudiksha27"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddyKSqAH2gAyNTIzMzgwNjM2OmY4N2MyNGU0NjI1MmVlNGY4ODE1NjUwMWQ4Y2Q1YWJhMmFkY2ZmOGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeGm4qAH2gAyNTIzMzgwNjM2OjljZmZiM2FkZjRiMjBjNzdiZTQyMjM5NzEzZjE4ZTA1MDZlMDYxOWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f87c24e46252ee4f88156501d8cd5aba2adcff8d", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/f87c24e46252ee4f88156501d8cd5aba2adcff8d", "committedDate": "2020-11-18T18:07:32Z", "message": "Modify leaderTimes api + remove getCommitTimestamps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad2898bcc661357253d5afd1d516365254096b3b", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/ad2898bcc661357253d5afd1d516365254096b3b", "committedDate": "2020-11-18T18:09:55Z", "message": " Fix tests + remove redundant tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64526e998aa6f23adeaa55cda45d32acd8a1f15d", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/64526e998aa6f23adeaa55cda45d32acd8a1f15d", "committedDate": "2020-11-18T18:32:33Z", "message": "Minor refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0Mjc1OTg5", "url": "https://github.com/palantir/atlasdb/pull/5119#pullrequestreview-534275989", "createdAt": "2020-11-19T10:25:49Z", "commit": {"oid": "64526e998aa6f23adeaa55cda45d32acd8a1f15d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDoyNTo0OVrOH2WUVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDoyNjo1OVrOH2WXMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1MDgwNQ==", "bodyText": "Hmm. I think this test really should target two underlying timelock services which return different times, and we should check that the wiring is correct. (This test would allow for a couple of bad behaviours!)", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r526750805", "createdAt": "2020-11-19T10:25:49Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/batch/MultiClientConjureTimelockResourceTest.java", "diffHunk": "@@ -67,59 +58,23 @@ public void before() {\n     @Test\n     public void canGetLeaderTimesForMultipleClients() {\n         when(timelockService.leaderTime()).thenReturn(Futures.immediateFuture(leaderTime));\n-        Set<String> namespaces = ImmutableSet.of(\"client1\", \"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n         assertThat(Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n                 .isEqualTo(getLeaderTimesForNamespaces(namespaces));\n     }\n \n-    @Test\n-    public void canGetCommitTimestampsForMultipleClients() {\n-        GetCommitTimestampsResponse getCommitTimestampsResponse = GetCommitTimestampsResponse.of(\n-                COMMIT_TS_LOWER_INCLUSIVE, COMMIT_TS_UPPER_INCLUSIVE, lockWatchStateUpdate);\n-\n-        when(timelockService.getCommitTimestamps(anyInt(), any()))\n-                .thenReturn(Futures.immediateFuture(getCommitTimestampsResponse));\n-\n-        Set<String> namespaces = ImmutableSet.of(\"client1\", \"client2\");\n-        assertThat(Futures.getUnchecked(\n-                        resource.getCommitTimestamps(AUTH_HEADER, getGetCommitTimestampsRequests(namespaces))))\n-                .isEqualTo(getGetCommitTimestampsResponseList(namespaces));\n-    }\n-\n     @Test\n     public void requestThrowsIfAnyQueryFails() {\n         when(timelockService.leaderTime())\n                 .thenReturn(Futures.immediateFuture(leaderTime))\n                 .thenThrow(new BlockingTimeoutException(\"\"));\n-        Set<String> namespaces = ImmutableSet.of(\"client1\", \"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n         assertThatThrownBy(() -> Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n                 .isInstanceOf(BlockingTimeoutException.class);\n     }\n \n-    private List<NamespacedGetCommitTimestampsResponse> getGetCommitTimestampsResponseList(Set<String> namespaces) {\n-        return namespaces.stream()\n-                .map(namespace -> NamespacedGetCommitTimestampsResponse.builder()\n-                        .namespace(namespace)\n-                        .inclusiveLower(COMMIT_TS_LOWER_INCLUSIVE)\n-                        .inclusiveUpper(COMMIT_TS_UPPER_INCLUSIVE)\n-                        .lockWatchUpdate(lockWatchStateUpdate)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<NamespacedGetCommitTimestampsRequest> getGetCommitTimestampsRequests(Set<String> namespaces) {\n-        return namespaces.stream()\n-                .map(namespace -> NamespacedGetCommitTimestampsRequest.builder()\n-                        .namespace(namespace)\n-                        .numTimestamps(4)\n-                        .build())\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<NamespacedLeaderTime> getLeaderTimesForNamespaces(Set<String> namespaces) {\n-        return namespaces.stream()\n-                .map(namespace -> NamespacedLeaderTime.of(namespace, leaderTime))\n-                .collect(Collectors.toList());\n+    private LeaderTimes getLeaderTimesForNamespaces(Set<Namespace> namespaces) {\n+        return LeaderTimes.of(namespaces.stream().collect(Collectors.toMap(x -> x, x -> leaderTime)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64526e998aa6f23adeaa55cda45d32acd8a1f15d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1MTUzOQ==", "bodyText": "can we just have leaderTimes? Map<Namespace, T> implies it's namespace-wise already", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r526751539", "createdAt": "2020-11-19T10:26:59Z", "author": {"login": "jeremyk-91"}, "path": "timelock-api/src/main/conjure/timelock-api.yml", "diffHunk": "@@ -110,21 +110,11 @@ types:\n       LockWatchRequest:\n         fields:\n           references: set<LockWatchReference>\n-      NamespacedLeaderTime:\n+      Namespace:\n+        alias: string\n+      LeaderTimes:\n         fields:\n-          namespace: string\n-          leaderTime: LeaderTime\n-      NamespacedGetCommitTimestampsRequest:\n-        fields:\n-          namespace: string\n-          numTimestamps: integer\n-          lastKnownVersion: optional<ConjureIdentifiedVersion>\n-      NamespacedGetCommitTimestampsResponse:\n-        fields:\n-          namespace: string\n-          inclusiveLower: Long\n-          inclusiveUpper: Long\n-          lockWatchUpdate: LockWatchStateUpdate\n+          namespaceWiseLeaderTimes: map<Namespace, LeaderTime>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64526e998aa6f23adeaa55cda45d32acd8a1f15d"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ced70611e32487dcb539d113405169705fc730e4", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/ced70611e32487dcb539d113405169705fc730e4", "committedDate": "2020-11-19T11:00:50Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0Njk5MjA5", "url": "https://github.com/palantir/atlasdb/pull/5119#pullrequestreview-534699209", "createdAt": "2020-11-19T17:46:32Z", "commit": {"oid": "ced70611e32487dcb539d113405169705fc730e4"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0NjozMlrOH2qa_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0Nzo0NVrOH2qeAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MDE5MQ==", "bodyText": "nit: just use one instance of client1? This won't really test multiple requests because the immutableset will kill off the doubles before we call resource.getLeaderTimes", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r527080191", "createdAt": "2020-11-19T17:46:32Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/batch/MultiClientConjureTimelockResourceTest.java", "diffHunk": "@@ -46,35 +51,58 @@\n     private static final RedirectRetryTargeter TARGETER =\n             RedirectRetryTargeter.create(LOCAL, ImmutableList.of(LOCAL, REMOTE));\n \n-    private AsyncTimelockService timelockService = mock(AsyncTimelockService.class);\n-    private LeaderTime leaderTime = mock(LeaderTime.class);\n+    private Map<String, AsyncTimelockService> namespaces = new HashMap();\n+    private Map<String, LeadershipId> namespaceToLeaderMap = new HashMap();\n+\n     private MultiClientConjureTimelockResource resource;\n \n     @Before\n     public void before() {\n-        resource = new MultiClientConjureTimelockResource(TARGETER, unused -> timelockService);\n+        resource = new MultiClientConjureTimelockResource(TARGETER, this::getServiceForClient);\n     }\n \n     @Test\n     public void canGetLeaderTimesForMultipleClients() {\n-        when(timelockService.leaderTime()).thenReturn(Futures.immediateFuture(leaderTime));\n-        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n-        assertThat(Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n-                .isEqualTo(getLeaderTimesForNamespaces(namespaces));\n+        Namespace client1 = Namespace.of(\"client1\");\n+        Namespace client2 = Namespace.of(\"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(client1, client1, client2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced70611e32487dcb539d113405169705fc730e4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MDk2Mg==", "bodyText": "nice!", "url": "https://github.com/palantir/atlasdb/pull/5119#discussion_r527080962", "createdAt": "2020-11-19T17:47:45Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/batch/MultiClientConjureTimelockResourceTest.java", "diffHunk": "@@ -46,35 +51,58 @@\n     private static final RedirectRetryTargeter TARGETER =\n             RedirectRetryTargeter.create(LOCAL, ImmutableList.of(LOCAL, REMOTE));\n \n-    private AsyncTimelockService timelockService = mock(AsyncTimelockService.class);\n-    private LeaderTime leaderTime = mock(LeaderTime.class);\n+    private Map<String, AsyncTimelockService> namespaces = new HashMap();\n+    private Map<String, LeadershipId> namespaceToLeaderMap = new HashMap();\n+\n     private MultiClientConjureTimelockResource resource;\n \n     @Before\n     public void before() {\n-        resource = new MultiClientConjureTimelockResource(TARGETER, unused -> timelockService);\n+        resource = new MultiClientConjureTimelockResource(TARGETER, this::getServiceForClient);\n     }\n \n     @Test\n     public void canGetLeaderTimesForMultipleClients() {\n-        when(timelockService.leaderTime()).thenReturn(Futures.immediateFuture(leaderTime));\n-        Set<Namespace> namespaces = ImmutableSet.of(Namespace.of(\"client1\"), Namespace.of(\"client2\"));\n-        assertThat(Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces)))\n-                .isEqualTo(getLeaderTimesForNamespaces(namespaces));\n+        Namespace client1 = Namespace.of(\"client1\");\n+        Namespace client2 = Namespace.of(\"client2\");\n+        Set<Namespace> namespaces = ImmutableSet.of(client1, client1, client2);\n+\n+        LeaderTimes leaderTimesResponse = Futures.getUnchecked(resource.leaderTimes(AUTH_HEADER, namespaces));\n+        Map<Namespace, LeaderTime> leaderTimes = leaderTimesResponse.getLeaderTimes();\n+\n+        // leaderTimes for namespaces are computed by their respective underlying AsyncTimelockService instances\n+        leaderTimes.forEach((namespace, leaderTime) -> {\n+            assertThat(leaderTime.id()).isEqualTo(namespaceToLeaderMap.get(namespace.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ced70611e32487dcb539d113405169705fc730e4"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cffb3adf4b20c77be42239713f18e0506e0619b", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/9cffb3adf4b20c77be42239713f18e0506e0619b", "committedDate": "2020-11-19T17:56:52Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2502, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}