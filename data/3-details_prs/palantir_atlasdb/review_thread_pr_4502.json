{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNDg2MjE4", "number": 4502, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMToyMDoyNVrODdIcOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMToyOTozNlrODdImvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODczNTkzOnYy", "diffSide": "RIGHT", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchStateUpdater.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMToyMDoyNVrOFlj3CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMTowNDozOFrOFlz4ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyOTE2MQ==", "bodyText": "By this, do we mean that we make a new updater if we fall out of the window and/or there is a leader election?", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r374929161", "createdAt": "2020-02-04T21:20:25Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchStateUpdater.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.OptionalLong;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import com.google.common.collect.RangeSet;\n+import com.palantir.lock.LockDescriptor;\n+\n+@NotThreadSafe\n+public class LockWatchStateUpdater implements LockWatchEvent.Visitor<Void> {\n+    private final RangeSet<LockDescriptor> watches;\n+    private final Map<LockDescriptor, LockWatchInfo> lockWatchState;\n+    private final Set<UUID> unmatchedOpenLocksEvents;\n+\n+    /**\n+     * LockWatchStateUpdater is a LockWatchEvent visitor that updates the set of current lock watches, the state of\n+     * specific locks, and tracks the information on encountered open locks events. It is the responsibility of the\n+     * caller to visit lock watch events in the correct order as they occurred, without skipping events.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "192c3cd5e231b3036c332428d0457e2398b073fe"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MTY1Mg==", "bodyText": "Discussed offline: Usage is once per batch of updates, so that's ok - the calling class is responsible for invalidation in the election/too-much-lag cases.", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r375191652", "createdAt": "2020-02-05T11:04:38Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchStateUpdater.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.OptionalLong;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import com.google.common.collect.RangeSet;\n+import com.palantir.lock.LockDescriptor;\n+\n+@NotThreadSafe\n+public class LockWatchStateUpdater implements LockWatchEvent.Visitor<Void> {\n+    private final RangeSet<LockDescriptor> watches;\n+    private final Map<LockDescriptor, LockWatchInfo> lockWatchState;\n+    private final Set<UUID> unmatchedOpenLocksEvents;\n+\n+    /**\n+     * LockWatchStateUpdater is a LockWatchEvent visitor that updates the set of current lock watches, the state of\n+     * specific locks, and tracks the information on encountered open locks events. It is the responsibility of the\n+     * caller to visit lock watch events in the correct order as they occurred, without skipping events.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyOTE2MQ=="}, "originalCommit": {"oid": "192c3cd5e231b3036c332428d0457e2398b073fe"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODc2Mjg2OnYy", "diffSide": "RIGHT", "path": "lock-api/src/test/java/com/palantir/lock/watch/LockWatchStateUpdaterTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMToyOTozNlrOFlkHhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxMToyNDo1NVrOFl0aRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMzM4MQ==", "bodyText": "not sure how I feel about this test, it feels dependent on the contract of RangeSet (which is that it must coalesce) rather than anything we're doing in the code", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r374933381", "createdAt": "2020-02-04T21:29:36Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/watch/LockWatchStateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+import static com.palantir.lock.watch.LockWatchInfo.State.LOCKED;\n+import static com.palantir.lock.watch.LockWatchInfo.State.UNLOCKED;\n+import static com.palantir.lock.watch.LockWatchReferences.TO_RANGES_VISITOR;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.OptionalLong;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Range;\n+import com.google.common.collect.RangeSet;\n+import com.google.common.collect.TreeRangeSet;\n+import com.palantir.lock.AtlasCellLockDescriptor;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n+\n+public class LockWatchStateUpdaterTest {\n+    private static final String TABLE_NAME = \"test.table1\";\n+    private static final byte[] ROW = {1};\n+    private static final LockWatchReference TABLE_1 = LockWatchReferences.entireTable(TABLE_NAME);\n+    private static final LockWatchReference TABLE_2 = LockWatchReferences.entireTable(\"test.table2\");\n+    private static final LockWatchReference TABLE_3 = LockWatchReferences.entireTable(\"test.table3\");\n+    private static final LockWatchReference ROW_REF = LockWatchReferences.exactRow(TABLE_NAME, ROW);\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE_NAME, ROW);\n+    private static final LockWatchEvent OPEN_LOCKS_EVENT = LockWatchOpenLocksEvent\n+            .builder(ImmutableSet.of(DESCRIPTOR), UUID.randomUUID())\n+            .build(1);\n+    private static final LockToken TOKEN = LockToken.of(UUID.randomUUID());\n+\n+    private final RangeSet<LockDescriptor> watches = TreeRangeSet.create();\n+    private final Map<LockDescriptor, LockWatchInfo> lockWatchState = new HashMap<>();\n+    private ConcurrentSkipListSet<UUID> unmatchedOpenLocksEvents = new ConcurrentSkipListSet<>();\n+    private final LockWatchStateUpdater updater = new LockWatchStateUpdater(watches, lockWatchState,\n+            unmatchedOpenLocksEvents);\n+\n+    @Test\n+    public void watchesAreUpdatedOnSingleEventWhenOpenLocksHappenedBefore() {\n+        UUID lockWatchId = UUID.randomUUID();\n+\n+        LockWatchEvent openLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(DESCRIPTOR), lockWatchId)\n+                .build(1);\n+        LockWatchEvent watchCreatedEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1, TABLE_3)), lockWatchId)\n+                .build(10);\n+\n+        openLocks.accept(updater);\n+        watchCreatedEvent.accept(updater);\n+        assertThat(watches.asRanges())\n+                .containsExactlyInAnyOrder(TABLE_1.accept(TO_RANGES_VISITOR), TABLE_3.accept(TO_RANGES_VISITOR));\n+    }\n+\n+    @Test\n+    public void watchesAreNotUpdatedOnSingleEventWhenOpenLocksHasNotHappenedWithSameId() {\n+        LockWatchEvent watchCreatedEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1, TABLE_3)), UUID.randomUUID())\n+                .build(10);\n+\n+        OPEN_LOCKS_EVENT.accept(updater);\n+        watchCreatedEvent.accept(updater);\n+        assertThat(watches.asRanges()).isEmpty();\n+    }\n+\n+    @Test\n+    public void watchesAreUpdatedOnMultipleEvents() {\n+        UUID first = UUID.randomUUID();\n+        UUID second = UUID.randomUUID();\n+\n+        LockWatchEvent firstOpenLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(DESCRIPTOR), first)\n+                .build(1);\n+        LockWatchEvent secondOpenLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(), second)\n+                .build(2);\n+\n+        LockWatchEvent firstEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1)), second).build(10);\n+        LockWatchEvent secondEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_3)), first).build(20);\n+\n+        firstOpenLocks.accept(updater);\n+        secondOpenLocks.accept(updater);\n+        firstEvent.accept(updater);\n+        secondEvent.accept(updater);\n+\n+        assertThat(watches.asRanges())\n+                .containsExactlyInAnyOrder(TABLE_1.accept(TO_RANGES_VISITOR), TABLE_3.accept(TO_RANGES_VISITOR));\n+    }\n+\n+    @Test\n+    public void overlappingWatchesAreMergedOnUpdates() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "192c3cd5e231b3036c332428d0457e2398b073fe"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMDMyNA==", "bodyText": "That's fair, but it's critical for us that re-registering watches does not blow up our ranges so I think it's fine to have this just to verify the invariant. Also, RangeSet is technically @Beta...", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r375200324", "createdAt": "2020-02-05T11:24:55Z", "author": {"login": "gmaretic"}, "path": "lock-api/src/test/java/com/palantir/lock/watch/LockWatchStateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+import static com.palantir.lock.watch.LockWatchInfo.State.LOCKED;\n+import static com.palantir.lock.watch.LockWatchInfo.State.UNLOCKED;\n+import static com.palantir.lock.watch.LockWatchReferences.TO_RANGES_VISITOR;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.OptionalLong;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Range;\n+import com.google.common.collect.RangeSet;\n+import com.google.common.collect.TreeRangeSet;\n+import com.palantir.lock.AtlasCellLockDescriptor;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n+\n+public class LockWatchStateUpdaterTest {\n+    private static final String TABLE_NAME = \"test.table1\";\n+    private static final byte[] ROW = {1};\n+    private static final LockWatchReference TABLE_1 = LockWatchReferences.entireTable(TABLE_NAME);\n+    private static final LockWatchReference TABLE_2 = LockWatchReferences.entireTable(\"test.table2\");\n+    private static final LockWatchReference TABLE_3 = LockWatchReferences.entireTable(\"test.table3\");\n+    private static final LockWatchReference ROW_REF = LockWatchReferences.exactRow(TABLE_NAME, ROW);\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE_NAME, ROW);\n+    private static final LockWatchEvent OPEN_LOCKS_EVENT = LockWatchOpenLocksEvent\n+            .builder(ImmutableSet.of(DESCRIPTOR), UUID.randomUUID())\n+            .build(1);\n+    private static final LockToken TOKEN = LockToken.of(UUID.randomUUID());\n+\n+    private final RangeSet<LockDescriptor> watches = TreeRangeSet.create();\n+    private final Map<LockDescriptor, LockWatchInfo> lockWatchState = new HashMap<>();\n+    private ConcurrentSkipListSet<UUID> unmatchedOpenLocksEvents = new ConcurrentSkipListSet<>();\n+    private final LockWatchStateUpdater updater = new LockWatchStateUpdater(watches, lockWatchState,\n+            unmatchedOpenLocksEvents);\n+\n+    @Test\n+    public void watchesAreUpdatedOnSingleEventWhenOpenLocksHappenedBefore() {\n+        UUID lockWatchId = UUID.randomUUID();\n+\n+        LockWatchEvent openLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(DESCRIPTOR), lockWatchId)\n+                .build(1);\n+        LockWatchEvent watchCreatedEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1, TABLE_3)), lockWatchId)\n+                .build(10);\n+\n+        openLocks.accept(updater);\n+        watchCreatedEvent.accept(updater);\n+        assertThat(watches.asRanges())\n+                .containsExactlyInAnyOrder(TABLE_1.accept(TO_RANGES_VISITOR), TABLE_3.accept(TO_RANGES_VISITOR));\n+    }\n+\n+    @Test\n+    public void watchesAreNotUpdatedOnSingleEventWhenOpenLocksHasNotHappenedWithSameId() {\n+        LockWatchEvent watchCreatedEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1, TABLE_3)), UUID.randomUUID())\n+                .build(10);\n+\n+        OPEN_LOCKS_EVENT.accept(updater);\n+        watchCreatedEvent.accept(updater);\n+        assertThat(watches.asRanges()).isEmpty();\n+    }\n+\n+    @Test\n+    public void watchesAreUpdatedOnMultipleEvents() {\n+        UUID first = UUID.randomUUID();\n+        UUID second = UUID.randomUUID();\n+\n+        LockWatchEvent firstOpenLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(DESCRIPTOR), first)\n+                .build(1);\n+        LockWatchEvent secondOpenLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(), second)\n+                .build(2);\n+\n+        LockWatchEvent firstEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1)), second).build(10);\n+        LockWatchEvent secondEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_3)), first).build(20);\n+\n+        firstOpenLocks.accept(updater);\n+        secondOpenLocks.accept(updater);\n+        firstEvent.accept(updater);\n+        secondEvent.accept(updater);\n+\n+        assertThat(watches.asRanges())\n+                .containsExactlyInAnyOrder(TABLE_1.accept(TO_RANGES_VISITOR), TABLE_3.accept(TO_RANGES_VISITOR));\n+    }\n+\n+    @Test\n+    public void overlappingWatchesAreMergedOnUpdates() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMzM4MQ=="}, "originalCommit": {"oid": "192c3cd5e231b3036c332428d0457e2398b073fe"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2392, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}