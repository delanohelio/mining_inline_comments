{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3OTEwNjcw", "number": 5069, "title": "Leader Election Metrics 1b: Estimate Leader Election Duration", "bodyText": "Goals (and why):\nIn addition to existing metrics, calculate the estimated leader duration\nImplementation Description (bullets):\nJavadoc explains the approach in detail. Other things to note:\n\nThe ordering of updates for the maps and creating the snapshots is selected so that the keys of upperbounds are a superset of lowerbounds\nWe do some simple trivial cleanup from the maps, but generally there shouldn't be so many leader elections to warrant too much effort here\nStill need to wire this through, but that is not relevant for the review\n\nTesting (What was existing testing like?  What have you done to improve it?):\nSome initial unit tests are there\nConcerns (what feedback would you like?):\nProbably needs some polishing, but overall I think the approach is reasonable. Would appreciate a detailed review and suggestions for additional tests.\nWhere should we start reviewing?:\nRead the Javadoc\nPriority (whenever / two weeks / yesterday):\nSoon", "createdAt": "2020-10-21T23:01:29Z", "url": "https://github.com/palantir/atlasdb/pull/5069", "merged": true, "mergeCommit": {"oid": "daa6046257439161d1d8abbdfb77c00732508e48"}, "closed": true, "closedAt": "2020-10-23T15:46:46Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUp8N0AH2gAyNTA3OTEwNjcwOmI3OTMyNjQ2ODJiYjA3NWE3YzVhNzc5ZDVkYzMzNGE0MzAyZmFkOTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVYjBOgFqTUxNTc5MjczMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b793264682bb075a7c5a779d5dc334a4302fad95", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b793264682bb075a7c5a779d5dc334a4302fad95", "committedDate": "2020-10-21T09:27:36Z", "message": "Transfer changes from other branches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee6bb046be4501552fe35f873a4fade024c877b8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ee6bb046be4501552fe35f873a4fade024c877b8", "committedDate": "2020-10-21T14:12:34Z", "message": "Pull in the right things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "committedDate": "2020-10-21T15:12:01Z", "message": "Merge branch 'develop' into le/client-i"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "committedDate": "2020-10-21T15:25:12Z", "message": "rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1f7fa37374952504467f157c810a015c2a507d3", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/d1f7fa37374952504467f157c810a015c2a507d3", "committedDate": "2020-10-21T22:53:36Z", "message": "Implementation and some tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "committedDate": "2020-10-22T08:39:58Z", "message": "Should fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c33135c2cf946bed86c415df29eab145cf3fcf5", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/1c33135c2cf946bed86c415df29eab145cf3fcf5", "committedDate": "2020-10-22T09:37:12Z", "message": "Make tests great again"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTMzNjM2", "url": "https://github.com/palantir/atlasdb/pull/5069#pullrequestreview-514533636", "createdAt": "2020-10-22T09:29:56Z", "commit": {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOToyOTo1NlrOHmY8Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTozNjowMFrOHmZL_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNjU5NQ==", "bodyText": "IMO this is pretty hard to take in. My understanding of it is as follows:\n\nLower and upper bound are referring to the temporal bounds of when A is the leader (I don't think that's really mentioned explicitly, and it's not obvious just from the text here).\nLower bound is the first successful response from leader A;\nUpper bound is the last successful request to leader A.\n\nWhile what you've said is true for a single request/response pair, it's quite unintuitive reasoning on that scale.", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510016595", "createdAt": "2020-10-22T09:29:56Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +140,129 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * Although from just one request, the lower bound is greater than the upper bound, after multiple responses that\n+     * is generally not going to be the case anymore.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAyMDYwNA==", "bodyText": "I think this is right, but was also pretty hard to reason through - I had to write it out as above to verify that this works.\nWe're definitely going to want some solid ETE tests here to make sure that this is right. Fortunately, the cost of failure here is just dodgy metrics, so an ETE test in a separate PR is fine, but we'll still want to verify this logic.", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510020604", "createdAt": "2020-10-22T09:36:00Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +140,129 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * Although from just one request, the lower bound is greater than the upper bound, after multiple responses that\n+     * is generally not going to be the case anymore.\n+     *\n+     * Ordering leaderships:\n+     * Let L_A and U_A be the lower and upper bound, respectively, of leader A, and let L_B and U_B be the respective\n+     * bounds of leader B. We distinguish 3 cases:\n+     *   1. (L_A < U_A && L_B < U_B): for both leaders there is an interval of guaranteed leadership, which by\n+     *   definitions cannot overlap. It is therefore trivial to order leadership of A and B.\n+     *   2. (w.l.o.g. L_A < U_A && L_B >= U_B):\n+     *      a) if U_B > U_A, A was the leader before B\n+     *      b) if L_B < L_A, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering\n+     *   3. (L_A >= U_A && L_B >= U_B):\n+     *      a) if U_B > L_A, A was the leader before B\n+     *      b) if U_A > L_B, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf458d26cce07fe45302d80a57a03d86bf06fd4c", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/cf458d26cce07fe45302d80a57a03d86bf06fd4c", "committedDate": "2020-10-22T14:52:48Z", "message": "Merge with develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "committedDate": "2020-10-22T16:09:08Z", "message": "Bleh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/133bfa79b08a664ddabf141187edbaa8066ccb3c", "committedDate": "2020-10-23T09:51:07Z", "message": "Cleanup, more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NTMxMDY2", "url": "https://github.com/palantir/atlasdb/pull/5069#pullrequestreview-515531066", "createdAt": "2020-10-23T10:15:18Z", "commit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMDoxNToxOFrOHnHrsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMDoyNTo0MlrOHnICDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4MjM4Ng==", "bodyText": "Can you just pair this check with the isEmpty one? e.g.\nif (sortedLongTermLeaders.isEmpty() || sortedLongTermLeaders.size()` == 1) {", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510782386", "createdAt": "2020-10-23T10:15:18Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +144,120 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * T_1 is the upper bound in the sense that if we know that A was the leader before T_1, we know for certain it was\n+     * still the leader until T_1. Similarly, T_2 is the lower bound in the sense that if A was not the leader at any\n+     * point after T_2, it was certainly the leader at T_2. This is slightly counter-intuitive with just a single\n+     * request, since T_1 < T_2, but as soon as another response is received such that T_1' > T_2, we can determine an\n+     * interval [T_2, T_1'] when A was definitely the leader. Let us denote this interval by [L_A, U_A] and call A a\n+     * long term leader.\n+     *\n+     * Last leader election:\n+     * Given that the lower and upper bound for a leader are updated with each response from that leader, it is\n+     * unlikely that any leader is not going to be a long term leader except in the initial moments after leadership\n+     * has been acquired. We will therefore observe the last two leaderships where the older leader A has had enough\n+     * data points so that L_A < U_A, while the newer leader B is allowed to not have become a long term leader yet.\n+     *\n+     * Ordering leaderships:\n+     * Let A be a long term leader and let B another leader. We distinguish 2 cases:\n+     *   1. (B is a long term leader): for both leaders there is an interval of guaranteed leadership, which by\n+     *   definition cannot overlap. It is therefore trivial to order leadership of A and B.\n+     *   2. (B is not a long term leader yet, i.e., L_B >= U_B):\n+     *      a) if U_B > U_A, A was the leader before B\n+     *      b) if L_B < L_A, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering\n+     *\n+     * Calculating the estimate:\n+     * Let A be a long term leader let L be the minimal lower bound of all leaders that became leaders after A as\n+     * described in 1) and 2b). The estimated (over-approximated) duration of the leadership election is then\n+     * given by the duration between U_A and L, since L is the latest possible moment at which another leader was\n+     * elected while U_A is the earliest moment at which A could have lost leadership. This method will always return\n+     * the duration of the most recent such interval.\n+     */\n+    public Optional<Duration> calculateLastLeaderElectionDuration() {\n+        Map<UUID, Instant> lowerBounds = ImmutableMap.copyOf(leadershipLowerBound.entrySet());\n+        Map<UUID, Instant> upperBounds = ImmutableMap.copyOf(leadershipUpperBound.entrySet());\n+\n+        Set<UUID> leaders = leadersWithBothBounds(lowerBounds, upperBounds);\n+        List<UUID> sortedLongTermLeaders = orderedLongTermLeaders(lowerBounds, upperBounds, leaders);\n+        clearOldLongTermLeaders(sortedLongTermLeaders);\n+\n+        if (sortedLongTermLeaders.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        UUID lastLongTermLeader = sortedLongTermLeaders.get(sortedLongTermLeaders.size() - 1);\n+\n+        Optional<Duration> result = durationToNextLeader(lowerBounds, upperBounds, leaders, lastLongTermLeader);\n+        if (result.isPresent()) {\n+            return result;\n+        }\n+\n+        if (sortedLongTermLeaders.size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NDcxOQ==", "bodyText": "hm - given that the second call returns at 6L, why is the expected duration not 6L -> 15L? I realise that I'm probably misunderstanding your massive and lengthy explanation above, but when laid out this way, it just seems weird", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510784719", "createdAt": "2020-10-23T10:19:24Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NTc5Mw==", "bodyText": "start of B is after that last A call, so you should make the ASCII overlap", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510785793", "createdAt": "2020-10-23T10:21:23Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NjUyMA==", "bodyText": "21 is the start of the second B call, so presumably this arrow should represent that?", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510786520", "createdAt": "2020-10-23T10:22:52Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *             <===============>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NjY3OQ==", "bodyText": "nit: LongTerm?", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510786679", "createdAt": "2020-10-23T10:23:09Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *             <===============>\n+     */\n+    @Test\n+    public void detectFreshLeaderElectionWithTwoLongTurnLeaders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4ODExMQ==", "bodyText": "I think the arrow is one short", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510788111", "createdAt": "2020-10-23T10:25:42Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *             <===============>\n+     */\n+    @Test\n+    public void detectFreshLeaderElectionWithTwoLongTurnLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(21L), Instant.ofEpochMilli(45L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *                [ B ]\n+     *             [    A    ]\n+     *             <======>\n+     */\n+    @Test\n+    public void updateOldLeaderUpperBoundWithNewRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(15L, 21L, LEADER_2),\n+                ImmutableSingleCall.of(10L, 28L, LEADER_1));\n+        assertExpectedDuration(Instant.ofEpochMilli(10L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ C ]\n+     *                         [ C ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectFirstLeaderElectionFromLongTermLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_3),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [       B       ]\n+     *                [ C ]\n+     *                      [ C ]\n+     *       <===========>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/5e99024ebe65fc2047460d8afec49fe56b96121b", "committedDate": "2020-10-23T11:10:33Z", "message": "CR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NjkxMTI1", "url": "https://github.com/palantir/atlasdb/pull/5069#pullrequestreview-515691125", "createdAt": "2020-10-23T13:56:24Z", "commit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMzo1NjoyNFrOHnO-bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNDowMTo1NlrOHnPNIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwMTg2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Let A be a long term leader let L be the minimal lower bound of all leaders that became leaders after A as\n          \n          \n            \n                 * Let A be a long term leader and let L be the minimal lower bound of all leaders that became leaders after A as", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510901868", "createdAt": "2020-10-23T13:56:24Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +144,116 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * T_1 is the upper bound in the sense that if we know that A was the leader before T_1, we know for certain it was\n+     * still the leader until T_1. Similarly, T_2 is the lower bound in the sense that if A was not the leader at any\n+     * point after T_2, it was certainly the leader at T_2. This is slightly counter-intuitive with just a single\n+     * request, since T_1 < T_2, but as soon as another response is received such that T_1' > T_2, we can determine an\n+     * interval [T_2, T_1'] when A was definitely the leader. Let us denote this interval by [L_A, U_A] and call A a\n+     * long term leader.\n+     *\n+     * Last leader election:\n+     * Given that the lower and upper bound for a leader are updated with each response from that leader, it is\n+     * unlikely that any leader is not going to be a long term leader except in the initial moments after leadership\n+     * has been acquired. We will therefore observe the last two leaderships where the older leader A has had enough\n+     * data points so that L_A < U_A, while the newer leader B is allowed to not have become a long term leader yet.\n+     *\n+     * Ordering leaderships:\n+     * Let A be a long term leader and let B another leader. We distinguish 2 cases:\n+     *   1. (B is a long term leader): for both leaders there is an interval of guaranteed leadership, which by\n+     *   definition cannot overlap. It is therefore trivial to order leadership of A and B.\n+     *   2. (B is not a long term leader yet, i.e., L_B >= U_B):\n+     *      a) if U_B > U_A, A was the leader before B\n+     *      b) if L_B < L_A, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering\n+     *\n+     * Calculating the estimate:\n+     * Let A be a long term leader let L be the minimal lower bound of all leaders that became leaders after A as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNDMzMQ==", "bodyText": "I think the theory here is that we want to have an upper bound, and what could have happened is\nT = 3, A makes request\nT = 3 + epsilon, the leadership check on timelock passes, and timelock starts running the actual code that was protected by a leader election service\nT = 3 + epsilon + mu, current timelock loses leadership / election begins\nT = 6, the response finally comes back (note: this looks spooky but is allowed)\nIn general, if you have a request running 3 to 6 and this is the last request you know about that had a leader A, you know that the election didn't begin before 3, but you don't know that the election hadn't begun at any point after 3.", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510904331", "createdAt": "2020-10-23T14:00:01Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NDcxOQ=="}, "originalCommit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNTYzMw==", "bodyText": "this is clever. Thanks a lot for the ASCII art, really helps convey what's going on", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510905633", "createdAt": "2020-10-23T14:01:56Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                  [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *                   <=========>\n+     */\n+    @Test\n+    public void detectFreshLeaderElectionWithTwoLongTurnLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(21L), Instant.ofEpochMilli(45L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *                [ B ]\n+     *             [    A    ]\n+     *             <======>\n+     */\n+    @Test\n+    public void updateOldLeaderUpperBoundWithNewRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(15L, 21L, LEADER_2),\n+                ImmutableSingleCall.of(10L, 28L, LEADER_1));\n+        assertExpectedDuration(Instant.ofEpochMilli(10L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ C ]\n+     *                         [ C ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectFirstLeaderElectionFromLongTermLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_3),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [       B       ]\n+     *                [ C ]\n+     *                      [ C ]\n+     *       <============>\n+     */\n+    @Test\n+    public void detectFirstLeaderElectionFromLongTermLeaderWithSlowRequest() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 45L, LEADER_2),\n+                ImmutableSingleCall.of(15L, 21L, LEADER_3),\n+                ImmutableSingleCall.of(28L, 36L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [        B       ]\n+     *          [ C ]\n+     *                 [ C ]\n+     */\n+    @Test\n+    public void doNotCalculateLeadershipBeforeFirstLongTermLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 36L, LEADER_2),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_3),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_3));\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isEmpty();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [        A       ]\n+     *          [ C ]\n+     *                 [ C ]\n+     *       <======>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzAzMTcz", "url": "https://github.com/palantir/atlasdb/pull/5069#pullrequestreview-515703173", "createdAt": "2020-10-23T14:09:47Z", "commit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNDowOTo0OFrOHnPhOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNDowOTo0OFrOHnPhOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkxMDc3OA==", "bodyText": "This should end at the end of B, surely", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510910778", "createdAt": "2020-10-23T14:09:48Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                  [ B ]\n+     *           <=============>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzA0MDAy", "url": "https://github.com/palantir/atlasdb/pull/5069#pullrequestreview-515704002", "createdAt": "2020-10-23T14:10:44Z", "commit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNDoxMDo0NFrOHnPj5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNDoxMDo0NFrOHnPj5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkxMTQ2MA==", "bodyText": "Could we have one for overlapping but non-consuming?\ni.e.\n[         A         ]\n               [         A        ]\n                          [         B     ]\n               <==========================>", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510911460", "createdAt": "2020-10-23T14:10:44Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                  [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a83f1aed3773999d3ec69d4aba13e829bcd9c0b", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/2a83f1aed3773999d3ec69d4aba13e829bcd9c0b", "committedDate": "2020-10-23T15:27:13Z", "message": "CR fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzkyNzMz", "url": "https://github.com/palantir/atlasdb/pull/5069#pullrequestreview-515792733", "createdAt": "2020-10-23T15:45:37Z", "commit": {"oid": "2a83f1aed3773999d3ec69d4aba13e829bcd9c0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2416, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}