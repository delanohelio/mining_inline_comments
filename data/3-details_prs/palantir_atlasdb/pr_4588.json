{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzMwNzA1", "number": 4588, "title": "Safer workflow for getting rows from CassandraKvs", "bodyText": "Goals (and why):\nThe getRows endpoint fetches all the cells (all the versions) for a given list of rows  from Cassandra if the columns are not explicitly specified. This endpoint thus causes a lot of very large reads on Cassandra when reading a list of rows from a table with many rows that are quite wide.\nInstead of reading all the cells (and all the versions of these cells) from Cassandra in one request, split the very large read query into number of serial requests with limited reads. It is maintained that all the cells are read and only (some) older versions of cells may be skipped while reading from Cassandra.\nImplementation Description (bullets):\n\nModify getRowsForSingleHost endpoint to split one very large read query into number of serial requests with limited reads.\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nTests added to verify correctness\n\nConcerns (what feedback would you like?):\n\nTuning required depending on individual deployment\nDo hit and trial in order to determine the read limit per row per request.\n\nWhere should we start reviewing?:\n\nCassandraKeyValueServiceImpl#getRowsForSingleHost\n\nPriority (whenever / two weeks / yesterday):\n\nEOD - 24 Feb", "createdAt": "2020-02-19T18:46:22Z", "url": "https://github.com/palantir/atlasdb/pull/4588", "merged": true, "mergeCommit": {"oid": "44771e7594363d986912e290b9b11684b761d797"}, "closed": true, "closedAt": "2020-02-24T16:51:43Z", "author": {"login": "sudiksha27"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGLZTIgFqTM2MTQxMTM1MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHgRzzAH2gAyMzc3MzMwNzA1OmFmZWJkZjVlYmJiOWRjMzdiMzU1ODYyZWQ4MmE0OTQzN2UxZGNjYWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDExMzUx", "url": "https://github.com/palantir/atlasdb/pull/4588#pullrequestreview-361411351", "createdAt": "2020-02-19T20:25:59Z", "commit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDoyNTo1OVrOFr2Ztw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo0NTowM1rOFsTz1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNDQwNw==", "bodyText": "this is drafts, but I would put in normal review, I'll leave the other stuff out since you have todos on that.\nTo make tests a bit more readable, we typically get rid of the cruft by way of static functions e.g.\nprivate static Cell createCell(String row, String column) { ... }\nsince the PtBytes.toBytes is not important and is just cruft", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381524407", "createdAt": "2020-02-19T20:25:59Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzQ2NQ==", "bodyText": "do you want a containsOnly? that verifies you're skipping stuff?", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381527465", "createdAt": "2020-02-19T20:32:20Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{\n+           add(PtBytes.toBytes(\"row1\"));\n+            add(PtBytes.toBytes(\"row2\"));\n+            add(PtBytes.toBytes(\"row3\"));\n+            add(PtBytes.toBytes(\"row4\"));\n+            add(PtBytes.toBytes(\"row5\"));\n+\n+        }};\n+\n+        Map<Cell, Value> result = keyValueService.getRows(tableReference, rows, ColumnSelection.all(), STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsKeys(CELL_1, CELL_2, CELL_3, CELL_4, CELL_5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODY3Ng==", "bodyText": "similarly here, it's quite hard to see what's going on here, a nice helper method such as:\nprivate static Multimap<Cell, Value> cellWithValue(Cell cell, String data, long timestamp) {\n  return ImmutableListMultimap.of(cell, Value.create(PtBytes.toBytes(data), timestamp));\n}\nNot sure whether you wanted separate put's for any particular reason, but if not, make use of the ImmutableListMultimap.Builder\ne.g.\nprivate static Value value(String data, long timestamp) { ... }\n\nImmutableListMultimap.builder()\n  .putAll(CELL, value(\"data2\", 88L))\n  .putAll(CELL_1, value(\"moreData\", 80L), value(\"moreData\", 90L)\n  .putAll(CELL_2, valueWithTimestamps(\"moreData\", 73L, 75L, 60L))\n  ...\n  build();", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381528676", "createdAt": "2020-02-19T20:34:50Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyOTY4MQ==", "bodyText": "use ImmutableList constructor: ImmutableList.of(PtBytes.toBytes(\"row1\"), ...).\nOne step further:\nprivate static Iterable<byte[]> rows(String... rowNames) {\n  return Arrays.stream(rowNames).map(PtBytes::toBytes).collect(Collectors.toList());\n}", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381529681", "createdAt": "2020-02-19T20:36:48Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMjAxOQ==", "bodyText": "what happens when this is null? how does it behave?", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381532019", "createdAt": "2020-02-19T20:41:34Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {\n+        if (columns.size() > 0) {\n+\n+            ColumnOrSuperColumn lastCol = columns.get(columns.size() - 1);\n+            Pair<byte[], Long> pair =  CassandraKeyValueServices.decompose(lastCol.getColumn().name);\n+\n+            return SlicePredicates.create(Range.of(CassandraKeyValueServices\n+                    .makeCompositeBuffer(RangeRequests.nextLexicographicName(pair.lhSide), Long.MAX_VALUE),\n+                    Range.UNBOUND_END), Limit.of(1));\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzM3Ng==", "bodyText": "should it fallback to what it was doing before?\nhow about this method return the KeyPredicate, so any null handling you have to do is within a function, if absolutely have to do any null handling.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381533376", "createdAt": "2020-02-19T20:44:27Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {\n+        if (columns.size() > 0) {\n+\n+            ColumnOrSuperColumn lastCol = columns.get(columns.size() - 1);\n+            Pair<byte[], Long> pair =  CassandraKeyValueServices.decompose(lastCol.getColumn().name);\n+\n+            return SlicePredicates.create(Range.of(CassandraKeyValueServices\n+                    .makeCompositeBuffer(RangeRequests.nextLexicographicName(pair.lhSide), Long.MAX_VALUE),\n+                    Range.UNBOUND_END), Limit.of(1));\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMjAxOQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzUwOA==", "bodyText": "the deletion at this point isn't really important, in your test you have no deletion code anyway (not that I'm asking you to do so either), should name this along the lines of \"testGetRowsDoesNotReadOldData\" or something along those lines", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381997508", "createdAt": "2020-02-20T13:29:31Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5ODAyMw==", "bodyText": "if it's alright to put it into one, then I think the latter style works quite nicely i.e. single multimap with valueWithTimestamps method.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381998023", "createdAt": "2020-02-20T13:30:28Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODY3Ng=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5ODU2MA==", "bodyText": "if I've understood correctly this should verify that the rows don't contain old timestamps?", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381998560", "createdAt": "2020-02-20T13:31:24Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{\n+           add(PtBytes.toBytes(\"row1\"));\n+            add(PtBytes.toBytes(\"row2\"));\n+            add(PtBytes.toBytes(\"row3\"));\n+            add(PtBytes.toBytes(\"row4\"));\n+            add(PtBytes.toBytes(\"row5\"));\n+\n+        }};\n+\n+        Map<Cell, Value> result = keyValueService.getRows(tableReference, rows, ColumnSelection.all(), STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsKeys(CELL_1, CELL_2, CELL_3, CELL_4, CELL_5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzQ2NQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5OTI4NQ==", "bodyText": "or better still, in order to not have to scroll up to figure out what row1 means, just use CELL.getRowName, or have the signature be Iterable<byte[]> rowNames(Cell... cells)", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381999285", "createdAt": "2020-02-20T13:32:47Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyOTY4MQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ==", "bodyText": "this feels oddly similar to translateRowsToKeyPredicates", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382001915", "createdAt": "2020-02-20T13:37:30Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMzczNQ==", "bodyText": "perhaps instead of mutating the query, how about just setting it at the bottom? it would be nice to just make a new query object each time but we probably don't want recursion here.. so need some mutation somewhere.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382003735", "createdAt": "2020-02-20T13:40:47Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDA3Nw==", "bodyText": "that way, I think you can reuse translateRowsToKeyPredicates, although I may be mistaken", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382004077", "createdAt": "2020-02-20T13:41:25Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDc4MQ==", "bodyText": "just return  Maps.transformValues(...)", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382004781", "createdAt": "2020-02-20T13:42:37Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNjIzMA==", "bodyText": "at some point, you want to comment on the optimisation is that you're doing, it's easy to get lost in CassandraKeyValueServiceImpl. If you're able to encode that in your method names, even better, but might make sense to just comment/javadoc.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382006230", "createdAt": "2020-02-20T13:45:03Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/d51118f240929ff0f28e1137dfb03c7b7a9bd666", "committedDate": "2020-02-20T13:48:03Z", "message": "Prototype"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4edea24dfd8d85378566856acaaf9f2b0d05bf9e", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/4edea24dfd8d85378566856acaaf9f2b0d05bf9e", "committedDate": "2020-02-20T13:48:03Z", "message": "Minor changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "303a3aa59a02ed5761c403c6fc47ac1877287063", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/303a3aa59a02ed5761c403c6fc47ac1877287063", "committedDate": "2020-02-20T13:48:04Z", "message": "Use multiget_multislice"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f54abfce26d407df7acdbc58a2959e152652733", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/4f54abfce26d407df7acdbc58a2959e152652733", "committedDate": "2020-02-20T13:48:04Z", "message": "Make read limit configurable + cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "452e13d3c236f846b26ddbca60680936bd8f9b9b", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/452e13d3c236f846b26ddbca60680936bd8f9b9b", "committedDate": "2020-02-20T13:48:04Z", "message": "Add todos"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/89973c53f510ea83b50253a27d8d9408518c535f", "committedDate": "2020-02-19T18:43:18Z", "message": "Add todos"}, "afterCommit": {"oid": "452e13d3c236f846b26ddbca60680936bd8f9b9b", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/452e13d3c236f846b26ddbca60680936bd8f9b9b", "committedDate": "2020-02-20T13:48:04Z", "message": "Add todos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b2bbbe52453bac03a330e046979fb939448a043", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/1b2bbbe52453bac03a330e046979fb939448a043", "committedDate": "2020-02-20T15:00:35Z", "message": "Test clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4159d42ce6e7eb478dd922243a235d2331fbbb07", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/4159d42ce6e7eb478dd922243a235d2331fbbb07", "committedDate": "2020-02-20T15:01:42Z", "message": "Bug Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4381f0f8dbdd36f96fd91e5e52aa2a18a8549948", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/4381f0f8dbdd36f96fd91e5e52aa2a18a8549948", "committedDate": "2020-02-20T16:31:25Z", "message": "Refactor | part 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc068c8ba41a0782fd631edd68764cea0b59bc8b", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/cc068c8ba41a0782fd631edd68764cea0b59bc8b", "committedDate": "2020-02-20T17:36:25Z", "message": "Refactor | credits - Felix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e381da52b91e7c24397ff47b5242c20ada6e629", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/7e381da52b91e7c24397ff47b5242c20ada6e629", "committedDate": "2020-02-20T17:38:33Z", "message": "Minor refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8046d3f51106b1002c3727fd5fe3590b33e16736", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/8046d3f51106b1002c3727fd5fe3590b33e16736", "committedDate": "2020-02-20T17:42:19Z", "message": "Bug fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMTU1NTg3", "url": "https://github.com/palantir/atlasdb/pull/4588#pullrequestreview-362155587", "createdAt": "2020-02-20T19:02:43Z", "commit": {"oid": "8046d3f51106b1002c3727fd5fe3590b33e16736"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOTowMjo0M1rOFsfchQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOTowMjo0M1rOFsfchQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Njg2OQ==", "bodyText": "To be modified", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382196869", "createdAt": "2020-02-20T19:02:43Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java", "diffHunk": "@@ -64,6 +64,8 @@\n     // TODO (jkong): Review this limit, it seems like we are making very big requests to Cassandra even at this value\n     public static final int DEFAULT_SINGLE_QUERY_LOAD_BATCH_LIMIT = 50_000;\n \n+    public static final int DEFAULT_READ_LIMIT_PER_ROW = 200;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8046d3f51106b1002c3727fd5fe3590b33e16736"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3b709048584523bf0e3282ed2441596ff6f70ab", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/a3b709048584523bf0e3282ed2441596ff6f70ab", "committedDate": "2020-02-21T12:48:12Z", "message": "Remove unnecessary change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a88bfcb257f4a65e81b70c6422c760fefc1f158", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/9a88bfcb257f4a65e81b70c6422c760fefc1f158", "committedDate": "2020-02-21T17:02:40Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1531d39d1691d675a73607367f6412a07c1161e", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/b1531d39d1691d675a73607367f6412a07c1161e", "committedDate": "2020-02-21T17:06:56Z", "message": "Modify read limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1f2bd4f9d7140bfa84b335df3c9e5eed45d4cf2", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/d1f2bd4f9d7140bfa84b335df3c9e5eed45d4cf2", "committedDate": "2020-02-21T18:16:48Z", "message": "Test added"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d83d0b4745028333f76c40566f673e74ce0d733", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/3d83d0b4745028333f76c40566f673e74ce0d733", "committedDate": "2020-02-21T18:30:15Z", "message": "Minor test refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34128de63695be16d801bcfcfb4fcb8564836ce9", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/34128de63695be16d801bcfcfb4fcb8564836ce9", "committedDate": "2020-02-21T18:30:15Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/b4925c0ec513fd964411d9f6d3668f62c87cb989", "committedDate": "2020-02-21T18:52:58Z", "message": "Update pr-4588.v2.yml"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDYxNDI3", "url": "https://github.com/palantir/atlasdb/pull/4588#pullrequestreview-363461427", "createdAt": "2020-02-24T15:11:57Z", "commit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxMTo1N1rOFtkHyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0NjozOVrOFtlfJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjA1Ng==", "bodyText": "This method is actually fetching the values as well, not just the cells. I would name it something like getAllCellsForRows", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383322056", "createdAt": "2020-02-24T15:11:57Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNTA2Mw==", "bodyText": "as above, I'd prefer get instead of fetch because we are getting the values. Strictly speaking it should be getForCellsForKeyPredicates but I find that a bit clumsy, so would be ok with just changing the first word.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383325063", "createdAt": "2020-02-24T15:16:54Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjQyNg==", "bodyText": "nit: ... + \" cells)\"; rather than two separate strings", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383326426", "createdAt": "2020-02-24T15:19:05Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} starting at timestamp {} on {} \"\n+                                            + \"as part of fetching cells for key predicates.\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+\n+                        return Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        return \"multiget_multislice(\" + host + \", \" + tableRef +\n+                                + query.size() + \" cells\" + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjcxMQ==", "bodyText": "And we probably want a comma before saying the number of cells. The idea is to get something like multiget_multislice(host, table, 1000 cells)", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383326711", "createdAt": "2020-02-24T15:19:34Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} starting at timestamp {} on {} \"\n+                                            + \"as part of fetching cells for key predicates.\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+\n+                        return Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        return \"multiget_multislice(\" + host + \", \" + tableRef +\n+                                + query.size() + \" cells\" + \")\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjQyNg=="}, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0MTI2OQ==", "bodyText": "Let's move this to the runtime config, so it can be reloaded more easily.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383341269", "createdAt": "2020-02-24T15:41:50Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java", "diffHunk": "@@ -290,6 +290,11 @@ default int rangesConcurrency() {\n         return 32;\n     }\n \n+    @Value.Default\n+    default int fetchReadLimitPerRow() {\n+        return CassandraConstants.DEFAULT_READ_LIMIT_PER_ROW;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0NDQyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();\n          \n      \n    \n    \n  \n\nIt's unused.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383344423", "createdAt": "2020-02-24T15:46:39Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +306,66 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRows_highlyVersionedCells() {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+\n+        byte[] data = PtBytes.toBytes(\"data\");\n+\n+        Cell CELL_WITH_VERSIONS = Cell.create(row(1), column(1));\n+        Cell CELL_WITH_SAME_ROW = Cell.create(row(1), column(2));\n+\n+        ImmutableListMultimap<Cell, Value> tableValues = ImmutableListMultimap.<Cell, Value>builder()\n+                .putAll(CELL_WITH_VERSIONS, valueWithNumberOfTimestamps(data, 250L))\n+                .putAll(CELL_WITH_SAME_ROW, valueWithNumberOfTimestamps(data, 200L))\n+                .build();\n+\n+        keyValueService.putWithTimestamps(tableReference, tableValues);\n+\n+        Map<Cell, Value> result = keyValueService.getRows(\n+                tableReference,\n+                ImmutableList.of(CELL_WITH_VERSIONS.getRowName(), CELL_WITH_SAME_ROW.getRowName()),\n+                ColumnSelection.all(),\n+                STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsOnly(\n+                entry(CELL_WITH_VERSIONS, Value.create(data, 250L)),\n+                entry(CELL_WITH_SAME_ROW, Value.create(data, 200L)));\n+    }\n+\n+    @Test\n+    public void testGetRows_manyColumnRows() {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+\n+        byte[] data = PtBytes.toBytes(\"data\");\n+\n+        ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "205a7246f2f210d37873e62ef149c57c92079daa", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/205a7246f2f210d37873e62ef149c57c92079daa", "committedDate": "2020-02-24T16:26:23Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNTI0OTMx", "url": "https://github.com/palantir/atlasdb/pull/4588#pullrequestreview-363524931", "createdAt": "2020-02-24T16:29:35Z", "commit": {"oid": "205a7246f2f210d37873e62ef149c57c92079daa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdbe833301e3f4ecd681edb3b93fd87bcadba41c", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/fdbe833301e3f4ecd681edb3b93fd87bcadba41c", "committedDate": "2020-02-24T16:38:01Z", "message": "Update pr-4588.v2.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afebdf5ebbb9dc37b355862ed82a49437e1dccab", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/afebdf5ebbb9dc37b355862ed82a49437e1dccab", "committedDate": "2020-02-24T16:39:58Z", "message": "Checkstyles"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2271, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}