{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MDIzMDcz", "number": 4692, "title": "[Timelock Partitioning] Test Switching Between SL and Batched SL", "bodyText": "Goals (and why):\nTest that it is safe to switch to using batched single leader as a runtime change.\nImplementation Description (bullets):\n\nAllow to switch between the two settings at the TestableTimelockServer level.\nTest switching the behaviour at one node at a time, forcing a leader election each time and verifying that sequence numbers are consistent both for the old and the new acceptor clients.\n\nPaired with @jeremyk-91 on this", "createdAt": "2020-04-01T14:14:13Z", "url": "https://github.com/palantir/atlasdb/pull/4692", "merged": true, "mergeCommit": {"oid": "58db14ceeedc9feb51ada1e6229f2b07459ac112"}, "closed": true, "closedAt": "2020-04-02T11:19:03Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTYPD-gH2gAyMzk3MDIzMDczOmQ5NjgyODRiNDkxZjc3MmI5NWExOGI4M2VmZmUyNTc4Nzc3YWQ4NGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTcPuvAFqTM4NTY0NTQwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d968284b491f772b95a18b83effe2578777ad84b", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/d968284b491f772b95a18b83effe2578777ad84b", "committedDate": "2020-04-01T14:04:49Z", "message": "Add tests for migrating between single leader and batched single leader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/701a376e3057f915a8b253bd5e8b104ed5d8b2ad", "committedDate": "2020-04-01T14:17:06Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NjQ1NDAz", "url": "https://github.com/palantir/atlasdb/pull/4692#pullrequestreview-385645403", "createdAt": "2020-04-01T14:33:21Z", "commit": {"oid": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDozMzoyMlrOF_DjhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxODo0NTowM1rOF_N41g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2Mjg1Mw==", "bodyText": "Eh... not really a fan of this, but I guess the alternative is adding another mode to install config, and we want this to be runtime configurable. I wouldn't block on this, though maybe we should add a TODO to consider going via runtime configuration once this becomes available.", "url": "https://github.com/palantir/atlasdb/pull/4692#discussion_r401662853", "createdAt": "2020-04-01T14:33:22Z", "author": {"login": "jeremyk-91"}, "path": "timelock-server/src/testCommon/java/com/palantir/atlasdb/timelock/TestableTimelockServer.java", "diffHunk": "@@ -77,9 +81,24 @@ void start() {\n         serverHolder.start();\n     }\n \n+    void startUsingBatchedSingleLeader() {\n+        switchToBatched = true;\n+    }\n+\n+    void stopUsingBatchedSingleLeader() {\n+        switchToBatched = false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzMjE1MA==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/palantir/atlasdb/pull/4692#discussion_r401832150", "createdAt": "2020-04-01T18:45:03Z", "author": {"login": "jeremyk-91"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/SingleLeaderMultiNodePaxosTimeLockIntegrationTest.java", "diffHunk": "@@ -84,4 +98,61 @@ public void noConflictIfLeaderAndNonLeadersSeparatelyInitializeClient() {\n         long ts2 = namespace.getFreshTimestamp();\n         assertThat(ts1).isLessThan(ts2);\n     }\n+\n+    @Test\n+    public void migrationToBatchedSingleLeaderHasConsistentSequenceNumbers() {\n+        NamespacedClients client = cluster.clientForRandomNamespace().throughWireMockProxy();\n+        cluster.waitUntilAllServersOnlineAndReadyToServeNamespaces(ImmutableList.of(client.namespace()));\n+\n+        List<Long> sequenceNumbers = new ArrayList<>();\n+\n+        for (TestableTimelockServer server : cluster.servers()) {\n+            server.startUsingBatchedSingleLeader();\n+            cluster.failoverToNewLeader(client.namespace());\n+            long sequenceForBatchedEndpoint = getSequenceForServerUsingBatchedEndpoint(server);\n+            long sequenceForOldEndpoint = getSequenceForServerUsingOldEndpoint(server);\n+            assertThat(sequenceForBatchedEndpoint).isLessThanOrEqualTo(sequenceForOldEndpoint);\n+            sequenceNumbers.add(sequenceForBatchedEndpoint);\n+        }\n+\n+        assertThat(sequenceNumbers).isSorted();\n+        assertThat(ImmutableSet.copyOf(sequenceNumbers)).hasSameSizeAs(sequenceNumbers);\n+    }\n+\n+    @Test\n+    public void reverseMigrationFromBatchedSingleLeaderHasConsistentSequenceNumbers() {\n+        NamespacedClients client = cluster.clientForRandomNamespace().throughWireMockProxy();\n+        cluster.waitUntilAllServersOnlineAndReadyToServeNamespaces(ImmutableList.of(client.namespace()));\n+        cluster.servers().forEach(TestableTimelockServer::startUsingBatchedSingleLeader);\n+        List<Long> sequenceNumbers = new ArrayList<>();\n+\n+        for (TestableTimelockServer server : cluster.servers()) {\n+            server.stopUsingBatchedSingleLeader();\n+            cluster.failoverToNewLeader(client.namespace());\n+            long sequenceForBatchedEndpoint = getSequenceForServerUsingBatchedEndpoint(server);\n+            long sequenceForOldEndpoint = getSequenceForServerUsingOldEndpoint(server);\n+            assertThat(sequenceForBatchedEndpoint).isLessThanOrEqualTo(sequenceForOldEndpoint);\n+            sequenceNumbers.add(sequenceForBatchedEndpoint);\n+        }\n+\n+        assertThat(sequenceNumbers).isSorted();\n+        assertThat(ImmutableSet.copyOf(sequenceNumbers)).hasSameSizeAs(sequenceNumbers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3040, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}