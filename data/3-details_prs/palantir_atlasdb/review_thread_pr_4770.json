{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NjEwNjUy", "number": 4770, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo0NTozNVrOD8kFJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo0NTozNVrOD8kFJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODMyMjk1OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo0NTozNVrOGVlM_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1OTozNlrOGVlwUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4MjgxNQ==", "bodyText": "/**\n   * Discards any cached values for the {@code keys}. The behavior of this operation is undefined\n   * for an entry that is being loaded (or reloaded) and is otherwise not present.\n   *\n   * @param keys the keys whose associated values are to be removed\n   * @throws NullPointerException if the specified collection is null or contains a null element\n   */\n  void invalidateAll(@NonNull Iterable<?> keys);\n\nInvalidating something that's not there looks like it could end up either way. It's a bit nasty, but should we take a read-write lock?", "url": "https://github.com/palantir/atlasdb/pull/4770#discussion_r425282815", "createdAt": "2020-05-14T16:45:35Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -51,7 +52,17 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                     return cache;\n                 });\n \n-        return tableRef -> sweepStrategySupplierLoadingCache.get().get(tableRef);\n+        return new SweepStrategyManager() {\n+            @Override\n+            public SweepStrategy get(TableReference tableRef) {\n+                return sweepStrategySupplierLoadingCache.get().get(tableRef);\n+            }\n+\n+            @Override\n+            public void invalidateCaches(Set<TableReference> tableRefs) {\n+                sweepStrategySupplierLoadingCache.get().invalidateAll(tableRefs);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "beaaf2ec3a71738aedcd1b7df7ae4aeb94f0724d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5MTg1OQ==", "bodyText": "Discussed offline: The \"undefined-ness\" here just means that load and invalidate could race and end up either way. This is fine for the internal use case we have planned here.", "url": "https://github.com/palantir/atlasdb/pull/4770#discussion_r425291859", "createdAt": "2020-05-14T16:59:36Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -51,7 +52,17 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                     return cache;\n                 });\n \n-        return tableRef -> sweepStrategySupplierLoadingCache.get().get(tableRef);\n+        return new SweepStrategyManager() {\n+            @Override\n+            public SweepStrategy get(TableReference tableRef) {\n+                return sweepStrategySupplierLoadingCache.get().get(tableRef);\n+            }\n+\n+            @Override\n+            public void invalidateCaches(Set<TableReference> tableRefs) {\n+                sweepStrategySupplierLoadingCache.get().invalidateAll(tableRefs);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4MjgxNQ=="}, "originalCommit": {"oid": "beaaf2ec3a71738aedcd1b7df7ae4aeb94f0724d"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2841, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}