{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4Mzk0NzU5", "number": 4592, "title": "[LW] Snapshot Updates", "bodyText": "Goals (and why):\nThis PR reworks lock watch updates and registration, to avoid the awkward workflow of having to re-register lock watches every time we fall behind. In addition, lock watch registration is calculated in a similar way, removing the need for separate open locks and lock watch registered events and simplifying client side logic.\nImplementation Description (bullets):\n\nLockWatchStateUpdate was completely reworked: there are now three types of updates\n\nSuccess: if we are able to get all events from last known version, which includes the list of events\nSnapshot: if we are not able to get events from last known version, which includes references of current watches and currently held locks that are watched\nFailed: if we are unable to calculate the snapshot\n\n\n\nAdditionally, OptionalLong.empty() now really stands for unknown version, so the responses return a long instead (-1 means log is empty).\n\nLockWatchCreatedEvent now includes references that were added (as already watched references are filtered out), as well as the set of all currently held locks matching those watches\nLockWatchingServiceImpl now tracks both lock watch references and ranges to better enable the above workflow\nRemoved LockWatchStateUpdater as we moved away from that approach and required some effort to reflect the changes\nSimilarly removed the implementation of LockWatchTestingService as it wasn't trivial to fix, but did not remove it altogether as it will be useful in the future.\n\nTesting (What was existing testing like?  What have you done to improve it?):\nFixed existing tests, and added some new tests for the lock watch log. The added tests are not very exhaustive, so if you have concerns, open to elaborating them.\nConcerns (what feedback would you like?):\nOne point of contention is that it is possible (although quite unreasonable) that the creation and therefore logging of the lock watch created event fails. In this case, the lock watch will still be updated, but there will never be a corresponding event. Consequently, further lock watch creation requests will not log it either because the watches will be registered already. This is fine, as we can always request a snapshot though.\nWhere should we start reviewing?:\nLockEventLogImpl?\nPriority (whenever / two weeks / yesterday):\nNext week. I suggest you look at it first, and then we can pair on any questions, say Wednesday or earlier?", "createdAt": "2020-02-21T17:37:50Z", "url": "https://github.com/palantir/atlasdb/pull/4592", "merged": true, "mergeCommit": {"oid": "91a8b6fb99e1c84f63069f639bb607965814da6e"}, "closed": true, "closedAt": "2020-02-26T10:07:01Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGIxlvAH2gAyMzc4Mzk0NzU5Ojg3NDBhYjliMGViOGU4ZGFmNGQyZDgxNTIyMzE3MzhkMDdkNDI0OGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcH2yc-AFqTM2NDM2Mzg4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8740ab9b0eb8e8daf4d2d8152231738d07d4248e", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/8740ab9b0eb8e8daf4d2d8152231738d07d4248e", "committedDate": "2020-02-20T10:43:02Z", "message": "Be better, one day at a time. Also fix nasty concurrency issue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c3a9d273d2ff4ec589001af51cb408ed67b14fa", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/2c3a9d273d2ff4ec589001af51cb408ed67b14fa", "committedDate": "2020-02-21T16:58:50Z", "message": "Rework lock watch updates and registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d311fef3558808de8fa7bf90975ff50d3b7115d7", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/d311fef3558808de8fa7bf90975ff50d3b7115d7", "committedDate": "2020-02-24T10:46:42Z", "message": "Merge with develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "121eada2e9528cbedc9c694d7067a0d8eea5421a", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/121eada2e9528cbedc9c694d7067a0d8eea5421a", "committedDate": "2020-02-24T11:34:03Z", "message": "Do not filter unlocks for replayer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/413cc995a5ed5ff3de45629bf34f778e663e3be1", "committedDate": "2020-02-24T11:44:02Z", "message": "Add test for snapshot reflecting events logged during open locks calculation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MjA0MTE2", "url": "https://github.com/palantir/atlasdb/pull/4592#pullrequestreview-364204116", "createdAt": "2020-02-25T14:55:04Z", "commit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTowNVrOFuJLvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNTowODo0OFrOFuJwXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTI3OA==", "bodyText": "Ideally would like some JavaDoc on what the updates mean here (success = you're current, snapshot = you're behind but here's the state of the world, failed = I couldn't get you a state of the world).", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383929278", "createdAt": "2020-02-25T14:55:05Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java", "diffHunk": "@@ -17,53 +17,96 @@\n package com.palantir.lock.watch;\n \n import java.util.List;\n-import java.util.OptionalLong;\n+import java.util.Set;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.google.common.collect.ImmutableList;\n-import com.palantir.logsafe.Preconditions;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n \n-@Value.Immutable\n-@Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n-@JsonSerialize(as = ImmutableLockWatchStateUpdate.class)\n-@JsonDeserialize(as = ImmutableLockWatchStateUpdate.class)\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+@JsonSubTypes({\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Failed.class, name = LockWatchStateUpdate.Failed.TYPE),\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Success.class, name = LockWatchStateUpdate.Success.TYPE),\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Snapshot.class, name = LockWatchStateUpdate.Snapshot.TYPE)})\n public interface LockWatchStateUpdate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDc4NQ==", "bodyText": "nit: just call lastVersion() here?", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383930785", "createdAt": "2020-02-25T14:57:13Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -74,21 +83,23 @@ public synchronized void add(LockWatchEvent.Builder eventBuilder) {\n      *      this method, that is no longer the case when the method returns.\n      */\n     public Optional<List<LockWatchEvent>> getFromVersion(long version) {\n-        long lastWrittenSequence = nextSequence - 1;\n+        return getFromTo(version, nextSequence - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjQ4OA==", "bodyText": "please use heldLocksCollection or locksCollection, HeldLocks is a different object which made me find this section a bit confusing", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383932488", "createdAt": "2020-02-25T14:59:32Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java", "diffHunk": "@@ -16,38 +16,94 @@\n \n package com.palantir.atlasdb.timelock.lock.watch;\n \n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n import java.util.OptionalLong;\n import java.util.Set;\n import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n+import com.google.common.collect.RangeSet;\n+import com.palantir.atlasdb.timelock.lock.AsyncLock;\n+import com.palantir.atlasdb.timelock.lock.HeldLocksCollection;\n import com.palantir.lock.LockDescriptor;\n import com.palantir.lock.v2.LockToken;\n import com.palantir.lock.watch.LockEvent;\n import com.palantir.lock.watch.LockWatchCreatedEvent;\n import com.palantir.lock.watch.LockWatchEvent;\n-import com.palantir.lock.watch.LockWatchOpenLocksEvent;\n-import com.palantir.lock.watch.LockWatchRequest;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n import com.palantir.lock.watch.LockWatchStateUpdate;\n import com.palantir.lock.watch.UnlockEvent;\n \n public class LockEventLogImpl implements LockEventLog {\n-    private final UUID leaderId = UUID.randomUUID();\n+    private final UUID logId = UUID.randomUUID();\n     private final ArrayLockEventSlidingWindow slidingWindow = new ArrayLockEventSlidingWindow(1000);\n+    private final Supplier<LockWatches> watchesSupplier;\n+    private final HeldLocksCollection heldLocks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzODY1Mw==", "bodyText": "nice!", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383938653", "createdAt": "2020-02-25T15:08:48Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImplTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.OptionalLong;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.RangeSet;\n+import com.google.common.collect.TreeRangeSet;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.watch.LockWatchReferenceUtils;\n+import com.palantir.atlasdb.timelock.lock.AsyncLock;\n+import com.palantir.atlasdb.timelock.lock.ExclusiveLock;\n+import com.palantir.atlasdb.timelock.lock.HeldLocks;\n+import com.palantir.atlasdb.timelock.lock.HeldLocksCollection;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+public class LockEventLogImplTest {\n+    private final AtomicReference<LockWatches> lockWatches = new AtomicReference<>(LockWatches.create());\n+    private final HeldLocksCollection heldLocksCollection = mock(HeldLocksCollection.class);\n+    private final HeldLocks heldLocks = mock(HeldLocks.class);\n+    private final LockEventLog log = new LockEventLogImpl(lockWatches::get, heldLocksCollection);\n+\n+    private static final TableReference TABLE_REF = TableReference.createFromFullyQualifiedName(\"test.table\");\n+    private static final String TABLE = TABLE_REF.getQualifiedName();\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"1\"));\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"2\"));\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"3\"));\n+    private static final AsyncLock LOCK_2 = new ExclusiveLock(DESCRIPTOR_2);\n+    private static final AsyncLock LOCK_3 = new ExclusiveLock(DESCRIPTOR_3);\n+    private static final LockToken TOKEN = LockToken.of(UUID.randomUUID());\n+\n+    @Before\n+    public void setupMocks() {\n+        when(heldLocks.getLocks()).thenReturn(ImmutableSet.of(LOCK_2, LOCK_3));\n+        when(heldLocks.getToken()).thenReturn(TOKEN);\n+        when(heldLocksCollection.locksHeld()).thenReturn(ImmutableSet.of(heldLocks));\n+    }\n+\n+    @Test\n+    public void lockUpdateTest() {\n+        ImmutableSet<LockDescriptor> locks = ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2);\n+        log.logLock(locks, TOKEN);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(LockEvent.builder(locks, TOKEN).build(0L));\n+    }\n+\n+    @Test\n+    public void unlockUpdateTest() {\n+        ImmutableSet<LockDescriptor> locks = ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2);\n+        log.logUnlock(locks);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(UnlockEvent.builder(locks).build(0L));\n+    }\n+\n+    @Test\n+    public void createLockWatchUpdateTest() {\n+        LockWatchReference secondRowReference = LockWatchReferenceUtils.rowPrefix(TABLE_REF, PtBytes.toBytes(\"2\"));\n+        LockWatches newWatches = createWatchesFor(secondRowReference);\n+        log.logLockWatchCreated(newWatches);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(\n+                        newWatches.references(),\n+                        ImmutableSet.of(DESCRIPTOR_2))\n+                        .build(0L));\n+    }\n+\n+    @Test\n+    public void noKnownVersionReturnsSnapshotContainingCurrentMatchingLocks() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.empty());\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(-1L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void snapshotIgnoresPreviousLogEntriesInLocksCalculation() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        log.logLock(ImmutableSet.of(DESCRIPTOR), TOKEN);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.empty());\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(0L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void requestForTheFutureReturnsSnapshot() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(100L));\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(-1L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void snapshotReflectsEventsOcurringDuringOpenLocksCalculation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd8d27ea941e103c42de38676dc595328baabdc", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/5cd8d27ea941e103c42de38676dc595328baabdc", "committedDate": "2020-02-25T16:42:54Z", "message": "Address CR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzYzODg3", "url": "https://github.com/palantir/atlasdb/pull/4592#pullrequestreview-364363887", "createdAt": "2020-02-25T18:53:21Z", "commit": {"oid": "5cd8d27ea941e103c42de38676dc595328baabdc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MzoyMlrOFuRDtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MzoyMlrOFuRDtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1ODI5Mw==", "bodyText": "yep, this is exactly what I was looking for. Thanks!", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r384058293", "createdAt": "2020-02-25T18:53:22Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockWatchingServiceImplTest.java", "diffHunk": "@@ -105,6 +105,29 @@ public void registeringWatchWithWiderScopeLogsAlreadyWatchedLocksAgain() {\n         assertLoggedEvents(expectedEvents);\n     }\n \n+    @Test\n+    public void registeringWatchWithOverlappingScopeLogsAlreadyWatchedLocksInScopeAgain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cd8d27ea941e103c42de38676dc595328baabdc"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2276, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}