{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDgwMjQy", "number": 4623, "title": "[Timelock Partitioning] Part 52: ManualBatchingLeaderPinger", "bodyText": "Goals (and why):\nIn LEADER_PER_CLIENT mode, each namespace has its own LeaderElectionService and at least one AwaitingLeadershipProxy, which means that each LeaderElectionService tries to ping nodes for the leader.\nI had previously put in an autobatcher, but the batches were relatively small, and we were pinging far more than the default 20 times a second (ping rate 50ms). In addition there is no benefit in doing so.\nInstead, you register your desire to check leadership, and then there is a single guava Service per host that will ping the node with all registered clients every pingRate. This is because there is no additional benefit to checking  more often but with a different subset of clients.\nImplementation Description (bullets):\nTesting (What was existing testing like?  What have you done to improve it?):\nConcerns (what feedback would you like?):\nIn the steady state, you're sending over the same amount of bytes - the set of clients you want to check leadership for - 20 times a second. Could consider doing something similar to the BatchingPaxosLatestSequenceCache, where instead you send some token that represents your view of the cache at a particular time, and save on the bytes transferred etc.\nConsidering that the cache itself gets way more requests per second and we're still not seeing amazing perf just yet, it's probably worth looking there first.\nWhere should we start reviewing?:\n\nManualBatchingPingableLeader\nManualBatchingPingableLeaderTest\nAutobatchingPingableLeaderFactory\nPriority (whenever / two weeks / yesterday):\nASAP please.", "createdAt": "2020-03-02T16:26:45Z", "url": "https://github.com/palantir/atlasdb/pull/4623", "merged": true, "mergeCommit": {"oid": "a302b3461c2f470d061e264d5970f3a703841925"}, "closed": true, "closedAt": "2020-03-03T14:52:04Z", "author": {"login": "felixdesouza"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJsZjWAH2gAyMzgyNDgwMjQyOjRhM2M3NTdjMjIzMTU4ZWM1NWQ2Y2FkNjM3ZDBiMmE5Yzg2YWQ2MTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKDWgCgFqTM2ODAzMjc0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4a3c757c223158ec55d6cad637d0b2a9c86ad615", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/4a3c757c223158ec55d6cad637d0b2a9c86ad615", "committedDate": "2020-03-02T11:55:08Z", "message": "Put exceptions in the correct place for logs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "281395819e2d5838a029d04a7ef0b75ca5f90816", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/281395819e2d5838a029d04a7ef0b75ca5f90816", "committedDate": "2020-03-02T11:55:09Z", "message": "Don't spin up a new thread just so we can have timeouts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90465fa78104678c80d2d9176d3f4af9061c1005", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/90465fa78104678c80d2d9176d3f4af9061c1005", "committedDate": "2020-03-02T11:55:38Z", "message": "Try bounded leader pinger."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "653ce0cbb504272b5ae53ac35f1bf77ba13a3f8f", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/653ce0cbb504272b5ae53ac35f1bf77ba13a3f8f", "committedDate": "2020-03-02T11:55:39Z", "message": "Actually wire in the ping rate."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4eb5ace6b34c1b3d57f3b6ec9f55508cf6cad0", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/7f4eb5ace6b34c1b3d57f3b6ec9f55508cf6cad0", "committedDate": "2020-03-02T11:55:39Z", "message": "Log when the pinger itself times out, and also make sure the timeout logic is correct."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad45f6fa29a4ba1954baf05e54a32a4105554ba", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/0ad45f6fa29a4ba1954baf05e54a32a4105554ba", "committedDate": "2020-03-02T15:18:21Z", "message": "Update comments and log lines."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbe2f35dc6b93dc6d38f85c48016107b397071d3", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/fbe2f35dc6b93dc6d38f85c48016107b397071d3", "committedDate": "2020-03-02T16:12:19Z", "message": "Remove tag from testing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/7f0f5e760a824e320d2cc346a65ff498b806f78d", "committedDate": "2020-03-02T16:12:48Z", "message": "Add tests for ManualBatchingPingableLeader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MzU3MjY5", "url": "https://github.com/palantir/atlasdb/pull/4623#pullrequestreview-367357269", "createdAt": "2020-03-02T16:50:07Z", "commit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjo1MDowOFrOFwnCGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjo1NToxMVrOFwnOyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxNTQ4MA==", "bodyText": "nit: you repeated not in this sentence: to check whether or not the remote client is the leader or not", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386515480", "createdAt": "2020-03-02T16:50:08Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxNjgwNQ==", "bodyText": "nit: generally this comment is hard to read (all one sentence and not much punctuation).", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386516805", "createdAt": "2020-03-02T16:52:05Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not\n+        // since there is a case where we'll miss the window, we must wait until the client has been registered and\n+        // been included in an existing batch before reading from the in memory state\n+        // wait up to leaderPingResponseRate each time until it has been included and requested in a batch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxODczMQ==", "bodyText": "nit: the first line of the comment reads as if it is a separate sentence but its adjacency to the rest of the comment makes it feel like it should be connected to the rest (thus not making much sense)", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386518731", "createdAt": "2020-03-02T16:55:11Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not\n+        // since there is a case where we'll miss the window, we must wait until the client has been registered and\n+        // been included in an existing batch before reading from the in memory state\n+        // wait up to leaderPingResponseRate each time until it has been included and requested in a batch\n+        Instant requestTime = Instant.now();\n+\n+        return FluentFuture.from(hasProcessedFirstRequest.computeIfAbsent(client, $ -> SettableFuture.create()))\n+                .transform(\n+                        // this will never be null, since we waited for our request to be processed at least once\n+                        // semantic difference here is that values are effectively cached for leaderPingResponseWait\n+                        // in the event that things are not good, but in the bigger picture these *should* be\n+                        // equivalent.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDY3NzYy", "url": "https://github.com/palantir/atlasdb/pull/4623#pullrequestreview-367467762", "createdAt": "2020-03-02T19:31:25Z", "commit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTozMToyNVrOFwsaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTo0ODowNFrOFws60Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMzYyNw==", "bodyText": "checking: safe because of guarantees of the guava Service class, right?", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386603627", "createdAt": "2020-03-02T19:31:25Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManualBatchingPingableLeader.class);\n+\n+    private final LeaderPingerContext<BatchPingableLeader> remoteClient;\n+    private final Duration leaderPingRate;\n+    private final Duration leaderPingResponseWait;\n+    private final UUID nodeUuid;\n+\n+    private final Map<Client, SettableFuture<Void>> hasProcessedFirstRequest = Maps.newConcurrentMap();\n+    private final AtomicReference<LastResult> lastResult = new AtomicReference<>();\n+    private final Histogram histogram;\n+\n+    ManualBatchingPingableLeader(\n+            LeaderPingerContext<BatchPingableLeader> remoteClient,\n+            Duration leaderPingRate,\n+            Duration leaderPingResponseWait,\n+            UUID nodeUuid) {\n+        this.remoteClient = remoteClient;\n+        this.leaderPingRate = leaderPingRate;\n+        this.leaderPingResponseWait = leaderPingResponseWait;\n+        this.nodeUuid = nodeUuid;\n+\n+        // for comparison to the previous autobatching version, can easily remove later\n+        MetricName metricName = MetricName.builder()\n+                .safeName(\"atlasdb.autobatcherMeter\")\n+                .putSafeTags(\"identifier\", \"batch-pingable-leader.ping\")\n+                .putSafeTags(\"remoteHostAndPort\", remoteClient.hostAndPort().toString())\n+                .build();\n+        this.histogram = SharedTaggedMetricRegistries.getSingleton().histogram(metricName);\n+    }\n+\n+    @Override\n+    public Future<LeaderPingResult> ping(UUID requestedUuid, Client client) {\n+        // register client with the batcher to check whether or not the remote client is the leader or not\n+        // since there is a case where we'll miss the window, we must wait until the client has been registered and\n+        // been included in an existing batch before reading from the in memory state\n+        // wait up to leaderPingResponseRate each time until it has been included and requested in a batch\n+        Instant requestTime = Instant.now();\n+\n+        return FluentFuture.from(hasProcessedFirstRequest.computeIfAbsent(client, $ -> SettableFuture.create()))\n+                .transform(\n+                        // this will never be null, since we waited for our request to be processed at least once\n+                        // semantic difference here is that values are effectively cached for leaderPingResponseWait\n+                        // in the event that things are not good, but in the bigger picture these *should* be\n+                        // equivalent.\n+                        $ -> {\n+                            // if for any reason we've stopped, bubble up the exception\n+                            checkNotShutdown();\n+                            return lastResult.get().result(\n+                                    client,\n+                                    requestTime.minus(leaderPingResponseWait),\n+                                    remoteClient.hostAndPort(),\n+                                    requestedUuid);\n+                        },\n+                        MoreExecutors.directExecutor());\n+    }\n+\n+    private void checkNotShutdown() {\n+        State state = state();\n+        Preconditions.checkState(state != State.STOPPING && state != State.TERMINATED,\n+                \"pinger is either shutdown or in the process of shutting down\");\n+    }\n+\n+    @Override\n+    protected String serviceName() {\n+        return String.format(\"ManualBatchingPingableLeader %s -> %s\", nodeUuid.toString(), remoteClient.hostAndPort());\n+    }\n+\n+    @Override\n+    public LeaderPingerContext<BatchPingableLeader> underlyingRpcClient() {\n+        return remoteClient;\n+    }\n+\n+    @Override\n+    protected void runOneIteration() {\n+        try {\n+            Set<Client> clientsToCheck = ImmutableSet.copyOf(hasProcessedFirstRequest.keySet());\n+            Instant before = Instant.now();\n+            Set<Client> clientsThisNodeIsTheLeaderFor = remoteClient.pinger().ping(clientsToCheck);\n+            Instant after = Instant.now();\n+\n+            Duration pingDuration = Duration.between(before, after);\n+            if (pingDuration.compareTo(leaderPingResponseWait) >= 0) {\n+                log.info(\"Ping took more than ping response wait, any waiters will report that ping timed out\",\n+                        SafeArg.of(\"pingDuration\", pingDuration),\n+                        SafeArg.of(\"leaderPingResponseWait\", leaderPingResponseWait));\n+            }\n+            LastResult newResult = ImmutableLastResult.of(after, clientsThisNodeIsTheLeaderFor);\n+            this.lastResult.set(newResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwNjU0Nw==", "bodyText": "I find this class a little confusing, perhaps because of the naming similarity to Autobatchers and co. In particular, if a given client is requested once, it will continue to be requested for the life of the object, while in most things that batch I would not expect the request to be sent after the first time it is processed.\nThe logic makes sense (as you do mention in the comments, the worry here is serialization cost - but I think it's worth a shot, we can test with an RC if you'd prefer).", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386606547", "createdAt": "2020-03-02T19:37:03Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeader.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.Histogram;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Maps;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.AbstractScheduledService;\n+import com.google.common.util.concurrent.FluentFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+import com.palantir.tritium.metrics.registry.MetricName;\n+import com.palantir.tritium.metrics.registry.SharedTaggedMetricRegistries;\n+\n+final class ManualBatchingPingableLeader extends AbstractScheduledService implements ClientAwarePingableLeader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxMTkyMQ==", "bodyText": "There's a test that I think is quite important that's missing here:\n\nrunOneIteration will ping (and continue to ping) services that haven't been requested since the last iteration - this is the behaviour I was confused by, but given its usage I think would be good to codify it", "url": "https://github.com/palantir/atlasdb/pull/4623#discussion_r386611921", "createdAt": "2020-03-02T19:48:04Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/ManualBatchingPingableLeaderTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.only;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.net.HostAndPort;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.timelock.paxos.ManualBatchingPingableLeader.LastResult;\n+import com.palantir.paxos.ImmutableLeaderPingerContext;\n+import com.palantir.paxos.LeaderPingResult;\n+import com.palantir.paxos.LeaderPingResults;\n+import com.palantir.paxos.LeaderPingerContext;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class ManualBatchingPingableLeaderTest {\n+\n+    private static final Client CLIENT_WHO_IS_LED = Client.of(\"client-1\");\n+    private static final Client CLIENT_WHO_IS_NOT_LED = Client.of(\"client-2\");\n+\n+    private static final HostAndPort HOST_AND_PORT = HostAndPort.fromParts(\"localhost\", 1234);\n+    private static final UUID HOST_UUID = UUID.randomUUID();\n+\n+    @Mock\n+    private BatchPingableLeader batchPingableLeader;\n+    private LeaderPingerContext<BatchPingableLeader> pingerWithContext;\n+\n+    @Before\n+    public void setUp() {\n+        pingerWithContext = ImmutableLeaderPingerContext.of(batchPingableLeader, HOST_AND_PORT);\n+    }\n+\n+    @Test\n+    public void testTooOldResultReturnsTimeOut() {\n+        Instant completedAt = Instant.now();\n+        Instant earliestCompletedDeadline = completedAt.plus(Duration.ofMillis(10));\n+        LastResult lastResult = ImmutableLastResult.of(completedAt, ImmutableSet.of(CLIENT_WHO_IS_LED));\n+        LeaderPingResult result =\n+                lastResult.result(CLIENT_WHO_IS_LED, earliestCompletedDeadline, HOST_AND_PORT, HOST_UUID);\n+\n+        assertThat(result)\n+                .as(\"earliest completed deadline was not met, meaning we've timed out\")\n+                .isEqualTo(LeaderPingResults.pingTimedOut());\n+    }\n+\n+    @Test\n+    public void testClientBeingLedShowsUpAsTrue() {\n+        Instant completedAt = Instant.now();\n+        Instant earliestCompletedDeadline = completedAt.minus(Duration.ofMillis(10));\n+        LastResult lastResult = ImmutableLastResult.of(completedAt, ImmutableSet.of(CLIENT_WHO_IS_LED));\n+        LeaderPingResult result =\n+                lastResult.result(CLIENT_WHO_IS_LED, earliestCompletedDeadline, HOST_AND_PORT, HOST_UUID);\n+\n+        assertThat(result)\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+    }\n+\n+    @Test\n+    public void testClientNotBeingLedShowsUpAsFalse() {\n+        Instant completedAt = Instant.now();\n+        Instant earliestCompletedDeadline = completedAt.minus(Duration.ofMillis(10));\n+        LastResult lastResult = ImmutableLastResult.of(completedAt, ImmutableSet.of(CLIENT_WHO_IS_LED));\n+        LeaderPingResult result =\n+                lastResult.result(CLIENT_WHO_IS_NOT_LED, earliestCompletedDeadline, HOST_AND_PORT, HOST_UUID);\n+\n+        assertThat(result)\n+                .isEqualTo(LeaderPingResults.pingReturnedFalse());\n+    }\n+\n+    @Test\n+    public void singleIterationUpdatesInMemoryReference() {\n+        ManualBatchingPingableLeader manualBatchingPingableLeader = new ManualBatchingPingableLeader(\n+                pingerWithContext,\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(1),\n+                HOST_UUID);\n+\n+        Future<LeaderPingResult> clientWhoIsLed = manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+        Future<LeaderPingResult> clientWhoIsNotLed =\n+                manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_NOT_LED);\n+\n+        when(batchPingableLeader.ping(ImmutableSet.of(CLIENT_WHO_IS_LED, CLIENT_WHO_IS_NOT_LED)))\n+                .thenReturn(ImmutableSet.of(CLIENT_WHO_IS_LED));\n+\n+        manualBatchingPingableLeader.runOneIteration();\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsLed))\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsNotLed))\n+                .isEqualTo(LeaderPingResults.pingReturnedFalse());\n+    }\n+\n+    @Test\n+    public void getUnresolvedFutureUntilSingleIterationHasRun() {\n+        ManualBatchingPingableLeader manualBatchingPingableLeader = new ManualBatchingPingableLeader(\n+                pingerWithContext,\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(1),\n+                HOST_UUID);\n+\n+        Future<LeaderPingResult> clientWhoIsLed = manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+\n+        assertThat(clientWhoIsLed)\n+                .as(\"it's hard to test that it never gets resolved prior to running the single iteration\")\n+                .isNotDone();\n+\n+        when(batchPingableLeader.ping(ImmutableSet.of(CLIENT_WHO_IS_LED)))\n+                .thenReturn(ImmutableSet.of(CLIENT_WHO_IS_LED));\n+\n+        manualBatchingPingableLeader.runOneIteration();\n+\n+        assertThat(clientWhoIsLed)\n+                .as(\"we expect this to be done, everything is running within a single thread in this test\")\n+                .isDone();\n+    }\n+\n+    @Test\n+    public void getBackCachedResultIfTryingToPingTwice() {\n+        ManualBatchingPingableLeader manualBatchingPingableLeader = new ManualBatchingPingableLeader(\n+                pingerWithContext,\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(1),\n+                HOST_UUID);\n+\n+        Future<LeaderPingResult> clientWhoIsLed = manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+\n+        when(batchPingableLeader.ping(ImmutableSet.of(CLIENT_WHO_IS_LED)))\n+                .thenReturn(ImmutableSet.of(CLIENT_WHO_IS_LED))\n+                .thenReturn(ImmutableSet.of());\n+\n+        manualBatchingPingableLeader.runOneIteration();\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsLed))\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+\n+        Future<LeaderPingResult> clientWhoIsLedSecondRequest =\n+                manualBatchingPingableLeader.ping(HOST_UUID, CLIENT_WHO_IS_LED);\n+\n+        assertThat(Futures.getUnchecked(clientWhoIsLedSecondRequest))\n+                .isEqualTo(LeaderPingResults.pingReturnedTrue(HOST_UUID, HOST_AND_PORT));\n+\n+        verify(batchPingableLeader, only()).ping(ImmutableSet.of(CLIENT_WHO_IS_LED));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0f5e760a824e320d2cc346a65ff498b806f78d"}, "originalPosition": 173}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d0b3b003b3e68a4e94e5a082af3db35a3381561", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/0d0b3b003b3e68a4e94e5a082af3db35a3381561", "committedDate": "2020-03-03T14:38:43Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MDMyNzQ2", "url": "https://github.com/palantir/atlasdb/pull/4623#pullrequestreview-368032746", "createdAt": "2020-03-03T14:39:37Z", "commit": {"oid": "0d0b3b003b3e68a4e94e5a082af3db35a3381561"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2327, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}