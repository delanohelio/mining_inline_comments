{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzMwNzA1", "number": 4588, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDoyNTo1OVrODhNb7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0NjozOVrODiYBUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTQ5NzQxOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDoyNTo1OVrOFr2Ztw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDoyNTo1OVrOFr2Ztw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNDQwNw==", "bodyText": "this is drafts, but I would put in normal review, I'll leave the other stuff out since you have todos on that.\nTo make tests a bit more readable, we typically get rid of the cruft by way of static functions e.g.\nprivate static Cell createCell(String row, String column) { ... }\nsince the PtBytes.toBytes is not important and is just cruft", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381524407", "createdAt": "2020-02-19T20:25:59Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTUxNzAwOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozMjoyMFrOFr2lqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMToyNFrOFsTV4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzQ2NQ==", "bodyText": "do you want a containsOnly? that verifies you're skipping stuff?", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381527465", "createdAt": "2020-02-19T20:32:20Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{\n+           add(PtBytes.toBytes(\"row1\"));\n+            add(PtBytes.toBytes(\"row2\"));\n+            add(PtBytes.toBytes(\"row3\"));\n+            add(PtBytes.toBytes(\"row4\"));\n+            add(PtBytes.toBytes(\"row5\"));\n+\n+        }};\n+\n+        Map<Cell, Value> result = keyValueService.getRows(tableReference, rows, ColumnSelection.all(), STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsKeys(CELL_1, CELL_2, CELL_3, CELL_4, CELL_5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5ODU2MA==", "bodyText": "if I've understood correctly this should verify that the rows don't contain old timestamps?", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381998560", "createdAt": "2020-02-20T13:31:24Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{\n+           add(PtBytes.toBytes(\"row1\"));\n+            add(PtBytes.toBytes(\"row2\"));\n+            add(PtBytes.toBytes(\"row3\"));\n+            add(PtBytes.toBytes(\"row4\"));\n+            add(PtBytes.toBytes(\"row5\"));\n+\n+        }};\n+\n+        Map<Cell, Value> result = keyValueService.getRows(tableReference, rows, ColumnSelection.all(), STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsKeys(CELL_1, CELL_2, CELL_3, CELL_4, CELL_5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzQ2NQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTUyNDcwOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozNDo1MFrOFr2qZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMDoyOFrOFsTTxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODY3Ng==", "bodyText": "similarly here, it's quite hard to see what's going on here, a nice helper method such as:\nprivate static Multimap<Cell, Value> cellWithValue(Cell cell, String data, long timestamp) {\n  return ImmutableListMultimap.of(cell, Value.create(PtBytes.toBytes(data), timestamp));\n}\nNot sure whether you wanted separate put's for any particular reason, but if not, make use of the ImmutableListMultimap.Builder\ne.g.\nprivate static Value value(String data, long timestamp) { ... }\n\nImmutableListMultimap.builder()\n  .putAll(CELL, value(\"data2\", 88L))\n  .putAll(CELL_1, value(\"moreData\", 80L), value(\"moreData\", 90L)\n  .putAll(CELL_2, valueWithTimestamps(\"moreData\", 73L, 75L, 60L))\n  ...\n  build();", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381528676", "createdAt": "2020-02-19T20:34:50Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5ODAyMw==", "bodyText": "if it's alright to put it into one, then I think the latter style works quite nicely i.e. single multimap with valueWithTimestamps method.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381998023", "createdAt": "2020-02-20T13:30:28Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODY3Ng=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTUzMTMzOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozNjo0OFrOFr2uUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozMjo0N1rOFsTYtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyOTY4MQ==", "bodyText": "use ImmutableList constructor: ImmutableList.of(PtBytes.toBytes(\"row1\"), ...).\nOne step further:\nprivate static Iterable<byte[]> rows(String... rowNames) {\n  return Arrays.stream(rowNames).map(PtBytes::toBytes).collect(Collectors.toList());\n}", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381529681", "createdAt": "2020-02-19T20:36:48Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5OTI4NQ==", "bodyText": "or better still, in order to not have to scroll up to figure out what row1 means, just use CELL.getRowName, or have the signature be Iterable<byte[]> rowNames(Cell... cells)", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381999285", "createdAt": "2020-02-20T13:32:47Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyOTY4MQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTU0NjI3OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0MTozNFrOFr23cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0NDoyN1rOFr28wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMjAxOQ==", "bodyText": "what happens when this is null? how does it behave?", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381532019", "createdAt": "2020-02-19T20:41:34Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {\n+        if (columns.size() > 0) {\n+\n+            ColumnOrSuperColumn lastCol = columns.get(columns.size() - 1);\n+            Pair<byte[], Long> pair =  CassandraKeyValueServices.decompose(lastCol.getColumn().name);\n+\n+            return SlicePredicates.create(Range.of(CassandraKeyValueServices\n+                    .makeCompositeBuffer(RangeRequests.nextLexicographicName(pair.lhSide), Long.MAX_VALUE),\n+                    Range.UNBOUND_END), Limit.of(1));\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzM3Ng==", "bodyText": "should it fallback to what it was doing before?\nhow about this method return the KeyPredicate, so any null handling you have to do is within a function, if absolutely have to do any null handling.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381533376", "createdAt": "2020-02-19T20:44:27Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {\n+        if (columns.size() > 0) {\n+\n+            ColumnOrSuperColumn lastCol = columns.get(columns.size() - 1);\n+            Pair<byte[], Long> pair =  CassandraKeyValueServices.decompose(lastCol.getColumn().name);\n+\n+            return SlicePredicates.create(Range.of(CassandraKeyValueServices\n+                    .makeCompositeBuffer(RangeRequests.nextLexicographicName(pair.lhSide), Long.MAX_VALUE),\n+                    Range.UNBOUND_END), Limit.of(1));\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMjAxOQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDc4NjgzOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzoyOTozMVrOFsTRxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzoyOTozMVrOFsTRxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzUwOA==", "bodyText": "the deletion at this point isn't really important, in your test you have no deletion code anyway (not that I'm asking you to do so either), should name this along the lines of \"testGetRowsDoesNotReadOldData\" or something along those lines", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381997508", "createdAt": "2020-02-20T13:29:31Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDgxNjE2OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzozNzozMFrOFsTi-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo0MToyNVrOFsTrbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ==", "bodyText": "this feels oddly similar to translateRowsToKeyPredicates", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382001915", "createdAt": "2020-02-20T13:37:30Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMzczNQ==", "bodyText": "perhaps instead of mutating the query, how about just setting it at the bottom? it would be nice to just make a new query object each time but we probably don't want recursion here.. so need some mutation somewhere.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382003735", "createdAt": "2020-02-20T13:40:47Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDA3Nw==", "bodyText": "that way, I think you can reuse translateRowsToKeyPredicates, although I may be mistaken", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382004077", "createdAt": "2020-02-20T13:41:25Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ=="}, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDgzNDU5OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo0MjozN1rOFsTuLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo0MjozN1rOFsTuLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDc4MQ==", "bodyText": "just return  Maps.transformValues(...)", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382004781", "createdAt": "2020-02-20T13:42:37Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDg0MzYxOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo0NTowM1rOFsTz1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzo0NTowM1rOFsTz1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNjIzMA==", "bodyText": "at some point, you want to comment on the optimisation is that you're doing, it's easy to get lost in CassandraKeyValueServiceImpl. If you're able to encode that in your method names, even better, but might make sense to just comment/javadoc.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382006230", "createdAt": "2020-02-20T13:45:03Z", "author": {"login": "felixdesouza"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89973c53f510ea83b50253a27d8d9408518c535f"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NjAzODMwOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxOTowMjo0M1rOFsfchQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNTo0MDo1M1rOFs7L4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Njg2OQ==", "bodyText": "To be modified", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382196869", "createdAt": "2020-02-20T19:02:43Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java", "diffHunk": "@@ -64,6 +64,8 @@\n     // TODO (jkong): Review this limit, it seems like we are making very big requests to Cassandra even at this value\n     public static final int DEFAULT_SINGLE_QUERY_LOAD_BATCH_LIMIT = 50_000;\n \n+    public static final int DEFAULT_READ_LIMIT_PER_ROW = 200;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8046d3f51106b1002c3727fd5fe3590b33e16736"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MTM2Mg==", "bodyText": "Integer.MAX_VALUE for now as we want to maintain the existing behaviour.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382651362", "createdAt": "2020-02-21T15:40:53Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java", "diffHunk": "@@ -64,6 +64,8 @@\n     // TODO (jkong): Review this limit, it seems like we are making very big requests to Cassandra even at this value\n     public static final int DEFAULT_SINGLE_QUERY_LOAD_BATCH_LIMIT = 50_000;\n \n+    public static final int DEFAULT_READ_LIMIT_PER_ROW = 200;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Njg2OQ=="}, "originalCommit": {"oid": "8046d3f51106b1002c3727fd5fe3590b33e16736"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzU3Mzc4OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxMTo1N1rOFtkHyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxMTo1N1rOFtkHyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjA1Ng==", "bodyText": "This method is actually fetching the values as well, not just the cells. I would name it something like getAllCellsForRows", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383322056", "createdAt": "2020-02-24T15:11:57Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzU5MzEwOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxNjo1NFrOFtkThw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxNjo1NFrOFtkThw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNTA2Mw==", "bodyText": "as above, I'd prefer get instead of fetch because we are getting the values. Strictly speaking it should be getForCellsForKeyPredicates but I find that a bit clumsy, so would be ok with just changing the first word.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383325063", "createdAt": "2020-02-24T15:16:54Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzYwMTk1OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxOTowNVrOFtkY2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxOTozNFrOFtkZ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjQyNg==", "bodyText": "nit: ... + \" cells)\"; rather than two separate strings", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383326426", "createdAt": "2020-02-24T15:19:05Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} starting at timestamp {} on {} \"\n+                                            + \"as part of fetching cells for key predicates.\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+\n+                        return Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        return \"multiget_multislice(\" + host + \", \" + tableRef +\n+                                + query.size() + \" cells\" + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjcxMQ==", "bodyText": "And we probably want a comma before saying the number of cells. The idea is to get something like multiget_multislice(host, table, 1000 cells)", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383326711", "createdAt": "2020-02-24T15:19:34Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} starting at timestamp {} on {} \"\n+                                            + \"as part of fetching cells for key predicates.\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+\n+                        return Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        return \"multiget_multislice(\" + host + \", \" + tableRef +\n+                                + query.size() + \" cells\" + \")\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjQyNg=="}, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzY5NzA5OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0MTo1MFrOFtlS1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0MTo1MFrOFtlS1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0MTI2OQ==", "bodyText": "Let's move this to the runtime config, so it can be reloaded more easily.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383341269", "createdAt": "2020-02-24T15:41:50Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java", "diffHunk": "@@ -290,6 +290,11 @@ default int rangesConcurrency() {\n         return 32;\n     }\n \n+    @Value.Default\n+    default int fetchReadLimitPerRow() {\n+        return CassandraConstants.DEFAULT_READ_LIMIT_PER_ROW;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzcxNzMxOnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0NjozOVrOFtlfJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNTo0NjozOVrOFtlfJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0NDQyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();\n          \n      \n    \n    \n  \n\nIt's unused.", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383344423", "createdAt": "2020-02-24T15:46:39Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +306,66 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRows_highlyVersionedCells() {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+\n+        byte[] data = PtBytes.toBytes(\"data\");\n+\n+        Cell CELL_WITH_VERSIONS = Cell.create(row(1), column(1));\n+        Cell CELL_WITH_SAME_ROW = Cell.create(row(1), column(2));\n+\n+        ImmutableListMultimap<Cell, Value> tableValues = ImmutableListMultimap.<Cell, Value>builder()\n+                .putAll(CELL_WITH_VERSIONS, valueWithNumberOfTimestamps(data, 250L))\n+                .putAll(CELL_WITH_SAME_ROW, valueWithNumberOfTimestamps(data, 200L))\n+                .build();\n+\n+        keyValueService.putWithTimestamps(tableReference, tableValues);\n+\n+        Map<Cell, Value> result = keyValueService.getRows(\n+                tableReference,\n+                ImmutableList.of(CELL_WITH_VERSIONS.getRowName(), CELL_WITH_SAME_ROW.getRowName()),\n+                ColumnSelection.all(),\n+                STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsOnly(\n+                entry(CELL_WITH_VERSIONS, Value.create(data, 250L)),\n+                entry(CELL_WITH_SAME_ROW, Value.create(data, 200L)));\n+    }\n+\n+    @Test\n+    public void testGetRows_manyColumnRows() {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+\n+        byte[] data = PtBytes.toBytes(\"data\");\n+\n+        ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2313, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}