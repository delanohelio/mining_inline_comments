{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3OTgzMzE0", "number": 4775, "title": "[PaxosStateLog] Wire up and Migrate To Verifying PSL", "bodyText": "Goals (and why):\nEnable stage one of PSL migration, running in verification mode, still trusting the file system implementation as the source of truth.\nImplementation Description (bullets):\nOn startup does a one time migration from file to sqlite (migration will only be redone on future startups if discrepancy in greatest log entry is detected). Then, run in validation mode, where we do dual writing and dual reading to verify correctness of the new impl, but use old imps as the source of truth in case of mismatch.\nTesting (What was existing testing like?  What have you done to improve it?):\nAdded some integration tests that things are wired through correctly.\nConcerns (what feedback would you like?):\nDo we need more tests?\nThis enables verification mode by default and without the option to not run it. Do we want to make it configurable?\nAnything else I might have missed? I assume we don't want to migrate clients who use the leader block, but we could...\nWhere should we start reviewing?:\nPaxosStateLogMigrationIntegrationTest.java & LocalPaxosComponents.java\nPriority (whenever / two weeks / yesterday):\nToday, I hope", "createdAt": "2020-05-14T13:04:33Z", "url": "https://github.com/palantir/atlasdb/pull/4775", "merged": true, "mergeCommit": {"oid": "8466139bc996622403c2044b6670fb6efae4728b"}, "closed": true, "closedAt": "2020-05-15T13:04:30Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcg7KiXAH2gAyNDE3OTgzMzE0OjlkMzA3MTMwNjM4OTY4N2NkOWIwNWY0ODkwMmExNjQxYTNiNzkxYTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchg6lUAH2gAyNDE3OTgzMzE0OmRkNGRkYWRkNjIwNDlkYzc5MGZhZmU3ZDViMDE2MmUwMDI2NmNmYjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9d3071306389687cd9b05f48902a1641a3b791a3", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/9d3071306389687cd9b05f48902a1641a3b791a3", "committedDate": "2020-05-13T16:07:34Z", "message": "Implement different state support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40f00c368317882a67160675e25ef35a4e0db70a", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/40f00c368317882a67160675e25ef35a4e0db70a", "committedDate": "2020-05-13T16:17:19Z", "message": "Add migrated state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f279ca043c6de9bf195afe5990d4f9fe3114505e", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/f279ca043c6de9bf195afe5990d4f9fe3114505e", "committedDate": "2020-05-14T12:39:35Z", "message": "Wiring and integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/8bc4cd00a6dcc9f70fb90cec90003e8175d11d44", "committedDate": "2020-05-14T13:04:17Z", "message": "Small fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODU1Nzk5", "url": "https://github.com/palantir/atlasdb/pull/4775#pullrequestreview-411855799", "createdAt": "2020-05-14T14:22:21Z", "commit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDoyMjoyMlrOGVesUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDo0NzoyMlrOGVf3Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NjE0NA==", "bodyText": "\ud83c\udf89", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425176144", "createdAt": "2020-05-14T14:22:22Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3ODMzMg==", "bodyText": "I think it's already done in 162", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425178332", "createdAt": "2020-05-14T14:25:02Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3OTQ3NA==", "bodyText": "Bit of a funky param name for something that is supposed to exist \ud83d\ude04", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425179474", "createdAt": "2020-05-14T14:26:23Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner otherLearner = paxosComponents.learner(otherClient);\n+        PaxosStorageParameters otherParameters = getParametersForClient(otherClient);\n+        PaxosStateLog<PaxosValue> otherSqliteLog = createSqliteLog(otherParameters);\n+\n+        assertValueAbsent(round, otherSqliteLog);\n+        assertValuePresent(otherRound, otherSqliteLog);\n+        assertValueLearned(round, learner);\n+        assertValueNotLearned(otherRound, learner);\n+        assertValueNotLearned(round, otherLearner);\n+        assertValueLearned(otherRound, otherLearner);\n+    }\n+\n+    private void assertValueLearned(int secondRound, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(secondRound)).hasValue(valueForRound(secondRound));\n+    }\n+\n+    private void assertValueNotLearned(int rogueValue, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(rogueValue)).isEmpty();\n+    }\n+\n+    private void assertValuePresent(int rogueValue, PaxosStateLog<PaxosValue> sqliteLog) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MDM1MA==", "bodyText": "nit: dir.resolve(PaxosTimeLockConstants.LEARNER_SUBDIRECTORY_PATH).toString()?", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425180350", "createdAt": "2020-05-14T14:27:35Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner otherLearner = paxosComponents.learner(otherClient);\n+        PaxosStorageParameters otherParameters = getParametersForClient(otherClient);\n+        PaxosStateLog<PaxosValue> otherSqliteLog = createSqliteLog(otherParameters);\n+\n+        assertValueAbsent(round, otherSqliteLog);\n+        assertValuePresent(otherRound, otherSqliteLog);\n+        assertValueLearned(round, learner);\n+        assertValueNotLearned(otherRound, learner);\n+        assertValueNotLearned(round, otherLearner);\n+        assertValueLearned(otherRound, otherLearner);\n+    }\n+\n+    private void assertValueLearned(int secondRound, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(secondRound)).hasValue(valueForRound(secondRound));\n+    }\n+\n+    private void assertValueNotLearned(int rogueValue, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(rogueValue)).isEmpty();\n+    }\n+\n+    private void assertValuePresent(int rogueValue, PaxosStateLog<PaxosValue> sqliteLog) throws IOException {\n+        assertThat(PaxosValue.BYTES_HYDRATOR.hydrateFromBytes(sqliteLog.readRound(rogueValue)))\n+                .isEqualTo(valueForRound(rogueValue));\n+    }\n+\n+    private void assertValueAbsent(int nonMigratedRound, PaxosStateLog<PaxosValue> sqliteLog)\n+            throws IOException {\n+        assertThat(sqliteLog.readRound(nonMigratedRound)).isNull();\n+    }\n+\n+    private void resetPaxosComponents() {\n+        paxosComponents = new LocalPaxosComponents(\n+                TimelockPaxosMetrics.of(useCase, MetricsManagers.createForTests()),\n+                useCase,\n+                legacyDirectory,\n+                sqliteDirectory, UUID.randomUUID(), true);\n+    }\n+\n+    private PaxosValue valueForRound(int i) {\n+        return new PaxosValue(\"value\", i, new byte[] {1});\n+    }\n+\n+    private PaxosStateLog<PaxosValue> createFileSystemLog(Client client) {\n+        Path dir = useCase.logDirectoryRelativeToDataDirectory(legacyDirectory).resolve(client.value());\n+        String learnerLogDir = Paths.get(dir.toString(), PaxosTimeLockConstants.LEARNER_SUBDIRECTORY_PATH).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MTg3Mw==", "bodyText": "consider @VisibleForTesting in other class", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425181873", "createdAt": "2020-05-14T14:29:33Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.atlasdb.util.MetricsManagers;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.ImmutablePaxosStorageParameters;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosStateLogImpl;\n+import com.palantir.paxos.PaxosStorageParameters;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public class PaxosStateLogMigrationIntegrationTest {\n+    private static final Client CLIENT = Client.of(\"test\");\n+\n+    @Rule\n+    public final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+\n+    private LocalPaxosComponents paxosComponents;\n+    private PaxosUseCase useCase = PaxosUseCase.LEADER_FOR_ALL_CLIENTS;\n+    private Path legacyDirectory;\n+    private Path sqliteDirectory;\n+\n+    @Before\n+    public void setUp() throws IOException {\n+        legacyDirectory = TEMPORARY_FOLDER.newFolder(\"legacy\").toPath();\n+        sqliteDirectory = TEMPORARY_FOLDER.newFolder(\"sqlite\").toPath();\n+        resetPaxosComponents();\n+    }\n+\n+    @Test\n+    public void learnerMigratesLogStateCorrectly() throws IOException {\n+        int round = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        assertValuePresent(round, sqliteLog);\n+        assertValueLearned(round, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueOnlyInLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int nonMigratedRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValuePresent(nonMigratedRound, fileBasedLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void legacyLogIsTheSourceOfTruthWhenValueAbsentFromLegacy() throws IOException {\n+        int migratedRound = 100;\n+        int rogueValue = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(migratedRound, valueForRound(migratedRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        sqliteLog.writeRound(rogueValue, valueForRound(rogueValue));\n+\n+        assertValuePresent(rogueValue, sqliteLog);\n+        assertValueAbsent(rogueValue, fileBasedLog);\n+        assertValueNotLearned(rogueValue, learner);\n+    }\n+\n+    @Test\n+    public void doesNotMigrateAgainIfGreatestSequencesMatch() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        int nonMigratedRound = 150;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(nonMigratedRound, valueForRound(nonMigratedRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(firstRound, sqliteLog);\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueAbsent(nonMigratedRound, sqliteLog);\n+        assertValueLearned(nonMigratedRound, learner);\n+    }\n+\n+    @Test\n+    public void migratesAgainIfOutOfSyncDetected() throws IOException {\n+        int firstRound = 100;\n+        int secondRound = 200;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(firstRound, valueForRound(firstRound));\n+\n+        PaxosStorageParameters parameters = getParametersForClient(CLIENT);\n+        paxosComponents.learner(CLIENT);\n+        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(parameters);\n+\n+        fileBasedLog.writeRound(secondRound, valueForRound(secondRound));\n+\n+        resetPaxosComponents();\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        assertValuePresent(secondRound, sqliteLog);\n+        assertValueLearned(secondRound, learner);\n+    }\n+\n+    @Test\n+    public void noCrossClientPollution() throws IOException {\n+        int round = 200;\n+        int otherRound = 100;\n+        PaxosStateLog<PaxosValue> fileBasedLog = createFileSystemLog(CLIENT);\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner learner = paxosComponents.learner(CLIENT);\n+\n+        Client otherClient = Client.of(\"other\");\n+        PaxosStateLog<PaxosValue> otherFileBasedLog = createFileSystemLog(otherClient);\n+        otherFileBasedLog.writeRound(otherRound, valueForRound(otherRound));\n+        fileBasedLog.writeRound(round, valueForRound(round));\n+\n+        PaxosLearner otherLearner = paxosComponents.learner(otherClient);\n+        PaxosStorageParameters otherParameters = getParametersForClient(otherClient);\n+        PaxosStateLog<PaxosValue> otherSqliteLog = createSqliteLog(otherParameters);\n+\n+        assertValueAbsent(round, otherSqliteLog);\n+        assertValuePresent(otherRound, otherSqliteLog);\n+        assertValueLearned(round, learner);\n+        assertValueNotLearned(otherRound, learner);\n+        assertValueNotLearned(round, otherLearner);\n+        assertValueLearned(otherRound, otherLearner);\n+    }\n+\n+    private void assertValueLearned(int secondRound, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(secondRound)).hasValue(valueForRound(secondRound));\n+    }\n+\n+    private void assertValueNotLearned(int rogueValue, PaxosLearner learner) {\n+        assertThat(learner.getLearnedValue(rogueValue)).isEmpty();\n+    }\n+\n+    private void assertValuePresent(int rogueValue, PaxosStateLog<PaxosValue> sqliteLog) throws IOException {\n+        assertThat(PaxosValue.BYTES_HYDRATOR.hydrateFromBytes(sqliteLog.readRound(rogueValue)))\n+                .isEqualTo(valueForRound(rogueValue));\n+    }\n+\n+    private void assertValueAbsent(int nonMigratedRound, PaxosStateLog<PaxosValue> sqliteLog)\n+            throws IOException {\n+        assertThat(sqliteLog.readRound(nonMigratedRound)).isNull();\n+    }\n+\n+    private void resetPaxosComponents() {\n+        paxosComponents = new LocalPaxosComponents(\n+                TimelockPaxosMetrics.of(useCase, MetricsManagers.createForTests()),\n+                useCase,\n+                legacyDirectory,\n+                sqliteDirectory, UUID.randomUUID(), true);\n+    }\n+\n+    private PaxosValue valueForRound(int i) {\n+        return new PaxosValue(\"value\", i, new byte[] {1});\n+    }\n+\n+    private PaxosStateLog<PaxosValue> createFileSystemLog(Client client) {\n+        Path dir = useCase.logDirectoryRelativeToDataDirectory(legacyDirectory).resolve(client.value());\n+        String learnerLogDir = Paths.get(dir.toString(), PaxosTimeLockConstants.LEARNER_SUBDIRECTORY_PATH).toString();\n+        return new PaxosStateLogImpl<>(learnerLogDir);\n+    }\n+\n+    private PaxosStateLog<PaxosValue> createSqliteLog(PaxosStorageParameters parameters) {\n+        Supplier<Connection> conn = SqliteConnections\n+                .createDefaultNamedSqliteDatabaseAtPath(parameters.sqliteBasedLogDirectory());\n+        return SqlitePaxosStateLog.create(parameters.namespaceAndUseCase(), conn);\n+    }\n+\n+    private PaxosStorageParameters getParametersForClient(Client client) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MzMwNQ==", "bodyText": "This should just be sqliteLogDirectory: we don't need to have separate SQLite instances for each of the use cases.", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425183305", "createdAt": "2020-05-14T14:31:25Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/paxos/LocalPaxosComponents.java", "diffHunk": "@@ -50,12 +52,14 @@\n \n     LocalPaxosComponents(TimelockPaxosMetrics metrics,\n             PaxosUseCase paxosUseCase,\n-            Path baseLogDirectory,\n+            Path legacyLogDirectory,\n+            Path sqliteLogDirectory,\n             UUID leaderUuid,\n             boolean canCreateNewClients) {\n         this.metrics = metrics;\n         this.paxosUseCase = paxosUseCase;\n-        this.baseLogDirectory = baseLogDirectory;\n+        this.baseLogDirectory = legacyLogDirectory;\n+        this.sqliteLogDirectory = paxosUseCase.logDirectoryRelativeToDataDirectory(sqliteLogDirectory).toAbsolutePath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5NTMzMQ==", "bodyText": "\ud83c\udf89", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425195331", "createdAt": "2020-05-14T14:47:22Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosConsensusTestUtils.java", "diffHunk": "@@ -59,14 +62,15 @@ public static PaxosTestState setup(int numLeaders,\n         for (int i = 0; i < numLeaders; i++) {\n             failureToggles.add(new AtomicBoolean(false));\n \n-            PaxosLearner learner = PaxosLearnerImpl.newLearner(getLearnerLogDir(i));\n+            PaxosLearner learner = PaxosLearnerImpl\n+                    .newVerifyingLearner(getLearnerStorageParameters(i), PaxosKnowledgeEventRecorder.NO_OP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc4cd00a6dcc9f70fb90cec90003e8175d11d44"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3944229a48755017de6d51c4f7845eac089d762f", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/3944229a48755017de6d51c4f7845eac089d762f", "committedDate": "2020-05-14T15:26:04Z", "message": "Implement different state support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94d3595deb6cfeb690befe0f4a0e6509ebfbeb78", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/94d3595deb6cfeb690befe0f4a0e6509ebfbeb78", "committedDate": "2020-05-14T15:27:47Z", "message": "Add migrated state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "997dd6c79f0f6eb7adec467d34ba39cb74363727", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/997dd6c79f0f6eb7adec467d34ba39cb74363727", "committedDate": "2020-05-14T15:27:47Z", "message": "Wiring and integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39767cc205e35471b3adb439a1d79d4693fd01e7", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/39767cc205e35471b3adb439a1d79d4693fd01e7", "committedDate": "2020-05-14T15:27:47Z", "message": "Small fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad67539449fd3fe8338d8585fa40fd55934ac005", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/ad67539449fd3fe8338d8585fa40fd55934ac005", "committedDate": "2020-05-14T15:29:48Z", "message": "Merge and address old comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f8215469f582839e6687a1e7258309ba1ee7e7e", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/5f8215469f582839e6687a1e7258309ba1ee7e7e", "committedDate": "2020-05-14T15:56:45Z", "message": "Address CR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b09124bddad335d5e79d6ff32298325a2d86bc89", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/b09124bddad335d5e79d6ff32298325a2d86bc89", "committedDate": "2020-05-14T15:56:45Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNTU5NzMw", "url": "https://github.com/palantir/atlasdb/pull/4775#pullrequestreview-412559730", "createdAt": "2020-05-15T11:19:04Z", "commit": {"oid": "b09124bddad335d5e79d6ff32298325a2d86bc89"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMToxOTowNVrOGWAyJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMToyNDoyOFrOGWA7vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDY5Mg==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void migirateAgainIfMismatchDetected() throws IOException {\n          \n          \n            \n                public void migrateAgainIfMismatchDetected() throws IOException {", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425734692", "createdAt": "2020-05-15T11:19:05Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogMigratorTest.java", "diffHunk": "@@ -93,19 +93,44 @@ public void migrationDeletesExistingState() {\n     }\n \n     @Test\n-    public void doNotMigrateIfAlreadyMigrated() {\n-        migrationState.migrateToValidationState();\n+    public void doNotMigrateIfAlreadyMigratedAndNoMismatchDetected() throws IOException {\n+        long lowerBound = 10;\n+        long upperBound = 25;\n+        List<PaxosValue> expectedValues = insertValuesWithinBounds(lowerBound, upperBound, source);\n \n-        long lowerBound = 1;\n-        long upperBound = 22;\n-        List<PaxosValue> valuesWritten = insertValuesWithinBounds(lowerBound, upperBound, source);\n+        migrateFrom(source);\n+        assertThat(migrationState.hasMigratedFromInitialState()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(lowerBound);\n+        assertThat(target.getGreatestLogEntry()).isEqualTo(upperBound);\n \n+        List<PaxosValue> unExpectedValues = insertValuesWithinBounds(1, 2, source);\n         migrateFrom(source);\n \n+        assertThat(target.getLeastLogEntry()).isNotEqualTo(source.getLeastLogEntry());\n+        expectedValues.forEach(value -> assertThat(getPaxosValue(target, value.seq)).isEqualTo(value));\n+        unExpectedValues.forEach(value -> assertThat(readRoundUnchecked(target, value.seq)).isNull());\n+    }\n+\n+    @Test\n+    public void migirateAgainIfMismatchDetected() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09124bddad335d5e79d6ff32298325a2d86bc89"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNzE1MA==", "bodyText": "Could we add a bit more information (e.g. namespace, use-case, current/intended version) as args?", "url": "https://github.com/palantir/atlasdb/pull/4775#discussion_r425737150", "createdAt": "2020-05-15T11:24:28Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLogMigrationState.java", "diffHunk": "@@ -54,29 +56,45 @@ private void initialize() {\n     }\n \n     public void migrateToValidationState() {\n-        execute(dao -> dao.migrateToVersion(namespace, useCase, States.VALIDATION.schemaVersion));\n+        execute(migrateToState(States.VALIDATION));\n     }\n \n     public void migrateToMigratedState() {\n-        execute(dao -> dao.migrateToVersion(namespace, useCase, States.MIGRATED.schemaVersion));\n+        execute(migrateToState(States.MIGRATED));\n     }\n \n     public boolean hasMigratedFromInitialState() {\n-        return !Objects.equals(States.NONE.getSchemaVersion(), execute(dao -> dao.getVersion(namespace, useCase)));\n+        return execute(dao -> dao.getVersion(namespace, useCase).isPresent());\n     }\n \n     public boolean isInValidationState() {\n-        return States.VALIDATION.getSchemaVersion().equals(execute(dao -> dao.getVersion(namespace, useCase)));\n+        return execute(dao -> dao.getVersion(namespace, useCase)\n+                .map(States.VALIDATION.getSchemaVersion()::equals)\n+                .orElse(false));\n     }\n \n     public boolean isInMigratedState() {\n-        return States.MIGRATED.getSchemaVersion().equals(execute(dao -> dao.getVersion(namespace, useCase)));\n+        return execute(dao -> dao.getVersion(namespace, useCase)\n+                .map(States.MIGRATED.getSchemaVersion()::equals)\n+                .orElse(false));\n     }\n \n     private <T> T execute(Function<Queries, T> call) {\n         return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n+    private Function<Queries, Boolean> migrateToState(States state) {\n+        return dao -> {\n+            assertCurrentStateAtMost(dao, state);\n+            return dao.migrateToVersion(namespace, useCase, state.getSchemaVersion());\n+        };\n+    }\n+\n+    private void assertCurrentStateAtMost(Queries dao, States state) {\n+        dao.getVersion(namespace, useCase).ifPresent(currentVersion ->\n+                Preconditions.checkState(currentVersion <= state.getSchemaVersion()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09124bddad335d5e79d6ff32298325a2d86bc89"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48e5b08acb3fec47eda7d210f069ba95b5d58653", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/48e5b08acb3fec47eda7d210f069ba95b5d58653", "committedDate": "2020-05-15T12:05:23Z", "message": "Address CR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcc23e49fa9daf3aa206ce68a531e0af19475f47", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/bcc23e49fa9daf3aa206ce68a531e0af19475f47", "committedDate": "2020-05-15T12:05:29Z", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into psl/validation-wiring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd4ddadd62049dc790fafe7d5b0162e00266cfb9", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/dd4ddadd62049dc790fafe7d5b0162e00266cfb9", "committedDate": "2020-05-15T12:06:32Z", "message": "Add release notes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2846, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}