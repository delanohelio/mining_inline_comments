{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyMjgyNzM4", "number": 4508, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOTo0OToyNFrODXov2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMDowMToyNVrODXo9Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MTExNDUxOnYy", "diffSide": "RIGHT", "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOTo0OToyNFrOFdCllQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMjoxOTozN1rOFdGf_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk5NTQxMw==", "bodyText": "it's unclear to me based on Java semantics whether this needs to be volatile or not. But I'm gonna leave it as such.", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r365995413", "createdAt": "2020-01-13T19:49:24Z", "author": {"login": "j-baker"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +29,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        awaitDone(present.future);\n+        Round next = present.next;\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f70e6939bb51fb581bf87f7b4fce70f1e05eff"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA1OTUxOQ==", "bodyText": "I think not, since completing a future does happen before a join on that future. Not 100% confident in this one so agree with leaving it as such.", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r366059519", "createdAt": "2020-01-13T22:19:37Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +29,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        awaitDone(present.future);\n+        Round next = present.next;\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk5NTQxMw=="}, "originalCommit": {"oid": "04f70e6939bb51fb581bf87f7b4fce70f1e05eff"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MTExODk1OnYy", "diffSide": "RIGHT", "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOTo1MDo1MFrOFdCoLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMjoyMDo0OFrOFdGiDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk5NjA3OQ==", "bodyText": "This is much faster than the equivalent 'hasStarted.compareAndSet(false, true)'. I believe this is because the proposed solution can do the read in a MESI shared state, whereas the CAS will always make it exclusive.", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r365996079", "createdAt": "2020-01-13T19:50:50Z", "author": {"login": "j-baker"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +29,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        awaitDone(present.future);\n+        Round next = present.next;\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;\n+\n+        boolean isFirstToArrive() {\n+            return !hasStarted.get() && hasStarted.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f70e6939bb51fb581bf87f7b4fce70f1e05eff"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2MDA0Nw==", "bodyText": "Makes sense. I think we should document this in a comment here.", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r366060047", "createdAt": "2020-01-13T22:20:48Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +29,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        awaitDone(present.future);\n+        Round next = present.next;\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;\n+\n+        boolean isFirstToArrive() {\n+            return !hasStarted.get() && hasStarted.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk5NjA3OQ=="}, "originalCommit": {"oid": "04f70e6939bb51fb581bf87f7b4fce70f1e05eff"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MTE0OTAzOnYy", "diffSide": "RIGHT", "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMDowMToyNVrOFdC6eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMDoxNjoxMVrOFdDRxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwMDc2MQ==", "bodyText": "why are we eating this and not at least logging at lower level?", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r366000761", "createdAt": "2020-01-13T20:01:25Z", "author": {"login": "schlosna"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +28,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        Round next = present.awaitDone();\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;\n+\n+        boolean isFirstToArrive() {\n+            return !hasStarted.get() && hasStarted.compareAndSet(false, true);\n         }\n-    }\n \n-    private void resetAndCompleteIfNotCompleted(CompletableFuture<T> future) {\n-        if (future.isDone()) {\n-            return;\n+        Round awaitDone() {\n+            try {\n+                future.join();\n+            } catch (CompletionException e) {\n+                // ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f508977a98ef83b2074bfb7748cd9dcf90a103d9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwNjQ4MA==", "bodyText": "it's intended behaviour - we're literally just awaiting the conclusion of the future", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r366006480", "createdAt": "2020-01-13T20:15:34Z", "author": {"login": "j-baker"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +28,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        Round next = present.awaitDone();\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;\n+\n+        boolean isFirstToArrive() {\n+            return !hasStarted.get() && hasStarted.compareAndSet(false, true);\n         }\n-    }\n \n-    private void resetAndCompleteIfNotCompleted(CompletableFuture<T> future) {\n-        if (future.isDone()) {\n-            return;\n+        Round awaitDone() {\n+            try {\n+                future.join();\n+            } catch (CompletionException e) {\n+                // ignore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwMDc2MQ=="}, "originalCommit": {"oid": "f508977a98ef83b2074bfb7748cd9dcf90a103d9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwNjcyNg==", "bodyText": "we just want it to be complete. We shouldn't do anything with the exception because it's never relevant in this method.", "url": "https://github.com/palantir/atlasdb/pull/4508#discussion_r366006726", "createdAt": "2020-01-13T20:16:11Z", "author": {"login": "j-baker"}, "path": "atlasdb-commons/src/main/java/com/palantir/common/concurrent/CoalescingSupplier.java", "diffHunk": "@@ -29,52 +28,61 @@\n  * requested; requests will not receive results for computations that started prior to the request.\n  */\n public class CoalescingSupplier<T> implements Supplier<T> {\n-\n     private final Supplier<T> delegate;\n-    private volatile CompletableFuture<T> nextResult = new CompletableFuture<T>();\n-    private final Lock fairLock = new ReentrantLock(true);\n+    private volatile Round nextResult = new Round();\n \n     public CoalescingSupplier(Supplier<T> delegate) {\n         this.delegate = delegate;\n     }\n \n     @Override\n     public T get() {\n-        CompletableFuture<T> future = nextResult;\n-\n-        completeOrWaitForCompletion(future);\n-\n-        return getResult(future);\n+        Round present = nextResult;\n+        if (present.isFirstToArrive()) {\n+            present.execute();\n+            return present.getResult();\n+        }\n+        Round next = present.awaitDone();\n+        if (next.isFirstToArrive()) {\n+            next.execute();\n+        }\n+        return next.getResult();\n     }\n \n-    private void completeOrWaitForCompletion(CompletableFuture<T> future) {\n-        fairLock.lock();\n-        try {\n-            resetAndCompleteIfNotCompleted(future);\n-        } finally {\n-            fairLock.unlock();\n+    private final class Round {\n+        private final AtomicBoolean hasStarted = new AtomicBoolean(false);\n+        private final CompletableFuture<T> future = new CompletableFuture<>();\n+        private volatile Round next;\n+\n+        boolean isFirstToArrive() {\n+            return !hasStarted.get() && hasStarted.compareAndSet(false, true);\n         }\n-    }\n \n-    private void resetAndCompleteIfNotCompleted(CompletableFuture<T> future) {\n-        if (future.isDone()) {\n-            return;\n+        Round awaitDone() {\n+            try {\n+                future.join();\n+            } catch (CompletionException e) {\n+                // ignore", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwMDc2MQ=="}, "originalCommit": {"oid": "f508977a98ef83b2074bfb7748cd9dcf90a103d9"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2397, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}