{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNDY0MDA3", "number": 4793, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozOToyMlrOD-sB4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzoyMDowNFrOEAFunw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDU5NjgzOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozOToyMlrOGY8WQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzozOToyMlrOGY8WQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNzc0Nw==", "bodyText": "Seems like we should truncate both? Or just throw UnsupportedOperationException given where we're deploying this", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r428807747", "createdAt": "2020-05-21T17:39:22Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+\n+import com.palantir.common.persist.Persistable;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * e update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+\n+    public SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        if (seq >= cutoffInclusive) {\n+            currentLog.writeRound(seq, round);\n+        } else {\n+            markLegacyWrite.run();\n+            legacyLog.writeRound(seq, round);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        if (seq >= cutoffInclusive) {\n+            return currentLog.readRound(seq);\n+        } else {\n+            markLegacyRead.run();\n+            return legacyLog.readRound(seq);\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return currentLog.getLeastLogEntry();\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return currentLog.getGreatestLogEntry();\n+    }\n+\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        currentLog.truncate(toDeleteInclusive);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae1c1dea8ddae53b161dd69ce871713235d75df8"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDYwNDUzOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo0MTo0NVrOGY8bTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzo0MTo0NVrOGY8bTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwOTAzNw==", "bodyText": "We should talk about this one: I think it needs careful thought. The acceptors for example are just going to fail the legacy requests with a TruncatedStateLogException (see PaxosAcceptor.checkLogIfNeeded()) which might affect our visibility into them", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r428809037", "createdAt": "2020-05-21T17:41:45Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+\n+import com.palantir.common.persist.Persistable;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * e update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+\n+    public SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        if (seq >= cutoffInclusive) {\n+            currentLog.writeRound(seq, round);\n+        } else {\n+            markLegacyWrite.run();\n+            legacyLog.writeRound(seq, round);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        if (seq >= cutoffInclusive) {\n+            return currentLog.readRound(seq);\n+        } else {\n+            markLegacyRead.run();\n+            return legacyLog.readRound(seq);\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return currentLog.getLeastLogEntry();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae1c1dea8ddae53b161dd69ce871713235d75df8"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDc0OTM1OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo0NDowNFrOGace1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo0NDowNFrOGace1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM4MjgwNg==", "bodyText": "Good to disambiguate the types", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r430382806", "createdAt": "2020-05-26T12:44:04Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+    private final AtomicLong leastLogEntry;\n+\n+    private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive,\n+            AtomicLong leastLogEntry) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+        this.leastLogEntry = leastLogEntry;\n+    }\n+\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        return new SplittingPaxosStateLog<>(\n+                parameters.legacyLog(),\n+                parameters.currentLog(),\n+                parameters.markLegacyWrite(),\n+                parameters.markLegacyRead(),\n+                parameters.cutoffInclusive(),\n+                new AtomicLong(Math.min(parameters.legacyLog().getLeastLogEntry(), parameters.cutoffInclusive())));\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        if (seq >= cutoffInclusive) {\n+            currentLog.writeRound(seq, round);\n+        } else {\n+            markLegacyWrite.run();\n+            legacyLog.writeRound(seq, round);\n+            leastLogEntry.accumulateAndGet(seq, Math::min);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        if (seq >= cutoffInclusive) {\n+            return currentLog.readRound(seq);\n+        } else {\n+            markLegacyRead.run();\n+            return legacyLog.readRound(seq);\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return leastLogEntry.get();\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return currentLog.getGreatestLogEntry();\n+    }\n+\n+    /**\n+     * This implementation is a noop to ensure correctness of {@link #getLeastLogEntry()}.\n+     */\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        // noop\n+    }\n+\n+    @Value.Immutable\n+    abstract static class SplittingParameters<V extends Persistable & Versionable> {\n+        abstract PaxosStateLog<V> legacyLog();\n+        abstract PaxosStateLog<V> currentLog();\n+        abstract Runnable markLegacyWrite();\n+        abstract Runnable markLegacyRead();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6b637f0964be274182692688e5fd2a20cc6e829"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDc2ODAyOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo0ODo1NFrOGacqQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMzo0OToyM1rOGafJLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM4NTcyOA==", "bodyText": "This does incur a read whenever creating this object.\nThis is constructed once per (client, use-case). Let's go ahead with this for now I think", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r430385728", "createdAt": "2020-05-26T12:48:54Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+    private final AtomicLong leastLogEntry;\n+\n+    private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive,\n+            AtomicLong leastLogEntry) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+        this.leastLogEntry = leastLogEntry;\n+    }\n+\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        return new SplittingPaxosStateLog<>(\n+                parameters.legacyLog(),\n+                parameters.currentLog(),\n+                parameters.markLegacyWrite(),\n+                parameters.markLegacyRead(),\n+                parameters.cutoffInclusive(),\n+                new AtomicLong(Math.min(parameters.legacyLog().getLeastLogEntry(), parameters.cutoffInclusive())));\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        if (seq >= cutoffInclusive) {\n+            currentLog.writeRound(seq, round);\n+        } else {\n+            markLegacyWrite.run();\n+            legacyLog.writeRound(seq, round);\n+            leastLogEntry.accumulateAndGet(seq, Math::min);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        if (seq >= cutoffInclusive) {\n+            return currentLog.readRound(seq);\n+        } else {\n+            markLegacyRead.run();\n+            return legacyLog.readRound(seq);\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return leastLogEntry.get();\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return currentLog.getGreatestLogEntry();\n+    }\n+\n+    /**\n+     * This implementation is a noop to ensure correctness of {@link #getLeastLogEntry()}.\n+     */\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        // noop\n+    }\n+\n+    @Value.Immutable\n+    abstract static class SplittingParameters<V extends Persistable & Versionable> {\n+        abstract PaxosStateLog<V> legacyLog();\n+        abstract PaxosStateLog<V> currentLog();\n+        abstract Runnable markLegacyWrite();\n+        abstract Runnable markLegacyRead();\n+        abstract long cutoffInclusive();\n+\n+        @Value.Check\n+        void cutoffEntryMustBeInCurrentLogOrEqualToNoEntry() {\n+            try {\n+                Preconditions.checkState(cutoffInclusive() == PaxosAcceptor.NO_LOG_ENTRY\n+                                || currentLog().readRound(cutoffInclusive()) != null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6b637f0964be274182692688e5fd2a20cc6e829"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQyNjQxMg==", "bodyText": "discussing offline:\n\nActually, we want to check that at least one entry exists in the new log after the cutoff - and this can be checked by verifying that the greatest log entry in currentLog() is at least the cutoff", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r430426412", "createdAt": "2020-05-26T13:49:23Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+    private final AtomicLong leastLogEntry;\n+\n+    private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive,\n+            AtomicLong leastLogEntry) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+        this.leastLogEntry = leastLogEntry;\n+    }\n+\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        return new SplittingPaxosStateLog<>(\n+                parameters.legacyLog(),\n+                parameters.currentLog(),\n+                parameters.markLegacyWrite(),\n+                parameters.markLegacyRead(),\n+                parameters.cutoffInclusive(),\n+                new AtomicLong(Math.min(parameters.legacyLog().getLeastLogEntry(), parameters.cutoffInclusive())));\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        if (seq >= cutoffInclusive) {\n+            currentLog.writeRound(seq, round);\n+        } else {\n+            markLegacyWrite.run();\n+            legacyLog.writeRound(seq, round);\n+            leastLogEntry.accumulateAndGet(seq, Math::min);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        if (seq >= cutoffInclusive) {\n+            return currentLog.readRound(seq);\n+        } else {\n+            markLegacyRead.run();\n+            return legacyLog.readRound(seq);\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return leastLogEntry.get();\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return currentLog.getGreatestLogEntry();\n+    }\n+\n+    /**\n+     * This implementation is a noop to ensure correctness of {@link #getLeastLogEntry()}.\n+     */\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        // noop\n+    }\n+\n+    @Value.Immutable\n+    abstract static class SplittingParameters<V extends Persistable & Versionable> {\n+        abstract PaxosStateLog<V> legacyLog();\n+        abstract PaxosStateLog<V> currentLog();\n+        abstract Runnable markLegacyWrite();\n+        abstract Runnable markLegacyRead();\n+        abstract long cutoffInclusive();\n+\n+        @Value.Check\n+        void cutoffEntryMustBeInCurrentLogOrEqualToNoEntry() {\n+            try {\n+                Preconditions.checkState(cutoffInclusive() == PaxosAcceptor.NO_LOG_ENTRY\n+                                || currentLog().readRound(cutoffInclusive()) != null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM4NTcyOA=="}, "originalCommit": {"oid": "b6b637f0964be274182692688e5fd2a20cc6e829"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDc5MDU5OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo1NDo0NlrOGac4rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo1NToxM1rOGac5_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM4OTQyMQ==", "bodyText": "Discussed offline: This is ok as long as we make sure internal server doesn't say that it is fully ready until this has completed for all clients.", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r430389421", "createdAt": "2020-05-26T12:54:46Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+    private final AtomicLong leastLogEntry;\n+\n+    private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive,\n+            AtomicLong leastLogEntry) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+        this.leastLogEntry = leastLogEntry;\n+    }\n+\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        return new SplittingPaxosStateLog<>(\n+                parameters.legacyLog(),\n+                parameters.currentLog(),\n+                parameters.markLegacyWrite(),\n+                parameters.markLegacyRead(),\n+                parameters.cutoffInclusive(),\n+                new AtomicLong(Math.min(parameters.legacyLog().getLeastLogEntry(), parameters.cutoffInclusive())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6b637f0964be274182692688e5fd2a20cc6e829"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM4OTc1OQ==", "bodyText": "We can also hack in an optimisation to make getLeastLogEntry() faster at a majority of installations.", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r430389759", "createdAt": "2020-05-26T12:55:13Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+    private final AtomicLong leastLogEntry;\n+\n+    private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive,\n+            AtomicLong leastLogEntry) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+        this.leastLogEntry = leastLogEntry;\n+    }\n+\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        return new SplittingPaxosStateLog<>(\n+                parameters.legacyLog(),\n+                parameters.currentLog(),\n+                parameters.markLegacyWrite(),\n+                parameters.markLegacyRead(),\n+                parameters.cutoffInclusive(),\n+                new AtomicLong(Math.min(parameters.legacyLog().getLeastLogEntry(), parameters.cutoffInclusive())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM4OTQyMQ=="}, "originalCommit": {"oid": "b6b637f0964be274182692688e5fd2a20cc6e829"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDgwMjk5OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo1Nzo0OFrOGadAWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMjo1Nzo0OFrOGadAWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM5MTM4Ng==", "bodyText": "log.warn(\"Tried to truncate with an impl that doesn't support it\") or something like that please, this may confuse unsuspecting users.", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r430391386", "createdAt": "2020-05-26T12:57:48Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.Preconditions;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} delegates all reads and writes of rounds to one of two delegates, as\n+ * determined by the cutoff point. If a read or write does occur prior to the cutoff point, i.e., to the legacy delegate\n+ * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n+ */\n+public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private final PaxosStateLog<V> legacyLog;\n+    private final PaxosStateLog<V> currentLog;\n+    private final Runnable markLegacyWrite;\n+    private final Runnable markLegacyRead;\n+    private final long cutoffInclusive;\n+    private final AtomicLong leastLogEntry;\n+\n+    private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n+            PaxosStateLog<V> currentLog,\n+            Runnable markLegacyWrite,\n+            Runnable markLegacyRead,\n+            long cutoffInclusive,\n+            AtomicLong leastLogEntry) {\n+        this.legacyLog = legacyLog;\n+        this.currentLog = currentLog;\n+        this.markLegacyWrite = markLegacyWrite;\n+        this.markLegacyRead = markLegacyRead;\n+        this.cutoffInclusive = cutoffInclusive;\n+        this.leastLogEntry = leastLogEntry;\n+    }\n+\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        return new SplittingPaxosStateLog<>(\n+                parameters.legacyLog(),\n+                parameters.currentLog(),\n+                parameters.markLegacyWrite(),\n+                parameters.markLegacyRead(),\n+                parameters.cutoffInclusive(),\n+                new AtomicLong(Math.min(parameters.legacyLog().getLeastLogEntry(), parameters.cutoffInclusive())));\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        if (seq >= cutoffInclusive) {\n+            currentLog.writeRound(seq, round);\n+        } else {\n+            markLegacyWrite.run();\n+            legacyLog.writeRound(seq, round);\n+            leastLogEntry.accumulateAndGet(seq, Math::min);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        if (seq >= cutoffInclusive) {\n+            return currentLog.readRound(seq);\n+        } else {\n+            markLegacyRead.run();\n+            return legacyLog.readRound(seq);\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return leastLogEntry.get();\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return currentLog.getGreatestLogEntry();\n+    }\n+\n+    /**\n+     * This implementation is a noop to ensure correctness of {@link #getLeastLogEntry()}.\n+     */\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        // noop", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6b637f0964be274182692688e5fd2a20cc6e829"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTI0NjYyOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzoxMzoxOFrOGbJLJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzoxMzoxOFrOGbJLJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTExNTA0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            \"Cutoff value must either be -1, or the current log must contain en entry after the cutoff.\");\n          \n          \n            \n                            \"Cutoff value must either be -1, or the current log must contain an entry after the cutoff.\");", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r431115044", "createdAt": "2020-05-27T13:13:18Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SplittingPaxosStateLog.java", "diffHunk": "@@ -30,35 +32,40 @@\n  * we update the appropriate metric. Remaining methods are delegated only to the current delegate.\n  */\n public final class SplittingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(SplittingPaxosStateLog.class);\n+\n     private final PaxosStateLog<V> legacyLog;\n     private final PaxosStateLog<V> currentLog;\n     private final Runnable markLegacyWrite;\n     private final Runnable markLegacyRead;\n     private final long cutoffInclusive;\n-    private final AtomicLong leastLogEntry;\n+    private final AtomicLong legacyLogLeastLogEntry;\n \n     private SplittingPaxosStateLog(PaxosStateLog<V> legacyLog,\n             PaxosStateLog<V> currentLog,\n             Runnable markLegacyWrite,\n             Runnable markLegacyRead,\n             long cutoffInclusive,\n-            AtomicLong leastLogEntry) {\n+            AtomicLong legacyLogLeastLogEntry) {\n         this.legacyLog = legacyLog;\n         this.currentLog = currentLog;\n         this.markLegacyWrite = markLegacyWrite;\n         this.markLegacyRead = markLegacyRead;\n         this.cutoffInclusive = cutoffInclusive;\n-        this.leastLogEntry = leastLogEntry;\n+        this.legacyLogLeastLogEntry = legacyLogLeastLogEntry;\n     }\n \n     public static <V extends Persistable & Versionable> PaxosStateLog<V> create(SplittingParameters<V> parameters) {\n+        Preconditions.checkState(parameters.cutoffInclusive() == PaxosAcceptor.NO_LOG_ENTRY\n+                        || parameters.currentLog().getGreatestLogEntry() >= parameters.cutoffInclusive(),\n+                \"Cutoff value must either be -1, or the current log must contain en entry after the cutoff.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bded1cc78498cc6100e82425fadbdb600554a98f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTI5MzExOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzoyMDowNFrOGbJsCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMzoyMDowNFrOGbJsCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTEyMzQ2Ng==", "bodyText": "nit: We could probably just use mock-maker-inline", "url": "https://github.com/palantir/atlasdb/pull/4793#discussion_r431123466", "createdAt": "2020-05-27T13:20:04Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -34,7 +34,8 @@\n \n import com.palantir.common.persist.Persistable;\n \n-public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+@SuppressWarnings(\"FinalClass\") // non-final for mocking", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bded1cc78498cc6100e82425fadbdb600554a98f"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2870, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}