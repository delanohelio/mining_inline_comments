{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4Mzk0NzU5", "number": 4592, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTowNVrODiu5xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MzoyMlrODiz6fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ2NjI5OnYy", "diffSide": "RIGHT", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTowNVrOFuJLvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTowNVrOFuJLvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTI3OA==", "bodyText": "Ideally would like some JavaDoc on what the updates mean here (success = you're current, snapshot = you're behind but here's the state of the world, failed = I couldn't get you a state of the world).", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383929278", "createdAt": "2020-02-25T14:55:05Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java", "diffHunk": "@@ -17,53 +17,96 @@\n package com.palantir.lock.watch;\n \n import java.util.List;\n-import java.util.OptionalLong;\n+import java.util.Set;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.google.common.collect.ImmutableList;\n-import com.palantir.logsafe.Preconditions;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n \n-@Value.Immutable\n-@Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n-@JsonSerialize(as = ImmutableLockWatchStateUpdate.class)\n-@JsonDeserialize(as = ImmutableLockWatchStateUpdate.class)\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+@JsonSubTypes({\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Failed.class, name = LockWatchStateUpdate.Failed.TYPE),\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Success.class, name = LockWatchStateUpdate.Success.TYPE),\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Snapshot.class, name = LockWatchStateUpdate.Snapshot.TYPE)})\n public interface LockWatchStateUpdate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ3NTUzOnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NzoxM1rOFuJRoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NzoxM1rOFuJRoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDc4NQ==", "bodyText": "nit: just call lastVersion() here?", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383930785", "createdAt": "2020-02-25T14:57:13Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -74,21 +83,23 @@ public synchronized void add(LockWatchEvent.Builder eventBuilder) {\n      *      this method, that is no longer the case when the method returns.\n      */\n     public Optional<List<LockWatchEvent>> getFromVersion(long version) {\n-        long lastWrittenSequence = nextSequence - 1;\n+        return getFromTo(version, nextSequence - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ4NjMxOnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1OTozMlrOFuJYSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1OTozMlrOFuJYSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjQ4OA==", "bodyText": "please use heldLocksCollection or locksCollection, HeldLocks is a different object which made me find this section a bit confusing", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383932488", "createdAt": "2020-02-25T14:59:32Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java", "diffHunk": "@@ -16,38 +16,94 @@\n \n package com.palantir.atlasdb.timelock.lock.watch;\n \n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n import java.util.OptionalLong;\n import java.util.Set;\n import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n+import com.google.common.collect.RangeSet;\n+import com.palantir.atlasdb.timelock.lock.AsyncLock;\n+import com.palantir.atlasdb.timelock.lock.HeldLocksCollection;\n import com.palantir.lock.LockDescriptor;\n import com.palantir.lock.v2.LockToken;\n import com.palantir.lock.watch.LockEvent;\n import com.palantir.lock.watch.LockWatchCreatedEvent;\n import com.palantir.lock.watch.LockWatchEvent;\n-import com.palantir.lock.watch.LockWatchOpenLocksEvent;\n-import com.palantir.lock.watch.LockWatchRequest;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n import com.palantir.lock.watch.LockWatchStateUpdate;\n import com.palantir.lock.watch.UnlockEvent;\n \n public class LockEventLogImpl implements LockEventLog {\n-    private final UUID leaderId = UUID.randomUUID();\n+    private final UUID logId = UUID.randomUUID();\n     private final ArrayLockEventSlidingWindow slidingWindow = new ArrayLockEventSlidingWindow(1000);\n+    private final Supplier<LockWatches> watchesSupplier;\n+    private final HeldLocksCollection heldLocks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzUyNTU4OnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNTowODo0OFrOFuJwXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNTowODo0OFrOFuJwXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzODY1Mw==", "bodyText": "nice!", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383938653", "createdAt": "2020-02-25T15:08:48Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImplTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.OptionalLong;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.RangeSet;\n+import com.google.common.collect.TreeRangeSet;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.watch.LockWatchReferenceUtils;\n+import com.palantir.atlasdb.timelock.lock.AsyncLock;\n+import com.palantir.atlasdb.timelock.lock.ExclusiveLock;\n+import com.palantir.atlasdb.timelock.lock.HeldLocks;\n+import com.palantir.atlasdb.timelock.lock.HeldLocksCollection;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+public class LockEventLogImplTest {\n+    private final AtomicReference<LockWatches> lockWatches = new AtomicReference<>(LockWatches.create());\n+    private final HeldLocksCollection heldLocksCollection = mock(HeldLocksCollection.class);\n+    private final HeldLocks heldLocks = mock(HeldLocks.class);\n+    private final LockEventLog log = new LockEventLogImpl(lockWatches::get, heldLocksCollection);\n+\n+    private static final TableReference TABLE_REF = TableReference.createFromFullyQualifiedName(\"test.table\");\n+    private static final String TABLE = TABLE_REF.getQualifiedName();\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"1\"));\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"2\"));\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"3\"));\n+    private static final AsyncLock LOCK_2 = new ExclusiveLock(DESCRIPTOR_2);\n+    private static final AsyncLock LOCK_3 = new ExclusiveLock(DESCRIPTOR_3);\n+    private static final LockToken TOKEN = LockToken.of(UUID.randomUUID());\n+\n+    @Before\n+    public void setupMocks() {\n+        when(heldLocks.getLocks()).thenReturn(ImmutableSet.of(LOCK_2, LOCK_3));\n+        when(heldLocks.getToken()).thenReturn(TOKEN);\n+        when(heldLocksCollection.locksHeld()).thenReturn(ImmutableSet.of(heldLocks));\n+    }\n+\n+    @Test\n+    public void lockUpdateTest() {\n+        ImmutableSet<LockDescriptor> locks = ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2);\n+        log.logLock(locks, TOKEN);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(LockEvent.builder(locks, TOKEN).build(0L));\n+    }\n+\n+    @Test\n+    public void unlockUpdateTest() {\n+        ImmutableSet<LockDescriptor> locks = ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2);\n+        log.logUnlock(locks);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(UnlockEvent.builder(locks).build(0L));\n+    }\n+\n+    @Test\n+    public void createLockWatchUpdateTest() {\n+        LockWatchReference secondRowReference = LockWatchReferenceUtils.rowPrefix(TABLE_REF, PtBytes.toBytes(\"2\"));\n+        LockWatches newWatches = createWatchesFor(secondRowReference);\n+        log.logLockWatchCreated(newWatches);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(\n+                        newWatches.references(),\n+                        ImmutableSet.of(DESCRIPTOR_2))\n+                        .build(0L));\n+    }\n+\n+    @Test\n+    public void noKnownVersionReturnsSnapshotContainingCurrentMatchingLocks() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.empty());\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(-1L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void snapshotIgnoresPreviousLogEntriesInLocksCalculation() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        log.logLock(ImmutableSet.of(DESCRIPTOR), TOKEN);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.empty());\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(0L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void requestForTheFutureReturnsSnapshot() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(100L));\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(-1L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void snapshotReflectsEventsOcurringDuringOpenLocksCalculation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODI4NzMyOnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockWatchingServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MzoyMlrOFuRDtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MzoyMlrOFuRDtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1ODI5Mw==", "bodyText": "yep, this is exactly what I was looking for. Thanks!", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r384058293", "createdAt": "2020-02-25T18:53:22Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockWatchingServiceImplTest.java", "diffHunk": "@@ -105,6 +105,29 @@ public void registeringWatchWithWiderScopeLogsAlreadyWatchedLocksAgain() {\n         assertLoggedEvents(expectedEvents);\n     }\n \n+    @Test\n+    public void registeringWatchWithOverlappingScopeLogsAlreadyWatchedLocksInScopeAgain() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cd8d27ea941e103c42de38676dc595328baabdc"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2318, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}