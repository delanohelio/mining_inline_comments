{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NTMwMDQw", "number": 5011, "title": "[DB TimeLock] 1B, 1C: DB TimeLock for Multiple Series", "bodyText": "Goals (and why):\n\nAllow DB Timelock to support multiple namespaces and behave correctly in these circumstances.\nDon't actually turn it on.\n\nImplementation Description (bullets):\n\nChange the timestamp bound store to accept a strategy that in its legacy form reads/writes from a simple table\nAnd in the new format has a namespace -> last_allocated mapping.\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nExisting ETEs/integrations should valid nothing broke here: we are still using the old impl.\nI added some tests specific to the new bound store impl\n\nConcerns (what feedback would you like?):\n\nThe SQL handling code is laden with technical debt, but given timelines I don't really see us cleaning this up right now. I'd consider dedicating two days post-workstream to clean up this path.\nThere may be some duplication when we create the Oracle version of the Postgres multi series test, though an abstract test class hierarchy here felt like more complexity than I would like.\n\nWhere should we start reviewing?: MultiSeriesDbTimestampBoundStore\nPriority (whenever / two weeks / yesterday): today would be nice, but tomorrow is fine too", "createdAt": "2020-09-30T13:56:52Z", "url": "https://github.com/palantir/atlasdb/pull/5011", "merged": true, "mergeCommit": {"oid": "d23f04604a817a52c4d443d00a9991ec4b9175e9"}, "closed": true, "closedAt": "2020-10-01T18:16:00Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNc8mXgH2gAyNDk1NTMwMDQwOjJjMjA5MDJhODgyMDMzNTEzMDA1NGI5OWVlMWIyZTM3MTYzZmVkODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOVJuMAH2gAyNDk1NTMwMDQwOmJlZDUzZWJlYmEzMTBkMDM0ODYwMjEwZTNlZjhlYTE2Mzc3ZDdiMjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2c20902a8820335130054b99ee1b2e37163fed81", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/2c20902a8820335130054b99ee1b2e37163fed81", "committedDate": "2020-09-29T00:21:47Z", "message": "Refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e11a7ed128a5ab988225202cde18bf4f06ad356", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/5e11a7ed128a5ab988225202cde18bf4f06ad356", "committedDate": "2020-09-29T00:23:00Z", "message": "rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f57f752c720eb87a33939c6f95133c79938082d", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/6f57f752c720eb87a33939c6f95133c79938082d", "committedDate": "2020-09-29T00:48:48Z", "message": "multi seq"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4689810f02adff7d2b34a247bb684aee66736cf7", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/4689810f02adff7d2b34a247bb684aee66736cf7", "committedDate": "2020-09-30T10:56:25Z", "message": "refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2536960d7b2af0e811b2cbf2040d837b8be6ee3", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/f2536960d7b2af0e811b2cbf2040d837b8be6ee3", "committedDate": "2020-09-30T10:56:30Z", "message": "utils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe2fb565c18617d85cd52ada5abcee1366f3535", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/0fe2fb565c18617d85cd52ada5abcee1366f3535", "committedDate": "2020-09-30T12:35:11Z", "message": "updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d340284a07e1356a4cdadaee2492e735bcd58cce", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/d340284a07e1356a4cdadaee2492e735bcd58cce", "committedDate": "2020-09-30T12:35:19Z", "message": "multiseries tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c23842d67e2bc904f959bf5186a012cf2f65eae", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/3c23842d67e2bc904f959bf5186a012cf2f65eae", "committedDate": "2020-09-30T13:36:49Z", "message": "Baseline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90bb5a9a1320fa11cea2aa3c6cf68699ffc093c3", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/90bb5a9a1320fa11cea2aa3c6cf68699ffc093c3", "committedDate": "2020-09-30T13:49:31Z", "message": "audit previous legacy tables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/70b87434c3c58e1938baadd30e39d934b1582894", "committedDate": "2020-09-30T13:53:02Z", "message": "refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzEwMjQ5", "url": "https://github.com/palantir/atlasdb/pull/5011#pullrequestreview-500310249", "createdAt": "2020-10-01T12:48:53Z", "commit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMjo0ODo1M1rOHbIxrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMzowNDoyMlrOHbJYpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxNzM5MA==", "bodyText": "\ud83d\udcaf", "url": "https://github.com/palantir/atlasdb/pull/5011#discussion_r498217390", "createdAt": "2020-10-01T12:48:53Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/InDbTimestampBoundStore.java", "diffHunk": "@@ -72,32 +62,39 @@ public static InDbTimestampBoundStore create(\n             ConnectionManager connManager,\n             TableReference timestampTable,\n             String tablePrefixString) {\n-        InDbTimestampBoundStore inDbTimestampBoundStore = new InDbTimestampBoundStore(\n-                connManager,\n-                timestampTable,\n-                tablePrefixString);\n+        return createWithStrategy(connManager, new LegacyPhysicalBoundStoreStrategy(timestampTable, tablePrefixString));\n+    }\n \n-        inDbTimestampBoundStore.init();\n+    public static InDbTimestampBoundStore createForMultiSeries(\n+            ConnectionManager connManager,\n+            TableReference timestampTable,\n+            String series) {\n+        return createWithStrategy(connManager, new MultiSequencePhysicalBoundStoreStrategy(timestampTable, series));\n+    }\n \n+    private static InDbTimestampBoundStore createWithStrategy(ConnectionManager connManager,\n+            PhysicalBoundStoreStrategy strategy) {\n+        InDbTimestampBoundStore inDbTimestampBoundStore = new InDbTimestampBoundStore(connManager, strategy);\n+        inDbTimestampBoundStore.init();\n         return inDbTimestampBoundStore;\n     }\n \n-    private InDbTimestampBoundStore(ConnectionManager connManager, TableReference timestampTable, String tablePrefix) {\n+    private InDbTimestampBoundStore(ConnectionManager connManager,\n+            PhysicalBoundStoreStrategy physicalBoundStoreStrategy) {\n         this.connManager = Preconditions.checkNotNull(connManager, \"connectionManager is required\");\n-        this.timestampTable = Preconditions.checkNotNull(timestampTable, \"timestampTable is required\");\n-        this.tablePrefix = tablePrefix;\n+        this.physicalBoundStoreStrategy = physicalBoundStoreStrategy;\n     }\n \n     private void init() {\n         try (Connection conn = connManager.getConnection()) {\n-            createTimestampTable(conn);\n+            physicalBoundStoreStrategy.createTimestampTable(conn, this::getDbType);\n         } catch (SQLException error) {\n             throw PalantirSqlException.create(error);\n         }\n     }\n \n     private interface Operation {\n-        long run(Connection connection, @Nullable Long oldLimit) throws SQLException;\n+        long run(Connection connection, OptionalLong oldLimit) throws SQLException;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyMTc3MQ==", "bodyText": "nit: this is not being used anymore?", "url": "https://github.com/palantir/atlasdb/pull/5011#discussion_r498221771", "createdAt": "2020-10-01T12:55:42Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/LegacyPhysicalBoundStoreStrategy.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.nexus.db.DBType;\n+\n+public class LegacyPhysicalBoundStoreStrategy implements PhysicalBoundStoreStrategy {\n+    private static final Logger log = LoggerFactory.getLogger(LegacyPhysicalBoundStoreStrategy.class);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyMzIwNA==", "bodyText": "\ud83d\udcaf", "url": "https://github.com/palantir/atlasdb/pull/5011#discussion_r498223204", "createdAt": "2020-10-01T12:57:50Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/MultiSequencePhysicalBoundStoreStrategy.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.nexus.db.DBType;\n+\n+public class MultiSequencePhysicalBoundStoreStrategy implements PhysicalBoundStoreStrategy {\n+    private static final Logger log = LoggerFactory.getLogger(MultiSequencePhysicalBoundStoreStrategy.class);\n+\n+    private final TableReference timestampTable;\n+    private final String series;\n+\n+    public MultiSequencePhysicalBoundStoreStrategy(TableReference timestampTable, String series) {\n+        this.timestampTable = timestampTable;\n+        this.series = series;\n+    }\n+\n+    @Override\n+    public void createTimestampTable(Connection connection, Function<Connection, DBType> dbTypeExtractor)\n+            throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                connection,\n+                dbTypeExtractor,\n+                ImmutableCreateTimestampTableQueries.builder().postgresQuery(\n+                        String.format(\"CREATE TABLE IF NOT EXISTS %s (\"\n+                                        + \" client VARCHAR(2000) NOT NULL,\"\n+                                        + \" last_allocated int8 NOT NULL,\"\n+                                        + \" PRIMARY KEY (client))\",\n+                                timestampTable.getQualifiedName()))\n+                .oracleQuery(\n+                        String.format(\"CREATE TABLE %s (\"\n+                                        + \" client VARCHAR(2000) NOT NULL,\"\n+                                        + \" last_allocated NUMBER(38) NOT NULL,\"\n+                                        + \" CONSTRAINT %s_pk PRIMARY KEY (client))\",\n+                                timestampTable.getQualifiedName(),\n+                                timestampTable.getQualifiedName()))\n+                .build());\n+    }\n+\n+    @Override\n+    public OptionalLong readLimit(Connection connection) throws SQLException {\n+        String sql = String.format(\"SELECT last_allocated FROM %s WHERE client = ? FOR UPDATE\",\n+                timestampTable.getQualifiedName());\n+        QueryRunner run = new QueryRunner();\n+        return run.query(connection, sql, PhysicalBoundStoreDatabaseUtils::getLastAllocatedColumn, series);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyNjQwMQ==", "bodyText": "I see we're removing the option of providing tablePrefix for multi series, which should be fine. Maybe we should should use Client rather than String for type checking?", "url": "https://github.com/palantir/atlasdb/pull/5011#discussion_r498226401", "createdAt": "2020-10-01T13:02:51Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/InDbTimestampBoundStore.java", "diffHunk": "@@ -72,32 +62,39 @@ public static InDbTimestampBoundStore create(\n             ConnectionManager connManager,\n             TableReference timestampTable,\n             String tablePrefixString) {\n-        InDbTimestampBoundStore inDbTimestampBoundStore = new InDbTimestampBoundStore(\n-                connManager,\n-                timestampTable,\n-                tablePrefixString);\n+        return createWithStrategy(connManager, new LegacyPhysicalBoundStoreStrategy(timestampTable, tablePrefixString));\n+    }\n \n-        inDbTimestampBoundStore.init();\n+    public static InDbTimestampBoundStore createForMultiSeries(\n+            ConnectionManager connManager,\n+            TableReference timestampTable,\n+            String series) {\n+        return createWithStrategy(connManager, new MultiSequencePhysicalBoundStoreStrategy(timestampTable, series));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyNjU5Mw==", "bodyText": "Same as above.", "url": "https://github.com/palantir/atlasdb/pull/5011#discussion_r498226593", "createdAt": "2020-10-01T13:03:11Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/MultiSequencePhysicalBoundStoreStrategy.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.nexus.db.DBType;\n+\n+public class MultiSequencePhysicalBoundStoreStrategy implements PhysicalBoundStoreStrategy {\n+    private static final Logger log = LoggerFactory.getLogger(MultiSequencePhysicalBoundStoreStrategy.class);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyNzM2NA==", "bodyText": "Maybe add a comment that pg query to create table already accommodates this check?", "url": "https://github.com/palantir/atlasdb/pull/5011#discussion_r498227364", "createdAt": "2020-10-01T13:04:22Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/PhysicalBoundStoreDatabaseUtils.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.keyvalue.dbkvs.OracleErrorConstants;\n+import com.palantir.nexus.db.DBType;\n+\n+public final class PhysicalBoundStoreDatabaseUtils {\n+    private static final Logger log = LoggerFactory.getLogger(PhysicalBoundStoreDatabaseUtils.class);\n+\n+    private PhysicalBoundStoreDatabaseUtils() {\n+        // utilities\n+    }\n+\n+    public static void createTimestampTable(Connection connection,\n+            Function<Connection, DBType> dbTypeExtractor,\n+            CreateTimestampTableQueries queries) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (dbTypeExtractor.apply(connection).equals(DBType.ORACLE)) {\n+                createTimestampTableIgnoringAlreadyExistsError(statement, queries.oracleQuery());\n+            } else {\n+                statement.execute(queries.postgresQuery());\n+            }\n+        }\n+    }\n+\n+    private static void createTimestampTableIgnoringAlreadyExistsError(\n+            Statement statement, String oracleQuery) throws SQLException {\n+        try {\n+            statement.execute(oracleQuery);\n+        } catch (SQLException e) {\n+            if (!e.getMessage().contains(OracleErrorConstants.ORACLE_ALREADY_EXISTS_ERROR)) {\n+                log.error(\"Error occurred creating the Oracle timestamp table\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b87434c3c58e1938baadd30e39d934b1582894"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d87866b9c2a8fc9fbed20bb6b50afe9e47599ec", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/4d87866b9c2a8fc9fbed20bb6b50afe9e47599ec", "committedDate": "2020-10-01T17:31:58Z", "message": "CR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bed53ebeba310d034860210e3ef8ea16377d7b20", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/bed53ebeba310d034860210e3ef8ea16377d7b20", "committedDate": "2020-10-01T17:50:48Z", "message": "This is why type checking is important"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2610, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}