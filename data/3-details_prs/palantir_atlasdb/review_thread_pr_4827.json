{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNzkxOTA4", "number": 4827, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozMzo0NlrOED4Upw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozNjo1OVrOED4alg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTAzOTc1OnYy", "diffSide": "RIGHT", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozMzo0NlrOGhKATw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0MDoxNlrOGhKTIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDExMQ==", "bodyText": "This now needs to generate a new random UUID on each call to getEventsForTransactions - is that intentional? I thought -1 as a sequence number was enough to indicate that the Events value was meaningless.", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437420111", "createdAt": "2020-06-09T13:33:46Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -55,10 +52,19 @@ public CommitUpdate getCommitUpdate(long startTs) {\n     @Override\n     public TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n             Optional<IdentifiedVersion> version) {\n-        return NONE;\n+        IdentifiedVersion fakeVersion = generateFakeVersion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDkyOQ==", "bodyText": "This was a suggestion from the other PR by Jakub (ensuring that it 100% is treated as a snapshot each time) but in honesty this is unnecessary - things go off the snapshot flag anyway.", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437424929", "createdAt": "2020-06-09T13:40:16Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -55,10 +52,19 @@ public CommitUpdate getCommitUpdate(long startTs) {\n     @Override\n     public TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n             Optional<IdentifiedVersion> version) {\n-        return NONE;\n+        IdentifiedVersion fakeVersion = generateFakeVersion();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDExMQ=="}, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTA1MzgwOnYy", "diffSide": "RIGHT", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozNjo0NFrOGhKI1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0NzoxMVrOGhKvXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjI5Mw==", "bodyText": "I see why we'd want a boolean here, though this class feels like it should be renamed - it's quite a bit more than just the events now. Maybe TransactionsLockWatchUpdate?", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437422293", "createdAt": "2020-06-09T13:36:44Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -25,53 +25,9 @@\n  * Represents a condensed view of lock watch events occurring between some known version and a set of start transaction\n  * calls.\n  */\n+@Value.Immutable\n public interface TransactionsLockWatchEvents {\n-    <T> T accept(Visitor<T> visitor);\n-\n-    interface Visitor<T> {\n-        T visit(Events success);\n-        T visit(ForcedSnapshot failure);\n-    }\n-\n-    static Events success(List<LockWatchEvent> events, Map<Long, Long> startTsToSequence) {\n-        return ImmutableEvents.of(events, startTsToSequence);\n-    }\n-\n-    static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n-        return ImmutableForcedSnapshot.of(snapshot);\n-    }\n-\n-    /**\n-     * A successful result contains a list of all lock watch events occurring between the last known version and the\n-     * last started transaction, and a mapping of start timestamps to their respective last occurred event.\n-     */\n-    @Value.Immutable\n-    interface Events extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        List<LockWatchEvent> events();\n-        @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n-\n-    /**\n-     * A failure denotes that it was not possible to compute the result for all of the requested transactions. Since\n-     * that generally implies we will fail to get the necessary information for the commit timestamp anyway, instead of\n-     * giving partial information, we return a single snapshot that should be used to reseed the state of lock watches\n-     * for all future transactions.\n-     */\n-    @Value.Immutable\n-    interface ForcedSnapshot extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        LockWatchStateUpdate.Snapshot snapshot();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n+    List<LockWatchEvent> events();\n+    Map<Long, IdentifiedVersion> startTsToSequence();\n+    boolean clearCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNTMxMg==", "bodyText": "I think that is reasonable", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437425312", "createdAt": "2020-06-09T13:40:39Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -25,53 +25,9 @@\n  * Represents a condensed view of lock watch events occurring between some known version and a set of start transaction\n  * calls.\n  */\n+@Value.Immutable\n public interface TransactionsLockWatchEvents {\n-    <T> T accept(Visitor<T> visitor);\n-\n-    interface Visitor<T> {\n-        T visit(Events success);\n-        T visit(ForcedSnapshot failure);\n-    }\n-\n-    static Events success(List<LockWatchEvent> events, Map<Long, Long> startTsToSequence) {\n-        return ImmutableEvents.of(events, startTsToSequence);\n-    }\n-\n-    static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n-        return ImmutableForcedSnapshot.of(snapshot);\n-    }\n-\n-    /**\n-     * A successful result contains a list of all lock watch events occurring between the last known version and the\n-     * last started transaction, and a mapping of start timestamps to their respective last occurred event.\n-     */\n-    @Value.Immutable\n-    interface Events extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        List<LockWatchEvent> events();\n-        @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n-\n-    /**\n-     * A failure denotes that it was not possible to compute the result for all of the requested transactions. Since\n-     * that generally implies we will fail to get the necessary information for the commit timestamp anyway, instead of\n-     * giving partial information, we return a single snapshot that should be used to reseed the state of lock watches\n-     * for all future transactions.\n-     */\n-    @Value.Immutable\n-    interface ForcedSnapshot extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        LockWatchStateUpdate.Snapshot snapshot();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n+    List<LockWatchEvent> events();\n+    Map<Long, IdentifiedVersion> startTsToSequence();\n+    boolean clearCache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjI5Mw=="}, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNzgwNQ==", "bodyText": "Is that renaming considered a breaking change?", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437427805", "createdAt": "2020-06-09T13:43:01Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -25,53 +25,9 @@\n  * Represents a condensed view of lock watch events occurring between some known version and a set of start transaction\n  * calls.\n  */\n+@Value.Immutable\n public interface TransactionsLockWatchEvents {\n-    <T> T accept(Visitor<T> visitor);\n-\n-    interface Visitor<T> {\n-        T visit(Events success);\n-        T visit(ForcedSnapshot failure);\n-    }\n-\n-    static Events success(List<LockWatchEvent> events, Map<Long, Long> startTsToSequence) {\n-        return ImmutableEvents.of(events, startTsToSequence);\n-    }\n-\n-    static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n-        return ImmutableForcedSnapshot.of(snapshot);\n-    }\n-\n-    /**\n-     * A successful result contains a list of all lock watch events occurring between the last known version and the\n-     * last started transaction, and a mapping of start timestamps to their respective last occurred event.\n-     */\n-    @Value.Immutable\n-    interface Events extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        List<LockWatchEvent> events();\n-        @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n-\n-    /**\n-     * A failure denotes that it was not possible to compute the result for all of the requested transactions. Since\n-     * that generally implies we will fail to get the necessary information for the commit timestamp anyway, instead of\n-     * giving partial information, we return a single snapshot that should be used to reseed the state of lock watches\n-     * for all future transactions.\n-     */\n-    @Value.Immutable\n-    interface ForcedSnapshot extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        LockWatchStateUpdate.Snapshot snapshot();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n+    List<LockWatchEvent> events();\n+    Map<Long, IdentifiedVersion> startTsToSequence();\n+    boolean clearCache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjI5Mw=="}, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMjE1Ng==", "bodyText": "Technically yes (though this is internal API so I wouldn't be too concerned).", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437432156", "createdAt": "2020-06-09T13:47:11Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionsLockWatchEvents.java", "diffHunk": "@@ -25,53 +25,9 @@\n  * Represents a condensed view of lock watch events occurring between some known version and a set of start transaction\n  * calls.\n  */\n+@Value.Immutable\n public interface TransactionsLockWatchEvents {\n-    <T> T accept(Visitor<T> visitor);\n-\n-    interface Visitor<T> {\n-        T visit(Events success);\n-        T visit(ForcedSnapshot failure);\n-    }\n-\n-    static Events success(List<LockWatchEvent> events, Map<Long, Long> startTsToSequence) {\n-        return ImmutableEvents.of(events, startTsToSequence);\n-    }\n-\n-    static ForcedSnapshot failure(LockWatchStateUpdate.Snapshot snapshot) {\n-        return ImmutableForcedSnapshot.of(snapshot);\n-    }\n-\n-    /**\n-     * A successful result contains a list of all lock watch events occurring between the last known version and the\n-     * last started transaction, and a mapping of start timestamps to their respective last occurred event.\n-     */\n-    @Value.Immutable\n-    interface Events extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        List<LockWatchEvent> events();\n-        @Value.Parameter\n-        Map<Long, Long> startTsToSequence();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n-\n-    /**\n-     * A failure denotes that it was not possible to compute the result for all of the requested transactions. Since\n-     * that generally implies we will fail to get the necessary information for the commit timestamp anyway, instead of\n-     * giving partial information, we return a single snapshot that should be used to reseed the state of lock watches\n-     * for all future transactions.\n-     */\n-    @Value.Immutable\n-    interface ForcedSnapshot extends TransactionsLockWatchEvents {\n-        @Value.Parameter\n-        LockWatchStateUpdate.Snapshot snapshot();\n-\n-        @Override\n-        default <T> T accept(Visitor<T> visitor) {\n-            return visitor.visit(this);\n-        }\n-    }\n+    List<LockWatchEvent> events();\n+    Map<Long, IdentifiedVersion> startTsToSequence();\n+    boolean clearCache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjI5Mw=="}, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTA1NDk0OnYy", "diffSide": "RIGHT", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozNjo1OVrOGhKJiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0MDo1MVrOGhKVaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjQ3Mw==", "bodyText": "nit: If we want to keep this, this should be static. Though I think having a constant for the UUID would be preferable", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437422473", "createdAt": "2020-06-09T13:36:59Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -55,10 +52,19 @@ public CommitUpdate getCommitUpdate(long startTs) {\n     @Override\n     public TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n             Optional<IdentifiedVersion> version) {\n-        return NONE;\n+        IdentifiedVersion fakeVersion = generateFakeVersion();\n+        return ImmutableTransactionsLockWatchEvents.builder()\n+                .clearCache(true)\n+                .startTsToSequence(\n+                        startTimestamps.stream().collect(Collectors.toMap(startTs -> startTs, $ -> fakeVersion)))\n+                .build();\n     }\n \n     @Override\n     public void removeTransactionStateFromCache(long startTimestamp) {\n     }\n+\n+    private IdentifiedVersion generateFakeVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNTUxMw==", "bodyText": "As per the other, I agree.", "url": "https://github.com/palantir/atlasdb/pull/4827#discussion_r437425513", "createdAt": "2020-06-09T13:40:51Z", "author": {"login": "Jolyon-S"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -55,10 +52,19 @@ public CommitUpdate getCommitUpdate(long startTs) {\n     @Override\n     public TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n             Optional<IdentifiedVersion> version) {\n-        return NONE;\n+        IdentifiedVersion fakeVersion = generateFakeVersion();\n+        return ImmutableTransactionsLockWatchEvents.builder()\n+                .clearCache(true)\n+                .startTsToSequence(\n+                        startTimestamps.stream().collect(Collectors.toMap(startTs -> startTs, $ -> fakeVersion)))\n+                .build();\n     }\n \n     @Override\n     public void removeTransactionStateFromCache(long startTimestamp) {\n     }\n+\n+    private IdentifiedVersion generateFakeVersion() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjQ3Mw=="}, "originalCommit": {"oid": "5e4137d7eb1d4f506c3f6ab42291318280ac6320"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2933, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}