{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNDA5NTg1", "number": 4996, "title": "[Part 3 | Paxos history] Consolidate local and remote histories", "bodyText": "Goals (and why):\nPart 3 - Integrate local and remote Paxos histories for TimeLock corruption analysis.\nImplementation Description (bullets):\n\nBasically data transforms on local and remote histories.\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nAdded tests\n\nConcerns (what feedback would you like?):\n\nThe transforms are complex and therefore hard to read, are there better ways to implement this?\n\nWhere should we start reviewing?:\n\nPaxosLogHistoryProvider\n\nPriority (whenever / two weeks / yesterday):\nASAP \ud83c\udfc3\u200d\u2640\ufe0f", "createdAt": "2020-09-24T12:25:45Z", "url": "https://github.com/palantir/atlasdb/pull/4996", "merged": true, "mergeCommit": {"oid": "21b149c60fe9cc00f5ada02cd1fc5e7a8b38c0f0"}, "closed": true, "closedAt": "2020-09-25T17:07:25Z", "author": {"login": "sudiksha27"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMAQFtAH2gAyNDkyNDA5NTg1OmQxYzYwZTZjMTg5NDY4ZDgyYmJjZTBlNDU1NDRjNmU0YjJlNjRlZWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMYfY6AH2gAyNDkyNDA5NTg1OmQ4ODc3OWFkZWVkNzkxOWU4MTk2OWJiOTc4MzBlNDQ5N2E3ZGZkYWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d1c60e6c189468d82bbce0e45544c6e4b2e64eee", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/d1c60e6c189468d82bbce0e45544c6e4b2e64eee", "committedDate": "2020-09-24T12:21:54Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9c80f5ab601878788bf4a9a9d57d23595a66c85", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/d9c80f5ab601878788bf4a9a9d57d23595a66c85", "committedDate": "2020-09-24T12:22:09Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64ef82f4124ad1d8a27e170c829bdc21a4e322a6", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/64ef82f4124ad1d8a27e170c829bdc21a4e322a6", "committedDate": "2020-09-24T12:22:26Z", "message": "Use PaxosAcceptorData"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdc44ecb30acd20a5a10c49d38041931a29be708", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/cdc44ecb30acd20a5a10c49d38041931a29be708", "committedDate": "2020-09-24T12:51:11Z", "message": "Add test + clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1b229898478763a2dcd19c7f6b4f1e6b7a11e81", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/f1b229898478763a2dcd19c7f6b4f1e6b7a11e81", "committedDate": "2020-09-24T13:08:58Z", "message": "Modify docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/157561be9835d0d62b96c4f038478dbdfdf904a4", "committedDate": "2020-09-24T13:08:58Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzAzMTMy", "url": "https://github.com/palantir/atlasdb/pull/4996#pullrequestreview-495703132", "createdAt": "2020-09-24T15:37:15Z", "commit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTozNzoxNVrOHXg43Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjowMToxOVrOHXh8FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQxODE0MQ==", "bodyText": "Throughout this function: The methods are readable enough! So I don't think we need the comments :)", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494418141", "createdAt": "2020-09-24T15:37:15Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -61,16 +77,189 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n                 namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n     }\n \n+    /**\n+     * Gets history from all the nodes for all unique (namespace, useCase) tuples since last verified sequence numbers\n+     * i.e. the highest sequence number that was verified since the last time the bounds were reset.\n+     *\n+     * @throws Exception if fails to fetch history from all remote servers\n+     */\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = KeyedStream\n+\n+        /**\n+         * map of all unique (namespace, useCase) tuples to their respective last verified sequence numbers.\n+         */\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n+\n+        /**\n+         * The history queries are built from the lastVerifiedSequences map above,\n+         * required for conjure endpoints to load remote history.\n+         */\n+        List<HistoryQuery> historyQueries = getHistoryQueryListForRemoteServers(lastVerifiedSequences);\n+\n+        /**\n+         * List of logs from all remotes.\n+         */\n+        List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes = getHistoriesFromRemoteServers(historyQueries);\n+\n+        /**\n+         * List of consolidated histories from all remotes. Each history is a map of namespaceAndUseCase\n+         * to {@link ConsolidatedLearnerAndAcceptorRecord}.\n+         */\n+        List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyFromAllRemotes\n+                = buildHistoryFromRemoteResponses(rawHistoryFromAllRemotes);\n+\n+        /**\n+         * Consolidate and build complete history for each (namespace, useCase) pair\n+         * from histories loaded from local and remote servers.\n+         */\n+        return consolidateAndGetHistoriesAcrossAllNodes(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyMDQzNw==", "bodyText": "this one should probably be on the ConsolidatedLearnerAndAcceptorRecord object. Other comments are fine to remove since the code is self-describing.", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494420437", "createdAt": "2020-09-24T15:40:32Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -61,16 +77,189 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n                 namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n     }\n \n+    /**\n+     * Gets history from all the nodes for all unique (namespace, useCase) tuples since last verified sequence numbers\n+     * i.e. the highest sequence number that was verified since the last time the bounds were reset.\n+     *\n+     * @throws Exception if fails to fetch history from all remote servers\n+     */\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = KeyedStream\n+\n+        /**\n+         * map of all unique (namespace, useCase) tuples to their respective last verified sequence numbers.\n+         */\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n+\n+        /**\n+         * The history queries are built from the lastVerifiedSequences map above,\n+         * required for conjure endpoints to load remote history.\n+         */\n+        List<HistoryQuery> historyQueries = getHistoryQueryListForRemoteServers(lastVerifiedSequences);\n+\n+        /**\n+         * List of logs from all remotes.\n+         */\n+        List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes = getHistoriesFromRemoteServers(historyQueries);\n+\n+        /**\n+         * List of consolidated histories from all remotes. Each history is a map of namespaceAndUseCase\n+         * to {@link ConsolidatedLearnerAndAcceptorRecord}.\n+         */\n+        List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyFromAllRemotes\n+                = buildHistoryFromRemoteResponses(rawHistoryFromAllRemotes);\n+\n+        /**\n+         * Consolidate and build complete history for each (namespace, useCase) pair\n+         * from histories loaded from local and remote servers.\n+         */\n+        return consolidateAndGetHistoriesAcrossAllNodes(\n+                lastVerifiedSequences,\n+                localPaxosHistory,\n+                historyFromAllRemotes);\n+    }\n+\n+    private List<CompletePaxosHistoryForNamespaceAndUseCase> consolidateAndGetHistoriesAcrossAllNodes(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyFromAllRemotes) {\n+        return lastVerifiedSequences.keySet().stream()\n+                .map(namespaceAndUseCase -> buildCompleteHistory(\n+                        namespaceAndUseCase,\n+                        localPaxosHistory,\n+                        historyFromAllRemotes))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> buildHistoryFromRemoteResponses(\n+            List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes) {\n+        return rawHistoryFromAllRemotes.stream()\n+                .map(this::buildRecordFromRemoteResponse)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<PaxosHistoryOnRemote> getHistoriesFromRemoteServers(List<HistoryQuery> historyQueries) {\n+        return remoteHistoryProviders.stream().map(\n+                remote -> fetchHistoryFromRemote(historyQueries, remote)).collect(Collectors.toList());\n+    }\n+\n+    private List<HistoryQuery> getHistoryQueryListForRemoteServers(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n+        return KeyedStream.stream(lastVerifiedSequences)\n+                .mapEntries(this::buildHistoryQuery)\n+                .values()\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<NamespaceAndUseCase, Long> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n+        return KeyedStream\n                 .of(getNamespaceAndUseCaseTuples().stream())\n                 .map(namespaceAndUseCase -> verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase,\n                         this::getOrInsertVerificationState))\n                 .collectToMap();\n-        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(\n-                lastVerifiedSequences);\n+    }\n+\n+    private CompletePaxosHistoryForNamespaceAndUseCase buildCompleteHistory(NamespaceAndUseCase namespaceAndUseCase,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyLogsFromRemotes) {\n+\n+        /**\n+         * Rather than having two maps - one for learner records and one for acceptor records,\n+         * the consolidated record has a sequence number mapped to pair of (learnedValue, acceptedValue).\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyMTMxMA==", "bodyText": "nit: Paxos*Log*HistoryProviderTest?", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494421310", "createdAt": "2020-09-24T15:41:45Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosHistoryProviderTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNDQ4NA==", "bodyText": "nit: It's strange that the use case assertion is in here but the client one is not. Maybe allow the user to pass in a client to this method?", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494424484", "createdAt": "2020-09-24T15:46:15Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 100);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineDiscontinuousLogs() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 7, 54);\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 98, 127);\n+\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 78);\n+    }\n+\n+    @Test\n+    public void throwsIfRemoteThrows() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        when(remote.getPaxosHistory(any(), any())).thenThrow(new RuntimeException());\n+        assertThatThrownBy(paxosLogHistoryProvider::getHistory)\n+                .isInstanceOf(RuntimeException.class);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesSinceLastVerifiedState() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = 17;\n+        verificationProgressState.updateProgress(CLIENT, USE_CASE, lastVerified);\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 100 - lastVerified);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesAcrossNamespaceAndUseCases() {\n+        List<HistoryQuery> historyQueries = new ArrayList<>();\n+        IntStream.rangeClosed(1, 100).forEach(idx -> {\n+            Client client = Client.of(\"\" + idx);\n+            PaxosSerializationTestUtils.writeToLogs(\n+                    createAcceptorLog(ImmutableNamespaceAndUseCase.of(client, USE_CASE_ACCEPTOR)),\n+                    createLearnerLog(ImmutableNamespaceAndUseCase.of(client, USE_CASE_LEARNER)),\n+                    1, idx);\n+            historyQueries.add(HistoryQuery.of(ImmutableNamespaceAndUseCase.of(client, USE_CASE), -1));\n+        });\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+        assertThat(completeHistory.size()).isEqualTo(100);\n+        completeHistory.forEach(historyForNamespaceAndUseCase -> assertSanityOfFetchedRecords(\n+                historyForNamespaceAndUseCase, getIntegerValueOfClient(historyForNamespaceAndUseCase)\n+        ));\n+    }\n+\n+    // utils\n+    private PaxosStateLog<PaxosValue> createLearnerLog(NamespaceAndUseCase namespaceAndUseCase) {\n+        return SqlitePaxosStateLog.create(namespaceAndUseCase, dataSource);\n+    }\n+\n+    private PaxosStateLog<PaxosAcceptorState> createAcceptorLog(NamespaceAndUseCase namespaceAndUseCase) {\n+        return SqlitePaxosStateLog.create(namespaceAndUseCase, dataSource);\n+    }\n+\n+    private void assertSanityOfFetchedRecords(\n+            CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase,\n+            int numberOfLogs) {\n+\n+        assertThat(historyForNamespaceAndUseCase.useCase()).isEqualTo(USE_CASE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNTQzOQ==", "bodyText": "in general you can do Iterables.getOnlyElement(...) to quickly assert that there is one thing and get it.", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494425439", "createdAt": "2020-09-24T15:47:30Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNTgxOQ==", "bodyText": "I'd prefer if we wrote how we got 78, even if it's a horrible (54 - 7 + 1) + (127 - 98 + 1)?", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494425819", "createdAt": "2020-09-24T15:48:01Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 100);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineDiscontinuousLogs() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 7, 54);\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 98, 127);\n+\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 78);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNzAzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Client client = Client.of(\"\" + idx);\n          \n          \n            \n                        Client client = Client.of(String.valueOf(idx));", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494427032", "createdAt": "2020-09-24T15:49:39Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 100);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineDiscontinuousLogs() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 7, 54);\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 98, 127);\n+\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 78);\n+    }\n+\n+    @Test\n+    public void throwsIfRemoteThrows() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        when(remote.getPaxosHistory(any(), any())).thenThrow(new RuntimeException());\n+        assertThatThrownBy(paxosLogHistoryProvider::getHistory)\n+                .isInstanceOf(RuntimeException.class);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesSinceLastVerifiedState() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = 17;\n+        verificationProgressState.updateProgress(CLIENT, USE_CASE, lastVerified);\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+        assertThat(completeHistory.size()).isEqualTo(1);\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase = completeHistory.get(0);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, 100 - lastVerified);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesAcrossNamespaceAndUseCases() {\n+        List<HistoryQuery> historyQueries = new ArrayList<>();\n+        IntStream.rangeClosed(1, 100).forEach(idx -> {\n+            Client client = Client.of(\"\" + idx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNzM4MQ==", "bodyText": "Do we want a test for multiple different clients?", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494427381", "createdAt": "2020-09-24T15:50:06Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzMDYzNA==", "bodyText": "nit: indentation?", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494430634", "createdAt": "2020-09-24T15:54:42Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -61,16 +77,189 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n                 namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n     }\n \n+    /**\n+     * Gets history from all the nodes for all unique (namespace, useCase) tuples since last verified sequence numbers\n+     * i.e. the highest sequence number that was verified since the last time the bounds were reset.\n+     *\n+     * @throws Exception if fails to fetch history from all remote servers\n+     */\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = KeyedStream\n+\n+        /**\n+         * map of all unique (namespace, useCase) tuples to their respective last verified sequence numbers.\n+         */\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n+\n+        /**\n+         * The history queries are built from the lastVerifiedSequences map above,\n+         * required for conjure endpoints to load remote history.\n+         */\n+        List<HistoryQuery> historyQueries = getHistoryQueryListForRemoteServers(lastVerifiedSequences);\n+\n+        /**\n+         * List of logs from all remotes.\n+         */\n+        List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes = getHistoriesFromRemoteServers(historyQueries);\n+\n+        /**\n+         * List of consolidated histories from all remotes. Each history is a map of namespaceAndUseCase\n+         * to {@link ConsolidatedLearnerAndAcceptorRecord}.\n+         */\n+        List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyFromAllRemotes\n+                = buildHistoryFromRemoteResponses(rawHistoryFromAllRemotes);\n+\n+        /**\n+         * Consolidate and build complete history for each (namespace, useCase) pair\n+         * from histories loaded from local and remote servers.\n+         */\n+        return consolidateAndGetHistoriesAcrossAllNodes(\n+                lastVerifiedSequences,\n+                localPaxosHistory,\n+                historyFromAllRemotes);\n+    }\n+\n+    private List<CompletePaxosHistoryForNamespaceAndUseCase> consolidateAndGetHistoriesAcrossAllNodes(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyFromAllRemotes) {\n+        return lastVerifiedSequences.keySet().stream()\n+                .map(namespaceAndUseCase -> buildCompleteHistory(\n+                        namespaceAndUseCase,\n+                        localPaxosHistory,\n+                        historyFromAllRemotes))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> buildHistoryFromRemoteResponses(\n+            List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes) {\n+        return rawHistoryFromAllRemotes.stream()\n+                .map(this::buildRecordFromRemoteResponse)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<PaxosHistoryOnRemote> getHistoriesFromRemoteServers(List<HistoryQuery> historyQueries) {\n+        return remoteHistoryProviders.stream().map(\n+                remote -> fetchHistoryFromRemote(historyQueries, remote)).collect(Collectors.toList());\n+    }\n+\n+    private List<HistoryQuery> getHistoryQueryListForRemoteServers(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n+        return KeyedStream.stream(lastVerifiedSequences)\n+                .mapEntries(this::buildHistoryQuery)\n+                .values()\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<NamespaceAndUseCase, Long> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n+        return KeyedStream\n                 .of(getNamespaceAndUseCaseTuples().stream())\n                 .map(namespaceAndUseCase -> verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase,\n                         this::getOrInsertVerificationState))\n                 .collectToMap();\n-        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(\n-                lastVerifiedSequences);\n+    }\n+\n+    private CompletePaxosHistoryForNamespaceAndUseCase buildCompleteHistory(NamespaceAndUseCase namespaceAndUseCase,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyLogsFromRemotes) {\n+\n+        /**\n+         * Rather than having two maps - one for learner records and one for acceptor records,\n+         * the consolidated record has a sequence number mapped to pair of (learnedValue, acceptedValue).\n+         */\n+        ConsolidatedLearnerAndAcceptorRecord consolidatedLocalRecord\n+                = localPaxosHistory.getConsolidatedLocalAndRemoteRecord(namespaceAndUseCase);\n+\n+        /**\n+         * Retrieve history logs of this (namespace, useCase) pair from history logs fetched from remotes.\n+         */\n+        List<ConsolidatedLearnerAndAcceptorRecord> remoteHistoryLogsForNamespaceAndUseCase\n+                = extractRemoteHistoryLogsForNamespaceAndUseCase(namespaceAndUseCase, historyLogsFromRemotes);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> historyLogsAcrossAllNodes\n+                = combineLocalAndRemoteHistoryLogs(consolidatedLocalRecord, remoteHistoryLogsForNamespaceAndUseCase);\n+\n+        /**\n+         * Paxos history for (namespace, useCase) pair across all nodes in the cluster.\n+         */\n+        return ImmutableCompletePaxosHistoryForNamespaceAndUseCase.of(\n+                namespaceAndUseCase.namespace(),\n+                namespaceAndUseCase.useCase(),\n+                historyLogsAcrossAllNodes);\n+    }\n+\n+    private List<ConsolidatedLearnerAndAcceptorRecord> extractRemoteHistoryLogsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase,\n+            List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyLogsFromRemotes) {\n+        return historyLogsFromRemotes\n+                .stream()\n+                .map(history -> history.getRecordForNamespaceAndUseCase(namespaceAndUseCase))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<ConsolidatedLearnerAndAcceptorRecord> combineLocalAndRemoteHistoryLogs(\n+            ConsolidatedLearnerAndAcceptorRecord consolidatedLocalRecord,\n+            List<ConsolidatedLearnerAndAcceptorRecord> consolidatedRemoteRecords) {\n+        return ImmutableList\n+                .<ConsolidatedLearnerAndAcceptorRecord>builder()\n+                .addAll(consolidatedRemoteRecords)\n+                .add(consolidatedLocalRecord)\n+                .build();\n+    }\n+\n+    private NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords buildRecordFromRemoteResponse(\n+            PaxosHistoryOnRemote historyOnRemote) {\n+        /**\n+         * Build sequence number wise mapped record of learned and accepted values for each\n+         * (namespace, useCase) pair from history logs provided by remote.\n+         */\n+        Map<NamespaceAndUseCase, List<PaxosLogWithAcceptedAndLearnedValues>> namespaceWisePaxosLogs\n+                = historyOnRemote.getLogs()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        LogsForNamespaceAndUseCase::getNamespaceAndUseCase,\n+                        LogsForNamespaceAndUseCase::getLogs)\n+                );\n+\n+        return NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords.of(KeyedStream\n+                .stream(namespaceWisePaxosLogs)\n+                .map(this::getConsolidatedLearnerAndAcceptorRecordFromRemotePaxosLogs)\n+                .collectToMap());\n+    }\n+\n+    private ConsolidatedLearnerAndAcceptorRecord getConsolidatedLearnerAndAcceptorRecordFromRemotePaxosLogs(\n+            NamespaceAndUseCase unused,\n+            List<PaxosLogWithAcceptedAndLearnedValues> remoteLogs) {\n+        return ConsolidatedLearnerAndAcceptorRecord\n+                .of(getSequenceWiseLearnedAndAcceptedValuesFromRemoteLogs(remoteLogs));\n+    }\n+\n+    private Map<Long, LearnedAndAcceptedValue> getSequenceWiseLearnedAndAcceptedValuesFromRemoteLogs(\n+            List<PaxosLogWithAcceptedAndLearnedValues> remoteLogs) {\n+        return remoteLogs\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        PaxosLogWithAcceptedAndLearnedValues::getSeq,\n+                        remoteLog -> ImmutableLearnedAndAcceptedValue.of(\n+                                remoteLog.getPaxosValue(),\n+                                remoteLog.getAcceptedState()\n+                        ))\n+                );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzNTM0OQ==", "bodyText": "nit: maybe ClusterWidePaxosRecords?", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494435349", "createdAt": "2020-09-24T16:01:19Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import java.util.Map;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+\n+@Value.Immutable\n+public interface NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzI5MTg1", "url": "https://github.com/palantir/atlasdb/pull/4996#pullrequestreview-495729185", "createdAt": "2020-09-24T16:05:32Z", "commit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjowNTozMlrOHXiHdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjowNTozMlrOHXiHdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQzODI2Mw==", "bodyText": "This is quite a heavy class and it feels like the last two parts on translating PaxosHistoryOnRemote to CompletePaxosHistoryForNamespaceAndUseCase seems a bit of a separate concern from getting the data which the first three parts here do. We should split this up, though I'm fine with getting this in first as long as we track doing this when we return to this project later on.", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494438263", "createdAt": "2020-09-24T16:05:32Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -61,16 +77,189 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n                 namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n     }\n \n+    /**\n+     * Gets history from all the nodes for all unique (namespace, useCase) tuples since last verified sequence numbers\n+     * i.e. the highest sequence number that was verified since the last time the bounds were reset.\n+     *\n+     * @throws Exception if fails to fetch history from all remote servers\n+     */\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = KeyedStream\n+\n+        /**\n+         * map of all unique (namespace, useCase) tuples to their respective last verified sequence numbers.\n+         */\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n+\n+        /**\n+         * The history queries are built from the lastVerifiedSequences map above,\n+         * required for conjure endpoints to load remote history.\n+         */\n+        List<HistoryQuery> historyQueries = getHistoryQueryListForRemoteServers(lastVerifiedSequences);\n+\n+        /**\n+         * List of logs from all remotes.\n+         */\n+        List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes = getHistoriesFromRemoteServers(historyQueries);\n+\n+        /**\n+         * List of consolidated histories from all remotes. Each history is a map of namespaceAndUseCase\n+         * to {@link ConsolidatedLearnerAndAcceptorRecord}.\n+         */\n+        List<NamespaceAndUseCaseWiseConsolidatedLearnerAndAcceptorRecords> historyFromAllRemotes\n+                = buildHistoryFromRemoteResponses(rawHistoryFromAllRemotes);\n+\n+        /**\n+         * Consolidate and build complete history for each (namespace, useCase) pair\n+         * from histories loaded from local and remote servers.\n+         */\n+        return consolidateAndGetHistoriesAcrossAllNodes(\n+                lastVerifiedSequences,\n+                localPaxosHistory,\n+                historyFromAllRemotes);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157561be9835d0d62b96c4f038478dbdfdf904a4"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40c31a20f4263158b9bb5b196efec5aeb2ff141f", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/40c31a20f4263158b9bb5b196efec5aeb2ff141f", "committedDate": "2020-09-24T16:14:01Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98cd17c8be2ede33eaf0123e63f5cf63b7c6d8d1", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/98cd17c8be2ede33eaf0123e63f5cf63b7c6d8d1", "committedDate": "2020-09-24T16:55:16Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/aed661796a5de976a2ba2616c8f980c614da9ac2", "committedDate": "2020-09-24T17:15:09Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODY4ODk1", "url": "https://github.com/palantir/atlasdb/pull/4996#pullrequestreview-495868895", "createdAt": "2020-09-24T19:00:39Z", "commit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTowMDozOVrOHXorYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTowNToxNFrOHXo1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0NTc2Mg==", "bodyText": "I think it's useful to explain why the data is structured in this way as well, not just what it is", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494545762", "createdAt": "2020-09-24T19:00:39Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ConsolidatedLearnerAndAcceptorRecord.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import java.util.Map;\n+\n+import org.immutables.value.Value;\n+\n+/**\n+ * Rather than having two maps - one for learner records and one for acceptor records,\n+ * the consolidated record has a sequence number mapped to pair of (learnedValue, acceptedValue).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0NTg3MA==", "bodyText": "nit: indentation", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494545870", "createdAt": "2020-09-24T19:00:52Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -61,16 +77,153 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n                 namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n     }\n \n+\n+//     TODO(snanda): Refactor the two parts on translating PaxosHistoryOnRemote to\n+//      CompletePaxosHistoryForNamespaceAndUseCase to a separate component\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = KeyedStream\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+\n+        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n+\n+        List<HistoryQuery> historyQueries = getHistoryQueryListForRemoteServers(lastVerifiedSequences);\n+\n+        List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes = getHistoriesFromRemoteServers(historyQueries);\n+\n+        List<ConsolidatedPaxosHistoryOnSingleNode> historyFromAllRemotes\n+                = buildHistoryFromRemoteResponses(rawHistoryFromAllRemotes);\n+\n+        return consolidateAndGetHistoriesAcrossAllNodes(\n+                lastVerifiedSequences,\n+                localPaxosHistory,\n+                historyFromAllRemotes);\n+    }\n+\n+    private List<CompletePaxosHistoryForNamespaceAndUseCase> consolidateAndGetHistoriesAcrossAllNodes(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<ConsolidatedPaxosHistoryOnSingleNode> historyFromAllRemotes) {\n+        return lastVerifiedSequences.keySet().stream()\n+                .map(namespaceAndUseCase -> buildCompleteHistory(\n+                        namespaceAndUseCase,\n+                        localPaxosHistory,\n+                        historyFromAllRemotes))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<ConsolidatedPaxosHistoryOnSingleNode> buildHistoryFromRemoteResponses(\n+            List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes) {\n+        return rawHistoryFromAllRemotes.stream()\n+                .map(this::buildRecordFromRemoteResponse)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<PaxosHistoryOnRemote> getHistoriesFromRemoteServers(List<HistoryQuery> historyQueries) {\n+        return remoteHistoryProviders.stream().map(\n+                remote -> fetchHistoryFromRemote(historyQueries, remote)).collect(Collectors.toList());\n+    }\n+\n+    private List<HistoryQuery> getHistoryQueryListForRemoteServers(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n+        return KeyedStream.stream(lastVerifiedSequences)\n+                .mapEntries(this::buildHistoryQuery)\n+                .values()\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<NamespaceAndUseCase, Long> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n+        return KeyedStream\n                 .of(getNamespaceAndUseCaseTuples().stream())\n                 .map(namespaceAndUseCase -> verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase,\n                         this::getOrInsertVerificationState))\n                 .collectToMap();\n-        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(\n-                lastVerifiedSequences);\n+    }\n+\n+    private CompletePaxosHistoryForNamespaceAndUseCase buildCompleteHistory(NamespaceAndUseCase namespaceAndUseCase,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<ConsolidatedPaxosHistoryOnSingleNode> historyLogsFromRemotes) {\n+\n+        ConsolidatedLearnerAndAcceptorRecord consolidatedLocalRecord\n+                = localPaxosHistory.getConsolidatedLocalAndRemoteRecord(namespaceAndUseCase);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> remoteHistoryLogsForNamespaceAndUseCase\n+                = extractRemoteHistoryLogsForNamespaceAndUseCase(namespaceAndUseCase, historyLogsFromRemotes);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> historyLogsAcrossAllNodes\n+                = combineLocalAndRemoteHistoryLogs(consolidatedLocalRecord, remoteHistoryLogsForNamespaceAndUseCase);\n+\n+        return ImmutableCompletePaxosHistoryForNamespaceAndUseCase.of(\n+                namespaceAndUseCase.namespace(),\n+                namespaceAndUseCase.useCase(),\n+                historyLogsAcrossAllNodes);\n+    }\n+\n+    private List<ConsolidatedLearnerAndAcceptorRecord> extractRemoteHistoryLogsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase,\n+            List<ConsolidatedPaxosHistoryOnSingleNode> historyLogsFromRemotes) {\n+        return historyLogsFromRemotes\n+                .stream()\n+                .map(history -> history.getRecordForNamespaceAndUseCase(namespaceAndUseCase))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<ConsolidatedLearnerAndAcceptorRecord> combineLocalAndRemoteHistoryLogs(\n+            ConsolidatedLearnerAndAcceptorRecord consolidatedLocalRecord,\n+            List<ConsolidatedLearnerAndAcceptorRecord> consolidatedRemoteRecords) {\n+        return ImmutableList\n+                .<ConsolidatedLearnerAndAcceptorRecord>builder()\n+                .addAll(consolidatedRemoteRecords)\n+                .add(consolidatedLocalRecord)\n+                .build();\n+    }\n+\n+    private ConsolidatedPaxosHistoryOnSingleNode buildRecordFromRemoteResponse(\n+            PaxosHistoryOnRemote historyOnRemote) {\n+\n+        Map<NamespaceAndUseCase, List<PaxosLogWithAcceptedAndLearnedValues>> namespaceWisePaxosLogs\n+                = historyOnRemote.getLogs()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        LogsForNamespaceAndUseCase::getNamespaceAndUseCase,\n+                        LogsForNamespaceAndUseCase::getLogs)\n+                );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0NjI2MQ==", "bodyText": "nit: space after comma\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                + \"we cannot perform corruption checks without history from all nodes.\", exception);\n          \n          \n            \n                                + \" we cannot perform corruption checks without history from all nodes.\", exception);", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494546261", "createdAt": "2020-09-24T19:01:30Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -61,16 +77,153 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n                 namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n     }\n \n+\n+//     TODO(snanda): Refactor the two parts on translating PaxosHistoryOnRemote to\n+//      CompletePaxosHistoryForNamespaceAndUseCase to a separate component\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = KeyedStream\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+\n+        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n+\n+        List<HistoryQuery> historyQueries = getHistoryQueryListForRemoteServers(lastVerifiedSequences);\n+\n+        List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes = getHistoriesFromRemoteServers(historyQueries);\n+\n+        List<ConsolidatedPaxosHistoryOnSingleNode> historyFromAllRemotes\n+                = buildHistoryFromRemoteResponses(rawHistoryFromAllRemotes);\n+\n+        return consolidateAndGetHistoriesAcrossAllNodes(\n+                lastVerifiedSequences,\n+                localPaxosHistory,\n+                historyFromAllRemotes);\n+    }\n+\n+    private List<CompletePaxosHistoryForNamespaceAndUseCase> consolidateAndGetHistoriesAcrossAllNodes(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<ConsolidatedPaxosHistoryOnSingleNode> historyFromAllRemotes) {\n+        return lastVerifiedSequences.keySet().stream()\n+                .map(namespaceAndUseCase -> buildCompleteHistory(\n+                        namespaceAndUseCase,\n+                        localPaxosHistory,\n+                        historyFromAllRemotes))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<ConsolidatedPaxosHistoryOnSingleNode> buildHistoryFromRemoteResponses(\n+            List<PaxosHistoryOnRemote> rawHistoryFromAllRemotes) {\n+        return rawHistoryFromAllRemotes.stream()\n+                .map(this::buildRecordFromRemoteResponse)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<PaxosHistoryOnRemote> getHistoriesFromRemoteServers(List<HistoryQuery> historyQueries) {\n+        return remoteHistoryProviders.stream().map(\n+                remote -> fetchHistoryFromRemote(historyQueries, remote)).collect(Collectors.toList());\n+    }\n+\n+    private List<HistoryQuery> getHistoryQueryListForRemoteServers(\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n+        return KeyedStream.stream(lastVerifiedSequences)\n+                .mapEntries(this::buildHistoryQuery)\n+                .values()\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<NamespaceAndUseCase, Long> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n+        return KeyedStream\n                 .of(getNamespaceAndUseCaseTuples().stream())\n                 .map(namespaceAndUseCase -> verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase,\n                         this::getOrInsertVerificationState))\n                 .collectToMap();\n-        PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(\n-                lastVerifiedSequences);\n+    }\n+\n+    private CompletePaxosHistoryForNamespaceAndUseCase buildCompleteHistory(NamespaceAndUseCase namespaceAndUseCase,\n+            PaxosHistoryOnSingleNode localPaxosHistory,\n+            List<ConsolidatedPaxosHistoryOnSingleNode> historyLogsFromRemotes) {\n+\n+        ConsolidatedLearnerAndAcceptorRecord consolidatedLocalRecord\n+                = localPaxosHistory.getConsolidatedLocalAndRemoteRecord(namespaceAndUseCase);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> remoteHistoryLogsForNamespaceAndUseCase\n+                = extractRemoteHistoryLogsForNamespaceAndUseCase(namespaceAndUseCase, historyLogsFromRemotes);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> historyLogsAcrossAllNodes\n+                = combineLocalAndRemoteHistoryLogs(consolidatedLocalRecord, remoteHistoryLogsForNamespaceAndUseCase);\n+\n+        return ImmutableCompletePaxosHistoryForNamespaceAndUseCase.of(\n+                namespaceAndUseCase.namespace(),\n+                namespaceAndUseCase.useCase(),\n+                historyLogsAcrossAllNodes);\n+    }\n+\n+    private List<ConsolidatedLearnerAndAcceptorRecord> extractRemoteHistoryLogsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase,\n+            List<ConsolidatedPaxosHistoryOnSingleNode> historyLogsFromRemotes) {\n+        return historyLogsFromRemotes\n+                .stream()\n+                .map(history -> history.getRecordForNamespaceAndUseCase(namespaceAndUseCase))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<ConsolidatedLearnerAndAcceptorRecord> combineLocalAndRemoteHistoryLogs(\n+            ConsolidatedLearnerAndAcceptorRecord consolidatedLocalRecord,\n+            List<ConsolidatedLearnerAndAcceptorRecord> consolidatedRemoteRecords) {\n+        return ImmutableList\n+                .<ConsolidatedLearnerAndAcceptorRecord>builder()\n+                .addAll(consolidatedRemoteRecords)\n+                .add(consolidatedLocalRecord)\n+                .build();\n+    }\n+\n+    private ConsolidatedPaxosHistoryOnSingleNode buildRecordFromRemoteResponse(\n+            PaxosHistoryOnRemote historyOnRemote) {\n+\n+        Map<NamespaceAndUseCase, List<PaxosLogWithAcceptedAndLearnedValues>> namespaceWisePaxosLogs\n+                = historyOnRemote.getLogs()\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        LogsForNamespaceAndUseCase::getNamespaceAndUseCase,\n+                        LogsForNamespaceAndUseCase::getLogs)\n+                );\n+\n+        return ConsolidatedPaxosHistoryOnSingleNode.of(KeyedStream\n+                .stream(namespaceWisePaxosLogs)\n+                .map(this::getConsolidatedLearnerAndAcceptorRecordFromRemotePaxosLogs)\n+                .collectToMap());\n+    }\n+\n+    private ConsolidatedLearnerAndAcceptorRecord getConsolidatedLearnerAndAcceptorRecordFromRemotePaxosLogs(\n+            NamespaceAndUseCase unused,\n+            List<PaxosLogWithAcceptedAndLearnedValues> remoteLogs) {\n+        return ConsolidatedLearnerAndAcceptorRecord\n+                .of(getSequenceWiseLearnedAndAcceptedValuesFromRemoteLogs(remoteLogs));\n+    }\n+\n+    private Map<Long, LearnedAndAcceptedValue> getSequenceWiseLearnedAndAcceptedValuesFromRemoteLogs(\n+            List<PaxosLogWithAcceptedAndLearnedValues> remoteLogs) {\n+        return remoteLogs\n+                .stream()\n+                .collect(Collectors.toMap(\n+                        PaxosLogWithAcceptedAndLearnedValues::getSeq,\n+                        remoteLog -> ImmutableLearnedAndAcceptedValue.of(\n+                                remoteLog.getPaxosValue(),\n+                                remoteLog.getAcceptedState())));\n+    }\n+\n+    private PaxosHistoryOnRemote fetchHistoryFromRemote(List<HistoryQuery> historyQueries,\n+            TimeLockPaxosHistoryProvider remote) {\n+        try {\n+            return remote.getPaxosHistory(AUTH_HEADER, historyQueries);\n+        } catch (Exception exception) {\n+            log.warn(\"The remote failed to provide the history,\"\n+                    + \"we cannot perform corruption checks without history from all nodes.\", exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0Njk0OQ==", "bodyText": "nit: use hasSameSizeAs / hasSize for readability please", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494546949", "createdAt": "2020-09-24T19:02:47Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosLogHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE, 100);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineDiscontinuousLogs() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 7, 54);\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 98, 127);\n+\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE,\n+                (54 - 7 + 1) + (127 - 98 + 1));\n+    }\n+\n+    @Test\n+    public void throwsIfRemoteThrows() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        when(remote.getPaxosHistory(any(), any())).thenThrow(new RuntimeException());\n+        assertThatThrownBy(paxosLogHistoryProvider::getHistory)\n+                .isInstanceOf(RuntimeException.class);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesSinceLastVerifiedState() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = 17;\n+        verificationProgressState.updateProgress(CLIENT, USE_CASE, lastVerified);\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE, 100 - lastVerified);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesAcrossNamespaces() {\n+        List<HistoryQuery> historyQueries = new ArrayList<>();\n+        Set<NamespaceAndUseCase> namespaceAndUseCases = new HashSet();\n+\n+        IntStream.rangeClosed(1, 100).forEach(idx -> {\n+            String useCase = String.valueOf(idx);\n+            Client client =  Client.of(useCase);\n+\n+            PaxosSerializationTestUtils.writeToLogs(\n+                    createAcceptorLog(ImmutableNamespaceAndUseCase.of(client,\n+                            AcceptorUseCase.createAcceptorUseCase(useCase).value())),\n+                    createLearnerLog(ImmutableNamespaceAndUseCase.of(client,\n+                            LearnerUseCase.createLearnerUseCase(useCase).value())),\n+                    1, idx);\n+\n+            historyQueries.add(HistoryQuery.of(ImmutableNamespaceAndUseCase.of(client, useCase), -1));\n+            namespaceAndUseCases.add(ImmutableNamespaceAndUseCase.of(client, useCase));\n+        });\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+        assertThat(completeHistory.size()).isEqualTo(100);\n+\n+        completeHistory.forEach(historyForNamespaceAndUseCase -> {\n+            Client client = historyForNamespaceAndUseCase.namespace();\n+            String useCase = historyForNamespaceAndUseCase.useCase();\n+\n+            assertSanityOfFetchedRecords(\n+                    historyForNamespaceAndUseCase,\n+                    client,\n+                    useCase,\n+                    getIntegerValueOfClient(historyForNamespaceAndUseCase));\n+\n+            // to assert that history for all clients was fetched\n+            assertThat(namespaceAndUseCases.remove(ImmutableNamespaceAndUseCase.of(client, useCase))).isTrue();\n+\n+        });\n+        assertThat(namespaceAndUseCases).isEmpty();\n+    }\n+\n+    // utils\n+    private PaxosStateLog<PaxosValue> createLearnerLog(NamespaceAndUseCase namespaceAndUseCase) {\n+        return SqlitePaxosStateLog.create(namespaceAndUseCase, dataSource);\n+    }\n+\n+    private PaxosStateLog<PaxosAcceptorState> createAcceptorLog(NamespaceAndUseCase namespaceAndUseCase) {\n+        return SqlitePaxosStateLog.create(namespaceAndUseCase, dataSource);\n+    }\n+\n+    private void assertSanityOfFetchedRecords(\n+            CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase,\n+            Client client,\n+            String useCase,\n+            int numberOfLogs) {\n+\n+        assertThat(historyForNamespaceAndUseCase.useCase()).isEqualTo(useCase);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(client);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> localAndRemoteLearnerAndAcceptorRecords\n+                = historyForNamespaceAndUseCase.localAndRemoteLearnerAndAcceptorRecords();\n+\n+        assertThat(localAndRemoteLearnerAndAcceptorRecords.size()).isEqualTo(2); // there is one local and one remote\n+\n+        assertThat(localAndRemoteLearnerAndAcceptorRecords.get(0).record().size())\n+                .isEqualTo(localAndRemoteLearnerAndAcceptorRecords.get(1).record().size())\n+                .isEqualTo(numberOfLogs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0NzM1NQ==", "bodyText": "Is this part really needed? I think it's probably more readable to just do a stream/map on completeHistory and check that against another stream rather than relying on a mutable set", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494547355", "createdAt": "2020-09-24T19:03:35Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosLogHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE, 100);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineDiscontinuousLogs() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 7, 54);\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 98, 127);\n+\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE,\n+                (54 - 7 + 1) + (127 - 98 + 1));\n+    }\n+\n+    @Test\n+    public void throwsIfRemoteThrows() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        when(remote.getPaxosHistory(any(), any())).thenThrow(new RuntimeException());\n+        assertThatThrownBy(paxosLogHistoryProvider::getHistory)\n+                .isInstanceOf(RuntimeException.class);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesSinceLastVerifiedState() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = 17;\n+        verificationProgressState.updateProgress(CLIENT, USE_CASE, lastVerified);\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE, 100 - lastVerified);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesAcrossNamespaces() {\n+        List<HistoryQuery> historyQueries = new ArrayList<>();\n+        Set<NamespaceAndUseCase> namespaceAndUseCases = new HashSet();\n+\n+        IntStream.rangeClosed(1, 100).forEach(idx -> {\n+            String useCase = String.valueOf(idx);\n+            Client client =  Client.of(useCase);\n+\n+            PaxosSerializationTestUtils.writeToLogs(\n+                    createAcceptorLog(ImmutableNamespaceAndUseCase.of(client,\n+                            AcceptorUseCase.createAcceptorUseCase(useCase).value())),\n+                    createLearnerLog(ImmutableNamespaceAndUseCase.of(client,\n+                            LearnerUseCase.createLearnerUseCase(useCase).value())),\n+                    1, idx);\n+\n+            historyQueries.add(HistoryQuery.of(ImmutableNamespaceAndUseCase.of(client, useCase), -1));\n+            namespaceAndUseCases.add(ImmutableNamespaceAndUseCase.of(client, useCase));\n+        });\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+        assertThat(completeHistory.size()).isEqualTo(100);\n+\n+        completeHistory.forEach(historyForNamespaceAndUseCase -> {\n+            Client client = historyForNamespaceAndUseCase.namespace();\n+            String useCase = historyForNamespaceAndUseCase.useCase();\n+\n+            assertSanityOfFetchedRecords(\n+                    historyForNamespaceAndUseCase,\n+                    client,\n+                    useCase,\n+                    getIntegerValueOfClient(historyForNamespaceAndUseCase));\n+\n+            // to assert that history for all clients was fetched\n+            assertThat(namespaceAndUseCases.remove(ImmutableNamespaceAndUseCase.of(client, useCase))).isTrue();\n+\n+        });\n+        assertThat(namespaceAndUseCases).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0ODI3OA==", "bodyText": "I'd like to include some assertions on what the values written are as well: assuming that they've gone through SerializationUtils they have a very specific format, which you should make part of the contract of that test method.", "url": "https://github.com/palantir/atlasdb/pull/4996#discussion_r494548278", "createdAt": "2020-09-24T19:05:14Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.HistoryLoaderAndTransformer;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class PaxosLogHistoryProviderTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private TimeLockPaxosHistoryProvider remote;\n+    private DataSource dataSource;\n+    private PaxosStateLog<PaxosValue> learnerLog;\n+    private PaxosStateLog<PaxosAcceptorState> acceptorLog;\n+    private LocalHistoryLoader history;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+    private LogVerificationProgressState verificationProgressState;\n+\n+    @Before\n+    public void setup() {\n+        remote = mock(TimeLockPaxosHistoryProvider.class);\n+        dataSource = SqliteConnections.getPooledDataSource(tempFolder.getRoot().toPath());\n+\n+        learnerLog = createLearnerLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_LEARNER));\n+        acceptorLog = createAcceptorLog(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE_ACCEPTOR));\n+\n+        history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+\n+        verificationProgressState = LogVerificationProgressState.create(dataSource);\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(dataSource, ImmutableList.of(remote));\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesForLocalAndRemote() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE, 100);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineDiscontinuousLogs() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 7, 54);\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 98, 127);\n+\n+        int lastVerified = -1;\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(CLIENT);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE,\n+                (54 - 7 + 1) + (127 - 98 + 1));\n+    }\n+\n+    @Test\n+    public void throwsIfRemoteThrows() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        when(remote.getPaxosHistory(any(), any())).thenThrow(new RuntimeException());\n+        assertThatThrownBy(paxosLogHistoryProvider::getHistory)\n+                .isInstanceOf(RuntimeException.class);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesSinceLastVerifiedState() {\n+        PaxosSerializationTestUtils.writeToLogs(acceptorLog, learnerLog, 1, 100);\n+        int lastVerified = 17;\n+        verificationProgressState.updateProgress(CLIENT, USE_CASE, lastVerified);\n+\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(\n+                ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+\n+        CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase\n+                = Iterables.getOnlyElement(completeHistory);\n+        assertSanityOfFetchedRecords(historyForNamespaceAndUseCase, CLIENT, USE_CASE, 100 - lastVerified);\n+    }\n+\n+    @Test\n+    public void canFetchAndCombineHistoriesAcrossNamespaces() {\n+        List<HistoryQuery> historyQueries = new ArrayList<>();\n+        Set<NamespaceAndUseCase> namespaceAndUseCases = new HashSet();\n+\n+        IntStream.rangeClosed(1, 100).forEach(idx -> {\n+            String useCase = String.valueOf(idx);\n+            Client client =  Client.of(useCase);\n+\n+            PaxosSerializationTestUtils.writeToLogs(\n+                    createAcceptorLog(ImmutableNamespaceAndUseCase.of(client,\n+                            AcceptorUseCase.createAcceptorUseCase(useCase).value())),\n+                    createLearnerLog(ImmutableNamespaceAndUseCase.of(client,\n+                            LearnerUseCase.createLearnerUseCase(useCase).value())),\n+                    1, idx);\n+\n+            historyQueries.add(HistoryQuery.of(ImmutableNamespaceAndUseCase.of(client, useCase), -1));\n+            namespaceAndUseCases.add(ImmutableNamespaceAndUseCase.of(client, useCase));\n+        });\n+\n+        List<LogsForNamespaceAndUseCase> remoteHistory\n+                = HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n+        when(remote.getPaxosHistory(any(), any())).thenReturn(PaxosHistoryOnRemote.of(remoteHistory));\n+\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> completeHistory = paxosLogHistoryProvider.getHistory();\n+        assertThat(completeHistory.size()).isEqualTo(100);\n+\n+        completeHistory.forEach(historyForNamespaceAndUseCase -> {\n+            Client client = historyForNamespaceAndUseCase.namespace();\n+            String useCase = historyForNamespaceAndUseCase.useCase();\n+\n+            assertSanityOfFetchedRecords(\n+                    historyForNamespaceAndUseCase,\n+                    client,\n+                    useCase,\n+                    getIntegerValueOfClient(historyForNamespaceAndUseCase));\n+\n+            // to assert that history for all clients was fetched\n+            assertThat(namespaceAndUseCases.remove(ImmutableNamespaceAndUseCase.of(client, useCase))).isTrue();\n+\n+        });\n+        assertThat(namespaceAndUseCases).isEmpty();\n+    }\n+\n+    // utils\n+    private PaxosStateLog<PaxosValue> createLearnerLog(NamespaceAndUseCase namespaceAndUseCase) {\n+        return SqlitePaxosStateLog.create(namespaceAndUseCase, dataSource);\n+    }\n+\n+    private PaxosStateLog<PaxosAcceptorState> createAcceptorLog(NamespaceAndUseCase namespaceAndUseCase) {\n+        return SqlitePaxosStateLog.create(namespaceAndUseCase, dataSource);\n+    }\n+\n+    private void assertSanityOfFetchedRecords(\n+            CompletePaxosHistoryForNamespaceAndUseCase historyForNamespaceAndUseCase,\n+            Client client,\n+            String useCase,\n+            int numberOfLogs) {\n+\n+        assertThat(historyForNamespaceAndUseCase.useCase()).isEqualTo(useCase);\n+        assertThat(historyForNamespaceAndUseCase.namespace()).isEqualTo(client);\n+\n+        List<ConsolidatedLearnerAndAcceptorRecord> localAndRemoteLearnerAndAcceptorRecords\n+                = historyForNamespaceAndUseCase.localAndRemoteLearnerAndAcceptorRecords();\n+\n+        assertThat(localAndRemoteLearnerAndAcceptorRecords.size()).isEqualTo(2); // there is one local and one remote\n+\n+        assertThat(localAndRemoteLearnerAndAcceptorRecords.get(0).record().size())\n+                .isEqualTo(localAndRemoteLearnerAndAcceptorRecords.get(1).record().size())\n+                .isEqualTo(numberOfLogs);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed661796a5de976a2ba2616c8f980c614da9ac2"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c75b570fe583b31af6266186901af98d5d6e161", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/7c75b570fe583b31af6266186901af98d5d6e161", "committedDate": "2020-09-25T11:12:17Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22ca6a127ab5413ff0a225f3fa57168cc30038fe", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/22ca6a127ab5413ff0a225f3fa57168cc30038fe", "committedDate": "2020-09-25T11:16:04Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf963791121c895d108bc948d0a7e6d2a9476e03", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/bf963791121c895d108bc948d0a7e6d2a9476e03", "committedDate": "2020-09-25T11:40:51Z", "message": "Checkstyles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8063cb24adffb40c9ed519c7c71a1698e2483661", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/8063cb24adffb40c9ed519c7c71a1698e2483661", "committedDate": "2020-09-25T14:53:45Z", "message": "Test update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3889e7167c3c616c9507f1f45d36f237be34474", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/a3889e7167c3c616c9507f1f45d36f237be34474", "committedDate": "2020-09-25T14:55:45Z", "message": "Test update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTAyNjc2", "url": "https://github.com/palantir/atlasdb/pull/4996#pullrequestreview-496502676", "createdAt": "2020-09-25T14:59:40Z", "commit": {"oid": "a3889e7167c3c616c9507f1f45d36f237be34474"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff8517f69643e3cfe5306b922f3fd51853d4794c", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/ff8517f69643e3cfe5306b922f3fd51853d4794c", "committedDate": "2020-09-25T15:05:37Z", "message": "Checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88779adeed7919e81969bb97830e4497a7dfdab", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/d88779adeed7919e81969bb97830e4497a7dfdab", "committedDate": "2020-09-25T16:36:20Z", "message": "Minor cleanup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2591, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}