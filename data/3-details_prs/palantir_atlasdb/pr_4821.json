{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDI0Nzk3", "number": 4821, "title": "[GCV Blocker] Don't use org.json.simple", "bodyText": "Goals (and why):\n\nUnblock #4769, gradle consistent versions is good.\nThis PR is nontrivial enough that I feel it needs a review nonetheless.\n\nImplementation Description (bullets):\n\nSwap out the implementation of the JSON parser library in NameMetadataDescription, from json.simple to Jackson (which we use everywhere anyway)\nValidate that the behaviour of parsing is unchanged.\nNote that while it might not look like this is used anywhere, actually it is internally!\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nI wrote a heavy set of tests, mainly because I need to understand the nuances of this codepath myself.\n\nConcerns (what feedback would you like?):\nThere are some minor behaviour breaks:\n\nPassing in JSON of the wrong type (e.g. \"bleh\") used to give you a ClassCastException, while now it gives you an IllegalStateException. I think this is fine.\nCauses of PalantirRuntimeExceptions owing to parser failures are going to be different, especially for the 'gobbledygook' case.\n\nIs there anything else I missed out on?\nWhere should we start reviewing?: NameMetadataDescriptionTest\nPriority (whenever / two weeks / yesterday): this week\n@j-baker for SA", "createdAt": "2020-06-03T20:05:00Z", "url": "https://github.com/palantir/atlasdb/pull/4821", "merged": true, "mergeCommit": {"oid": "a8cea73209c4eca468ad8708bda55e14406147be"}, "closed": true, "closedAt": "2020-06-04T20:25:40Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnumIugH2gAyNDI3NDI0Nzk3OjgxOWNhMTE1YTFlNGVlYTQyNzUzMjhjOTIwNzZkMzMyODIwNTFlODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn9bWugH2gAyNDI3NDI0Nzk3OmMzMTM2NmQ5MzhmMTVjZjkzMTVjZjZhYjE4YWViNTRlOWQ4OGFmZjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "819ca115a1e4eea4275328c92076d33282051e87", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/819ca115a1e4eea4275328c92076d33282051e87", "committedDate": "2020-06-03T19:26:25Z", "message": "NMD Test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1b72bef743d112882a229dd24467caffd5fc3b8", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/e1b72bef743d112882a229dd24467caffd5fc3b8", "committedDate": "2020-06-03T19:41:28Z", "message": "NMD and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de921b6373ffd2fcb79bdb09e236cc9538d31f16", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/de921b6373ffd2fcb79bdb09e236cc9538d31f16", "committedDate": "2020-06-03T19:43:27Z", "message": "Don't use orgjson"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b61844c9f2f6773bdf3c59c95e8851a001c06d6", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/0b61844c9f2f6773bdf3c59c95e8851a001c06d6", "committedDate": "2020-06-03T19:54:18Z", "message": "Finish removal of jsonsimple"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47262452eae5ef0eacee6f466f0bd30bfb7061d1", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/47262452eae5ef0eacee6f466f0bd30bfb7061d1", "committedDate": "2020-06-03T20:02:50Z", "message": "valuetype test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf", "committedDate": "2020-06-03T20:19:54Z", "message": "no conjure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjEyNjY1", "url": "https://github.com/palantir/atlasdb/pull/4821#pullrequestreview-424212665", "createdAt": "2020-06-04T08:23:46Z", "commit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoyMzo0NlrOGe7Ffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODozMzo1MFrOGe7ddg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3ODUyNg==", "bodyText": "nit: I think there were two spaces after the full stop\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Only JSON objects can be deserialized into parsed byte arrays.  Passed json was: %s\",\n          \n          \n            \n                                \"Only JSON objects can be deserialized into parsed byte arrays. Passed json was: %s\",", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435078526", "createdAt": "2020-06-04T08:23:46Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/NameMetadataDescription.java", "diffHunk": "@@ -183,8 +185,13 @@ public String renderToJson(byte[] name) {\n \n     public byte[] parseFromJson(String json, boolean allowPrefix) {\n         try {\n-            JSONObject obj = (JSONObject) new JSONParser().parse(json);\n-            int numDefinedFields = countNumDefinedFields(obj);\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            Preconditions.checkState(jsonNode.isObject(),\n+                    \"Only JSON objects can be deserialized into parsed byte arrays.  Passed json was: %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MTY0MQ==", "bodyText": "To make sure I understand: before, you would get SafeIllegalArgumentExceptions if this was not a string, but now you just get a plain RuntimeException that wraps an IOException. Is my understanding correct, and is this behaviour OK?", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435081641", "createdAt": "2020-06-04T08:28:57Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/ValueType.java", "diffHunk": "@@ -464,9 +463,7 @@ public String convertToJava(byte[] value, int offset) {\n \n         @Override\n         public byte[] convertFromJson(String jsonValue) {\n-            Object s = JSONValue.parse(jsonValue);\n-            Preconditions.checkArgument(s instanceof String, \"%s must be a json string\", jsonValue);\n-            return convertFromString((String) s);\n+            return convertFromString(ValueType.readJson(jsonValue, String.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NDY2Mg==", "bodyText": "I can't quite understand this test - it implies to me that you could get either result non-deterministically. Is this really the case currently?", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435084662", "createdAt": "2020-06-04T08:33:50Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): This looks ridiculous, but I don't wish to change existing behaviour.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0cba74c5de8e6fb234f867dd7929a4cdd3aab37", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/e0cba74c5de8e6fb234f867dd7929a4cdd3aab37", "committedDate": "2020-06-04T09:05:49Z", "message": "CR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjUwNDg1", "url": "https://github.com/palantir/atlasdb/pull/4821#pullrequestreview-424250485", "createdAt": "2020-06-04T09:10:57Z", "commit": {"oid": "e0cba74c5de8e6fb234f867dd7929a4cdd3aab37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzQ1OTMz", "url": "https://github.com/palantir/atlasdb/pull/4821#pullrequestreview-424345933", "createdAt": "2020-06-04T11:24:33Z", "commit": {"oid": "e0cba74c5de8e6fb234f867dd7929a4cdd3aab37"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMToyNDozM1rOGfBW-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMToyNDozM1rOGfBW-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MTMwNg==", "bodyText": "I think the flag should be true for it to be in prefix mode?", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435181306", "createdAt": "2020-06-04T11:24:33Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): Tolerating duplicate fields was permitted, even though it is a bit dubious.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        \n+        // Which value is selected is an implementation detail - we should not guarantee this.\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));\n+    }\n+\n+    @Test\n+    public void throwsIfNoRelevantFieldsProvided() {\n+        String missingFields = \"{\\\"type\\\": \\\"string\\\"}\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(missingFields, false))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"JSON object needs a field named: string.\");\n+    }\n+\n+    @Test\n+    public void throwsOnRawJsonString() {\n+        String jsonString = \"\\\"string\\\"\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(jsonString, false))\n+                .isInstanceOf(IllegalStateException.class)\n+                .hasMessageContaining(\"Only JSON objects can be deserialized into parsed byte arrays.\");\n+    }\n+\n+    @Test\n+    public void throwsOnArrays() {\n+        String jsonString = \"[\\\"string\\\"]\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(jsonString, false))\n+                .isInstanceOf(IllegalStateException.class)\n+                .hasMessageContaining(\"Only JSON objects can be deserialized into parsed byte arrays.\");\n+    }\n+\n+    @Test\n+    public void throwsOnNonJsonInput() {\n+        String gobbledygook = \"]q2!a0v-_13r\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(gobbledygook, false))\n+                .isInstanceOf(PalantirRuntimeException.class)\n+                .hasMessageContaining(\"Unexpected close marker\");\n+    }\n+\n+    @Test\n+    public void parseAndRenderAreInverses_MultiPart() {\n+        assertThat(MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW), false)).containsExactly(SAMPLE_ROW);\n+    }\n+\n+    @Test\n+    public void missingFieldsAreNotToleratedWithoutPrefix() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"gamma\", \"omega\"));\n+\n+        assertThatThrownBy(() -> MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), false))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"JSON object has 2 defined fields, but the number of row components is 4.\");\n+    }\n+\n+    @Test\n+    public void missingSuffixFieldsAreToleratedInPrefixMode() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"gamma\", \"omega\"));\n+\n+        byte[] bytes = MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), true);\n+        assertThat(bytes).containsExactly(SAMPLE_ROW_PREFIX);\n+    }\n+\n+    @Test\n+    public void missingNonSuffixFieldsAreNotToleratedInPrefixMode() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"alpha\", \"omega\"));\n+\n+        assertThatThrownBy(() -> MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), false))\n+                .isInstanceOf(IllegalArgumentException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0cba74c5de8e6fb234f867dd7929a4cdd3aab37"}, "originalPosition": 151}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c31366d938f15cf9315cf6ab18aeb54e9d88aff9", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/c31366d938f15cf9315cf6ab18aeb54e9d88aff9", "committedDate": "2020-06-04T12:43:13Z", "message": "Bad test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2920, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}