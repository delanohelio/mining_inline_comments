{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NTA4NzUw", "number": 4785, "title": "[PaxosStateLog] Implement locking for SqlitePSL", "bodyText": "Goals (and why):\nIn a high concurrency setting we've been hitting Sqlite timeouts due to its locking mechanism. We now do our own locking to avoid that.\nImplementation Description (bullets):\nQuite straightforward\nTesting (What was existing testing like?  What have you done to improve it?):\nAdded test that was failing on develop, now passes\nConcerns (what feedback would you like?):\nIs the factory approach reasonable and clear enough?\nWhere should we start reviewing?:\nSmall\nPriority (whenever / two weeks / yesterday):\nToday", "createdAt": "2020-05-18T13:38:48Z", "url": "https://github.com/palantir/atlasdb/pull/4785", "merged": true, "mergeCommit": {"oid": "4b36c40875c7d8da11646c68d7e2c39fa11d5634"}, "closed": true, "closedAt": "2020-05-18T15:49:08Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcigAA0gH2gAyNDE5NTA4NzUwOmFmZDZlODMyYWI5MDhmYjE0OGZmMjFkZWE5NTdhN2I3Y2U3YTI0Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcihbMwgFqTQxMzY4OTE0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "afd6e832ab908fb148ff21dea957a7b7ce7a2469", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/afd6e832ab908fb148ff21dea957a7b7ce7a2469", "committedDate": "2020-05-18T13:36:29Z", "message": "Implement locking for SqlitePSL"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNjg5MTQ1", "url": "https://github.com/palantir/atlasdb/pull/4785#pullrequestreview-413689145", "createdAt": "2020-05-18T15:11:36Z", "commit": {"oid": "afd6e832ab908fb148ff21dea957a7b7ce7a2469"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToxMTozNlrOGW7ogA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToxNTo1M1rOGW70mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODg4MA==", "bodyText": "\u2b50", "url": "https://github.com/palantir/atlasdb/pull/4785#discussion_r426698880", "createdAt": "2020-05-18T15:11:36Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -38,60 +40,95 @@\n     private final Client namespace;\n     private final String useCase;\n     private final Jdbi jdbi;\n+    private final ReadWriteLock sharedLock;\n \n-    private SqlitePaxosStateLog(NamespaceAndUseCase namespaceAndUseCase, Jdbi jdbi) {\n+    private SqlitePaxosStateLog(NamespaceAndUseCase namespaceAndUseCase, Jdbi jdbi, ReadWriteLock sharedLock) {\n         this.namespace = namespaceAndUseCase.namespace();\n         this.useCase = namespaceAndUseCase.useCase();\n         this.jdbi = jdbi;\n+        this.sharedLock = sharedLock;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(NamespaceAndUseCase namespaceAndUseCase,\n-            Supplier<Connection> connectionSupplier) {\n+    private static <V extends Persistable & Versionable> PaxosStateLog<V> create(\n+            NamespaceAndUseCase namespaceAndUseCase,\n+            Supplier<Connection> connectionSupplier, ReadWriteLock sharedLock) {\n         Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n         jdbi.getConfig(JdbiImmutables.class).registerImmutable(Client.class, PaxosRound.class);\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespaceAndUseCase, jdbi);\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespaceAndUseCase, jdbi, sharedLock);\n         log.initialize();\n         return log;\n     }\n \n+    public static SqlitePaxosStateLogFactory createFactory() {\n+        return new SqlitePaxosStateLogFactory();\n+    }\n+\n     private void initialize() {\n-        execute(Queries::createTable);\n+        executeWrite(Queries::createTable);\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        execute(dao -> dao.writeRound(namespace, useCase, seq, round.persistToBytes()));\n+        executeWrite(dao -> dao.writeRound(namespace, useCase, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public void writeBatchOfRounds(Iterable<PaxosRound<V>> rounds) {\n-        execute(dao -> dao.writeBatchOfRounds(namespace, useCase, rounds));\n+        executeWrite(dao -> dao.writeBatchOfRounds(namespace, useCase, rounds));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return execute(dao -> dao.readRound(namespace, useCase, seq));\n+        return executeRead(dao -> dao.readRound(namespace, useCase, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return execute(dao -> dao.getLeastLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return executeRead(dao -> dao.getLeastLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return execute(dao -> dao.getGreatestLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return executeRead(dao -> dao.getGreatestLogEntry(namespace, useCase)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        execute(dao -> dao.truncate(namespace, useCase, toDeleteInclusive));\n+        executeWrite(dao -> dao.truncate(namespace, useCase, toDeleteInclusive));\n+    }\n+\n+    private <T> T executeWrite(Function<Queries, T> call) {\n+        sharedLock.writeLock().lock();\n+        try {\n+            return execute(call);\n+        } finally {\n+            sharedLock.writeLock().unlock();\n+        }\n+    }\n+\n+    private <T> T executeRead(Function<Queries, T> call) {\n+        sharedLock.readLock().lock();\n+        try {\n+            return execute(call);\n+        } finally {\n+            sharedLock.readLock().unlock();\n+        }\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd6e832ab908fb148ff21dea957a7b7ce7a2469"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTk3Ng==", "bodyText": "This is kind of unpleasant but I didn't find a better way to write it", "url": "https://github.com/palantir/atlasdb/pull/4785#discussion_r426701976", "createdAt": "2020-05-18T15:15:53Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "diffHunk": "@@ -179,14 +186,27 @@ public void valuesAreDistinguishedAcrossSequenceIdentifiers() throws IOException\n \n     @Test\n     public void differentLogsToTheSameNamespaceShareState() throws IOException {\n-        PaxosStateLog<PaxosValue> otherLogWithSameNamespace\n-                = SqlitePaxosStateLog.create(wrap(CLIENT_1, USE_CASE_1), connSupplier);\n+        PaxosStateLog<PaxosValue> otherLogWithSameNamespace = FACTORY.create(wrap(CLIENT_1, USE_CASE_1), conn);\n         writeValueForRound(1L);\n \n         assertThat(stateLog.readRound(1L)).isNotNull();\n         assertThat(otherLogWithSameNamespace.readRound(1L)).isEqualTo(stateLog.readRound(1L));\n     }\n \n+    @Test\n+    public void highConcurrencyDoesNotTimeoutWithSharedLock() {\n+        int numThreads = 100;\n+        ExecutorService executor = PTExecutors.newFixedThreadPool(numThreads);\n+        List<Future<?>> futures = IntStream.range(0, numThreads)\n+                .mapToObj(ignore -> executor.submit(() -> {\n+                    PaxosStateLog<PaxosValue> log = FACTORY.create(wrap(CLIENT_1, USE_CASE_1), conn);\n+                    for (int i = 0; i < 30; i++) {\n+                        log.writeRound(i, valueForRound(i));\n+                    }\n+                })).collect(Collectors.toList());\n+        futures.forEach(future -> assertThatCode(() -> Futures.getUnchecked(future)).doesNotThrowAnyException());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd6e832ab908fb148ff21dea957a7b7ce7a2469"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2853, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}