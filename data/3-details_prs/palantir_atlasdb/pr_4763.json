{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MzE3ODQ4", "number": 4763, "title": "[Dialogue] Part 3: AtlasDbDialogueServiceProvider", "bodyText": "Goals (and why):\n\nHave a way of wiring up AtlasDb services to communicate using Dialogue.\nValidate that #4761 and #4762 are kind of sane.\n\nImplementation Description (bullets):\n\nImplement AtlasDbDialogueServiceProvider that allows users to create a Dialogue client to TimeLock.\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nAdded integration tests. Beyond sanity checks, these tests also cover the two weird quirks of a timelock http client: it survives a barrage of 308s and can recover from that, and it identifies itself to the server saying what retry protocol it supports.\n\nConcerns (what feedback would you like?):\n\nThis can go in before palantir/dialogue#728, but turning this on is probably blocked on that @carterkozak fixed it! \ud83d\ude04\n\nWhere should we start reviewing?: Look at the test first to understand what the class must do, and then check out the impl.\nPriority (whenever / two weeks / yesterday): this week", "createdAt": "2020-05-11T20:08:58Z", "url": "https://github.com/palantir/atlasdb/pull/4763", "merged": true, "mergeCommit": {"oid": "78f76a1fa46e18eee675aa2242f1ff2fc09cb2ff"}, "closed": true, "closedAt": "2020-05-12T17:12:16Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgWi4OAFqTQwOTU0MzkzOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgnKL-gH2gAyNDE2MzE3ODQ4OmY0NWYxYWE1ZTJmMTJmMTRlNDFlZTQ0MjI5NzkzNDlhMGI4MWM1MWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTQzOTM4", "url": "https://github.com/palantir/atlasdb/pull/4763#pullrequestreview-409543938", "createdAt": "2020-05-11T21:27:40Z", "commit": {"oid": "b09d1e85daba1098f8753578fa807c38a0cfe7f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyNzo0MFrOGTuBmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMToyNzo0MFrOGTuBmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMDIwMg==", "bodyText": "Is this new? In our initial testing I think we used the concurrency limiters without running into problems. In dialogue we've tried to allow them to ramp up more more quickly than CJR. There's definitely a bit of risk as we continue to tune the rate limiters, but it could help us avoid knocking over lock with too many handshakes.", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423330202", "createdAt": "2020-05-11T21:27:40Z", "author": {"login": "carterkozak"}, "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(\n+                        TIMELOCK_SHORT_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, false),\n+                        TIMELOCK_LONG_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, true)));\n+        DialogueClients.ReloadingFactory reloadingFactory\n+                = decorateForFailoverServices(baseFactory, timeLockRemoteConfigurations).withUserAgent(versionedAgent);\n+\n+        return new AtlasDbDialogueServiceProvider(reloadingFactory);\n+    }\n+\n+    ConjureTimelockService getConjureTimelockService() {\n+        Preconditions.checkState(isDialogue(ConjureTimelockServiceBlocking.class),\n+                \"Dialogue service provider attempted to provide a non-Dialogue class.\"\n+                        + \" This is an AtlasDB bug.\");\n+        ConjureTimelockServiceBlocking longTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_LONG_TIMEOUT);\n+        ConjureTimelockServiceBlocking shortTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_SHORT_TIMEOUT);\n+\n+        ShortAndLongTimeoutServices<ConjureTimelockService> shortAndLongTimeoutServices\n+                = ImmutableShortAndLongTimeoutServices.<ConjureTimelockServiceBlocking>builder()\n+                .longTimeout(longTimeoutService)\n+                .shortTimeout(shortTimeoutService)\n+                .build()\n+                .map(proxy -> FastFailoverProxy.newProxyInstance(ConjureTimelockServiceBlocking.class, () -> proxy))\n+                .map(DialogueAdaptingConjureTimelockService::new);\n+\n+        return new TimeoutSensitiveConjureTimelockService(shortAndLongTimeoutServices);\n+    }\n+\n+    private static RemoteServiceConfiguration createRemoteServiceConfiguration(\n+            UserAgent userAgent, ServerListConfig serverListConfig, boolean shouldUseExtendedTimeout) {\n+        return ImmutableRemoteServiceConfiguration.builder()\n+                .remotingParameters(getFailoverRemotingParameters(shouldUseExtendedTimeout, userAgent))\n+                .serverList(serverListConfig)\n+                .build();\n+    }\n+\n+    private static AuxiliaryRemotingParameters getFailoverRemotingParameters(\n+            boolean shouldSupportBlockingOperations, UserAgent userAgent) {\n+        return AuxiliaryRemotingParameters.builder()\n+                .shouldLimitPayload(true)\n+                .shouldRetry(true)\n+                .shouldUseExtendedTimeout(shouldSupportBlockingOperations)\n+                .userAgent(userAgent)\n+                .build();\n+    }\n+\n+    private static boolean isDialogue(Class<?> serviceInterface) {\n+        return getStaticOfMethod(serviceInterface).isPresent();\n+    }\n+\n+    private static Optional<Method> getStaticOfMethod(Class<?> dialogueInterface) {\n+        try {\n+            return Optional.ofNullable(dialogueInterface.getMethod(\"of\", Channel.class, ConjureRuntime.class));\n+        } catch (NoSuchMethodException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static DialogueClients.ReloadingFactory decorateForFailoverServices(\n+            DialogueClients.ReloadingFactory baseFactory,\n+            Refreshable<Map<String, RemoteServiceConfiguration>> serviceToRemoteConfiguration) {\n+        return baseFactory.reloading(serviceToRemoteConfiguration.map(\n+                DialogueClientOptions::toServicesConfigBlock))\n+                .withNodeSelectionStrategy(NodeSelectionStrategy.PIN_UNTIL_ERROR_WITHOUT_RESHUFFLE)\n+                .withClientQoS(ClientConfiguration.ClientQoS.DANGEROUS_DISABLE_SYMPATHETIC_CLIENT_QOS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b09d1e85daba1098f8753578fa807c38a0cfe7f4"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af5cd6ae5902a601a3703554fbfdea0f9acbb96b", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/af5cd6ae5902a601a3703554fbfdea0f9acbb96b", "committedDate": "2020-05-12T11:18:25Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04332f04a13fc1b4b6ebddd3f68c17ac5df26af7", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/04332f04a13fc1b4b6ebddd3f68c17ac5df26af7", "committedDate": "2020-05-12T11:18:28Z", "message": "ADDSP impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1604d72e86a6b7ad69cddc8eaaa7d2eb759a8a63", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/1604d72e86a6b7ad69cddc8eaaa7d2eb759a8a63", "committedDate": "2020-05-12T11:18:45Z", "message": "DACTS not in this PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3d8501e284b8eae588705c4bc52a7802ec65d99", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/c3d8501e284b8eae588705c4bc52a7802ec65d99", "committedDate": "2020-05-12T11:19:50Z", "message": "Revert \"don't put ADDSP in this commit\"\n\nThis reverts commit 0b20b83e8fc021971d4f979b8d4d5da4eb403296."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3f79733909fc8bfa7d1b49753ece1270fac2128", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/b3f79733909fc8bfa7d1b49753ece1270fac2128", "committedDate": "2020-05-12T11:19:50Z", "message": "Revert \"DACTS not in this PR\"\n\nThis reverts commit e746ac95672c2192281777b4b502e880f07005e0."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d16e8e828f03d9159d91a875518abe7338d9511", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/3d16e8e828f03d9159d91a875518abe7338d9511", "committedDate": "2020-05-12T11:19:50Z", "message": "sp test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f2b6b43f6989396b49bdda4c03a29d922ce7df6", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/6f2b6b43f6989396b49bdda4c03a29d922ce7df6", "committedDate": "2020-05-12T11:19:50Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14f02f5db8bfd3504ece84456088195fa675752d", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/14f02f5db8bfd3504ece84456088195fa675752d", "committedDate": "2020-05-12T11:19:50Z", "message": "Dialogue 1.40.1 and combine once-failing tests because they now pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3138d21cd4ee7b8e4aeca611850666c82a4d1845", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/3138d21cd4ee7b8e4aeca611850666c82a4d1845", "committedDate": "2020-05-12T11:19:50Z", "message": "bleh"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b09d1e85daba1098f8753578fa807c38a0cfe7f4", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/b09d1e85daba1098f8753578fa807c38a0cfe7f4", "committedDate": "2020-05-11T21:23:25Z", "message": "bleh"}, "afterCommit": {"oid": "3138d21cd4ee7b8e4aeca611850666c82a4d1845", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/3138d21cd4ee7b8e4aeca611850666c82a4d1845", "committedDate": "2020-05-12T11:19:50Z", "message": "bleh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7433e7d635ddabac8cae7d21fbd4daebf16fe76c", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/7433e7d635ddabac8cae7d21fbd4daebf16fe76c", "committedDate": "2020-05-12T11:21:10Z", "message": "borked changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f1448a7ed45143d32944ca359462b7da66ef8ad", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/5f1448a7ed45143d32944ca359462b7da66ef8ad", "committedDate": "2020-05-12T12:54:47Z", "message": "debug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "committedDate": "2020-05-12T13:02:06Z", "message": "5 seconds instead of 10 to avoid flakes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMDkyODQx", "url": "https://github.com/palantir/atlasdb/pull/4763#pullrequestreview-410092841", "createdAt": "2020-05-12T14:20:41Z", "commit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNDoyMDo0MVrOGUJDeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNDo0NDoyMFrOGUKMkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3MzA0OA==", "bodyText": "Lets make this 13+ so that the response makes sense", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423773048", "createdAt": "2020-05-12T14:20:41Z", "author": {"login": "gmaretic"}, "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProviderTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.config.ImmutableServerListConfig;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsResponse;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.api.config.service.ServicesConfigBlock;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.refreshable.Refreshable;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class AtlasDbDialogueServiceProviderTest {\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private static final String CLIENT = \"tom\";\n+    private static final String TIMESTAMP_PATH = \"/tl/ts/\" + CLIENT;\n+    private static final MappingBuilder TIMESTAMP_MAPPING = post(urlEqualTo(TIMESTAMP_PATH));\n+    private static final DialogueClients.ReloadingFactory DIALOGUE_BASE_FACTORY\n+            = DialogueClients.create(Refreshable.only(ServicesConfigBlock.builder().build()));\n+    private static final UserAgent USER_USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"jeremy\", \"77.79.12\"));\n+\n+    private int serverPort;\n+    private ConjureTimelockService conjureTimelockService;\n+\n+    @Rule\n+    public WireMockRule server = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        setupServerToGiveOutTimestamps();\n+\n+        serverPort = server.port();\n+        ServerListConfig serverListConfig = ImmutableServerListConfig.builder()\n+                .addServers(getUriForPort(serverPort))\n+                .sslConfiguration(SSL_CONFIGURATION)\n+                .build();\n+\n+        AtlasDbDialogueServiceProvider provider = AtlasDbDialogueServiceProvider.create(\n+                Refreshable.only(serverListConfig),\n+                DIALOGUE_BASE_FACTORY,\n+                USER_USER_AGENT);\n+        conjureTimelockService = provider.getConjureTimelockService();\n+    }\n+\n+\n+    @Test\n+    public void canMakeRequestsThroughDialogue() {\n+        ConjureGetFreshTimestampsResponse response = makeTimestampsRequest();\n+        assertThat(response.getInclusiveLower()).isEqualTo(58);\n+        assertThat(response.getInclusiveUpper()).isEqualTo(70);\n+    }\n+\n+    @Test\n+    public void requestsAreIdentifiedWithTheUserProvidedUserAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().name())));\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().version())));\n+    }\n+\n+    @Test\n+    public void atlasDbHttpClientVersionProvidedAsAnInformationalAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(\n+                        String.format(\"%s/%s\",\n+                                AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT,\n+                                AtlasDbRemotingConstants.CURRENT_CLIENT_PROTOCOL_VERSION.getProtocolVersionString()))));\n+    }\n+\n+    @Test\n+    public void resilientToRepeatedRedirects() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(308)\n+                .withHeader(\"Location\", getUriForPort(serverPort))));\n+\n+        Instant start = Instant.now();\n+        ExecutorService ex = PTExecutors.newSingleThreadExecutor(true);\n+        ex.submit(this::scheduleServerRecoveryAfterFiveSeconds);\n+\n+        assertThatCode(this::makeTimestampsRequest).doesNotThrowAnyException();\n+        assertThat(Instant.now())\n+                .as(\"should recover in a second after things are good again\")\n+                .isBefore(start.plus(Duration.ofSeconds(11)));\n+        ex.shutdown();\n+    }\n+\n+    private void scheduleServerRecoveryAfterFiveSeconds() {\n+        Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);\n+        setupServerToGiveOutTimestamps();\n+    }\n+\n+    private void setupServerToGiveOutTimestamps() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(200)\n+                .withHeader(\"Content-Type\", \"application/json\")\n+                .withBody(\"{\\\"inclusiveLower\\\": 58, \\\"inclusiveUpper\\\": 70}\")));\n+    }\n+\n+    private ConjureGetFreshTimestampsResponse makeTimestampsRequest() {\n+        return conjureTimelockService.getFreshTimestamps(\n+                AuthHeader.valueOf(\"Bearer unused\"), CLIENT, ConjureGetFreshTimestampsRequest.of(10));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3Nzk0MQ==", "bodyText": "Magic header strings are not the best, also for user agents", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423777941", "createdAt": "2020-05-12T14:26:28Z", "author": {"login": "gmaretic"}, "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProviderTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.config.ImmutableServerListConfig;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsResponse;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.api.config.service.ServicesConfigBlock;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.refreshable.Refreshable;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class AtlasDbDialogueServiceProviderTest {\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private static final String CLIENT = \"tom\";\n+    private static final String TIMESTAMP_PATH = \"/tl/ts/\" + CLIENT;\n+    private static final MappingBuilder TIMESTAMP_MAPPING = post(urlEqualTo(TIMESTAMP_PATH));\n+    private static final DialogueClients.ReloadingFactory DIALOGUE_BASE_FACTORY\n+            = DialogueClients.create(Refreshable.only(ServicesConfigBlock.builder().build()));\n+    private static final UserAgent USER_USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"jeremy\", \"77.79.12\"));\n+\n+    private int serverPort;\n+    private ConjureTimelockService conjureTimelockService;\n+\n+    @Rule\n+    public WireMockRule server = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        setupServerToGiveOutTimestamps();\n+\n+        serverPort = server.port();\n+        ServerListConfig serverListConfig = ImmutableServerListConfig.builder()\n+                .addServers(getUriForPort(serverPort))\n+                .sslConfiguration(SSL_CONFIGURATION)\n+                .build();\n+\n+        AtlasDbDialogueServiceProvider provider = AtlasDbDialogueServiceProvider.create(\n+                Refreshable.only(serverListConfig),\n+                DIALOGUE_BASE_FACTORY,\n+                USER_USER_AGENT);\n+        conjureTimelockService = provider.getConjureTimelockService();\n+    }\n+\n+\n+    @Test\n+    public void canMakeRequestsThroughDialogue() {\n+        ConjureGetFreshTimestampsResponse response = makeTimestampsRequest();\n+        assertThat(response.getInclusiveLower()).isEqualTo(58);\n+        assertThat(response.getInclusiveUpper()).isEqualTo(70);\n+    }\n+\n+    @Test\n+    public void requestsAreIdentifiedWithTheUserProvidedUserAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().name())));\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().version())));\n+    }\n+\n+    @Test\n+    public void atlasDbHttpClientVersionProvidedAsAnInformationalAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(\n+                        String.format(\"%s/%s\",\n+                                AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT,\n+                                AtlasDbRemotingConstants.CURRENT_CLIENT_PROTOCOL_VERSION.getProtocolVersionString()))));\n+    }\n+\n+    @Test\n+    public void resilientToRepeatedRedirects() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(308)\n+                .withHeader(\"Location\", getUriForPort(serverPort))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3OTI2Mg==", "bodyText": "Add a test for respecting long timeout on locks", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423779262", "createdAt": "2020-05-12T14:28:14Z", "author": {"login": "gmaretic"}, "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProviderTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.config.ImmutableServerListConfig;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsResponse;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.api.config.service.ServicesConfigBlock;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.refreshable.Refreshable;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class AtlasDbDialogueServiceProviderTest {\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private static final String CLIENT = \"tom\";\n+    private static final String TIMESTAMP_PATH = \"/tl/ts/\" + CLIENT;\n+    private static final MappingBuilder TIMESTAMP_MAPPING = post(urlEqualTo(TIMESTAMP_PATH));\n+    private static final DialogueClients.ReloadingFactory DIALOGUE_BASE_FACTORY\n+            = DialogueClients.create(Refreshable.only(ServicesConfigBlock.builder().build()));\n+    private static final UserAgent USER_USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"jeremy\", \"77.79.12\"));\n+\n+    private int serverPort;\n+    private ConjureTimelockService conjureTimelockService;\n+\n+    @Rule\n+    public WireMockRule server = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        setupServerToGiveOutTimestamps();\n+\n+        serverPort = server.port();\n+        ServerListConfig serverListConfig = ImmutableServerListConfig.builder()\n+                .addServers(getUriForPort(serverPort))\n+                .sslConfiguration(SSL_CONFIGURATION)\n+                .build();\n+\n+        AtlasDbDialogueServiceProvider provider = AtlasDbDialogueServiceProvider.create(\n+                Refreshable.only(serverListConfig),\n+                DIALOGUE_BASE_FACTORY,\n+                USER_USER_AGENT);\n+        conjureTimelockService = provider.getConjureTimelockService();\n+    }\n+\n+\n+    @Test\n+    public void canMakeRequestsThroughDialogue() {\n+        ConjureGetFreshTimestampsResponse response = makeTimestampsRequest();\n+        assertThat(response.getInclusiveLower()).isEqualTo(58);\n+        assertThat(response.getInclusiveUpper()).isEqualTo(70);\n+    }\n+\n+    @Test\n+    public void requestsAreIdentifiedWithTheUserProvidedUserAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().name())));\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().version())));\n+    }\n+\n+    @Test\n+    public void atlasDbHttpClientVersionProvidedAsAnInformationalAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(\n+                        String.format(\"%s/%s\",\n+                                AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT,\n+                                AtlasDbRemotingConstants.CURRENT_CLIENT_PROTOCOL_VERSION.getProtocolVersionString()))));\n+    }\n+\n+    @Test\n+    public void resilientToRepeatedRedirects() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(308)\n+                .withHeader(\"Location\", getUriForPort(serverPort))));\n+\n+        Instant start = Instant.now();\n+        ExecutorService ex = PTExecutors.newSingleThreadExecutor(true);\n+        ex.submit(this::scheduleServerRecoveryAfterFiveSeconds);\n+\n+        assertThatCode(this::makeTimestampsRequest).doesNotThrowAnyException();\n+        assertThat(Instant.now())\n+                .as(\"should recover in a second after things are good again\")\n+                .isBefore(start.plus(Duration.ofSeconds(11)));\n+        ex.shutdown();\n+    }\n+\n+    private void scheduleServerRecoveryAfterFiveSeconds() {\n+        Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);\n+        setupServerToGiveOutTimestamps();\n+    }\n+\n+    private void setupServerToGiveOutTimestamps() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(200)\n+                .withHeader(\"Content-Type\", \"application/json\")\n+                .withBody(\"{\\\"inclusiveLower\\\": 58, \\\"inclusiveUpper\\\": 70}\")));\n+    }\n+\n+    private ConjureGetFreshTimestampsResponse makeTimestampsRequest() {\n+        return conjureTimelockService.getFreshTimestamps(\n+                AuthHeader.valueOf(\"Bearer unused\"), CLIENT, ConjureGetFreshTimestampsRequest.of(10));\n+    }\n+\n+    private static String getUriForPort(int port) {\n+        return String.format(\"http://%s:%s\", WireMockConfiguration.DEFAULT_BIND_ADDRESS, port);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3OTg0Mg==", "bodyText": "Nice \ud83d\udd2a", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423779842", "createdAt": "2020-05-12T14:28:56Z", "author": {"login": "gmaretic"}, "path": "atlasdb-conjure/src/main/java/com/palantir/atlasdb/http/v2/FastFailoverProxy.java", "diffHunk": "@@ -98,19 +100,23 @@ private ResultOrThrowable isRetriable(Throwable throwable) {\n         }\n         InvocationTargetException exception = (InvocationTargetException) throwable;\n         Throwable cause = exception.getCause();\n-        if (!(cause instanceof RetryableException) || !isCausedByRetryOther((RetryableException) cause)) {\n+        if (!isCausedByRetryOther(cause)) {\n+            log.info(\"not caused by retry other!\", throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4MDc1Nw==", "bodyText": "This makes me sad but not actionable", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423780757", "createdAt": "2020-05-12T14:30:05Z", "author": {"login": "gmaretic"}, "path": "atlasdb-conjure/src/main/java/com/palantir/atlasdb/http/v2/FastFailoverProxy.java", "diffHunk": "@@ -98,19 +100,23 @@ private ResultOrThrowable isRetriable(Throwable throwable) {\n         }\n         InvocationTargetException exception = (InvocationTargetException) throwable;\n         Throwable cause = exception.getCause();\n-        if (!(cause instanceof RetryableException) || !isCausedByRetryOther((RetryableException) cause)) {\n+        if (!isCausedByRetryOther(cause)) {\n+            log.info(\"not caused by retry other!\", throwable);\n             return ResultOrThrowable.failure(cause);\n         }\n         return ResultOrThrowable.success(null);\n     }\n \n     @VisibleForTesting\n-    static boolean isCausedByRetryOther(RetryableException ex) {\n-        Throwable cause = ex;\n+    static boolean isCausedByRetryOther(Throwable throwable) {\n+        Throwable cause = throwable;\n         while (cause != null) {\n             if (cause instanceof QosException.RetryOther) {\n                 return true;\n             }\n+            if (cause instanceof UnknownRemoteException && ((UnknownRemoteException) cause).getStatus() == 308) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4NDEwNw==", "bodyText": "let's be consistent in naming :D", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423784107", "createdAt": "2020-05-12T14:34:21Z", "author": {"login": "gmaretic"}, "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(\n+                        TIMELOCK_SHORT_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, false),\n+                        TIMELOCK_LONG_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, true)));\n+        DialogueClients.ReloadingFactory reloadingFactory\n+                = decorateForFailoverServices(baseFactory, timeLockRemoteConfigurations).withUserAgent(versionedAgent);\n+\n+        return new AtlasDbDialogueServiceProvider(reloadingFactory);\n+    }\n+\n+    ConjureTimelockService getConjureTimelockService() {\n+        Preconditions.checkState(isDialogue(ConjureTimelockServiceBlocking.class),\n+                \"Dialogue service provider attempted to provide a non-Dialogue class.\"\n+                        + \" This is an AtlasDB bug.\");\n+        ConjureTimelockServiceBlocking longTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_LONG_TIMEOUT);\n+        ConjureTimelockServiceBlocking shortTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_SHORT_TIMEOUT);\n+\n+        ShortAndLongTimeoutServices<ConjureTimelockService> shortAndLongTimeoutServices\n+                = ImmutableShortAndLongTimeoutServices.<ConjureTimelockServiceBlocking>builder()\n+                .longTimeout(longTimeoutService)\n+                .shortTimeout(shortTimeoutService)\n+                .build()\n+                .map(proxy -> FastFailoverProxy.newProxyInstance(ConjureTimelockServiceBlocking.class, () -> proxy))\n+                .map(DialogueAdaptingConjureTimelockService::new);\n+\n+        return new TimeoutSensitiveConjureTimelockService(shortAndLongTimeoutServices);\n+    }\n+\n+    private static RemoteServiceConfiguration createRemoteServiceConfiguration(\n+            UserAgent userAgent, ServerListConfig serverListConfig, boolean shouldUseExtendedTimeout) {\n+        return ImmutableRemoteServiceConfiguration.builder()\n+                .remotingParameters(getFailoverRemotingParameters(shouldUseExtendedTimeout, userAgent))\n+                .serverList(serverListConfig)\n+                .build();\n+    }\n+\n+    private static AuxiliaryRemotingParameters getFailoverRemotingParameters(\n+            boolean shouldSupportBlockingOperations, UserAgent userAgent) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4NzU1NQ==", "bodyText": "Let's kill this check because it's really hacky and currently not needed (and let's keep it that way)", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423787555", "createdAt": "2020-05-12T14:38:53Z", "author": {"login": "gmaretic"}, "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(\n+                        TIMELOCK_SHORT_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, false),\n+                        TIMELOCK_LONG_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, true)));\n+        DialogueClients.ReloadingFactory reloadingFactory\n+                = decorateForFailoverServices(baseFactory, timeLockRemoteConfigurations).withUserAgent(versionedAgent);\n+\n+        return new AtlasDbDialogueServiceProvider(reloadingFactory);\n+    }\n+\n+    ConjureTimelockService getConjureTimelockService() {\n+        Preconditions.checkState(isDialogue(ConjureTimelockServiceBlocking.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5MTc2Mw==", "bodyText": "Extract a constant function or a method so it's a bit more visible how this works", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423791763", "createdAt": "2020-05-12T14:44:20Z", "author": {"login": "gmaretic"}, "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31894f7f715115a8dd1421ac9305416956e5c6a5", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/31894f7f715115a8dd1421ac9305416956e5c6a5", "committedDate": "2020-05-12T14:46:31Z", "message": "oops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2142613da2b5b1aac113a3451360392aa6d90bd4", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/2142613da2b5b1aac113a3451360392aa6d90bd4", "committedDate": "2020-05-12T16:30:38Z", "message": "CR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f45f1aa5e2f12f14e41ee4422979349a0b81c51f", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/f45f1aa5e2f12f14e41ee4422979349a0b81c51f", "committedDate": "2020-05-12T16:49:05Z", "message": "test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2830, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}