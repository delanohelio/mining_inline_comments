{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNzk0NDY2", "number": 4565, "title": "[Timelock Partitioning] Part 51: Wiremock integration tests for multi leader", "bodyText": "Goals (and why):\nSo previously, when #4515 merged/was introduced it didn't really assert anything regarding the multi leader capabilities. It just confirmed that for a single leader, are we still \"correct\".\nWith this PR we add specific tests exercise/assert that we're doing the right things. As it stands they're not exhaustive, but with the framework I've added it should make for a pretty easy way to add extra tests.\nImplementation Description (bullets):\n\nWe use wiremock as a proxy in front of timelock. This allows us to arbitrarily spy/reject requests to timelock that enables forcing timelock into a particular state. i.e. if we have decided on an allocation for leaders for timelock, we can then block all requests to that namespace, and ensure that the clients we use in the test all go through the proxy that's wired up to the wiremock server.\nWe add some basic smoke tests to confirm this works as we want i.e. if I were to speak to a node directly (not via failover) it'll 308 when it's not the leader etc.\n\nTesting (What was existing testing like?  What have you done to improve it?):\nThis is all tests.\nConcerns (what feedback would you like?):\nTests here aren't exhaustive, happy to pair to add some more.\nWhere should we start reviewing?:\nCommit by commit really.\nPriority (whenever / two weeks / yesterday):\nASAP \ud83d\udc83", "createdAt": "2020-02-11T17:44:06Z", "url": "https://github.com/palantir/atlasdb/pull/4565", "merged": true, "mergeCommit": {"oid": "0cf0c6f2300e66e2b65ef49d5a5d9930d6f58245"}, "closed": true, "closedAt": "2020-03-19T12:55:40Z", "author": {"login": "felixdesouza"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDk3DNAFqTM1NzMyMzU5Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPLPo3gH2gAyMzczNzk0NDY2OjM1YjIzN2ZmOTZhYTBmMDQzMzgwMjRlZWQ5ZmQxMjQxMjcxZTRhNTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MzIzNTkz", "url": "https://github.com/palantir/atlasdb/pull/4565#pullrequestreview-357323593", "createdAt": "2020-02-12T10:03:14Z", "commit": {"oid": "b94da329be84d89c534781fbd266b4f36be995a3"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowMzoxNFrOFooaDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTo0MTo1NVrOFore6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0OTM4OA==", "bodyText": "\ud83c\uddeb\ud83c\uddf7", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r378149388", "createdAt": "2020-02-12T10:03:14Z", "author": {"login": "jeremyk-91"}, "path": "timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/PaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -94,7 +98,7 @@ public static void waitForClusterToStabilize() {\n                         NAMESPACES.forEach(client -> TIMELOCK.client(client).legacyLockService().currentTimeMillis());\n                         return TIMELOCK.pinger().ping(NAMESPACES).containsAll(NAMESPACES);\n                     } catch (Throwable t) {\n-                        LoggerFactory.getLogger(PaxosTimeLockServerIntegrationTest.class).error(\"erreur!\", t);\n+                        log.error(\"erreur!\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b94da329be84d89c534781fbd266b4f36be995a3"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5ODk2NQ==", "bodyText": "nit: 308", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r378198965", "createdAt": "2020-02-12T11:40:02Z", "author": {"login": "jeremyk-91"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiLeaderMultiNodePaxosTimeLockIntegrationTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.timelock.suite.MultiLeaderPaxosSuite;\n+import com.palantir.atlasdb.timelock.util.ParameterInjector;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.conjure.java.api.errors.QosException;\n+\n+@RunWith(Parameterized.class)\n+public class MultiLeaderMultiNodePaxosTimeLockIntegrationTest {\n+\n+    @ClassRule\n+    public static ParameterInjector<TestableTimelockCluster> injector =\n+            ParameterInjector.withFallBackConfiguration(() -> MultiLeaderPaxosSuite.MULTI_LEADER_PAXOS);\n+\n+    @Parameterized.Parameter\n+    public TestableTimelockCluster cluster;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Iterable<TestableTimelockCluster> params() {\n+        return injector.getParameter();\n+    }\n+\n+\n+    @Test\n+    public void eachNamespaceGetsAssignedDifferentLeaders() {\n+        SetMultimap<TestableTimelockServer, String> allocations = allocateRandomNamespacesToAllNodes(3);\n+\n+        Set<String> allNamespaces = ImmutableSet.copyOf(allocations.values());\n+\n+        allNamespaces.stream()\n+                .map(cluster::client)\n+                .map(NamespacedClients::throughWireMockProxy)\n+                .forEach(NamespacedClients::getFreshTimestamp);\n+\n+        SetMultimap<TestableTimelockServer, String> namespacesByLeader =\n+                ImmutableSetMultimap.copyOf(cluster.currentLeaders(allNamespaces)).inverse();\n+\n+        assertThat(namespacesByLeader)\n+                .isEqualTo(allocations);\n+\n+        cluster.servers().forEach(TestableTimelockServer::allowAllNamespaces);\n+    }\n+\n+    @Test\n+    public void nonLeadersCorrectly308() {\n+        SetMultimap<TestableTimelockServer, String> allocations = allocateRandomNamespacesToAllNodes(1);\n+        String randomNamespace = Iterables.get(allocations.values(), 0);\n+        NamespacedClients clientForRandomNamespace = cluster.client(randomNamespace).throughWireMockProxy();\n+        clientForRandomNamespace.getFreshTimestamp();\n+\n+        cluster.servers().forEach(TestableTimelockServer::allowAllNamespaces);\n+\n+        TestableTimelockServer allocatedLeader = Iterables.getOnlyElement(\n+                ImmutableSetMultimap.copyOf(allocations).inverse().get(randomNamespace));\n+\n+        assertThat(cluster.currentLeaderFor(randomNamespace))\n+                .isEqualTo(allocatedLeader);\n+\n+        cluster.nonLeaders(randomNamespace).get(randomNamespace).forEach(nonLeader ->\n+                assertThatThrownBy(() -> nonLeader.client(randomNamespace).getFreshTimestamp())\n+                        .as(\"non leaders should return 503\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b94da329be84d89c534781fbd266b4f36be995a3"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE5OTc4Ng==", "bodyText": "Discussed offline: The reason this test works is because in the setup, if we have assigned namespace NAMESPACE to node A, then only A knows about NAMESPACE. So only A will propose in the Paxos sequence for NAMESPACE, and thus A should become the leader. Also, before we allowAllNamespaces the other nodes will just reply with 503s that are in front of the direct proxy, so it's not possible that there will be another election in any namespaces causing cluster.currentLeaders(...) to change.\nThis is pretty clever! Maybe worth a comment somewhere.", "url": "https://github.com/palantir/atlasdb/pull/4565#discussion_r378199786", "createdAt": "2020-02-12T11:41:55Z", "author": {"login": "jeremyk-91"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiLeaderMultiNodePaxosTimeLockIntegrationTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Stream;\n+\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.timelock.suite.MultiLeaderPaxosSuite;\n+import com.palantir.atlasdb.timelock.util.ParameterInjector;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.conjure.java.api.errors.QosException;\n+\n+@RunWith(Parameterized.class)\n+public class MultiLeaderMultiNodePaxosTimeLockIntegrationTest {\n+\n+    @ClassRule\n+    public static ParameterInjector<TestableTimelockCluster> injector =\n+            ParameterInjector.withFallBackConfiguration(() -> MultiLeaderPaxosSuite.MULTI_LEADER_PAXOS);\n+\n+    @Parameterized.Parameter\n+    public TestableTimelockCluster cluster;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Iterable<TestableTimelockCluster> params() {\n+        return injector.getParameter();\n+    }\n+\n+\n+    @Test\n+    public void eachNamespaceGetsAssignedDifferentLeaders() {\n+        SetMultimap<TestableTimelockServer, String> allocations = allocateRandomNamespacesToAllNodes(3);\n+\n+        Set<String> allNamespaces = ImmutableSet.copyOf(allocations.values());\n+\n+        allNamespaces.stream()\n+                .map(cluster::client)\n+                .map(NamespacedClients::throughWireMockProxy)\n+                .forEach(NamespacedClients::getFreshTimestamp);\n+\n+        SetMultimap<TestableTimelockServer, String> namespacesByLeader =\n+                ImmutableSetMultimap.copyOf(cluster.currentLeaders(allNamespaces)).inverse();\n+\n+        assertThat(namespacesByLeader)\n+                .isEqualTo(allocations);\n+\n+        cluster.servers().forEach(TestableTimelockServer::allowAllNamespaces);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b94da329be84d89c534781fbd266b4f36be995a3"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "301a67b5e7e2c7855348136032782aa9fdbbf9de", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/301a67b5e7e2c7855348136032782aa9fdbbf9de", "committedDate": "2020-03-19T12:23:56Z", "message": "Add wiremock capabilities to the tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9ccaf72a785a1d8e533ea9c03f370495a7b5be7", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/c9ccaf72a785a1d8e533ea9c03f370495a7b5be7", "committedDate": "2020-03-19T12:23:56Z", "message": "Add some multi leader tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b442ddaedcf39311188330a375368419b3764ef", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/9b442ddaedcf39311188330a375368419b3764ef", "committedDate": "2020-03-19T12:23:56Z", "message": "Fix checkstyle and broken tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b088e51874478706e87286893a8e4215437c8226", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/b088e51874478706e87286893a8e4215437c8226", "committedDate": "2020-03-19T12:23:56Z", "message": "Use correct truststore and password."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b16f364c158ce6cb3a1dec68c58845f394bf03b6", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/b16f364c158ce6cb3a1dec68c58845f394bf03b6", "committedDate": "2020-03-19T12:23:56Z", "message": "Checkstyle and remove truststore."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4f9e2220b3e7f82ba5efa11354264c910524071", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/e4f9e2220b3e7f82ba5efa11354264c910524071", "committedDate": "2020-03-19T12:23:56Z", "message": "Address comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b94da329be84d89c534781fbd266b4f36be995a3", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/b94da329be84d89c534781fbd266b4f36be995a3", "committedDate": "2020-02-11T22:48:24Z", "message": "Checkstyle and remove truststore."}, "afterCommit": {"oid": "e4f9e2220b3e7f82ba5efa11354264c910524071", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/e4f9e2220b3e7f82ba5efa11354264c910524071", "committedDate": "2020-03-19T12:23:56Z", "message": "Address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35b237ff96aa0f04338024eed9fd1241271e4a52", "author": {"user": {"login": "felixdesouza", "name": "Felix de Souza"}}, "url": "https://github.com/palantir/atlasdb/commit/35b237ff96aa0f04338024eed9fd1241271e4a52", "committedDate": "2020-03-19T12:40:59Z", "message": "Support conjure endpoints."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2255, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}