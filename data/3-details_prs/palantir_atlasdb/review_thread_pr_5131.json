{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3MzM0NzE2", "number": 5131, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo0NjowMFrOE9SW2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo1MzowMFrOE_Iv0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjk5MzUzOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo0NjowMFrOH55WLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo0NjowMFrOH55WLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDQ0NA==", "bodyText": "Technically, I don't think we guarantee non-negative timestamps, so this should be Long.MIN_VALUE", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r530470444", "createdAt": "2020-11-25T15:46:00Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -195,4 +206,35 @@ private static int getQuorumSize(List<ConsolidatedLearnerAndAcceptorRecord> reco\n     private static byte[] getPaxosValueData(Optional<PaxosValue> learnedValue) {\n         return learnedValue.map(PaxosValue::getData).orElse(null);\n     }\n+\n+    private static boolean clockWentBackwardsOnNode(ConsolidatedLearnerAndAcceptorRecord record) {\n+        List<SequenceAndTimestampPair> seqAndTimestampPairs = KeyedStream.stream(record.record())\n+                .map(val -> getPaxosValueData(val.learnedValue()))\n+                .filter(Predicates.notNull())\n+                .mapEntries((sequence, timestamp) -> Maps.immutableEntry(\n+                        sequence, ImmutableSequenceAndTimestampPair.of(sequence, PtBytes.toLong(timestamp))))\n+                .values()\n+                .sorted(Comparator.comparingLong(SequenceAndTimestampPair::sequence))\n+                .collect(Collectors.toList());\n+\n+        long greatestTimestampSoFar = -1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2aa51a2c1f7de1a8fe08cf88d8f47805478ef6"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzE5MTU5OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyODo1N1rOH57Ofg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyODo1N1rOH57Ofg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMTI0Ng==", "bodyText": "If you want to be a bit fancy:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<SequenceAndTimestampPair> seqAndTimestampPairs = KeyedStream.stream(record.record())\n          \n          \n            \n                            .map(val -> getPaxosValueData(val.learnedValue()))\n          \n          \n            \n                            .filter(Predicates.notNull())\n          \n          \n            \n                            .mapEntries((sequence, timestamp) -> Maps.immutableEntry(\n          \n          \n            \n                                    sequence, ImmutableSequenceAndTimestampPair.of(sequence, PtBytes.toLong(timestamp))))\n          \n          \n            \n                            .values()\n          \n          \n            \n                            .sorted(Comparator.comparingLong(SequenceAndTimestampPair::sequence))\n          \n          \n            \n                            .collect(Collectors.toList());\n          \n          \n            \n            \n          \n          \n            \n                    long greatestTimestampSoFar = -1L;\n          \n          \n            \n                    long currentTimestamp;\n          \n          \n            \n                    for (SequenceAndTimestampPair sequenceAndTimestampPair : seqAndTimestampPairs) {\n          \n          \n            \n                        currentTimestamp = sequenceAndTimestampPair.timestamp();\n          \n          \n            \n                        if (currentTimestamp <= greatestTimestampSoFar) {\n          \n          \n            \n                            return true;\n          \n          \n            \n                        }\n          \n          \n            \n                        greatestTimestampSoFar = currentTimestamp;\n          \n          \n            \n                    }\n          \n          \n            \n                    return false;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Value.Immutable\n          \n          \n            \n                interface SequenceAndTimestampPair {\n          \n          \n            \n                    @Value.Parameter\n          \n          \n            \n                    long sequence();\n          \n          \n            \n            \n          \n          \n            \n                    @Value.Parameter\n          \n          \n            \n                    long timestamp();\n          \n          \n            \n                }\n          \n          \n            \n                    Stream<Long> expectedSortedTimestamps = KeyedStream.stream(record.record())\n          \n          \n            \n                            .map(val -> getPaxosValueData(val.learnedValue()))\n          \n          \n            \n                            .filter(Predicates.notNull())\n          \n          \n            \n                            .mapEntries((sequence, timestamp) -> Maps.immutableEntry(sequence, PtBytes.toLong(timestamp)))\n          \n          \n            \n                            .entries()\n          \n          \n            \n                            .sorted(Comparator.comparingLong(Entry::getKey))\n          \n          \n            \n                            .map(Entry::getValue);\n          \n          \n            \n                    return StreamEx.of(expectedSortedTimestamps)\n          \n          \n            \n                            .pairMap((first, second) -> first >= second)\n          \n          \n            \n                            .anyMatch(x -> x);\n          \n      \n    \n    \n  \n\nIf you don't want to use StreamEx, you can still avoid the immutable by checking expectedSortedTimestamps in a for loop, but just compare neighbours instead of maintaining a global maximum", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r530501246", "createdAt": "2020-11-25T16:28:57Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -195,4 +206,35 @@ private static int getQuorumSize(List<ConsolidatedLearnerAndAcceptorRecord> reco\n     private static byte[] getPaxosValueData(Optional<PaxosValue> learnedValue) {\n         return learnedValue.map(PaxosValue::getData).orElse(null);\n     }\n+\n+    private static boolean clockWentBackwardsOnNode(ConsolidatedLearnerAndAcceptorRecord record) {\n+        List<SequenceAndTimestampPair> seqAndTimestampPairs = KeyedStream.stream(record.record())\n+                .map(val -> getPaxosValueData(val.learnedValue()))\n+                .filter(Predicates.notNull())\n+                .mapEntries((sequence, timestamp) -> Maps.immutableEntry(\n+                        sequence, ImmutableSequenceAndTimestampPair.of(sequence, PtBytes.toLong(timestamp))))\n+                .values()\n+                .sorted(Comparator.comparingLong(SequenceAndTimestampPair::sequence))\n+                .collect(Collectors.toList());\n+\n+        long greatestTimestampSoFar = -1L;\n+        long currentTimestamp;\n+        for (SequenceAndTimestampPair sequenceAndTimestampPair : seqAndTimestampPairs) {\n+            currentTimestamp = sequenceAndTimestampPair.timestamp();\n+            if (currentTimestamp <= greatestTimestampSoFar) {\n+                return true;\n+            }\n+            greatestTimestampSoFar = currentTimestamp;\n+        }\n+        return false;\n+    }\n+\n+    @Value.Immutable\n+    interface SequenceAndTimestampPair {\n+        @Value.Parameter\n+        long sequence();\n+\n+        @Value.Parameter\n+        long timestamp();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2aa51a2c1f7de1a8fe08cf88d8f47805478ef6"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTc3ODAwOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTowODo0NlrOH7_ZJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTowODo0NlrOH7_ZJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY2NjY2MA==", "bodyText": "This won't work, need to fetch the next seq number > upper and use range [lower, next_seq_after_upper] for analysis.", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r532666660", "createdAt": "2020-11-30T15:08:46Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n+import com.palantir.timelock.history.PaxosLogHistoryProgressTracker;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.util.UseCaseUtils;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.sql.DataSource;\n+import one.util.streamex.StreamEx;\n+\n+public class LocalTimestampInvariantsVerifier {\n+    @VisibleForTesting\n+    static final int DELTA = 5;\n+\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efcae68f1ca68ae6914b69cfc18c4890cd8d0568"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjMyMjkzOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalCorruptionDetector.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozNDozN1rOH8qm9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozNDozN1rOH8qm9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NDcxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        .putAllViolatingStatusesToNamespaceAndUseCase(\n          \n          \n            \n                                                paxosRoundCorruptionReport.violatingStatusesToNamespaceAndUseCase())\n          \n          \n            \n                                                                    .from(paxosRoundCorruptionReport)", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533374711", "createdAt": "2020-12-01T12:34:37Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalCorruptionDetector.java", "diffHunk": "@@ -34,30 +34,44 @@\n             new NamedThreadFactory(CORRUPTION_DETECTOR_THREAD_PREFIX, true));\n     private final LocalCorruptionHandler corruptionHandler;\n     private final PaxosLogHistoryProvider historyProvider;\n+    private final LocalTimestampInvariantsVerifier timestampInvariantsVerifier;\n \n     private volatile CorruptionStatus localCorruptionState = CorruptionStatus.HEALTHY;\n     private volatile CorruptionHealthReport localCorruptionReport = CorruptionHealthReport.defaultHealthyReport();\n \n     public static LocalCorruptionDetector create(\n-            PaxosLogHistoryProvider historyProvider, List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+            PaxosLogHistoryProvider historyProvider,\n+            List<TimeLockCorruptionNotifier> corruptionNotifiers,\n+            LocalTimestampInvariantsVerifier timestampInvariants) {\n         LocalCorruptionDetector localCorruptionDetector =\n-                new LocalCorruptionDetector(historyProvider, corruptionNotifiers);\n+                new LocalCorruptionDetector(historyProvider, corruptionNotifiers, timestampInvariants);\n \n         localCorruptionDetector.scheduleWithFixedDelay();\n         return localCorruptionDetector;\n     }\n \n     private LocalCorruptionDetector(\n-            PaxosLogHistoryProvider historyProvider, List<TimeLockCorruptionNotifier> corruptionNotifiers) {\n+            PaxosLogHistoryProvider historyProvider,\n+            List<TimeLockCorruptionNotifier> corruptionNotifiers,\n+            LocalTimestampInvariantsVerifier timestampInvariantsVerifier) {\n \n         this.historyProvider = historyProvider;\n+        this.timestampInvariantsVerifier = timestampInvariantsVerifier;\n         this.corruptionHandler = new LocalCorruptionHandler(corruptionNotifiers);\n     }\n \n     private void scheduleWithFixedDelay() {\n         executor.scheduleWithFixedDelay(\n                 () -> {\n-                    localCorruptionReport = analyzeHistoryAndBuildCorruptionHealthReport();\n+                    CorruptionHealthReport paxosRoundCorruptionReport = analyzeHistoryAndBuildCorruptionHealthReport();\n+                    CorruptionHealthReport timestampInvariantsReport =\n+                            timestampInvariantsVerifier.timestampInvariantsHealthReport();\n+                    localCorruptionReport = ImmutableCorruptionHealthReport.builder()\n+                            .putAllViolatingStatusesToNamespaceAndUseCase(\n+                                    paxosRoundCorruptionReport.violatingStatusesToNamespaceAndUseCase())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjMzNjI5OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozODozNlrOH8qvVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjozODozNlrOH8qvVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3Njg1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .filter(Predicates.notNull())\n          \n          \n            \n                            .filter(Objects::nonNull)", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533376855", "createdAt": "2020-12-01T12:38:36Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.util.UseCaseUtils;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.sql.DataSource;\n+import one.util.streamex.StreamEx;\n+\n+/**\n+ * This class validates that timestamp bounds increase with increasing sequence numbers.\n+ *\n+ * The validation is done batch wise, e.g. [1, n], [n, 2 * n - 1] and so on. Two consecutive batches share\n+ * boundaries, this is expected and is done to catch inversion at batch end.\n+ * */\n+public class LocalTimestampInvariantsVerifier {\n+    @VisibleForTesting\n+    public static final int LEARNER_LOG_BATCH_SIZE_LIMIT = 250;\n+\n+    public static final long MIN_SEQUENCE_TO_BE_VERIFIED = -1L;\n+\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+    private Map<NamespaceAndUseCase, Long> minInclusiveSeqBoundsToBeVerified = new ConcurrentHashMap<>();\n+\n+    public LocalTimestampInvariantsVerifier(DataSource dataSource) {\n+        this.sqlitePaxosStateLogHistory = SqlitePaxosStateLogHistory.create(dataSource);\n+    }\n+\n+    public CorruptionHealthReport timestampInvariantsHealthReport() {\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> namespacesExhibitingViolations = KeyedStream.of(\n+                        getNamespaceAndUseCaseTuples())\n+                .map(this::timestampInvariantsViolationLevel)\n+                .filter(CorruptionCheckViolation::raiseErrorAlert)\n+                .mapEntries((k, v) -> Maps.immutableEntry(v, k))\n+                .collectToSetMultimap();\n+        return ImmutableCorruptionHealthReport.builder()\n+                .violatingStatusesToNamespaceAndUseCase(namespacesExhibitingViolations)\n+                .build();\n+    }\n+\n+    private CorruptionCheckViolation timestampInvariantsViolationLevel(NamespaceAndUseCase namespaceAndUseCase) {\n+        Stream<Long> expectedSortedTimestamps = KeyedStream.stream(getLearnerLogs(namespaceAndUseCase))\n+                .map(PaxosValue::getData)\n+                .filter(Predicates.notNull())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM0NzE0OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0MToyNlrOH8q1qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0MToyNlrOH8q1qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3ODQ3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final long MIN_SEQUENCE_TO_BE_VERIFIED = -1L;\n          \n          \n            \n                public static final long MIN_SEQUENCE_TO_BE_VERIFIED = Long.MIN_VALUE;", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533378475", "createdAt": "2020-12-01T12:41:26Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifier.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.util.UseCaseUtils;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.sql.DataSource;\n+import one.util.streamex.StreamEx;\n+\n+/**\n+ * This class validates that timestamp bounds increase with increasing sequence numbers.\n+ *\n+ * The validation is done batch wise, e.g. [1, n], [n, 2 * n - 1] and so on. Two consecutive batches share\n+ * boundaries, this is expected and is done to catch inversion at batch end.\n+ * */\n+public class LocalTimestampInvariantsVerifier {\n+    @VisibleForTesting\n+    public static final int LEARNER_LOG_BATCH_SIZE_LIMIT = 250;\n+\n+    public static final long MIN_SEQUENCE_TO_BE_VERIFIED = -1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3MzE0OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0ODoxNlrOH8rFIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNToxNFrOH8uDXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjQzMw==", "bodyText": "This method name is kinda misleading, it's actually forcing the timestamp to go forward / sequence to go backwards. It's only making the timestamp go backwards for the sequence after, right?", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533382433", "createdAt": "2020-12-01T12:48:16Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTEzMg==", "bodyText": "Ah yes, that makes sense. Basically what I mean is - create inversion b/w this sequence and the next. I have changed the name to createTimestampInversion now.", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533431132", "createdAt": "2020-12-01T14:05:14Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjQzMw=="}, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3NzU3OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0OToyNlrOH8rHxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNjowN1rOH8uFzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzEwOQ==", "bodyText": "Shouldn't this then be helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT - 1);?", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533383109", "createdAt": "2020-12-01T12:49:26Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchStart() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(1);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchEnd() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTc1Nw==", "bodyText": "Good catch! yes, this is a copy pasting mistake.", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533431757", "createdAt": "2020-12-01T14:06:07Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchStart() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(1);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchEnd() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzEwOQ=="}, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM4NTkzOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo1MTozOFrOH8rMng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowNjo0OFrOH8uHww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NDM1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n          \n          \n            \n                    helper.forceTimestampToGoBackwards(1);\n          \n      \n    \n    \n  \n\nThis way we test that we don't skip the one entry from first check. Also I guess do this before the first check to be consistent", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533384350", "createdAt": "2020-12-01T12:51:38Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchStart() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(1);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchEnd() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsStartOfNextBatch() {\n+        helper.writeLogsOnDefaultLocalServer(1, 2 * LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsInLaterBatch() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 2 * LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(3 * LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void resetsProgressIfNotEnoughLogsForVerification() {\n+        helper.writeLogsOnDefaultLocalServer(1, 1);\n+        // No signs of corruption\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        helper.writeLogsOnDefaultLocalServer(2, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMjI1OQ==", "bodyText": "Done.", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533432259", "createdAt": "2020-12-01T14:06:48Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/LocalTimestampInvariantsVerifierTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static com.palantir.timelock.corruption.detection.LocalTimestampInvariantsVerifier.LEARNER_LOG_BATCH_SIZE_LIMIT;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalTimestampInvariantsVerifierTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionIfClockWentBackwardsOnNode() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT - 1);\n+        helper.forceTimestampToGoBackwards(5);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchStart() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(1);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsAtBatchEnd() {\n+        helper.writeLogsOnDefaultLocalServer(1, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsStartOfNextBatch() {\n+        helper.writeLogsOnDefaultLocalServer(1, 2 * LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void detectIfClockWentBackwardsInLaterBatch() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 2 * LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(3 * LEARNER_LOG_BATCH_SIZE_LIMIT / 2);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertClockWentBackwards();\n+    }\n+\n+    @Test\n+    public void resetsProgressIfNotEnoughLogsForVerification() {\n+        helper.writeLogsOnDefaultLocalServer(1, 1);\n+        // No signs of corruption\n+        helper.assertLocalTimestampInvariantsStand();\n+\n+        helper.writeLogsOnDefaultLocalServer(2, LEARNER_LOG_BATCH_SIZE_LIMIT);\n+        helper.forceTimestampToGoBackwards(LEARNER_LOG_BATCH_SIZE_LIMIT / 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NDM1MA=="}, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM5MDU4OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo1MzowMFrOH8rPgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo1MzowMFrOH8rPgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NTA5MQ==", "bodyText": "Maybe rename to assertClockWentBackwardsInNextBatch to be clearer? Same for the method below", "url": "https://github.com/palantir/atlasdb/pull/5131#discussion_r533385091", "createdAt": "2020-12-01T12:53:00Z", "author": {"login": "gmaretic"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -105,6 +105,31 @@ void assertViolationDetectedForNamespaceAndUseCases(\n         return timeLockCorruptionTestSetup.createStatLogForNamespaceAndUseCase(namespaceAndUseCase);\n     }\n \n+    void assertClockWentBackwards() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d1471a2271cd58e20b8779581494a79a788c53"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2519, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}