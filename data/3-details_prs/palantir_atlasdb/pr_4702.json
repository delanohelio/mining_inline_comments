{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTk4NDg5", "number": 4702, "title": "[PDS-115789] API Contracts for Snapshot Transaction Methods", "bodyText": "Goals (and why):\n\nThe lack of precision on what is and isn't expected of these methods was probably a contributing factor to PDS-115789.\nMake it very clear what, as AtlasDB developers, we need to check when these methods are changed\nMake it clear what, as AtlasDB users, we can and cannot expect from these endpoints.\n\nImplementation Description (bullets):\n\nAdd comments to the four methods at the top of SnapshotTransaction\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nNo new prod code here.\n\nConcerns (what feedback would you like?):\n\nAre these contracts correctly defined given (1) what the code actually does, and (2) current usage in the field?\nSome of these contracts may be stronger than necessary, in terms of the guarantees we offer consumers. Do we want to continue offering such strong guarantees?\nA little less confident on users seeing these (they use the generated code), but a responsible user should check; also, this is still useful for Atlas dev.\n\nI would not like this PR to merge without a sanity check from @j-baker and @mswintermeyer (or someone from large internal product).\nWhere should we start reviewing?: SnapshotTransaction\nPriority (whenever / two weeks / yesterday): this week or early next.", "createdAt": "2020-04-08T18:07:11Z", "url": "https://github.com/palantir/atlasdb/pull/4702", "merged": true, "mergeCommit": {"oid": "0fcac22a8bfe1abbdb6084ddbf6ac6421446b4ce"}, "closed": true, "closedAt": "2020-06-03T16:51:19Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVrlqkgH2gAyNDAwOTk4NDg5OmFhMGJmOTJiYTEwM2Q2MjE5NTRkZTFmMWY0MzQ5OTRmYzUwNjBjOTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnp4AygH2gAyNDAwOTk4NDg5OjE1YmE1OGQ0NGY3NTNkZTQ0MWE2NjhiODNiZmJlYTA2ODgzY2FmZWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aa0bf92ba103d621954de1f1f434994fc5060c93", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/aa0bf92ba103d621954de1f1f434994fc5060c93", "committedDate": "2020-04-08T17:45:33Z", "message": "Transaction javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "551203299cf154633e17b09fb9b0a5c965375b1e", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/551203299cf154633e17b09fb9b0a5c965375b1e", "committedDate": "2020-04-08T17:45:33Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af970ff523f3e57f30bd9f52bdaf1645bdecb9c4", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/af970ff523f3e57f30bd9f52bdaf1645bdecb9c4", "committedDate": "2020-04-09T08:44:34Z", "message": "."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/d0e2b1bc200bc1bf428ef7c9a4978d9a21043032", "committedDate": "2020-04-09T08:45:14Z", "message": "Merge branch 'jkong/apis' of github.com:palantir/atlasdb into jkong/apis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNzUyMTgw", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-390752180", "createdAt": "2020-04-09T12:37:02Z", "commit": {"oid": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozNzowMlrOGDW1Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozNzowMlrOGDW1Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MzAwNw==", "bodyText": "@jkozlowski notes: does same elements here mean the same objects, or just arrays that are equal in terms of Arrays#equals()? I intended the former, historically the behaviour of getRowsColumnRange is as follows:\n    @Test\n    public void identity() {\n        txMgr.runTaskWithRetry((tx) -> {\n            put(tx, \"tom\", \"aaa\", \"42\");\n            return null;\n        });\n\n        txMgr.runTaskWithRetry((tx) -> {\n            byte[] b1 = PtBytes.toBytes(\"tom\");\n            Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> iterators = tx.getRowsColumnRange(TEST_TABLE,\n                    ImmutableList.of(b1),\n                    BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 10));\n\n            byte[] b1v2 = PtBytes.toBytes(\"tom\");\n            assertThat(iterators.get(b1)).isNotNull(); // Passes\n            assertThat(iterators.get(b1v2)).isNotNull(); // Fails\n            return null;\n        });\n    }\n\nWe should probably be stricter/more explicit that the identity of the rows must be equal, will incorporate this.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406173007", "createdAt": "2020-04-09T12:37:02Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,92 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows},\n+     * even if there are rows where no columns match the predicate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNzkyNjM2", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-390792636", "createdAt": "2020-04-09T13:30:12Z", "commit": {"oid": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzozMDoxMlrOGDYw5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzozMDoxMlrOGDYw5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwNDY0Nw==", "bodyText": "For this one though, looking up in the returned SortedMap should obviously be allowed with the original byte array, as well as a new byte array with same contents.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406204647", "createdAt": "2020-04-09T13:30:12Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,92 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e204f59ee8f5970ed48f27fb06128bddeccf02e", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/8e204f59ee8f5970ed48f27fb06128bddeccf02e", "committedDate": "2020-04-15T18:54:03Z", "message": "Clarifications, plus a demonstrative test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "committedDate": "2020-04-15T18:55:12Z", "message": "wat"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDgwMzg0", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-405480384", "createdAt": "2020-05-05T04:01:18Z", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDowMToxOFrOGQZtmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDowMToxOFrOGQZtmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1MTY3Mg==", "bodyText": "It's worth a test (array of tests) for this, I think. Specifically, what do I get back if I e.g. delete a cell in a txn and then read the row?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419851672", "createdAt": "2020-05-05T04:01:18Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDgyODY5", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-405482869", "createdAt": "2020-05-05T04:13:46Z", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxMzo0NlrOGQZ3Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxMzo0NlrOGQZ3Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDEwNw==", "bodyText": "'with any byte array that is equivalent according to Arrays.equals(byte[], byte[])'.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854107", "createdAt": "2020-05-05T04:13:46Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDgzMDE4", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-405483018", "createdAt": "2020-05-05T04:14:30Z", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxNDozMFrOGQZ3vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxNDozMFrOGQZ3vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDI3MA==", "bodyText": "of columns?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854270", "createdAt": "2020-05-05T04:14:30Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDgzMjIz", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-405483223", "createdAt": "2020-05-05T04:15:31Z", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxNTozMVrOGQZ4cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxNTozMVrOGQZ4cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDQ1MA==", "bodyText": "Can we tighten this up? It'd be easy to (under the hood) just wrap with an ImmutableSortedMap and so have a consistent contract between this and getRows.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854450", "createdAt": "2020-05-05T04:15:31Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDg0MDE4", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-405484018", "createdAt": "2020-05-05T04:19:25Z", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxOToyNVrOGQZ7mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoxOToyNVrOGQZ7mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTI1OA==", "bodyText": "Can we tighten this up as well? You're right, of course, but all hell breaks loose if this happens. So when you see something like this, I think it's on us to actually clean the contract. In this case, internally we should do ImmutableList.copyOf.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419855258", "createdAt": "2020-05-05T04:19:25Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, behaviour is undefined.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDg0MzAz", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-405484303", "createdAt": "2020-05-05T04:20:55Z", "commit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoyMDo1NVrOGQZ87w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNDoyMDo1NVrOGQZ87w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTU5OQ==", "bodyText": "Likewise. Basically, if we get each method to the point where you can always lookup in the map via any equivalent byte array, then we can just shove it in a single comment at the top and avoid it on each method.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419855599", "createdAt": "2020-05-05T04:20:55Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, behaviour is undefined.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link Iterator}s are guaranteed to return cells matching the predicate, sorted on (ascending) byte\n+     * ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa54358395ca0845c8078be8b687232896499ddc", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/fa54358395ca0845c8078be8b687232896499ddc", "committedDate": "2020-05-05T14:28:01Z", "message": "Add test and switch to ISM backing for iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11c6ad653b62329f9f1cd1a83da74822c2ce67da", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/11c6ad653b62329f9f1cd1a83da74822c2ce67da", "committedDate": "2020-05-05T14:32:43Z", "message": "Simpler docs changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00953384d9e9a7d129affd262178fda16f44c789", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/00953384d9e9a7d129affd262178fda16f44c789", "committedDate": "2020-05-05T15:36:48Z", "message": "Patch tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af6a2cfbf843a9c20d0a0f71b54e2834ba42e95", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/7af6a2cfbf843a9c20d0a0f71b54e2834ba42e95", "committedDate": "2020-05-05T16:40:03Z", "message": "Avoid param reassignment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/3ee6cfb28b352e235933924f61adefaeae379f80", "committedDate": "2020-05-05T17:58:49Z", "message": "Define getRows semantics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjY4MzA4", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-410668308", "createdAt": "2020-05-13T07:45:55Z", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0NTo1NVrOGUlZLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0NTo1NVrOGUlZLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNzM1Nw==", "bodyText": "nit: i think this is more clear as rowKey.clone()", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424237357", "createdAt": "2020-05-13T07:45:55Z", "author": {"login": "j-baker"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java", "diffHunk": "@@ -1309,6 +1318,149 @@ public void testGetRangesPaging() {\n         verifyAllGetRangesImplsNumRanges(t, ranges, ImmutableList.of(\"v\"));\n     }\n \n+    @Test\n+    public void getRowsAccessibleThroughCopies() {\n+        Transaction t = startTransaction();\n+        byte[] rowKey = row(0);\n+        byte[] value = value(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(\n+                Cell.create(rowKey, column(0)), value));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> result =\n+                t.getRows(TEST_TABLE, ImmutableList.of(rowKey), ColumnSelection.all());\n+        assertThat(result.get(rowKey))\n+                .as(\"it should be possible to get a row from getRows with a passed-in byte array\")\n+                .isNotNull()\n+                .satisfies(rowResult ->\n+                        assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n+\n+        byte[] rowKeyCopy = row(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjcwMDc5", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-410670079", "createdAt": "2020-05-13T07:48:18Z", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0ODoxOFrOGUleeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0ODoxOFrOGUleeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzODcxMw==", "bodyText": "\ud83e\udd23", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424238713", "createdAt": "2020-05-13T07:48:18Z", "author": {"login": "j-baker"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterable<T> implements Iterable<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjcwNzEx", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-410670711", "createdAt": "2020-05-13T07:49:10Z", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0OToxMFrOGUlgZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0OToxMFrOGUlgZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzOTIwNQ==", "bodyText": "List iterationOrder = ImmutableList.copyOf(numbersIterable);\nList secondIterationOrder = ImmutableList.copyOf(numbersIterable);", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424239205", "createdAt": "2020-05-13T07:49:10Z", "author": {"login": "j-baker"}, "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterableTest {\n+    @Test\n+    public void orderingIsUnstable() {\n+        // Strobes once in 1000000! times. We can live with that.\n+        List<Integer> numbers = IntStream.range(0, 1000000).boxed().collect(Collectors.toList());\n+        Iterable<Integer> numbersIterable = new UnstableOrderedIterable<>(numbers);\n+\n+        List<Integer> iterationOrder = Lists.newArrayList();\n+        numbersIterable.iterator().forEachRemaining(iterationOrder::add);\n+\n+        List<Integer> secondIterationOrder = Lists.newArrayList();\n+        numbersIterable.iterator().forEachRemaining(secondIterationOrder::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjcxNzY4", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-410671768", "createdAt": "2020-05-13T07:50:37Z", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MDozOFrOGUlj6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1MDozOFrOGUlj6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MDEwNw==", "bodyText": "nope nope nope. Nondeterministic tests are bad. In this case you have to create 1 million objects.\nInstead, UnstableOrderedIterable should take as a field a Random, and you can instantiate that deterministically here, use the version of shuffle that takes a Random and guarantee it 100% of the time.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424240107", "createdAt": "2020-05-13T07:50:38Z", "author": {"login": "j-baker"}, "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterableTest {\n+    @Test\n+    public void orderingIsUnstable() {\n+        // Strobes once in 1000000! times. We can live with that.\n+        List<Integer> numbers = IntStream.range(0, 1000000).boxed().collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjc1ODkz", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-410675893", "createdAt": "2020-05-13T07:56:07Z", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1NjowN1rOGUlxAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo1NjowN1rOGUlxAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MzQ1OA==", "bodyText": "Recommend this, makes for an easier test and guarantees the property you want.\npublic class UnstableOrderedIterable<T extends Comparable<? super T>> implements Iterable<T> {\n    private final Iterator<ImmutableList<T>> underlying;\n\n    public UnstableOrderedIterable(Collection<T> underlying) {\n        this.underlying = Iterables.cycle(Collections2.orderedPermutations(underlying)).iterator();\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return underlying.next();\n    }\n}", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424243458", "createdAt": "2020-05-13T07:56:07Z", "author": {"login": "j-baker"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterable<T> implements Iterable<T> {\n+    private final List<T> underlying;\n+\n+    public UnstableOrderedIterable(Collection<T> underlying) {\n+        this.underlying = ImmutableList.copyOf(underlying);\n+    }\n+\n+    @Override\n+    public Iterator<T> iterator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjc5MDUy", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-410679052", "createdAt": "2020-05-13T08:00:17Z", "commit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowMDoxOFrOGUl6ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODowMDoxOFrOGUl6ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTg4Mw==", "bodyText": "and, just to make sure... do other Transaction implementations such as CachedTransaction obey these constraints? I know we have AbstractTransactionTests, do those get run on CachedTransactions? Personally I'd be minded to write a 'contract validating transaction' which we can wrap all transactions in that checks the properties (though not in this PR).", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424245883", "createdAt": "2020-05-13T08:00:18Z", "author": {"login": "j-baker"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbc61866156c982708ed4a3776224501618692d6", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/cbc61866156c982708ed4a3776224501618692d6", "committedDate": "2020-05-13T17:25:02Z", "message": "CR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f405b0108ecefae862c0e0463dd88bdf8e8e4c9", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/6f405b0108ecefae862c0e0463dd88bdf8e8e4c9", "committedDate": "2020-05-13T17:32:38Z", "message": "Ordering of map test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93ce6cd1ba63a9933e89fcbfde32be2eaa81a387", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/93ce6cd1ba63a9933e89fcbfde32be2eaa81a387", "committedDate": "2020-05-13T17:34:53Z", "message": "MCTT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6480a6dfe6655ad2f67d43743810db2c71997cf", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/b6480a6dfe6655ad2f67d43743810db2c71997cf", "committedDate": "2020-05-13T19:16:20Z", "message": "baseline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "committedDate": "2020-05-14T14:10:50Z", "message": "remove bad test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTAyODc5", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-422502879", "createdAt": "2020-06-02T09:30:00Z", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTozMDowMFrOGdppOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTozMDowMFrOGdppOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0NDE4NA==", "bodyText": "I think \"local\" might be an overloaded term for this. I would also maybe not mention key value service.\nWhat about: \"this accounts for writes and deletes done in this transaction: a row written to in this transaction will be present, and a row which is deleted in this transaction will be absent\"", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433744184", "createdAt": "2020-06-02T09:30:00Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTA4MTE0", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-422508114", "createdAt": "2020-06-02T09:36:08Z", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTozNjowOFrOGdp4GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTozNjowOFrOGdp4GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0Nzk5Mg==", "bodyText": "nit: \"which may be thought of as iterators over columns\". Unclear of the value of putting this here? you are linking to the interface, perhaps the interface should have this sentence?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433747992", "createdAt": "2020-06-02T09:36:08Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTE2MTU1", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-422516155", "createdAt": "2020-06-02T09:46:46Z", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo0Njo0NlrOGdqP9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo0Njo0NlrOGdqP9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDEwMg==", "bodyText": "Why does iteration order of the passed iterable need to be stable? Can we not pick one format for the return order and stick to it?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433754102", "createdAt": "2020-06-02T09:46:46Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTE3NDg3", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-422517487", "createdAt": "2020-06-02T09:48:35Z", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo0ODozNlrOGdqUGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo0ODozNlrOGdqUGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTE2MA==", "bodyText": "We don't return BatchingVisitable here?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433755160", "createdAt": "2020-06-02T09:48:36Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, the returned iterator will return cell-value pairs that are ordered within a row - that is,\n+     * columns from the same row are always grouped together and are always sorted on byte ordering, but there are no\n+     * guarantees on the ordering of rows.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTIwNTY2", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-422520566", "createdAt": "2020-06-02T09:52:40Z", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo1Mjo0MVrOGdqdWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOTo1Mjo0MVrOGdqdWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NzUyOQ==", "bodyText": "Should this also have something around Cell lookup from this map? I guess that's implied because Cell has an #equals we control.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433757529", "createdAt": "2020-06-02T09:52:41Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, the returned iterator will return cell-value pairs that are ordered within a row - that is,\n+     * columns from the same row are always grouped together and are always sorted on byte ordering, but there are no\n+     * guarantees on the ordering of rows.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> getRowsColumnRangeIterator(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Gets the values associated for each cell in {@code cells} from table specified by {@code tableRef}.\n+     *\n+     * @param tableRef the table from which to get the values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTc0Njk3", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-422574697", "createdAt": "2020-06-02T11:13:00Z", "commit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMToxMzowMFrOGds7xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMToyMTozOVrOGdtMdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5ODA4NQ==", "bodyText": "Local is used in some of the internal methods, though yeah that's more of an internal implementation term, so will change to \"in this transaction\".", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433798085", "createdAt": "2020-06-02T11:13:00Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0NDE4NA=="}, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5OTQzNw==", "bodyText": "good spot, bad copy-paste here \ud83d\ude13", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433799437", "createdAt": "2020-06-02T11:15:47Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, the returned iterator will return cell-value pairs that are ordered within a row - that is,\n+     * columns from the same row are always grouped together and are always sorted on byte ordering, but there are no\n+     * guarantees on the ordering of rows.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTE2MA=="}, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5OTcxNA==", "bodyText": "I could add it, though yeah I didn't because Cell#equals() behaves predictably", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433799714", "createdAt": "2020-06-02T11:16:20Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, the returned iterator will return cell-value pairs that are ordered within a row - that is,\n+     * columns from the same row are always grouped together and are always sorted on byte ordering, but there are no\n+     * guarantees on the ordering of rows.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> getRowsColumnRangeIterator(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Gets the values associated for each cell in {@code cells} from table specified by {@code tableRef}.\n+     *\n+     * @param tableRef the table from which to get the values", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NzUyOQ=="}, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTQ3Mg==", "bodyText": "The return order for the stable case has to be the same order as was passed in (this was the core issue in PDS-115789, where an internal user did getRowsColumnRange(table, [B, A], cols, batch) and expected the cells for B to come back first).\nGeneralising this to iterables without a consistent ordering seemed awkward. We could guarantee something stronger (i.e. if rows does not have a stable ordering, the returned iterator will return cell-value pairs where rows are sorted according to the order of the first iteration over it, and columns ...), but it seems like an implementation detail I wouldn't want users to rely on, and it seems easy to break inadvertently.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433801472", "createdAt": "2020-06-02T11:19:56Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDEwMg=="}, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjM1Ng==", "bodyText": "I think changing this to the version without the classes seems reasonable.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433802356", "createdAt": "2020-06-02T11:21:39Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0Nzk5Mg=="}, "originalCommit": {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/e73cd0863051faef64fee8332cfbe84151aff6e6", "committedDate": "2020-06-02T17:54:20Z", "message": "CR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDAxOTQ2", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423001946", "createdAt": "2020-06-02T19:41:44Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0MTo0NFrOGeBXQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0MTo0NFrOGeBXQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMjgwMQ==", "bodyText": "What does \"including via random access\" mean?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434132801", "createdAt": "2020-06-02T19:41:44Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDA0NzU0", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423004754", "createdAt": "2020-06-02T19:45:52Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0NTo1MlrOGeBfmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0NTo1MlrOGeBfmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNDkzOA==", "bodyText": "Meta comment: is this javadoc copied to the generated code? If not, this feels like nobody will actually read this and understand...", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434134938", "createdAt": "2020-06-02T19:45:52Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDA2Mzc4", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423006378", "createdAt": "2020-06-02T19:48:12Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0ODoxM1rOGeBkeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo0ODoxM1rOGeBkeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNjE4NA==", "bodyText": "Sometimes you say \"sorted on the byte order\" and sometimes you add \"with ascending byte ordering\".", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434136184", "createdAt": "2020-06-02T19:48:13Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDA5NTMz", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423009533", "createdAt": "2020-06-02T19:52:56Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo1Mjo1N1rOGeBt-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo1Mjo1N1rOGeBt-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzODYxNw==", "bodyText": "nit: I think in other places we use PtBytes#BYTES_COMPARATOR shim to this method. Just something I noticed.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434138617", "createdAt": "2020-06-02T19:52:57Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -408,16 +409,16 @@ public void disableReadWriteConflictChecking(TableReference tableRef) {\n         hasReads = true;\n         Map<byte[], RowColumnRangeIterator> rawResults = keyValueService.getRowsColumnRange(tableRef, rows,\n                 columnRangeSelection, getStartTimestamp());\n-        Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> postFilteredResults =\n-                Maps.newHashMapWithExpectedSize(rawResults.size());\n+        ImmutableSortedMap.Builder<byte[], Iterator<Map.Entry<Cell, byte[]>>> postFilteredResults =\n+                ImmutableSortedMap.orderedBy(UnsignedBytes.lexicographicalComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDEwNDIy", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423010422", "createdAt": "2020-06-02T19:54:16Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo1NDoxN1rOGeBwsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo1NDoxN1rOGeBwsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzOTMxNA==", "bodyText": "Iterables.isEmpty might create an iterator already. So I believe you need to create a copy before this if statement. But I'm not quite sure what inconsistent ordering for an iterator means, so not sure if this matters.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434139314", "createdAt": "2020-06-02T19:54:17Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -381,10 +381,11 @@ public void disableReadWriteConflictChecking(TableReference tableRef) {\n         if (Iterables.isEmpty(rows)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDExNjM4", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423011638", "createdAt": "2020-06-02T19:56:08Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo1NjowOFrOGeB0cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTo1NjowOFrOGeB0cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0MDI3NQ==", "bodyText": "What about duplicates here? Should we encode this behavior?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434140275", "createdAt": "2020-06-02T19:56:08Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDE5NjAz", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423019603", "createdAt": "2020-06-02T20:08:07Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDowODowN1rOGeCLtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDowODowN1rOGeCLtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0NjIyOQ==", "bodyText": "Where is this checked in the code? And I assume there are tests for this behavior.", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434146229", "createdAt": "2020-06-02T20:08:07Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of requested {@code rows} to corresponding columns from the queried table.\n+     * Only columns matching the provided predicate will be returned, and the single predicate provided applies across\n+     * all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDIyODky", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423022892", "createdAt": "2020-06-02T20:13:00Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoxMzowMVrOGeCV4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoxMzowMVrOGeCV4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0ODgzNQ==", "bodyText": "Maybe you want a separate scoped test for this, as opposed to putting this here?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434148835", "createdAt": "2020-06-02T20:13:01Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java", "diffHunk": "@@ -698,12 +707,12 @@ public void testColumnRangePagingTransaction_batchingVisitable() {\n         verifyMatchingResult(expected, row, columnRange);\n \n         columnRange =\n-                t.getRowsColumnRange(TEST_TABLE, ImmutableList.of(row), BatchColumnRangeSelection.create(PtBytes.toBytes(\"col\"), PtBytes.EMPTY_BYTE_ARRAY, 1));\n+                t.getRowsColumnRange(TEST_TABLE, ImmutableList.of(PtBytes.toBytes(\"row1\")), BatchColumnRangeSelection.create(PtBytes.toBytes(\"col\"), PtBytes.EMPTY_BYTE_ARRAY, 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDI3NjM2", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423027636", "createdAt": "2020-06-02T20:20:13Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoyMDoxM1rOGeCj9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoyMDoxM1rOGeCj9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjQzNw==", "bodyText": "Do we test somewhere the ColumnSelection and ordering of columns?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434152437", "createdAt": "2020-06-02T20:20:13Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java", "diffHunk": "@@ -1309,6 +1318,165 @@ public void testGetRangesPaging() {\n         verifyAllGetRangesImplsNumRanges(t, ranges, ImmutableList.of(\"v\"));\n     }\n \n+    @Test\n+    public void getRowsAccessibleThroughCopies() {\n+        Transaction t = startTransaction();\n+        byte[] rowKey = row(0);\n+        byte[] value = value(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(\n+                Cell.create(rowKey, column(0)), value));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> result =\n+                t.getRows(TEST_TABLE, ImmutableList.of(rowKey), ColumnSelection.all());\n+        assertThat(result.get(rowKey))\n+                .as(\"it should be possible to get a row from getRows with a passed-in byte array\")\n+                .isNotNull()\n+                .satisfies(rowResult ->\n+                        assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n+\n+        byte[] rowKeyCopy = rowKey.clone();\n+        assertThat(rowKeyCopy).isNotSameAs(rowKey);\n+        assertThat(result.get(rowKeyCopy))\n+                .as(\"it should be possible to get a row from getRows with a copy of a passed-in byte array\")\n+                .isNotNull()\n+                .satisfies(rowResult ->\n+                        assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n+    }\n+\n+    @Test\n+    public void getRowsSortedByByteOrder() {\n+        Transaction t = startTransaction();\n+        byte[] row0 = row(0);\n+        byte[] row1 = row(1);\n+        byte[] col0 = column(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(Cell.create(row0, col0), value(0), Cell.create(row1, col0), value(1)));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> readRows =\n+                t.getRows(TEST_TABLE, ImmutableList.of(row0, row1), ColumnSelection.all());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDI5MzE5", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423029319", "createdAt": "2020-06-02T20:22:48Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoyMjo0OFrOGeCo0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoyMjo0OFrOGeCo0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzY4Mw==", "bodyText": "Is there a test for this behavior?", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434153683", "createdAt": "2020-06-02T20:22:48Z", "author": {"login": "jkozlowski"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of requested {@code rows} to corresponding columns from the queried table.\n+     * Only columns matching the provided predicate will be returned, and the single predicate provided applies across\n+     * all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDMwNTQ2", "url": "https://github.com/palantir/atlasdb/pull/4702#pullrequestreview-423030546", "createdAt": "2020-06-02T20:24:42Z", "commit": {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "committedDate": "2020-06-03T10:18:54Z", "message": "CR feedback, additional tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15ba58d44f753de441a668b83bfbea06883cafeb", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/15ba58d44f753de441a668b83bfbea06883cafeb", "committedDate": "2020-06-03T13:56:25Z", "message": "restrict non-unique rows"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3050, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}