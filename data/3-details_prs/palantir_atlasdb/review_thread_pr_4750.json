{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyODc1NDg0", "number": 4750, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjoyNjowN1rOD49vIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjozNToyMVrOD497Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDU4MzM4OnYy", "diffSide": "RIGHT", "path": "changelog/@unreleased/pr-4750.v2.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjoyNjowN1rOGP9_DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMzozODozMFrOGQAuqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM5NzM4OA==", "bodyText": "We should have the description in two parts - 1. what the behavior is after the fix (i.e. what the fix is/ does),  2. what used to happen previously.", "url": "https://github.com/palantir/atlasdb/pull/4750#discussion_r419397388", "createdAt": "2020-05-04T12:26:07Z", "author": {"login": "sudiksha27"}, "path": "changelog/@unreleased/pr-4750.v2.yml", "diffHunk": "@@ -0,0 +1,6 @@\n+type: fix\n+fix:\n+  description: Fix case when TimeLockClient fails to register lock after starting\n+    transaction and drops the immutableTs lock.\n+  links:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41af889c56d4bfab1d2572842f1a674529b092ca"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0MjM0NA==", "bodyText": "I think the updated changelog covers both of those cases now, if not quite as explicitly as you said.", "url": "https://github.com/palantir/atlasdb/pull/4750#discussion_r419442344", "createdAt": "2020-05-04T13:38:30Z", "author": {"login": "Jolyon-S"}, "path": "changelog/@unreleased/pr-4750.v2.yml", "diffHunk": "@@ -0,0 +1,6 @@\n+type: fix\n+fix:\n+  description: Fix case when TimeLockClient fails to register lock after starting\n+    transaction and drops the immutableTs lock.\n+  links:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM5NzM4OA=="}, "originalCommit": {"oid": "41af889c56d4bfab1d2572842f1a674529b092ca"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDYxNDYyOnYy", "diffSide": "RIGHT", "path": "lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMjozNToyMVrOGP-SMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMzozNjoxNlrOGQAotg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQwMjI4OQ==", "bodyText": "When does LockRefresher.registerLock throw exception? Why don't we want to retry registering in that case?", "url": "https://github.com/palantir/atlasdb/pull/4750#discussion_r419402289", "createdAt": "2020-05-04T12:35:21Z", "author": {"login": "sudiksha27"}, "path": "lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java", "diffHunk": "@@ -96,7 +97,12 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n         StartIdentifiedAtlasDbTransactionResponse response = executeOnTimeLock(\n                 delegate::startIdentifiedAtlasDbTransaction);\n-        lockRefresher.registerLock(response.immutableTimestamp().getLock());\n+        try {\n+            lockRefresher.registerLock(response.immutableTimestamp().getLock());\n+        } catch (Throwable t) {\n+            unlock(ImmutableSet.of(response.immutableTimestamp().getLock()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41af889c56d4bfab1d2572842f1a674529b092ca"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0MDgyMg==", "bodyText": "registerLock (which in the future PR becomes registerLocks, i.e. a batched variant) essentially performs addAll on a ConcurrentHashMap. The only documented exceptions here are NullPointerException in the case when the lock is null (which will naturally throw when trying to unlock also), or UnsupportedOperationException which really should not throw unless something is really wrong.\nSo all in all, there is little-to-no chance that, in practice, this would happen anyway; however, to be technically correct we should do this (or if it takes on additional behaviour in the future). We probably don't want to retry because that probably means something really wrong has happened, and in that case we want that to propagate up.", "url": "https://github.com/palantir/atlasdb/pull/4750#discussion_r419440822", "createdAt": "2020-05-04T13:36:16Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java", "diffHunk": "@@ -96,7 +97,12 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n         StartIdentifiedAtlasDbTransactionResponse response = executeOnTimeLock(\n                 delegate::startIdentifiedAtlasDbTransaction);\n-        lockRefresher.registerLock(response.immutableTimestamp().getLock());\n+        try {\n+            lockRefresher.registerLock(response.immutableTimestamp().getLock());\n+        } catch (Throwable t) {\n+            unlock(ImmutableSet.of(response.immutableTimestamp().getLock()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQwMjI4OQ=="}, "originalCommit": {"oid": "41af889c56d4bfab1d2572842f1a674529b092ca"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3113, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}