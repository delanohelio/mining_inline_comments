{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyNTMyOTQy", "number": 5026, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowODoxOFrOEtaXuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDozNzoxM1rOEta_kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDUzNDM1OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosAcceptorState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowODoxOFrOHhL1sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowODoxOFrOHhL1sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1OTAyNg==", "bodyText": "Can we figure out a way to introduce a special method for this instead of relying on #equals? There's no harm in that, and relying on equals feels wrong, especially since you're ignoring some fields + if you have equals that forces you to have hashCode, which again we don't need.", "url": "https://github.com/palantir/atlasdb/pull/5026#discussion_r504559026", "createdAt": "2020-10-14T10:08:18Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosAcceptorState.java", "diffHunk": "@@ -117,4 +118,38 @@ public PaxosProposalId getLastAcceptedId() {\n     public PaxosValue getLastAcceptedValue() {\n         return lastAcceptedValue;\n     }\n+\n+    /**\n+     * Standard equals implementation, note that {@link #version} is not persisted and as such is not used in the\n+     * calculation.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDU1NzkxOnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDoxNDo0N1rOHhMEcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDoxNDo0N1rOHhMEcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU2MjgwMw==", "bodyText": "nit: already.", "url": "https://github.com/palantir/atlasdb/pull/5026#discussion_r504562803", "createdAt": "2020-10-14T10:14:47Z", "author": {"login": "jkozlowski"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -160,25 +161,17 @@ public void learningValuesBeforeCutoffPersistsToLegacyLog() throws IOException {\n     }\n \n     @Test\n-    public void migrateOnlyOnce() throws IOException {\n+    public void failWhenOldLogWritesAtGreaterSequenceAfterMigrationAlreadyRan() throws IOException {\n         fileBasedLearnerLog.writeRound(LATEST_ROUND_BEFORE_MIGRATING, valueForRound(LATEST_ROUND_BEFORE_MIGRATING));\n \n-        LocalPaxosComponents paxosComponents = createPaxosComponents();\n+        createPaxosComponents();\n \n         long newRound = LATEST_ROUND_BEFORE_MIGRATING + 3;\n         fileBasedLearnerLog.writeRound(newRound, valueForRound(newRound));\n \n-        createPaxosComponents();\n-\n-        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(paxosComponents.getLearnerParameters(CLIENT));\n-        assertValuePresent(LATEST_ROUND_BEFORE_MIGRATING, sqliteLog);\n-        assertValueAbsent(newRound, sqliteLog);\n-\n-        PaxosLearner learner = paxosComponents.learner(CLIENT);\n-        assertValueNotLearned(newRound, learner);\n-\n-        assertThat(paxosComponents.getWriteCounter(PaxosLearner.class).getCount()).isEqualTo(0L);\n-        assertThat(paxosComponents.getReadCounter(PaxosLearner.class).getCount()).isEqualTo(0L);\n+        assertThatThrownBy(this::createPaxosComponents)\n+                .as(\"Written to file based log at greater sequence after migration alredy ran\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDYzNjM0OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDozNzoxM1rOHhM0kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDozNzoxM1rOHhM0kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU3NTEyMQ==", "bodyText": "That's just weird - just throw a SafeIllegalStateException, surely?", "url": "https://github.com/palantir/atlasdb/pull/5026#discussion_r504575121", "createdAt": "2020-10-14T10:37:13Z", "author": {"login": "Jolyon-S"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -117,6 +120,39 @@ private void writeBatchRetryingUpToFiveTimes(PaxosStateLog<V> target, List<Paxos\n         target.writeBatchOfRounds(batch);\n     }\n \n+    private static <V extends Persistable & Versionable> void validateConsistency(MigrationContext<V> context) {\n+        long migrationCutoff = calculateCutoff(context);\n+        long persistedCutoff = context.migrationState().getCutoff();\n+        long greatestSourceEntry = context.sourceLog().getGreatestLogEntry();\n+        Preconditions.checkState(migrationCutoff <= persistedCutoff,\n+                \"The migration to the destination state log was already performed in the past, but the \"\n+                        + \"persisted cutoff value does not match a newly calculated one. This indicates the source \"\n+                        + \"log has advanced since the migration was performed which could lead to data corruption if \"\n+                        + \"allowed to continue.\",\n+                SafeArg.of(\"fresh cutoff\", migrationCutoff),\n+                SafeArg.of(\"persisted cutoff\", persistedCutoff),\n+                SafeArg.of(\"source greatest entry\", greatestSourceEntry));\n+        if (greatestSourceEntry == PaxosAcceptor.NO_LOG_ENTRY) {\n+            return;\n+        }\n+        try {\n+            V source = context.hydrator().hydrateFromBytes(context.sourceLog().readRound(greatestSourceEntry));\n+            byte[] destinationBytes = context.destinationLog().readRound(greatestSourceEntry);\n+            V dest = destinationBytes != null ? context.hydrator().hydrateFromBytes(destinationBytes) : null;\n+            Preconditions.checkState(source.equals(dest),\n+                    \"The migration to the destination state log was already performed in the past, but the \"\n+                            + \"entry with the greatest sequence in source log does not match the entry in the \"\n+                            + \"destination log. This indicates the source log has advanced since the migration was \"\n+                            + \"performed which could lead to data corruption if allowed to continue.\",\n+                    SafeArg.of(\"source entry\", source),\n+                    SafeArg.of(\"destination entry\", dest));\n+        } catch (IOException e) {\n+            Preconditions.checkState(false,\n+                    \"Unable to verify consistency between source and destination paxos logs because the \"\n+                            + \"source log entry could not be read.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2623, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}