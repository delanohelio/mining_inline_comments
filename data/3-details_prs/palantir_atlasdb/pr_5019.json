{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5ODE5MDE1", "number": 5019, "title": "Revert revert dvkvs invalidator", "bodyText": "Goals (and why):\nRevert revert #5010 and remove the incorrect hasColumn check.\nImplementation Description (bullets):\n\n\nRemove hasColumn check\n\n\nRemove fail fast if db is poisoned\n\n\nTesting (What was existing testing like?  What have you done to improve it?):\nTests in 5010 should suffice\nConcerns (what feedback would you like?):\n\nOracle tests\n\nWhere should we start reviewing?:\n\nInvalidationRunner.java\n\nPriority (whenever / two weeks / yesterday):\nMonday would be ideal", "createdAt": "2020-10-08T10:27:18Z", "url": "https://github.com/palantir/atlasdb/pull/5019", "merged": true, "mergeCommit": {"oid": "6246367fcd691d277299c7d57e511ac966a2f87b"}, "closed": true, "closedAt": "2020-10-13T16:41:47Z", "author": {"login": "sudiksha27"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQOS5UAH2gAyNDk5ODE5MDE1OjlkZTdhMDNmMTRkOGIyYjEwNzY4ZDkwMDA1ZjViN2MzMDcwMTkwNDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSKiEUAH2gAyNDk5ODE5MDE1OjI3NjQxN2FkMDA5MjBkODIzYTgxMzBkYjc3NDRhYjRiODQyZThjN2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9de7a03f14d8b2b10768d90005f5b7c307019046", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/9de7a03f14d8b2b10768d90005f5b7c307019046", "committedDate": "2020-10-07T14:59:20Z", "message": "Revert \"Revert 5010 (#5016)\"\n\nThis reverts commit 54b18788bff7a48d05a0a4ab3f828875d45defd9."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a8be9180ebf0f93b8de880e733c1771e2e63ef6", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/3a8be9180ebf0f93b8de880e733c1771e2e63ef6", "committedDate": "2020-10-08T10:24:00Z", "message": "Remove fail fast | remove incorrect hasColumns check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134", "committedDate": "2020-10-12T12:22:40Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTc1NDcy", "url": "https://github.com/palantir/atlasdb/pull/5019#pullrequestreview-506575472", "createdAt": "2020-10-12T12:30:56Z", "commit": {"oid": "eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjozMjozN1rOHf8wIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjozMjozN1rOHf8wIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzI2NQ==", "bodyText": "Check on the RC if this works with Oracle", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r503263265", "createdAt": "2020-10-12T12:32:37Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                poisonOracleTable(connection, statement);\n+            } else {\n+                poisonPostgresTable(connection, statement);\n+            }\n+        }\n+    }\n+\n+    private void poisonOracleTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.oracleColumnDoesNotExistError(e)) {\n+                throw e;\n+            }\n+            // Do not need to commit transaction here as Oracle doesn't throw an exception when a\n+            // query fails on a connection within a transaction.\n+        }\n+    }\n+\n+    private void poisonPostgresTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.postgresColumnDoesNotExistError(e)) {\n+                throw e;\n+            } else {\n+                connection.commit();\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa75b4a608e6998a86f9e184eabee7d55d29fe3d", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/fa75b4a608e6998a86f9e184eabee7d55d29fe3d", "committedDate": "2020-10-12T13:33:34Z", "message": "Rollback, don't commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e7554a396f9b1911107046bc597f072f0006862", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/0e7554a396f9b1911107046bc597f072f0006862", "committedDate": "2020-10-12T13:33:34Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3ca3331e3f78760ea24a2e2770f237f92c891b", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/fa3ca3331e3f78760ea24a2e2770f237f92c891b", "committedDate": "2020-10-12T13:38:17Z", "message": "Autorelease 0.249.1-rc1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "452a96d3af2fc26c1523c3e01c3f23d68b50177a", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/452a96d3af2fc26c1523c3e01c3f23d68b50177a", "committedDate": "2020-10-13T12:52:21Z", "message": "No metaData check works with Oracle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "committedDate": "2020-10-13T13:28:39Z", "message": "Oh Oracle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NTUwNDI3", "url": "https://github.com/palantir/atlasdb/pull/5019#pullrequestreview-507550427", "createdAt": "2020-10-13T15:17:37Z", "commit": {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNToxNzozN1rOHgsCRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNToyMjozM1rOHgsRcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzNzk1OA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    long lastAllocated;\n          \n          \n            \n            \n          \n          \n            \n                    if (tableStatus == TableStatus.NO_DATA) {\n          \n          \n            \n                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        lastAllocated = limits.upperLimit().get().value();\n          \n          \n            \n                    }\n          \n          \n            \n                    long lastAllocated = tableStatus == TableStatus.NO_DATA\n          \n          \n            \n                            ? AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP\n          \n          \n            \n                            : limits.upperLimit().get().value();", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504037958", "createdAt": "2020-10-13T15:17:37Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzOTQ2OA==", "bodyText": "nit: enums are usually compared with == as opposed to Objects::equals", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504039468", "createdAt": "2020-10-13T15:19:37Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0MDY4Nw==", "bodyText": "nit: I don't think the comment is needed? Seems self-explanatory", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504040687", "createdAt": "2020-10-13T15:21:05Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                poisonOracleTable(connection, statement);\n+            } else {\n+                poisonPostgresTable(connection, statement);\n+            }\n+        }\n+    }\n+\n+    private void poisonOracleTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.oracleDuplicateColumnError(e)) {\n+                throw e;\n+            }\n+            connection.rollback();\n+        }\n+    }\n+\n+    private void poisonPostgresTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.postgresColumnDoesNotExistError(e)) {\n+                throw e;\n+            }\n+            connection.rollback();\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        String sql = String.format(\"SELECT * FROM %s FOR UPDATE\", prefixedTimestampTableName());\n+        QueryRunner run = new QueryRunner();\n+        return run.query(connection, sql, rs -> {\n+            if (rs.next()) {\n+                return ImmutableLimits.builder()\n+                        .upperLimit(getColumnStatusFromResultSet(rs, LAST_ALLOCATED))\n+                        .legacyUpperLimit(getColumnStatusFromResultSet(rs, LEGACY_LAST_ALLOCATED))\n+                        .build();\n+            } else {\n+                return ImmutableLimits.builder().build();\n+            }\n+        });\n+    }\n+\n+    private Optional<ColumnStatus> getColumnStatusFromResultSet(ResultSet rs, String colName) throws SQLException {\n+        try {\n+            return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+        } catch (SQLException e) {\n+            if (PhysicalBoundStoreDatabaseUtils.oracleInvalidColumnError(e)\n+                    || PhysicalBoundStoreDatabaseUtils.postgresColumnDoesNotExistError(e)) {\n+                return Optional.empty();\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private TableStatus checkTableStatus(Limits limits) {\n+        TableStatus status = getTableStatus(limits);\n+\n+        Preconditions.checkState(status != TableStatus.BOTH_COLUMNS,\n+                \"We detected the table has been poisoned but last_allocated column still exists.\"\n+                        + \"This is unexpected. Please contact support.\");\n+        return status;\n+    }\n+\n+    private TableStatus getTableStatus(Limits limits) {\n+        boolean upperLimitExists = limits.upperLimit().isPresent();\n+        boolean legacyUpperLimitExists = limits.legacyUpperLimit().isPresent();\n+\n+        if (upperLimitExists) {\n+            return legacyUpperLimitExists ? TableStatus.BOTH_COLUMNS : TableStatus.HEALTHY;\n+        }\n+        return legacyUpperLimitExists ? TableStatus.POISONED : TableStatus.NO_DATA; // no data in table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0MTg0MQ==", "bodyText": "nit: These boolean methods usually have verbs indicating they are predicates e.g. isTableAlreadyExistsError(...)", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504041841", "createdAt": "2020-10-13T15:22:33Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/PhysicalBoundStoreDatabaseUtils.java", "diffHunk": "@@ -63,17 +63,27 @@ private static void createTimestampTableIgnoringAlreadyExistsError(\n         }\n     }\n \n+    public static boolean tableAlreadyExistsError(SQLException exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "276417ad00920d823a8130db7744ab4b842e8c7f", "author": {"user": {"login": "sudiksha27", "name": "sudiksha nanda"}}, "url": "https://github.com/palantir/atlasdb/commit/276417ad00920d823a8130db7744ab4b842e8c7f", "committedDate": "2020-10-13T15:44:08Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2622, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}