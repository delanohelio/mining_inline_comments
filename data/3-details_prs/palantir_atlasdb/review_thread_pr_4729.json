{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3Mzg0MTI4", "number": 4729, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNzoyMVrOD1QxDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMTowNTo0NlrOD1uC3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTc1ODIyOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNzoyMVrOGKnDoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNzoyMVrOGKnDoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3ODg0OQ==", "bodyText": "We talked offline so I know why this is needed, but probably best to document that.", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r413778849", "createdAt": "2020-04-23T12:37:21Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "diffHunk": "@@ -102,4 +127,34 @@ private static PaxosValue valueForRound(long round) {\n         ThreadLocalRandom.current().nextBytes(bytes);\n         return new PaxosValue(\"someLeader\", round, bytes);\n     }\n+\n+    private static Supplier<Connection> createReusableMemoizedConnection() {\n+        Supplier<Connection> baseConnectionSupplier = SqliteConnections.createDatabaseForTest();\n+        Supplier<Connection> nonClosingConnectionSupplier = bypassCloseOnConnection(baseConnectionSupplier);\n+        return Suppliers.memoize(nonClosingConnectionSupplier::get);\n+    }\n+\n+    private static Supplier<Connection> bypassCloseOnConnection(Supplier<Connection> connectionSupplier) {\n+        return Suppliers.compose(conn ->\n+                        (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),\n+                                new Class<?>[] {Connection.class},\n+                                new CloseIgnoringInvocationHandler(conn)),\n+                connectionSupplier::get);\n+    }\n+\n+    private static final class CloseIgnoringInvocationHandler extends AbstractInvocationHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "521a3eec0ba99a626c2e899e44336d60e07234cb"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTc2MDI2OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNzo1NFrOGKnE5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjozNzo1NFrOGKnE5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3OTE3Mw==", "bodyText": "nit: standardise x vs dao", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r413779173", "createdAt": "2020-04-23T12:37:54Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;\n+    private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier) {\n-        this.connectionSupplier = connectionSupplier;\n+    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+        this.namespace = namespace;\n+        this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(Supplier<Connection> conn) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+            Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        executeVoid(\"CREATE TABLE IF NOT EXISTS paxosLog (seq BIGINT, val BLOB, CONSTRAINT pk_dual PRIMARY KEY (seq))\");\n+        execute(dao -> dao.createTable(namespace));\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        try {\n-            PreparedStatement preparedStatement = connectionSupplier.get().prepareStatement(\n-                    \"INSERT OR REPLACE INTO paxosLog (seq, val) VALUES (?, ?)\");\n-            preparedStatement.setLong(1, seq);\n-            preparedStatement.setBytes(2, round.persistToBytes());\n-            preparedStatement.execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return executeStatement(String.format(\"SELECT val FROM paxosLog WHERE seq = %s\", seq))\n-                .map(SqlitePaxosStateLog::getByteArrayUnchecked)\n-                .orElse(null);\n+        return execute(dao -> dao.readRound(namespace, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return executeStatement(\"SELECT MIN(seq) FROM paxosLog\")\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(x -> x.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return executeStatement(\"SELECT MAX(seq) FROM paxosLog\")\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(x -> x.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "521a3eec0ba99a626c2e899e44336d60e07234cb"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjUyMjUyOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMDo1NjozMlrOGLSLJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDowOTozMFrOGLZgcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4NTI4NQ==", "bodyText": "Is there a validation/parsing of the namespace somewhere in timelock? I wonder what restrictions sqllite places on table names.", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414485285", "createdAt": "2020-04-24T10:56:32Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NjMzMg==", "bodyText": "Yeah, we have to pass in a valid namespace which we take care of elsewhere", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414546332", "createdAt": "2020-04-24T12:43:32Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4NTI4NQ=="}, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU3OTU0NQ==", "bodyText": "What about sqlite restrictions? are all namespaces valid for sqlite tables?", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414579545", "createdAt": "2020-04-24T13:33:44Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4NTI4NQ=="}, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYwNTQyNQ==", "bodyText": "Can we have a Namespace wrapper type? so that the validation done is clear here?", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414605425", "createdAt": "2020-04-24T14:09:30Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4NTI4NQ=="}, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjUyNDEzOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMDo1NzowMFrOGLSMFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjozMjoxOVrOGLVfvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4NTUyNg==", "bodyText": "Do we need some sort of try-catch here in case log.initialize fails later?", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414485526", "createdAt": "2020-04-24T10:57:00Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;\n+    private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier) {\n-        this.connectionSupplier = connectionSupplier;\n+    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+        this.namespace = namespace;\n+        this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(Supplier<Connection> conn) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+            Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUzOTcxMA==", "bodyText": "No, this does not take up any resources that need to be cleaned up later", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414539710", "createdAt": "2020-04-24T12:32:19Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -16,105 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n+    private final String namespace;\n+    private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier) {\n-        this.connectionSupplier = connectionSupplier;\n+    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+        this.namespace = namespace;\n+        this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(Supplier<Connection> conn) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+            Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ4NTUyNg=="}, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NjU1NTE2OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMTowNTo0NlrOGLSePA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo0MzowMVrOGLV4SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5MDE3Mg==", "bodyText": "Is there no way to amend this behavior? How about SQLiteDataSource, does that do it better? And then also SQLiteConnectionPoolDataSource,", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414490172", "createdAt": "2020-04-24T11:05:46Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "diffHunk": "@@ -102,4 +127,39 @@ private static PaxosValue valueForRound(long round) {\n         ThreadLocalRandom.current().nextBytes(bytes);\n         return new PaxosValue(\"someLeader\", round, bytes);\n     }\n+\n+    private static Supplier<Connection> createReusableMemoizedConnection() {\n+        Supplier<Connection> baseConnectionSupplier = SqliteConnections.createDatabaseForTest();\n+        Supplier<Connection> nonClosingConnectionSupplier = bypassCloseOnConnection(baseConnectionSupplier);\n+        return Suppliers.memoize(nonClosingConnectionSupplier::get);\n+    }\n+\n+    private static Supplier<Connection> bypassCloseOnConnection(Supplier<Connection> connectionSupplier) {\n+        return Suppliers.compose(conn ->\n+                        (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),\n+                                new Class<?>[] {Connection.class},\n+                                new CloseIgnoringInvocationHandler(conn)),\n+                connectionSupplier::get);\n+    }\n+\n+    /**\n+     * JDBI closes the connection after executing a query. This is desired behaviour, but does not play nicely with in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNDQ5MQ==", "bodyText": "Or how about we use the disk in tests too? Shouldn't really be a problem I suspect? We can give it temp directories", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414504491", "createdAt": "2020-04-24T11:31:37Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "diffHunk": "@@ -102,4 +127,39 @@ private static PaxosValue valueForRound(long round) {\n         ThreadLocalRandom.current().nextBytes(bytes);\n         return new PaxosValue(\"someLeader\", round, bytes);\n     }\n+\n+    private static Supplier<Connection> createReusableMemoizedConnection() {\n+        Supplier<Connection> baseConnectionSupplier = SqliteConnections.createDatabaseForTest();\n+        Supplier<Connection> nonClosingConnectionSupplier = bypassCloseOnConnection(baseConnectionSupplier);\n+        return Suppliers.memoize(nonClosingConnectionSupplier::get);\n+    }\n+\n+    private static Supplier<Connection> bypassCloseOnConnection(Supplier<Connection> connectionSupplier) {\n+        return Suppliers.compose(conn ->\n+                        (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),\n+                                new Class<?>[] {Connection.class},\n+                                new CloseIgnoringInvocationHandler(conn)),\n+                connectionSupplier::get);\n+    }\n+\n+    /**\n+     * JDBI closes the connection after executing a query. This is desired behaviour, but does not play nicely with in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5MDE3Mg=="}, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU0NTk5Mw==", "bodyText": "OK, we use disk", "url": "https://github.com/palantir/atlasdb/pull/4729#discussion_r414545993", "createdAt": "2020-04-24T12:43:01Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/SqlitePaxosStateLogTest.java", "diffHunk": "@@ -102,4 +127,39 @@ private static PaxosValue valueForRound(long round) {\n         ThreadLocalRandom.current().nextBytes(bytes);\n         return new PaxosValue(\"someLeader\", round, bytes);\n     }\n+\n+    private static Supplier<Connection> createReusableMemoizedConnection() {\n+        Supplier<Connection> baseConnectionSupplier = SqliteConnections.createDatabaseForTest();\n+        Supplier<Connection> nonClosingConnectionSupplier = bypassCloseOnConnection(baseConnectionSupplier);\n+        return Suppliers.memoize(nonClosingConnectionSupplier::get);\n+    }\n+\n+    private static Supplier<Connection> bypassCloseOnConnection(Supplier<Connection> connectionSupplier) {\n+        return Suppliers.compose(conn ->\n+                        (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(),\n+                                new Class<?>[] {Connection.class},\n+                                new CloseIgnoringInvocationHandler(conn)),\n+                connectionSupplier::get);\n+    }\n+\n+    /**\n+     * JDBI closes the connection after executing a query. This is desired behaviour, but does not play nicely with in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5MDE3Mg=="}, "originalCommit": {"oid": "b88059c5da41ac7d6d1f7657e564786298ca8c80"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3082, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}