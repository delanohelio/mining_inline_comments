{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2ODY0NzU2", "number": 4820, "title": "Remove LockWatchStateUpdate#Failed.", "bodyText": "Goals (and why):\nTry to simplify the code by removing a response that we should be able to not have.\nImplementation Description (bullets):\nIf the client is too far behind, calculate a snapshot. Operations that touch the log, always lock it exclusively (whether for reading or writing), therefore we can always calculate a cohesive snapshot: all mutations will wait while we are calculating the snapshot, therefore the client will then later be able to get all the events. They might get the same \"event\" multiple times (because HeldLocks iteration is not blocking), but the ordering of these events will always be causal (e.g. unlock always comes after lock), but they should be able to deal with that\nTesting (What was existing testing like?  What have you done to improve it?):\nExisting unit tests\nConcerns (what feedback would you like?):\nWhether there is any problems with this approach.\nWhere should we start reviewing?:\nPriority (whenever / two weeks / yesterday):", "createdAt": "2020-06-02T22:37:50Z", "url": "https://github.com/palantir/atlasdb/pull/4820", "merged": true, "mergeCommit": {"oid": "27dbba71c69ca431a02b52e68190f1f352680f91"}, "closed": true, "closedAt": "2020-06-25T10:52:10Z", "author": {"login": "jkozlowski"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnbwJIgH2gAyNDI2ODY0NzU2OjU3ZWIyYjE1M2RjMDA3NjFkYzI3OWI1M2E1NmYyZTI2ODkyYTg0YjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcur7uSgFqTQzNzM1ODY2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "57eb2b153dc00761dc279b53a56f2e26892a84b4", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/57eb2b153dc00761dc279b53a56f2e26892a84b4", "committedDate": "2020-06-02T21:29:09Z", "message": "Naive fix for this."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5df122ab0bfdb9532f237b1f125927a159c9c721", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/5df122ab0bfdb9532f237b1f125927a159c9c721", "committedDate": "2020-06-02T22:37:18Z", "message": "Remove fancy synchronization."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTI5MTk2", "url": "https://github.com/palantir/atlasdb/pull/4820#pullrequestreview-423129196", "createdAt": "2020-06-02T23:45:37Z", "commit": {"oid": "5df122ab0bfdb9532f237b1f125927a159c9c721"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzo0NTozN1rOGeHigA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzo0NTozN1rOGeHigA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMzk4NA==", "bodyText": "The thing to understand here is what does this snapshot actually mean: it's a best effort thing to indicate if there are any open locks and return them. This snapshot isn't really a consistent snapshot: while we're locked here in the log, the HeldLocksCollection is still granting locks, which, as soon as we unlock the log, will add their events. But as per the RFC, this doesn't matter for any transactions that end up working with this snapshot: what matters for conflict checking is that there were no events for cached rows in between the transaction starting and trying to commit.\nAfter these changes (and possibly before them), if we compute a snapshot, the node might later receive events it already knows about from the snapshot again. And that should be fine.", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r434233984", "createdAt": "2020-06-02T23:45:37Z", "author": {"login": "jkozlowski"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java", "diffHunk": "@@ -50,58 +50,67 @@\n     }\n \n     @Override\n-    public LockWatchStateUpdate getLogDiff(Optional<IdentifiedVersion> fromVersion) {\n-        return getLogDiff(fromVersion, slidingWindow.lastVersion());\n+    public synchronized LockWatchStateUpdate getLogDiff(Optional<IdentifiedVersion> fromVersion) {\n+        if (shouldCalculateSnapshot(fromVersion)) {\n+            return calculateSnapshot();\n+        }\n+        List<LockWatchEvent> events = slidingWindow.getFromVersion(fromVersion.get().version());\n+        return LockWatchStateUpdate.success(logId, slidingWindow.lastVersion(), events);\n     }\n \n     @Override\n-    public LockWatchStateUpdate getLogDiff(Optional<IdentifiedVersion> fromVersion, long toVersion) {\n-        if (isVersionStale(fromVersion)) {\n-            return attemptToCalculateSnapshot();\n-        }\n-        Optional<List<LockWatchEvent>> maybeEvents = slidingWindow.getFromTo(fromVersion.get().version(), toVersion);\n-        if (!maybeEvents.isPresent()) {\n-            return attemptToCalculateSnapshot();\n+    public synchronized <T> AtomicValue<T> runTaskAndAtomicallyReturnLockWatchStateUpdate(\n+            Optional<IdentifiedVersion> lastKnownVersion, Supplier<T> task) {\n+        T t = task.get();\n+        LockWatchStateUpdate logDiff = getLogDiff(lastKnownVersion);\n+        return AtomicValue.of(logDiff, t);\n+    }\n+\n+    @Override\n+    public synchronized void logLock(Set<LockDescriptor> locksTakenOut, LockToken lockToken) {\n+        // I feel like this would be simpler if the isEmpty check was done somewhere else, it's weird API\n+        if (!locksTakenOut.isEmpty()) {\n+            synchronized (this) {\n+                slidingWindow.add(LockEvent.builder(locksTakenOut, lockToken));\n+            }\n         }\n-        List<LockWatchEvent> events = maybeEvents.get();\n-        return LockWatchStateUpdate.success(logId, toVersion, events);\n     }\n \n-    private boolean isVersionStale(Optional<IdentifiedVersion> fromVersion) {\n-        return !fromVersion.isPresent() || !fromVersion.get().id().equals(logId);\n+    @Override\n+    public void logUnlock(Set<LockDescriptor> locksUnlocked) {\n+        if (!locksUnlocked.isEmpty()) {\n+            synchronized (this) {\n+                slidingWindow.add(UnlockEvent.builder(locksUnlocked));\n+            }\n+        }\n     }\n \n-    /**\n-     * Gets a snapshot estimate, then replays all lock watch events that occurred in the meantime on top of it\n-     * to correct any inconsistencies as discussed in {@link this#calculateOpenLocks(RangeSet)}.\n-     */\n-    private LockWatchStateUpdate attemptToCalculateSnapshot() {\n-        long startVersion = slidingWindow.lastVersion();\n-        SnapshotEventReplayer eventReplayer = getSnapshotEstimateAndCreateReplayer();\n-        long endVersion = slidingWindow.lastVersion();\n+    @Override\n+    public synchronized void logLockWatchCreated(LockWatches newWatches) {\n+        Set<LockDescriptor> openLocks = calculateOpenLocks(newWatches.ranges());\n+        slidingWindow.add(LockWatchCreatedEvent.builder(newWatches.references(), openLocks));\n+    }\n \n-        Optional<List<LockWatchEvent>> eventsToReplay = slidingWindow.getFromTo(startVersion, endVersion);\n-        if (!eventsToReplay.isPresent()) {\n-            return LockWatchStateUpdate.failed(logId);\n-        }\n-        eventsToReplay.get().forEach(eventReplayer::replay);\n-        return LockWatchStateUpdate.snapshot(\n-                logId,\n-                endVersion,\n-                eventReplayer.locked,\n-                eventReplayer.watches);\n+    private boolean shouldCalculateSnapshot(Optional<IdentifiedVersion> fromVersion) {\n+        return !fromVersion.isPresent() || !fromVersion.get().id().equals(logId) || !slidingWindow.contains(\n+                fromVersion.get().version());\n     }\n \n-    private SnapshotEventReplayer getSnapshotEstimateAndCreateReplayer() {\n+    private LockWatchStateUpdate calculateSnapshot() {\n+        long lastVersion = slidingWindow.lastVersion();\n         LockWatches currentWatches = watchesSupplier.get();\n-        Set<LockWatchReference> watched = new HashSet<>(currentWatches.references());\n-        Set<LockDescriptor> estimatedLocks = calculateOpenLocks(currentWatches.ranges());\n-        return new SnapshotEventReplayer(watched, estimatedLocks);\n+        Set<LockWatchReference> watches = new HashSet<>(currentWatches.references());\n+        Set<LockDescriptor> openLocks = calculateOpenLocks(currentWatches.ranges());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df122ab0bfdb9532f237b1f125927a159c9c721"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ba7a8e92e420121869d2ab8cd13583e3c4cd094", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/2ba7a8e92e420121869d2ab8cd13583e3c4cd094", "committedDate": "2020-06-23T15:27:52Z", "message": "Merge branch 'develop' into failure-is-not-an-option-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdcd89cd276bcb0e21ab91fdca8864522ddfe90a", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/bdcd89cd276bcb0e21ab91fdca8864522ddfe90a", "committedDate": "2020-06-23T20:27:14Z", "message": "Merge branch 'develop' into failure-is-not-an-option-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3ece14eae213c947e8ebd9a226f44e7e425d363", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/f3ece14eae213c947e8ebd9a226f44e7e425d363", "committedDate": "2020-06-23T20:29:43Z", "message": "Fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3e9b5c0001315ac93549679d5fff6be63873a65", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/c3e9b5c0001315ac93549679d5fff6be63873a65", "committedDate": "2020-06-23T20:53:36Z", "message": "Cleanup some more."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c93c41d67f5c19556c583e47855b096ea27f7fb", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/3c93c41d67f5c19556c583e47855b096ea27f7fb", "committedDate": "2020-06-23T21:08:33Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70a37f287093424d304a663d82abebc4270f6bf4", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/70a37f287093424d304a663d82abebc4270f6bf4", "committedDate": "2020-06-23T21:28:26Z", "message": "Add a bit of comments and rename methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "762d644d647a9ebdf9d4319c352ab5f57e4c51c4", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/762d644d647a9ebdf9d4319c352ab5f57e4c51c4", "committedDate": "2020-06-23T21:40:26Z", "message": "Cleanup test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/83ea431fa3d8c1edbdb53b4e11ab35fc42a62683", "committedDate": "2020-06-23T21:42:28Z", "message": "Reflow."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDAzNTI4", "url": "https://github.com/palantir/atlasdb/pull/4820#pullrequestreview-437003528", "createdAt": "2020-06-24T21:01:03Z", "commit": {"oid": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowMTowM1rOGoi-qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowNjozMlrOGojI8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTMyMQ==", "bodyText": "This returns true if the version is unloadable, which I find strange. Maybe either flip this, or isVersionUnknown or something along those lines.", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445169321", "createdAt": "2020-06-24T21:01:03Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -44,92 +38,43 @@ long lastVersion() {\n         return nextSequence - 1;\n     }\n \n-    /**\n-     * Adds an event to the sliding window. Assigns a unique sequence to the event.\n-     *\n-     * Note on concurrency:\n-     * 1. Each write to buffer is followed by a write to nextSequence, which is volatile.\n-     */\n-    synchronized void add(LockWatchEvent.Builder eventBuilder) {\n+    void add(LockWatchEvent.Builder eventBuilder) {\n         LockWatchEvent event = eventBuilder.build(nextSequence);\n         buffer[LongMath.mod(nextSequence, maxSize)] = event;\n         nextSequence++;\n     }\n \n-    synchronized void finalizeAndAddSnapshot(long startVersion, LockWatchCreatedEventReplayer eventReplayer) {\n-        Optional<List<LockWatchEvent>> remaining = getFromVersion(startVersion);\n-        if (remaining.isPresent()) {\n-            remaining.get().forEach(eventReplayer::replay);\n-            add(LockWatchCreatedEvent.builder(eventReplayer.getReferences(), eventReplayer.getLockedDescriptors()));\n-        }\n+    boolean hasNextEvents(long version) {\n+        return !validateVersion(version);\n     }\n \n-    /**\n-     * Warning: this will block all lock and unlock requests until the task is done. Improper use of this method can\n-     * result in a deadlock.\n-     */\n-    synchronized <T> ValueAndVersion<T> runTaskAndAtomicallyReturnVersion(Supplier<T> task) {\n-        return ValueAndVersion.of(lastVersion(), task.get());\n-    }\n-\n-    /**\n-     * Returns a list of all events that occurred immediately after the requested version up to the most recent version,\n-     * ordered by consecutively increasing sequence numbers. If the list cannot be created, either a priori or because\n-     * new events are added to the window during execution of this method causing eviction an event before it was read,\n-     * the method will return {@link Optional#empty()}.\n-     *\n-     * Note on concurrency:\n-     * 2. Before reading from buffer, we read nextSequence.\n-     *\n-     * 1. and 2. ensure that calls to this method have an up to date view of buffer, containing all updates made so\n-     * far. The buffer may be updated after the volatile read of nextSequence, and these updates may or may not be\n-     * visible. This does not affect correctness:\n-     *   a) the newer updates are not expected to be reflected in the returned list\n-     *   b) if (some of) the newer updates are visible and overwrite a value that should have been included in the\n-     *      returned list, it may end up included in the candidate result. This will be detected by\n-     *      validateConsistencyOrReturnEmpty, and {@link Optional#empty()} will be returned. This correctly reflects\n-     *      the state where, even though all the necessary events were in the requested window at the start of executing\n-     *      this method, that is no longer the case when the method returns.\n-     */\n-    public Optional<List<LockWatchEvent>> getFromVersion(long version) {\n-        return getFromTo(version, lastVersion());\n-    }\n-\n-    public Optional<List<LockWatchEvent>> getFromTo(long startVersion, long endVersion) {\n-        if (versionInTheFuture(startVersion, endVersion) || versionTooOld(startVersion, endVersion)) {\n-            return Optional.empty();\n-        }\n-\n-        int startIndex = LongMath.mod(startVersion + 1, maxSize);\n-        int windowSize = Ints.saturatedCast(endVersion - startVersion);\n+    public List<LockWatchEvent> getNextEvents(long version) {\n+        Preconditions.checkArgument(hasNextEvents(version), \"Version not in the log\");\n+        int startIndex = LongMath.mod(version + 1, maxSize);\n+        int windowSize = Ints.saturatedCast(lastVersion() - version);\n         List<LockWatchEvent> events = new ArrayList<>(windowSize);\n \n         for (int i = startIndex; events.size() < windowSize; i = incrementAndMod(i)) {\n             events.add(buffer[i]);\n         }\n \n-        return validateConsistencyOrReturnEmpty(startVersion, events);\n+        return events;\n     }\n \n     private int incrementAndMod(int num) {\n         num++;\n         return num >= maxSize ? num % maxSize : num;\n     }\n \n-    private boolean versionInTheFuture(long lastVersion, long lastWrittenSequence) {\n-        return lastVersion > lastWrittenSequence;\n+    private boolean validateVersion(long version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDE0Nw==", "bodyText": "sanity check: Is hasNextEvents() queried at the last version intentionally true?\nnon-actionable: this is basically hasEventsFromHereToLastKnown though that is kind of verbose so just hasNextEvents is fine.", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445170147", "createdAt": "2020-06-24T21:02:46Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -44,92 +38,43 @@ long lastVersion() {\n         return nextSequence - 1;\n     }\n \n-    /**\n-     * Adds an event to the sliding window. Assigns a unique sequence to the event.\n-     *\n-     * Note on concurrency:\n-     * 1. Each write to buffer is followed by a write to nextSequence, which is volatile.\n-     */\n-    synchronized void add(LockWatchEvent.Builder eventBuilder) {\n+    void add(LockWatchEvent.Builder eventBuilder) {\n         LockWatchEvent event = eventBuilder.build(nextSequence);\n         buffer[LongMath.mod(nextSequence, maxSize)] = event;\n         nextSequence++;\n     }\n \n-    synchronized void finalizeAndAddSnapshot(long startVersion, LockWatchCreatedEventReplayer eventReplayer) {\n-        Optional<List<LockWatchEvent>> remaining = getFromVersion(startVersion);\n-        if (remaining.isPresent()) {\n-            remaining.get().forEach(eventReplayer::replay);\n-            add(LockWatchCreatedEvent.builder(eventReplayer.getReferences(), eventReplayer.getLockedDescriptors()));\n-        }\n+    boolean hasNextEvents(long version) {\n+        return !validateVersion(version);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTk1NQ==", "bodyText": "nit: Might be worth calling out @NotThreadSafe (it's really obvious, but worth noting)", "url": "https://github.com/palantir/atlasdb/pull/4820#discussion_r445171955", "createdAt": "2020-06-24T21:06:32Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -18,22 +18,16 @@\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Supplier;\n-\n-import javax.annotation.concurrent.ThreadSafe;\n \n import com.google.common.math.LongMath;\n import com.google.common.primitives.Ints;\n-import com.palantir.atlasdb.timelock.lock.watch.LockEventLogImpl.LockWatchCreatedEventReplayer;\n-import com.palantir.lock.watch.LockWatchCreatedEvent;\n import com.palantir.lock.watch.LockWatchEvent;\n+import com.palantir.logsafe.Preconditions;\n \n-@ThreadSafe\n public class ArrayLockEventSlidingWindow {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83ea431fa3d8c1edbdb53b4e11ab35fc42a62683"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f8170617ac83626e4437137339405e42d179bb0", "author": {"user": {"login": "jkozlowski", "name": "Jakub Kozlowski"}}, "url": "https://github.com/palantir/atlasdb/commit/6f8170617ac83626e4437137339405e42d179bb0", "committedDate": "2020-06-24T21:39:44Z", "message": "CR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MzU4NjYw", "url": "https://github.com/palantir/atlasdb/pull/4820#pullrequestreview-437358660", "createdAt": "2020-06-25T10:17:45Z", "commit": {"oid": "6f8170617ac83626e4437137339405e42d179bb0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2918, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}