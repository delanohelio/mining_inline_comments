{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyNTMyOTQy", "number": 5026, "title": "Double check that the SQLite migration is consistent with current state", "bodyText": "Goals (and why):\nIf we upgraded to version with SQLite paxos log, downgraded to a version before, used timelock for a bit, and then upgraded again, migration would not run because it had already run. Normally, the downgrade itself would have already cause data corruption if allowed, but it is possible to restore from backup to a previous version, and then upgrade after running on the restored version at which point the migration would silently noop and we would start using the pre-restore SQLite paxos state log. This PR verifies the consistency whenever we detect that the migration has already run.\nImplementation Description (bullets):\nWe have imperfect information and do not want to effectively redo the migration on every startup, so we do the following:\n\nVerify the cutoff that was persisted matches a newly calculated one. This guarantees the learner has not advanced except in the special case where the greatest log entry is was less than 50 at migration time and then advanced but is still less than 50.\nVerify that the greatest log entry in the legacy log is not larger than the one in SQLite, and also verify that the entry is present in SQLite and equal. This covers both the special case above and the acceptor as acceptor uses the cutoff from the learner.\n\nAlso needed to implement equality for PaxosAcceptorState.java, which has to not include the version which is not persisted. Not in love with this, but beats the alternatives.\nTesting (What was existing testing like?  What have you done to improve it?):\nUnit tests for the migrator and for the PAS equality.\nConcerns (what feedback would you like?):\nNote that (2) above is not foolproof as it is possible that the legacy log wrote some new entries and then happened to write the latest one to exactly mach one that SQLite wrote after the migration while there are some in between that do not match. I am not aware of a way to do this with more certainty while not also effectively redoing the migration on every startup, which is prohibitively expensive. An alternative approach would be to have a new migration state table where we persist the greatest migrated sequence as well as cutoff, and would then have to migrate all already migrated deployments, but that seems excessive since the chance of (2) failing while also (1) passing is very low.\nWhere should we start reviewing?:\nPaxosStateLogMigrator.java\nPriority (whenever / two weeks / yesterday):\nASAP", "createdAt": "2020-10-13T16:22:15Z", "url": "https://github.com/palantir/atlasdb/pull/5026", "merged": true, "mergeCommit": {"oid": "de9f2645217c7ce30632c2c55f348d6c5b4f75ec"}, "closed": true, "closedAt": "2020-10-15T12:56:03Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSKj2kgH2gAyNTAyNTMyOTQyOmYzNjJiYTFmYWVkOTk3YTk4Njg2MjRlMDNhZDhkZDRkNDVlNzljODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSxUBCgFqTUwOTM0NTU1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f362ba1faed997a9868624e03ad8dd4d45e79c81", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/f362ba1faed997a9868624e03ad8dd4d45e79c81", "committedDate": "2020-10-13T15:46:05Z", "message": "Double check that the SQLite migration is consistent with current state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be21fdf9644789f564a108be1e1841a539b5149c", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/be21fdf9644789f564a108be1e1841a539b5149c", "committedDate": "2020-10-13T16:07:05Z", "message": "Remove unused variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f6370c8946918a422e2291db28e6f6f6aa888b4", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/3f6370c8946918a422e2291db28e6f6f6aa888b4", "committedDate": "2020-10-13T16:38:05Z", "message": "Fix naughty integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/33199045e2350764efccfcbdf2b18a1d0e273044", "committedDate": "2020-10-13T16:38:05Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MTkzNDcz", "url": "https://github.com/palantir/atlasdb/pull/5026#pullrequestreview-508193473", "createdAt": "2020-10-14T10:08:18Z", "commit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDowODoxOFrOHhL1sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDoxNDo0N1rOHhMEcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1OTAyNg==", "bodyText": "Can we figure out a way to introduce a special method for this instead of relying on #equals? There's no harm in that, and relying on equals feels wrong, especially since you're ignoring some fields + if you have equals that forces you to have hashCode, which again we don't need.", "url": "https://github.com/palantir/atlasdb/pull/5026#discussion_r504559026", "createdAt": "2020-10-14T10:08:18Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosAcceptorState.java", "diffHunk": "@@ -117,4 +118,38 @@ public PaxosProposalId getLastAcceptedId() {\n     public PaxosValue getLastAcceptedValue() {\n         return lastAcceptedValue;\n     }\n+\n+    /**\n+     * Standard equals implementation, note that {@link #version} is not persisted and as such is not used in the\n+     * calculation.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU2MjgwMw==", "bodyText": "nit: already.", "url": "https://github.com/palantir/atlasdb/pull/5026#discussion_r504562803", "createdAt": "2020-10-14T10:14:47Z", "author": {"login": "jkozlowski"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/paxos/PaxosStateLogMigrationIntegrationTest.java", "diffHunk": "@@ -160,25 +161,17 @@ public void learningValuesBeforeCutoffPersistsToLegacyLog() throws IOException {\n     }\n \n     @Test\n-    public void migrateOnlyOnce() throws IOException {\n+    public void failWhenOldLogWritesAtGreaterSequenceAfterMigrationAlreadyRan() throws IOException {\n         fileBasedLearnerLog.writeRound(LATEST_ROUND_BEFORE_MIGRATING, valueForRound(LATEST_ROUND_BEFORE_MIGRATING));\n \n-        LocalPaxosComponents paxosComponents = createPaxosComponents();\n+        createPaxosComponents();\n \n         long newRound = LATEST_ROUND_BEFORE_MIGRATING + 3;\n         fileBasedLearnerLog.writeRound(newRound, valueForRound(newRound));\n \n-        createPaxosComponents();\n-\n-        PaxosStateLog<PaxosValue> sqliteLog = createSqliteLog(paxosComponents.getLearnerParameters(CLIENT));\n-        assertValuePresent(LATEST_ROUND_BEFORE_MIGRATING, sqliteLog);\n-        assertValueAbsent(newRound, sqliteLog);\n-\n-        PaxosLearner learner = paxosComponents.learner(CLIENT);\n-        assertValueNotLearned(newRound, learner);\n-\n-        assertThat(paxosComponents.getWriteCounter(PaxosLearner.class).getCount()).isEqualTo(0L);\n-        assertThat(paxosComponents.getReadCounter(PaxosLearner.class).getCount()).isEqualTo(0L);\n+        assertThatThrownBy(this::createPaxosComponents)\n+                .as(\"Written to file based log at greater sequence after migration alredy ran\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MjE0MDMz", "url": "https://github.com/palantir/atlasdb/pull/5026#pullrequestreview-508214033", "createdAt": "2020-10-14T10:37:12Z", "commit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDozNzoxM1rOHhM0kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMDozNzoxM1rOHhM0kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU3NTEyMQ==", "bodyText": "That's just weird - just throw a SafeIllegalStateException, surely?", "url": "https://github.com/palantir/atlasdb/pull/5026#discussion_r504575121", "createdAt": "2020-10-14T10:37:13Z", "author": {"login": "Jolyon-S"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -117,6 +120,39 @@ private void writeBatchRetryingUpToFiveTimes(PaxosStateLog<V> target, List<Paxos\n         target.writeBatchOfRounds(batch);\n     }\n \n+    private static <V extends Persistable & Versionable> void validateConsistency(MigrationContext<V> context) {\n+        long migrationCutoff = calculateCutoff(context);\n+        long persistedCutoff = context.migrationState().getCutoff();\n+        long greatestSourceEntry = context.sourceLog().getGreatestLogEntry();\n+        Preconditions.checkState(migrationCutoff <= persistedCutoff,\n+                \"The migration to the destination state log was already performed in the past, but the \"\n+                        + \"persisted cutoff value does not match a newly calculated one. This indicates the source \"\n+                        + \"log has advanced since the migration was performed which could lead to data corruption if \"\n+                        + \"allowed to continue.\",\n+                SafeArg.of(\"fresh cutoff\", migrationCutoff),\n+                SafeArg.of(\"persisted cutoff\", persistedCutoff),\n+                SafeArg.of(\"source greatest entry\", greatestSourceEntry));\n+        if (greatestSourceEntry == PaxosAcceptor.NO_LOG_ENTRY) {\n+            return;\n+        }\n+        try {\n+            V source = context.hydrator().hydrateFromBytes(context.sourceLog().readRound(greatestSourceEntry));\n+            byte[] destinationBytes = context.destinationLog().readRound(greatestSourceEntry);\n+            V dest = destinationBytes != null ? context.hydrator().hydrateFromBytes(destinationBytes) : null;\n+            Preconditions.checkState(source.equals(dest),\n+                    \"The migration to the destination state log was already performed in the past, but the \"\n+                            + \"entry with the greatest sequence in source log does not match the entry in the \"\n+                            + \"destination log. This indicates the source log has advanced since the migration was \"\n+                            + \"performed which could lead to data corruption if allowed to continue.\",\n+                    SafeArg.of(\"source entry\", source),\n+                    SafeArg.of(\"destination entry\", dest));\n+        } catch (IOException e) {\n+            Preconditions.checkState(false,\n+                    \"Unable to verify consistency between source and destination paxos logs because the \"\n+                            + \"source log entry could not be read.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33199045e2350764efccfcbdf2b18a1d0e273044"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "981a5d5ab63089d1368342bd17796adc2aa2aa5b", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/981a5d5ab63089d1368342bd17796adc2aa2aa5b", "committedDate": "2020-10-14T15:54:15Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MzQ1NTU2", "url": "https://github.com/palantir/atlasdb/pull/5026#pullrequestreview-509345556", "createdAt": "2020-10-15T12:55:05Z", "commit": {"oid": "981a5d5ab63089d1368342bd17796adc2aa2aa5b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2634, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}