{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExNzc1OTA5", "number": 4747, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjoyNTo1NFrOD4Ommw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMDoyNToxNFrOD4VdoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjg2MTA3OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjoyNTo1NFrOGO8dSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDoxNDo0NVrOGPK1qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMzc4NA==", "bodyText": "For my knowledge, what is seqId?", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418323784", "createdAt": "2020-04-30T22:25:54Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4NjMwNQ==", "bodyText": "Yes, this is not super descriptive, I imagine it's a combination of use case and acceptor/learner?", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418486305", "createdAt": "2020-05-01T10:04:00Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMzc4NA=="}, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5ODcxNg==", "bodyText": "Right, yeah. The problem is that PaxosUseCase as a concept only exists in TimeLock (this project is also used by embedded services and clustered lock in large internal product), which is why I opted to be generic and just describe it as a sequence ID. It is meant to be (PaxosUseCase, Acceptor|Learner), yes.", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418498716", "createdAt": "2020-05-01T10:53:56Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMzc4NA=="}, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1OTQwMg==", "bodyText": "I think we discussed offline and went for useCase - this does run the risk of people conflating it with PaxosUseCase, but it is general enough still.", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418559402", "createdAt": "2020-05-01T14:14:45Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMzc4NA=="}, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzk1NjgwOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMDowNzo1OFrOGPGcLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNDoxODozNlrOGPK71w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4NzM0Mw==", "bodyText": "As in the other PR, should be 'Set'", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418487343", "createdAt": "2020-05-01T10:07:58Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;\n     private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+    private SqlitePaxosStateLog(Client namespace, String seqId, Jdbi jdbi) {\n         this.namespace = namespace;\n+        this.seqId = seqId;\n         this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(Client namespace,\n+            String sequenceId,\n             Supplier<Connection> connectionSupplier) {\n         Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n-        jdbi.getConfig(JdbiImmutables.class).registerImmutable(PaxosRound.class);\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n+        jdbi.getConfig(JdbiImmutables.class).registerImmutable(Client.class, PaxosRound.class);\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, sequenceId, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        execute(dao -> dao.createTable(namespace));\n+        execute(Queries::createTable);\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n+        execute(dao -> dao.writeRound(namespace, seqId, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public void writeBatchOfRounds(Iterable<PaxosRound<V>> rounds) {\n-        execute(dao -> dao.writeBatchOfRounds(namespace, rounds));\n+        execute(dao -> dao.writeBatchOfRounds(namespace, seqId, rounds));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return execute(dao -> dao.readRound(namespace, seq));\n+        return execute(dao -> dao.readRound(namespace, seqId, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return execute(dao -> dao.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getLeastLogEntry(namespace, seqId)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return execute(dao -> dao.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getGreatestLogEntry(namespace, seqId)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        execute(dao -> dao.truncate(namespace, toDeleteInclusive));\n+        execute(dao -> dao.truncate(namespace, seqId, toDeleteInclusive));\n     }\n \n     private <T> T execute(Function<Queries, T> call) {\n         return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n     public interface Queries {\n-        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS <table> (seq BIGINT PRIMARY KEY, val BLOB)\")\n-        boolean createTable(@Define(\"table\") String table);\n-\n-        @SqlUpdate(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:seq, :value)\")\n-        boolean writeRound(@Define(\"table\") String table, @Bind(\"seq\") long seq, @Bind(\"value\") byte[] value);\n-\n-        @SqlQuery(\"SELECT val FROM <table> WHERE seq = :seq\")\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS paxosLog (\"\n+                + \"namespace TEXT,\"\n+                + \"seqId TEXT,\"\n+                + \"seq BIGINT, \"\n+                + \"val BLOB,\"\n+                + \"PRIMARY KEY(namespace, seqId, seq))\")\n+        boolean createTable();\n+\n+        @SqlUpdate(\"INSERT OR REPLACE INTO paxosLog (namespace, seqId, seq, val) VALUES (\"\n+                + \":namespace.value, :seqId, :seq, :value)\")\n+        boolean writeRound(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"seqId\") String seqId,\n+                @Bind(\"seq\") long seq,\n+                @Bind(\"value\") byte[] value);\n+\n+        @SqlQuery(\"SELECT val FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId AND seq = :seq\")\n         @SingleValue\n-        byte[] readRound(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+        byte[] readRound(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId, @Bind(\"seq\") long seq);\n \n-        @SqlQuery(\"SELECT MIN(seq) FROM <table>\")\n-        OptionalLong getLeastLogEntry(@Define(\"table\") String table);\n+        @SqlQuery(\"SELECT MIN(seq) FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId\")\n+        OptionalLong getLeastLogEntry(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId);\n \n-        @SqlQuery(\"SELECT MAX(seq) FROM <table>\")\n-        OptionalLong getGreatestLogEntry(@Define(\"table\") String table);\n+        @SqlQuery(\"SELECT MAX(seq) FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId\")\n+        OptionalLong getGreatestLogEntry(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId);\n \n-        @SqlUpdate(\"DELETE FROM <table> WHERE seq <= :seq\")\n-        boolean truncate(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+        @SqlUpdate(\"DELETE FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId AND seq <= :seq\")\n+        boolean truncate(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId, @Bind(\"seq\") long seq);\n \n-        @SqlBatch(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:round.sequence, :round.valueBytes)\")\n-        <V extends Persistable & Versionable> boolean[] writeBatchOfRounds(@Define(\"table\") String table,\n+        @SqlBatch(\"INSERT OR REPLACE INTO paxosLog (namespace, seqId, seq, val) VALUES (\"\n+                + \":namespace.value, :seqId, :round.sequence, :round.valueBytes)\")\n+        <V extends Persistable & Versionable> boolean[] writeBatchOfRounds(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"seqId\") String seqId,\n                 @BindPojo(\"round\") Iterable<PaxosRound<V>> rounds);\n+\n+        @SqlQuery(\"SELECT DISTINCT(namespace) FROM paxosLog\")\n+        List<String> getAllNamespaces();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5MTQ0MQ==", "bodyText": "Also would be nice if this returned Set<Client> but doesn't seem to be trivial to implement, so this is fine", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418491441", "createdAt": "2020-05-01T10:24:18Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;\n     private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+    private SqlitePaxosStateLog(Client namespace, String seqId, Jdbi jdbi) {\n         this.namespace = namespace;\n+        this.seqId = seqId;\n         this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(Client namespace,\n+            String sequenceId,\n             Supplier<Connection> connectionSupplier) {\n         Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n-        jdbi.getConfig(JdbiImmutables.class).registerImmutable(PaxosRound.class);\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n+        jdbi.getConfig(JdbiImmutables.class).registerImmutable(Client.class, PaxosRound.class);\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, sequenceId, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        execute(dao -> dao.createTable(namespace));\n+        execute(Queries::createTable);\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n+        execute(dao -> dao.writeRound(namespace, seqId, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public void writeBatchOfRounds(Iterable<PaxosRound<V>> rounds) {\n-        execute(dao -> dao.writeBatchOfRounds(namespace, rounds));\n+        execute(dao -> dao.writeBatchOfRounds(namespace, seqId, rounds));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return execute(dao -> dao.readRound(namespace, seq));\n+        return execute(dao -> dao.readRound(namespace, seqId, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return execute(dao -> dao.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getLeastLogEntry(namespace, seqId)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return execute(dao -> dao.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getGreatestLogEntry(namespace, seqId)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        execute(dao -> dao.truncate(namespace, toDeleteInclusive));\n+        execute(dao -> dao.truncate(namespace, seqId, toDeleteInclusive));\n     }\n \n     private <T> T execute(Function<Queries, T> call) {\n         return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n     public interface Queries {\n-        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS <table> (seq BIGINT PRIMARY KEY, val BLOB)\")\n-        boolean createTable(@Define(\"table\") String table);\n-\n-        @SqlUpdate(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:seq, :value)\")\n-        boolean writeRound(@Define(\"table\") String table, @Bind(\"seq\") long seq, @Bind(\"value\") byte[] value);\n-\n-        @SqlQuery(\"SELECT val FROM <table> WHERE seq = :seq\")\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS paxosLog (\"\n+                + \"namespace TEXT,\"\n+                + \"seqId TEXT,\"\n+                + \"seq BIGINT, \"\n+                + \"val BLOB,\"\n+                + \"PRIMARY KEY(namespace, seqId, seq))\")\n+        boolean createTable();\n+\n+        @SqlUpdate(\"INSERT OR REPLACE INTO paxosLog (namespace, seqId, seq, val) VALUES (\"\n+                + \":namespace.value, :seqId, :seq, :value)\")\n+        boolean writeRound(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"seqId\") String seqId,\n+                @Bind(\"seq\") long seq,\n+                @Bind(\"value\") byte[] value);\n+\n+        @SqlQuery(\"SELECT val FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId AND seq = :seq\")\n         @SingleValue\n-        byte[] readRound(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+        byte[] readRound(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId, @Bind(\"seq\") long seq);\n \n-        @SqlQuery(\"SELECT MIN(seq) FROM <table>\")\n-        OptionalLong getLeastLogEntry(@Define(\"table\") String table);\n+        @SqlQuery(\"SELECT MIN(seq) FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId\")\n+        OptionalLong getLeastLogEntry(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId);\n \n-        @SqlQuery(\"SELECT MAX(seq) FROM <table>\")\n-        OptionalLong getGreatestLogEntry(@Define(\"table\") String table);\n+        @SqlQuery(\"SELECT MAX(seq) FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId\")\n+        OptionalLong getGreatestLogEntry(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId);\n \n-        @SqlUpdate(\"DELETE FROM <table> WHERE seq <= :seq\")\n-        boolean truncate(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+        @SqlUpdate(\"DELETE FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId AND seq <= :seq\")\n+        boolean truncate(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId, @Bind(\"seq\") long seq);\n \n-        @SqlBatch(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:round.sequence, :round.valueBytes)\")\n-        <V extends Persistable & Versionable> boolean[] writeBatchOfRounds(@Define(\"table\") String table,\n+        @SqlBatch(\"INSERT OR REPLACE INTO paxosLog (namespace, seqId, seq, val) VALUES (\"\n+                + \":namespace.value, :seqId, :round.sequence, :round.valueBytes)\")\n+        <V extends Persistable & Versionable> boolean[] writeBatchOfRounds(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"seqId\") String seqId,\n                 @BindPojo(\"round\") Iterable<PaxosRound<V>> rounds);\n+\n+        @SqlQuery(\"SELECT DISTINCT(namespace) FROM paxosLog\")\n+        List<String> getAllNamespaces();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4NzM0Mw=="}, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2MDk4Mw==", "bodyText": "Changing to Set works. As discussed a full change to Set<Client> is nontrivial", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418560983", "createdAt": "2020-05-01T14:18:36Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -27,91 +28,109 @@\n import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n import org.jdbi.v3.sqlobject.customizer.Bind;\n import org.jdbi.v3.sqlobject.customizer.BindPojo;\n-import org.jdbi.v3.sqlobject.customizer.Define;\n import org.jdbi.v3.sqlobject.statement.SqlBatch;\n import org.jdbi.v3.sqlobject.statement.SqlQuery;\n import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n \n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final String namespace;\n+    private final Client namespace;\n+    private final String seqId;\n     private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+    private SqlitePaxosStateLog(Client namespace, String seqId, Jdbi jdbi) {\n         this.namespace = namespace;\n+        this.seqId = seqId;\n         this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(Client namespace,\n+            String sequenceId,\n             Supplier<Connection> connectionSupplier) {\n         Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n-        jdbi.getConfig(JdbiImmutables.class).registerImmutable(PaxosRound.class);\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n+        jdbi.getConfig(JdbiImmutables.class).registerImmutable(Client.class, PaxosRound.class);\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, sequenceId, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        execute(dao -> dao.createTable(namespace));\n+        execute(Queries::createTable);\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n+        execute(dao -> dao.writeRound(namespace, seqId, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public void writeBatchOfRounds(Iterable<PaxosRound<V>> rounds) {\n-        execute(dao -> dao.writeBatchOfRounds(namespace, rounds));\n+        execute(dao -> dao.writeBatchOfRounds(namespace, seqId, rounds));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return execute(dao -> dao.readRound(namespace, seq));\n+        return execute(dao -> dao.readRound(namespace, seqId, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return execute(dao -> dao.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getLeastLogEntry(namespace, seqId)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return execute(dao -> dao.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getGreatestLogEntry(namespace, seqId)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        execute(dao -> dao.truncate(namespace, toDeleteInclusive));\n+        execute(dao -> dao.truncate(namespace, seqId, toDeleteInclusive));\n     }\n \n     private <T> T execute(Function<Queries, T> call) {\n         return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n     public interface Queries {\n-        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS <table> (seq BIGINT PRIMARY KEY, val BLOB)\")\n-        boolean createTable(@Define(\"table\") String table);\n-\n-        @SqlUpdate(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:seq, :value)\")\n-        boolean writeRound(@Define(\"table\") String table, @Bind(\"seq\") long seq, @Bind(\"value\") byte[] value);\n-\n-        @SqlQuery(\"SELECT val FROM <table> WHERE seq = :seq\")\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS paxosLog (\"\n+                + \"namespace TEXT,\"\n+                + \"seqId TEXT,\"\n+                + \"seq BIGINT, \"\n+                + \"val BLOB,\"\n+                + \"PRIMARY KEY(namespace, seqId, seq))\")\n+        boolean createTable();\n+\n+        @SqlUpdate(\"INSERT OR REPLACE INTO paxosLog (namespace, seqId, seq, val) VALUES (\"\n+                + \":namespace.value, :seqId, :seq, :value)\")\n+        boolean writeRound(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"seqId\") String seqId,\n+                @Bind(\"seq\") long seq,\n+                @Bind(\"value\") byte[] value);\n+\n+        @SqlQuery(\"SELECT val FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId AND seq = :seq\")\n         @SingleValue\n-        byte[] readRound(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+        byte[] readRound(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId, @Bind(\"seq\") long seq);\n \n-        @SqlQuery(\"SELECT MIN(seq) FROM <table>\")\n-        OptionalLong getLeastLogEntry(@Define(\"table\") String table);\n+        @SqlQuery(\"SELECT MIN(seq) FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId\")\n+        OptionalLong getLeastLogEntry(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId);\n \n-        @SqlQuery(\"SELECT MAX(seq) FROM <table>\")\n-        OptionalLong getGreatestLogEntry(@Define(\"table\") String table);\n+        @SqlQuery(\"SELECT MAX(seq) FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId\")\n+        OptionalLong getGreatestLogEntry(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId);\n \n-        @SqlUpdate(\"DELETE FROM <table> WHERE seq <= :seq\")\n-        boolean truncate(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+        @SqlUpdate(\"DELETE FROM paxosLog WHERE namespace = :namespace.value AND seqId = :seqId AND seq <= :seq\")\n+        boolean truncate(@BindPojo(\"namespace\") Client namespace, @Bind(\"seqId\") String seqId, @Bind(\"seq\") long seq);\n \n-        @SqlBatch(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:round.sequence, :round.valueBytes)\")\n-        <V extends Persistable & Versionable> boolean[] writeBatchOfRounds(@Define(\"table\") String table,\n+        @SqlBatch(\"INSERT OR REPLACE INTO paxosLog (namespace, seqId, seq, val) VALUES (\"\n+                + \":namespace.value, :seqId, :round.sequence, :round.valueBytes)\")\n+        <V extends Persistable & Versionable> boolean[] writeBatchOfRounds(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"seqId\") String seqId,\n                 @BindPojo(\"round\") Iterable<PaxosRound<V>> rounds);\n+\n+        @SqlQuery(\"SELECT DISTINCT(namespace) FROM paxosLog\")\n+        List<String> getAllNamespaces();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4NzM0Mw=="}, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzk4NDk2OnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/management/SqliteNamespaceLoader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMDoyNToxNFrOGPGtHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMDoyNToxNFrOGPGtHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5MTY3Ng==", "bodyText": "As above, make it a set?", "url": "https://github.com/palantir/atlasdb/pull/4747#discussion_r418491676", "createdAt": "2020-05-01T10:25:14Z", "author": {"login": "gmaretic"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/management/SqliteNamespaceLoader.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.management;\n+\n+import java.sql.Connection;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+\n+public final class SqliteNamespaceLoader {\n+    private final Jdbi jdbi;\n+\n+    private SqliteNamespaceLoader(Jdbi jdbi) {\n+        this.jdbi = jdbi;\n+    }\n+\n+    public static SqliteNamespaceLoader create(Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n+        jdbi.withExtension(SqlitePaxosStateLog.Queries.class, SqlitePaxosStateLog.Queries::createTable);\n+        return new SqliteNamespaceLoader(jdbi);\n+    }\n+\n+    public List<Client> getAllRegisteredNamespaces() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a69d1e2a0e4498557aaca9ac130d7d0dd6ac5d6"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3108, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}