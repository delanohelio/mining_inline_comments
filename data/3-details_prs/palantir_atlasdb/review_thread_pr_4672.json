{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzAyNTk2", "number": 4672, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODozMToyNlrODrWH1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODozMToyNlrODrWH1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Nzc3ODE1OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/leader/proxy/AsyncRetrier.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODozMToyNlrOF7o5iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwODo0MToyMVrOF78Umg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4MDM5NQ==", "bodyText": "nit: should we remove the inner transformAsync as it should be unnecessary if we're getting from the supplier on the current thread?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Futures.transformAsync(Futures.submitAsync(supplier::get, MoreExecutors.directExecutor()),\n          \n          \n            \n                    return Futures.transformAsync(supplier.get(),", "url": "https://github.com/palantir/atlasdb/pull/4672#discussion_r398080395", "createdAt": "2020-03-25T18:31:26Z", "author": {"login": "schlosna"}, "path": "leader-election-impl/src/main/java/com/palantir/leader/proxy/AsyncRetrier.java", "diffHunk": "@@ -53,20 +54,33 @@\n         return execute(supplier, maxAttempts);\n     }\n \n+    /*\n+    Threading model: Given the context of this class, it is likely that the first request will pass. Since this occurs\n+    in the hot path, we should probably avoid putting it on another thread to do what would be light work as we will\n+    pay for that in context switches.\n+\n+    In a similar vein to reduce context switches, when the supplier::get call returns, the processing should be fairly\n+    lightweight, so we should be able to do it in whatever thread ran/took control of the original supplier::get call,\n+    hence the usage of directExecutor.\n+\n+    If we do have to retry, then we're likely \"slow\" enough that we should give up the initial calling thread and\n+    offload the work onto a separate executor.\n+     */\n     private ListenableFuture<T> execute(Supplier<ListenableFuture<T>> supplier, int retriesRemaining) {\n-        return Futures.transformAsync(Futures.submitAsync(supplier::get, executionExecutor),\n+        return Futures.transformAsync(Futures.submitAsync(supplier::get, MoreExecutors.directExecutor()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c80c2a1706daaac8566b65b50ab97dccbbd25c56"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM4NzAzNA==", "bodyText": "A good shout, thanks!", "url": "https://github.com/palantir/atlasdb/pull/4672#discussion_r398387034", "createdAt": "2020-03-26T08:20:20Z", "author": {"login": "felixdesouza"}, "path": "leader-election-impl/src/main/java/com/palantir/leader/proxy/AsyncRetrier.java", "diffHunk": "@@ -53,20 +54,33 @@\n         return execute(supplier, maxAttempts);\n     }\n \n+    /*\n+    Threading model: Given the context of this class, it is likely that the first request will pass. Since this occurs\n+    in the hot path, we should probably avoid putting it on another thread to do what would be light work as we will\n+    pay for that in context switches.\n+\n+    In a similar vein to reduce context switches, when the supplier::get call returns, the processing should be fairly\n+    lightweight, so we should be able to do it in whatever thread ran/took control of the original supplier::get call,\n+    hence the usage of directExecutor.\n+\n+    If we do have to retry, then we're likely \"slow\" enough that we should give up the initial calling thread and\n+    offload the work onto a separate executor.\n+     */\n     private ListenableFuture<T> execute(Supplier<ListenableFuture<T>> supplier, int retriesRemaining) {\n-        return Futures.transformAsync(Futures.submitAsync(supplier::get, executionExecutor),\n+        return Futures.transformAsync(Futures.submitAsync(supplier::get, MoreExecutors.directExecutor()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4MDM5NQ=="}, "originalCommit": {"oid": "c80c2a1706daaac8566b65b50ab97dccbbd25c56"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM5ODYxOA==", "bodyText": "Had to wrap the supplier so we don't throw but return failed futures, but I think it's fine.", "url": "https://github.com/palantir/atlasdb/pull/4672#discussion_r398398618", "createdAt": "2020-03-26T08:41:21Z", "author": {"login": "felixdesouza"}, "path": "leader-election-impl/src/main/java/com/palantir/leader/proxy/AsyncRetrier.java", "diffHunk": "@@ -53,20 +54,33 @@\n         return execute(supplier, maxAttempts);\n     }\n \n+    /*\n+    Threading model: Given the context of this class, it is likely that the first request will pass. Since this occurs\n+    in the hot path, we should probably avoid putting it on another thread to do what would be light work as we will\n+    pay for that in context switches.\n+\n+    In a similar vein to reduce context switches, when the supplier::get call returns, the processing should be fairly\n+    lightweight, so we should be able to do it in whatever thread ran/took control of the original supplier::get call,\n+    hence the usage of directExecutor.\n+\n+    If we do have to retry, then we're likely \"slow\" enough that we should give up the initial calling thread and\n+    offload the work onto a separate executor.\n+     */\n     private ListenableFuture<T> execute(Supplier<ListenableFuture<T>> supplier, int retriesRemaining) {\n-        return Futures.transformAsync(Futures.submitAsync(supplier::get, executionExecutor),\n+        return Futures.transformAsync(Futures.submitAsync(supplier::get, MoreExecutors.directExecutor()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4MDM5NQ=="}, "originalCommit": {"oid": "c80c2a1706daaac8566b65b50ab97dccbbd25c56"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2999, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}