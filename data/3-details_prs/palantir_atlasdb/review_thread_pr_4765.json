{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODUwNTY1", "number": 4765, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoxOTo1MlrOD7v_DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyOTo0NlrOD7wNWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTc4NzY1OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoxOTo1MlrOGURAng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoxOTo1MlrOGURAng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMzM5MA==", "bodyText": "Non-actionable: sigh. This was almost entirely agnostic of SQLite. Given we aren't going to be implementing another migration state any time soon though, I'd say leave it.", "url": "https://github.com/palantir/atlasdb/pull/4765#discussion_r423903390", "createdAt": "2020-05-12T17:19:52Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.util.stream.LongStream;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.common.persist.Persistable;\n+\n+public final class PaxosStateLogMigrator<V extends Persistable & Versionable> {\n+    @VisibleForTesting\n+    static final int BATCH_SIZE = 10_000;\n+\n+    private final PaxosStateLog<V> sourceLog;\n+    private final PaxosStateLog<V> destinationLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+    private final SqlitePaxosStateLogMigrationState migrationState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d43594469c3921f79c3aa8418a5c99b8ef34d3c8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTgxMjYyOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyNjo0NVrOGURQ9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwOTo0MDozMVrOGUptZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNzU3Mg==", "bodyText": "It's benign, but to avoid future confusion we should handle the edge case here: this method returns PaxosAcceptor.NO_LOG_ENTRY if there are zero entries in the source log, meaning that numberOfBatches = (-1 - 0) / BATCH_SIZE + 1 which by Java semantics is actually 1. Then there is a batch from zero to BATCH_SIZE entries that the reader will try and read.", "url": "https://github.com/palantir/atlasdb/pull/4765#discussion_r423907572", "createdAt": "2020-05-12T17:26:45Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.util.stream.LongStream;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.common.persist.Persistable;\n+\n+public final class PaxosStateLogMigrator<V extends Persistable & Versionable> {\n+    @VisibleForTesting\n+    static final int BATCH_SIZE = 10_000;\n+\n+    private final PaxosStateLog<V> sourceLog;\n+    private final PaxosStateLog<V> destinationLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+    private final SqlitePaxosStateLogMigrationState migrationState;\n+\n+    private PaxosStateLogMigrator(PaxosStateLog<V> sourceLog,\n+            PaxosStateLog<V> destinationLog,\n+            Persistable.Hydrator<V> hydrator,\n+            SqlitePaxosStateLogMigrationState migrationState) {\n+        this.sourceLog = sourceLog;\n+        this.destinationLog = destinationLog;\n+        this.hydrator = hydrator;\n+        this.migrationState = migrationState;\n+    }\n+\n+    public static <V extends Persistable & Versionable> void migrate(MigrationContext<V> migrationContext) {\n+        PaxosStateLogMigrator<V> migrator = new PaxosStateLogMigrator<>(\n+                migrationContext.sourceLog(),\n+                migrationContext.destinationLog(),\n+                migrationContext.hydrator(),\n+                migrationContext.migrationState());\n+        migrator.runMigration();\n+    }\n+\n+    private void runMigration() {\n+        if (migrationState.hasAlreadyMigrated()) {\n+            return;\n+        }\n+        destinationLog.truncate(destinationLog.getGreatestLogEntry());\n+        long lowerBound = lowestSequenceToMigrate();\n+        long upperBound = sourceLog.getGreatestLogEntry();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d43594469c3921f79c3aa8418a5c99b8ef34d3c8"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMwODA2OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/palantir/atlasdb/pull/4765#discussion_r424308068", "createdAt": "2020-05-13T09:40:31Z", "author": {"login": "gmaretic"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogMigrator.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.util.stream.LongStream;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.common.persist.Persistable;\n+\n+public final class PaxosStateLogMigrator<V extends Persistable & Versionable> {\n+    @VisibleForTesting\n+    static final int BATCH_SIZE = 10_000;\n+\n+    private final PaxosStateLog<V> sourceLog;\n+    private final PaxosStateLog<V> destinationLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+    private final SqlitePaxosStateLogMigrationState migrationState;\n+\n+    private PaxosStateLogMigrator(PaxosStateLog<V> sourceLog,\n+            PaxosStateLog<V> destinationLog,\n+            Persistable.Hydrator<V> hydrator,\n+            SqlitePaxosStateLogMigrationState migrationState) {\n+        this.sourceLog = sourceLog;\n+        this.destinationLog = destinationLog;\n+        this.hydrator = hydrator;\n+        this.migrationState = migrationState;\n+    }\n+\n+    public static <V extends Persistable & Versionable> void migrate(MigrationContext<V> migrationContext) {\n+        PaxosStateLogMigrator<V> migrator = new PaxosStateLogMigrator<>(\n+                migrationContext.sourceLog(),\n+                migrationContext.destinationLog(),\n+                migrationContext.hydrator(),\n+                migrationContext.migrationState());\n+        migrator.runMigration();\n+    }\n+\n+    private void runMigration() {\n+        if (migrationState.hasAlreadyMigrated()) {\n+            return;\n+        }\n+        destinationLog.truncate(destinationLog.getGreatestLogEntry());\n+        long lowerBound = lowestSequenceToMigrate();\n+        long upperBound = sourceLog.getGreatestLogEntry();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNzU3Mg=="}, "originalCommit": {"oid": "d43594469c3921f79c3aa8418a5c99b8ef34d3c8"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTgxNTIxOnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyNzoyNlrOGURSjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyNzoyNlrOGURSjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNzk4MA==", "bodyText": "\ud83c\udf89", "url": "https://github.com/palantir/atlasdb/pull/4765#discussion_r423907980", "createdAt": "2020-05-12T17:27:26Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -97,7 +96,7 @@ public void truncate(long toDeleteInclusive) {\n         @SqlUpdate(\"CREATE TABLE IF NOT EXISTS paxosLog (\"\n                 + \"namespace TEXT,\"\n                 + \"useCase TEXT,\"\n-                + \"seq BIGINT, \"\n+                + \"seq BIGINT,\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d43594469c3921f79c3aa8418a5c99b8ef34d3c8"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTgyNDI3OnYy", "diffSide": "RIGHT", "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogMigratorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyOTo0NlrOGURYhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoyOTo0NlrOGURYhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwOTUwOA==", "bodyText": "nice!", "url": "https://github.com/palantir/atlasdb/pull/4765#discussion_r423909508", "createdAt": "2020-05-12T17:29:46Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogMigratorTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import static com.palantir.paxos.PaxosStateLogMigrator.BATCH_SIZE;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.palantir.common.base.Throwables;\n+\n+public class PaxosStateLogMigratorTest {\n+    private static final NamespaceAndUseCase NAMESPACE = ImmutableNamespaceAndUseCase.of(Client.of(\"client\"), \"tom\");\n+\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private PaxosStateLog<PaxosValue> source;\n+    private PaxosStateLog<PaxosValue> target;\n+    private SqlitePaxosStateLogMigrationState migrationState;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        Supplier<Connection> sourceConnSupplier = SqliteConnections\n+                .createDefaultNamedSqliteDatabaseAtPath(tempFolder.newFolder(\"source\").toPath());\n+        Supplier<Connection> targetConnSupplier = SqliteConnections\n+                .createDefaultNamedSqliteDatabaseAtPath(tempFolder.newFolder(\"target\").toPath());\n+        source = SqlitePaxosStateLog.create(NAMESPACE, sourceConnSupplier);\n+        target = SqlitePaxosStateLog.create(NAMESPACE, targetConnSupplier);\n+        migrationState = SqlitePaxosStateLogMigrationState.create(NAMESPACE, targetConnSupplier);\n+    }\n+\n+    @Test\n+    public void emptyLogMigrationSuccessfullyMarksAsMigrated() {\n+        migrateFrom(source);\n+        assertThat(migrationState.hasAlreadyMigrated()).isTrue();\n+    }\n+\n+    @Test\n+    public void logMigrationSuccessfullyMigratesEntries() {\n+        long lowerBound = 10;\n+        long upperBound = 25;\n+        List<PaxosValue> valuesWritten = insertValuesWithinBounds(lowerBound, upperBound, source);\n+\n+        migrateFrom(source);\n+        assertThat(migrationState.hasAlreadyMigrated()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(lowerBound);\n+        assertThat(target.getGreatestLogEntry()).isEqualTo(upperBound);\n+\n+        valuesWritten.forEach(value ->\n+                assertThat(PaxosValue.BYTES_HYDRATOR.hydrateFromBytes(readRoundUnchecked(value.seq))).isEqualTo(value));\n+    }\n+\n+    @Test\n+    public void migrationDeletesExistingState() {\n+        long lowerBound = 13;\n+        long upperBound = 35;\n+        List<PaxosValue> valuesWritten = insertValuesWithinBounds(lowerBound, upperBound, target);\n+\n+        migrateFrom(source);\n+        assertThat(migrationState.hasAlreadyMigrated()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(PaxosAcceptor.NO_LOG_ENTRY);\n+        assertThat(target.getGreatestLogEntry()).isEqualTo(PaxosAcceptor.NO_LOG_ENTRY);\n+        valuesWritten.forEach(value -> assertThat(readRoundUnchecked(value.seq)).isNull());\n+    }\n+\n+    @Test\n+    public void doNotMigrateIfAlreadyMigrated() {\n+        migrationState.finishMigration();\n+\n+        long lowerBound = 1;\n+        long upperBound = 22;\n+        List<PaxosValue> valuesWritten = insertValuesWithinBounds(lowerBound, upperBound, source);\n+\n+        migrateFrom(source);\n+\n+        assertThat(migrationState.hasAlreadyMigrated()).isTrue();\n+        assertThat(target.getLeastLogEntry()).isEqualTo(PaxosAcceptor.NO_LOG_ENTRY);\n+        assertThat(target.getGreatestLogEntry()).isEqualTo(PaxosAcceptor.NO_LOG_ENTRY);\n+        valuesWritten.forEach(value -> assertThat(readRoundUnchecked(value.seq)).isNull());\n+    }\n+\n+    @Test\n+    public void logMigrationSuccessfullyMigratesManyEntriesIncludingSingleEntryInLastBatch() throws IOException {\n+        long lowerBound = 10;\n+        long upperBound = lowerBound + BATCH_SIZE * 10;\n+\n+        PaxosStateLog<PaxosValue> mockLog = mock(PaxosStateLog.class);\n+\n+        when(mockLog.getLeastLogEntry()).thenReturn(lowerBound);\n+        when(mockLog.getGreatestLogEntry()).thenReturn(upperBound);\n+        when(mockLog.readRound(anyLong())).thenAnswer(invocation -> {\n+            long sequence = (long) invocation.getArguments()[0];\n+            if (sequence > upperBound || sequence < lowerBound) {\n+                return null;\n+            }\n+            return valueForRound(sequence).persistToBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d43594469c3921f79c3aa8418a5c99b8ef34d3c8"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2830, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}