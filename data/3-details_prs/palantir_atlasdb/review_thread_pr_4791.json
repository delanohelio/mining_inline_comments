{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwODI4NTgz", "number": 4791, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMzozNlrOD-SaNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoyODo1M1rOD-TBZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjM5OTI3OnYy", "diffSide": "RIGHT", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjowMzozNlrOGYTAeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzowMjoyOVrOGYVbSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQyNg==", "bodyText": "Thinking about this a bit more: I think this is a change in behavior, in that every startTransactions call now will cause timelock to compute a snapshot, until we have an impl.", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428130426", "createdAt": "2020-05-20T16:03:36Z", "author": {"login": "jkozlowski"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -25,18 +25,17 @@\n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion\n-            .of(UUID.randomUUID(), Optional.empty());\n+    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion.of(UUID.randomUUID(), 0L);\n     private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), 0L, ImmutableSet.of(), ImmutableSet.of()));\n+            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n \n     private NoOpLockWatchEventCache() {\n         // singleton\n     }\n \n     @Override\n-    public IdentifiedVersion lastKnownVersion() {\n-        return FAKE;\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE1MTcyMQ==", "bodyText": "I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428151721", "createdAt": "2020-05-20T16:35:22Z", "author": {"login": "jeremyk-91"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -25,18 +25,17 @@\n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion\n-            .of(UUID.randomUUID(), Optional.empty());\n+    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion.of(UUID.randomUUID(), 0L);\n     private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), 0L, ImmutableSet.of(), ImmutableSet.of()));\n+            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n \n     private NoOpLockWatchEventCache() {\n         // singleton\n     }\n \n     @Override\n-    public IdentifiedVersion lastKnownVersion() {\n-        return FAKE;\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQyNg=="}, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE2ODk4Ng==", "bodyText": "Exactly, I think snapshotting is cheap so I shouldn't worry about it.", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428168986", "createdAt": "2020-05-20T17:00:46Z", "author": {"login": "jkozlowski"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -25,18 +25,17 @@\n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion\n-            .of(UUID.randomUUID(), Optional.empty());\n+    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion.of(UUID.randomUUID(), 0L);\n     private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), 0L, ImmutableSet.of(), ImmutableSet.of()));\n+            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n \n     private NoOpLockWatchEventCache() {\n         // singleton\n     }\n \n     @Override\n-    public IdentifiedVersion lastKnownVersion() {\n-        return FAKE;\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQyNg=="}, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3MDA1OA==", "bodyText": "Returning FAKE is same as Optional.empty, see impl. So I don't mind, I'll revert it.", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428170058", "createdAt": "2020-05-20T17:02:29Z", "author": {"login": "jkozlowski"}, "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/NoOpLockWatchEventCache.java", "diffHunk": "@@ -25,18 +25,17 @@\n @SuppressWarnings(\"FinalClass\") // mocks\n public class NoOpLockWatchEventCache implements LockWatchEventCache {\n     public static final LockWatchEventCache INSTANCE = new NoOpLockWatchEventCache();\n-    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion\n-            .of(UUID.randomUUID(), Optional.empty());\n+    private static final IdentifiedVersion FAKE = ImmutableIdentifiedVersion.of(UUID.randomUUID(), 0L);\n     private static final TransactionsLockWatchEvents NONE = TransactionsLockWatchEvents.failure(\n-            LockWatchStateUpdate.snapshot(UUID.randomUUID(), 0L, ImmutableSet.of(), ImmutableSet.of()));\n+            LockWatchStateUpdate.snapshot(UUID.randomUUID(), -1L, ImmutableSet.of(), ImmutableSet.of()));\n \n     private NoOpLockWatchEventCache() {\n         // singleton\n     }\n \n     @Override\n-    public IdentifiedVersion lastKnownVersion() {\n-        return FAKE;\n+    public Optional<IdentifiedVersion> lastKnownVersion() {\n+        return Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDQyNg=="}, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjQ5NTA2OnYy", "diffSide": "RIGHT", "path": "timelock-api/src/main/conjure/timelock-api.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoyNzo0M1rOGYT-JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMTozNzoyMFrOGYvqZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE0NjIxMg==", "bodyText": "since we'd already declared the external java Long I'd suggest using it? I get that this usage is probably safe, but probably best to be consistent especially with places where we really don't want this to be safelong (i.e. timestamps)", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428146212", "createdAt": "2020-05-20T16:27:43Z", "author": {"login": "jeremyk-91"}, "path": "timelock-api/src/main/conjure/timelock-api.yml", "diffHunk": "@@ -36,12 +36,18 @@ types:\n   definitions:\n     default-package: com.palantir.atlasdb.timelock.api\n     objects:\n+      ConjureIdentifiedVersion:\n+        fields:\n+          id: uuid\n+          version: safelong", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU5OTkwOA==", "bodyText": "Done", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428599908", "createdAt": "2020-05-21T11:37:20Z", "author": {"login": "jkozlowski"}, "path": "timelock-api/src/main/conjure/timelock-api.yml", "diffHunk": "@@ -36,12 +36,18 @@ types:\n   definitions:\n     default-package: com.palantir.atlasdb.timelock.api\n     objects:\n+      ConjureIdentifiedVersion:\n+        fields:\n+          id: uuid\n+          version: safelong", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE0NjIxMg=="}, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjQ5OTU5OnYy", "diffSide": "RIGHT", "path": "timelock-api/src/main/conjure/timelock-api.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNjoyODo1M1rOGYUBGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzowNToxN1rOGYVhiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE0Njk2OA==", "bodyText": "nit: the Lock Watch stuff never really had a non-conjurized (?) form, so it's probably fine to just name this IdentifiedVersion", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428146968", "createdAt": "2020-05-20T16:28:53Z", "author": {"login": "jeremyk-91"}, "path": "timelock-api/src/main/conjure/timelock-api.yml", "diffHunk": "@@ -36,12 +36,18 @@ types:\n   definitions:\n     default-package: com.palantir.atlasdb.timelock.api\n     objects:\n+      ConjureIdentifiedVersion:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3MTY1Ng==", "bodyText": "So problem is that that IdentifiedVersion is already defined in the lock-api-objects. So until we clean that up, I think it makes sense to keep this as ConjureIdentifiedVersion.", "url": "https://github.com/palantir/atlasdb/pull/4791#discussion_r428171656", "createdAt": "2020-05-20T17:05:17Z", "author": {"login": "jkozlowski"}, "path": "timelock-api/src/main/conjure/timelock-api.yml", "diffHunk": "@@ -36,12 +36,18 @@ types:\n   definitions:\n     default-package: com.palantir.atlasdb.timelock.api\n     objects:\n+      ConjureIdentifiedVersion:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE0Njk2OA=="}, "originalCommit": {"oid": "05e0a701d91721501b8d6b0c4badf70e4278bbc7"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2863, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}