{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NDMzMTAx", "number": 5077, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMDo0OTowOFrOEx2IgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzowMTozNFrOEydNRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzAyNTkyOnYy", "diffSide": "RIGHT", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/DbAtlasDbFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMDo0OTowOFrOHoKE0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMDo0OTowOFrOHoKE0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg3MDE2MQ==", "bodyText": "nit: inline?", "url": "https://github.com/palantir/atlasdb/pull/5077#discussion_r511870161", "createdAt": "2020-10-26T10:49:08Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/DbAtlasDbFactory.java", "diffHunk": "@@ -95,49 +91,26 @@ public ManagedTimestampService createManagedTimestampService(\n                 rawKvs.getClass());\n         ConnectionManagerAwareDbKvs dbkvs = (ConnectionManagerAwareDbKvs) rawKvs;\n \n-        return PersistentTimestampServiceImpl.create(createTimestampBoundStore(creationParameters, dbkvs));\n+        return PersistentTimestampServiceImpl.create(createTimestampBoundStore(tableReferenceOverride, dbkvs));\n     }\n \n     private static InDbTimestampBoundStore createTimestampBoundStore(\n-            Optional<DbTimestampCreationSetting> creationParameters, ConnectionManagerAwareDbKvs dbkvs) {\n-        return creationParameters\n-                .map(params -> DbTimestampCreationSettings.caseOf(params)\n-                        .multipleSeries((table, series) -> multiSeries(dbkvs, table, series))\n-                        .singleSeries(table -> singleSeries(dbkvs, table)))\n-                .orElseGet(() -> defaultTimestampBoundStore(dbkvs));\n-    }\n-\n-    private static InDbTimestampBoundStore singleSeries(\n-            ConnectionManagerAwareDbKvs dbkvs, Optional<TableReference> tableRef) {\n+            Optional<TableReference> tableRef, ConnectionManagerAwareDbKvs dbkvs) {\n         // Not using the table prefix here, as the tableRef should contain any necessary prefix.\n         return tableRef.map(reference -> InDbTimestampBoundStore.create(dbkvs.getConnectionManager(), reference))\n                 .orElseGet(() -> defaultTimestampBoundStore(dbkvs));\n     }\n \n-    private static InDbTimestampBoundStore multiSeries(\n-            ConnectionManagerAwareDbKvs dbkvs, TableReference tableRef, TimestampSeries series) {\n-        return InDbTimestampBoundStore.createForMultiSeries(dbkvs.getConnectionManager(), tableRef, series);\n-    }\n-\n     private static InDbTimestampBoundStore defaultTimestampBoundStore(ConnectionManagerAwareDbKvs dbkvs) {\n         return InDbTimestampBoundStore.create(\n                 dbkvs.getConnectionManager(), defaultTimestampTable(), defaultTablePrefix(dbkvs));\n     }\n \n     @Override\n     public TimestampStoreInvalidator createTimestampStoreInvalidator(\n-            KeyValueService rawKvs, Optional<DbTimestampCreationSetting> creationParameters) {\n+            KeyValueService rawKvs, Optional<TableReference> tableReference) {\n         ConnectionManagerAwareDbKvs dbkvs = (ConnectionManagerAwareDbKvs) rawKvs;\n-        return creationParameters\n-                .map(params -> DbTimestampCreationSettings.caseOf(params)\n-                        .singleSeries(table -> timestampStoreInvalidator(dbkvs, table))\n-                        .otherwise(() -> {\n-                            throw new SafeIllegalStateException(\n-                                    \"Invalidator must only be called by embedded DB timeLock that \"\n-                                            + \"does not support multi series timestamp store. This is unexpected, \"\n-                                            + \"please contact support.\");\n-                        }))\n-                .orElseGet(() -> timestampStoreInvalidator(dbkvs, Optional.empty()));\n+        return timestampStoreInvalidator(dbkvs, tableReference);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b130ba59220382da56c3410b02c107a9f2a2b83"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzAzOTA4OnYy", "diffSide": "RIGHT", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/DbAtlasDbFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMDo1MjozMlrOHoKMiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyODoyNFrOHp4BgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg3MjEzNg==", "bodyText": "Would it be useful to validation checks here i.e. tableReferenceOverride is not DB_TIMELOCK_TIMESTAMP_TABLE?", "url": "https://github.com/palantir/atlasdb/pull/5077#discussion_r511872136", "createdAt": "2020-10-26T10:52:32Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/DbAtlasDbFactory.java", "diffHunk": "@@ -84,7 +80,7 @@ public KeyValueService createRawKeyValueService(\n \n     @Override\n     public ManagedTimestampService createManagedTimestampService(\n-            KeyValueService rawKvs, Optional<DbTimestampCreationSetting> creationParameters, boolean initializeAsync) {\n+            KeyValueService rawKvs, Optional<TableReference> tableReferenceOverride, boolean initializeAsync) {\n         if (initializeAsync) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b130ba59220382da56c3410b02c107a9f2a2b83"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3MTU1Mg==", "bodyText": "Ah, that's a decent call. I think that makes sense", "url": "https://github.com/palantir/atlasdb/pull/5077#discussion_r513671552", "createdAt": "2020-10-28T18:28:24Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/DbAtlasDbFactory.java", "diffHunk": "@@ -84,7 +80,7 @@ public KeyValueService createRawKeyValueService(\n \n     @Override\n     public ManagedTimestampService createManagedTimestampService(\n-            KeyValueService rawKvs, Optional<DbTimestampCreationSetting> creationParameters, boolean initializeAsync) {\n+            KeyValueService rawKvs, Optional<TableReference> tableReferenceOverride, boolean initializeAsync) {\n         if (initializeAsync) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg3MjEzNg=="}, "originalCommit": {"oid": "2b130ba59220382da56c3410b02c107a9f2a2b83"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzQyNzg5OnYy", "diffSide": "LEFT", "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbTimestampStoreInvalidatorCreationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzowMTozNFrOHpG8hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyODowMVrOHp4Aqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg2NzQ2Mw==", "bodyText": "Why did we remove this test?", "url": "https://github.com/palantir/atlasdb/pull/5077#discussion_r512867463", "createdAt": "2020-10-27T17:01:34Z", "author": {"login": "gmaretic"}, "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbTimestampStoreInvalidatorCreationTest.java", "diffHunk": "@@ -75,35 +71,15 @@ public void setUp() {\n         invalidationRunner.createTableIfDoesNotExist();\n     }\n \n-    @Test\n-    public void doesNotInvalidateMultiSeriesTable() {\n-        assertThatThrownBy(() -> storeUpperLimitAndGetTimestampStoreInvalidator(Optional.of(\n-                        DbTimestampCreationSettings.multipleSeries(otherTable, TimestampSeries.of(\"test\")))))\n-                .isInstanceOf(SafeIllegalStateException.class)\n-                .hasMessageContaining(\"Invalidator must only be called by embedded DB timeLock that does not support \"\n-                        + \"multi series timestamp store. This is unexpected, please contact support.\");\n-    }\n-\n     @Test\n     public void canInvalidatorForSingleSeriesTable() {\n-        TimestampStoreInvalidator timestampStoreInvalidator = storeUpperLimitAndGetTimestampStoreInvalidator(\n-                Optional.of(DbTimestampCreationSettings.singleSeries(Optional.of(otherTable))));\n+        TimestampStoreInvalidator timestampStoreInvalidator =\n+                storeUpperLimitAndGetTimestampStoreInvalidator(Optional.of(otherTable));\n         assertThat(timestampStoreInvalidator.backupAndInvalidate()).isEqualTo(TIMESTAMP_1);\n \n         assertBoundNotReadableAfterBeingPoisoned(otherStore);\n     }\n \n-    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b130ba59220382da56c3410b02c107a9f2a2b83"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3MTMzOA==", "bodyText": "Since the changes you can't physically create a config where single series is not implied. So this test becomes equivalent to invalidatesDefaultTableForEmptyParameters() below it", "url": "https://github.com/palantir/atlasdb/pull/5077#discussion_r513671338", "createdAt": "2020-10-28T18:28:01Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-dbkvs-tests/src/test/java/com/palantir/atlasdb/keyvalue/dbkvs/DbTimestampStoreInvalidatorCreationTest.java", "diffHunk": "@@ -75,35 +71,15 @@ public void setUp() {\n         invalidationRunner.createTableIfDoesNotExist();\n     }\n \n-    @Test\n-    public void doesNotInvalidateMultiSeriesTable() {\n-        assertThatThrownBy(() -> storeUpperLimitAndGetTimestampStoreInvalidator(Optional.of(\n-                        DbTimestampCreationSettings.multipleSeries(otherTable, TimestampSeries.of(\"test\")))))\n-                .isInstanceOf(SafeIllegalStateException.class)\n-                .hasMessageContaining(\"Invalidator must only be called by embedded DB timeLock that does not support \"\n-                        + \"multi series timestamp store. This is unexpected, please contact support.\");\n-    }\n-\n     @Test\n     public void canInvalidatorForSingleSeriesTable() {\n-        TimestampStoreInvalidator timestampStoreInvalidator = storeUpperLimitAndGetTimestampStoreInvalidator(\n-                Optional.of(DbTimestampCreationSettings.singleSeries(Optional.of(otherTable))));\n+        TimestampStoreInvalidator timestampStoreInvalidator =\n+                storeUpperLimitAndGetTimestampStoreInvalidator(Optional.of(otherTable));\n         assertThat(timestampStoreInvalidator.backupAndInvalidate()).isEqualTo(TIMESTAMP_1);\n \n         assertBoundNotReadableAfterBeingPoisoned(otherStore);\n     }\n \n-    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg2NzQ2Mw=="}, "originalCommit": {"oid": "2b130ba59220382da56c3410b02c107a9f2a2b83"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2435, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}