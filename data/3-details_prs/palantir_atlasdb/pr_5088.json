{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMTc0OTA4", "number": 5088, "title": "[LE] Server Side Metrics Accumulator For Leadership Duration", "bodyText": "Goals (and why):\nCurrently, each client will send to timelock its view of how long the leader election took. These will initially be imprecise, but should stabilise pretty quickly as the shortest duration is the most precise estimate here. Also, for each client the leader IDs will be unique. The idea is to accumulate these durations in a histogram so that exactly one duration is reported per client once we have achieved confidence.\nImplementation Description (bullets):\nWhenever we get an update, we check if we have already reported the duration for this leader id pair, if yes we ignore. Otherwise, we keep the minimum seen so far for this pair and increase the update count for it. One we hit 10 updates we report the current minimum and remember this pair so it is never reported again.\nTesting (What was existing testing like?  What have you done to improve it?):\nAdded quite extensive unit tests, with some pretty aggressive multithreaded behaviour.\nConcerns (what feedback would you like?):\nI'm not concerned about correctness, but does this type of accumulation where we basically have a histogram using a sliding window over 5 minutes (should it be longer?) that accumulates each client's view of that leader election give useful information?\nWhere should we start reviewing?:\nTests?\nPriority (whenever / two weeks / yesterday):\nBefore Wednesday", "createdAt": "2020-10-27T23:24:21Z", "url": "https://github.com/palantir/atlasdb/pull/5088", "merged": true, "mergeCommit": {"oid": "c8c41d3770fd0bc07459d4e766d419664f19223a"}, "closed": true, "closedAt": "2020-11-03T17:42:32Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUp8N0AH2gAyNTExMTc0OTA4OmI3OTMyNjQ2ODJiYjA3NWE3YzVhNzc5ZDVkYzMzNGE0MzAyZmFkOTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY8lB1AH2gAyNTExMTc0OTA4OmIwMWQ2M2NlZDkwN2QzYTRhNzQ0NGRhMzM2YjFmNzExZmFiZTkyNTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b793264682bb075a7c5a779d5dc334a4302fad95", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b793264682bb075a7c5a779d5dc334a4302fad95", "committedDate": "2020-10-21T09:27:36Z", "message": "Transfer changes from other branches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee6bb046be4501552fe35f873a4fade024c877b8", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ee6bb046be4501552fe35f873a4fade024c877b8", "committedDate": "2020-10-21T14:12:34Z", "message": "Pull in the right things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "committedDate": "2020-10-21T15:12:01Z", "message": "Merge branch 'develop' into le/client-i"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "committedDate": "2020-10-21T15:25:12Z", "message": "rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1f7fa37374952504467f157c810a015c2a507d3", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/d1f7fa37374952504467f157c810a015c2a507d3", "committedDate": "2020-10-21T22:53:36Z", "message": "Implementation and some tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "committedDate": "2020-10-22T08:39:58Z", "message": "Should fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c33135c2cf946bed86c415df29eab145cf3fcf5", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/1c33135c2cf946bed86c415df29eab145cf3fcf5", "committedDate": "2020-10-22T09:37:12Z", "message": "Make tests great again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf458d26cce07fe45302d80a57a03d86bf06fd4c", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/cf458d26cce07fe45302d80a57a03d86bf06fd4c", "committedDate": "2020-10-22T14:52:48Z", "message": "Merge with develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "committedDate": "2020-10-22T16:09:08Z", "message": "Bleh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edb7750726df1240901dc1bc41fb9ce7aaf967c1", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/edb7750726df1240901dc1bc41fb9ce7aaf967c1", "committedDate": "2020-10-23T09:28:16Z", "message": "Pull out only necessary files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a93f810c495937bdee87ac041fb00c6fe09bba50", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a93f810c495937bdee87ac041fb00c6fe09bba50", "committedDate": "2020-10-23T09:35:22Z", "message": "address aggressive autoformat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a75c069358bbef81d993781a8238a9829fcddad", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/4a75c069358bbef81d993781a8238a9829fcddad", "committedDate": "2020-10-23T09:39:07Z", "message": "current value metric"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/133bfa79b08a664ddabf141187edbaa8066ccb3c", "committedDate": "2020-10-23T09:51:07Z", "message": "Cleanup, more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c19da98f9fef5e3b8da5441f0b262b768a32e97", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0c19da98f9fef5e3b8da5441f0b262b768a32e97", "committedDate": "2020-10-23T09:59:50Z", "message": "add testing to LERTST"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5f6339842ff2cff883413a576c51676803474ec", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a5f6339842ff2cff883413a576c51676803474ec", "committedDate": "2020-10-23T12:58:04Z", "message": "Merge branch 'le/client-ii' into le/server-ia\n\n# Conflicts:\n#\tlock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java\n#\tlock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddf2f72859208dc58405c3192d447bb6bf87f3e4", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ddf2f72859208dc58405c3192d447bb6bf87f3e4", "committedDate": "2020-10-23T13:10:07Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "debe1230b0cf305c036e6ecfea76e42e283b4939", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/debe1230b0cf305c036e6ecfea76e42e283b4939", "committedDate": "2020-10-26T13:59:52Z", "message": "Merge conflicts, modify duration estimate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a587b993b87e7378825d961ef1e2718247c7ef0", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/7a587b993b87e7378825d961ef1e2718247c7ef0", "committedDate": "2020-10-26T17:45:24Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "984f58e38d5499715907393574e1cc1c2a9ff004", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/984f58e38d5499715907393574e1cc1c2a9ff004", "committedDate": "2020-10-26T23:29:11Z", "message": "Working implementation with tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfae539a07399fbd9ff5ccd9abb23facbc00126e", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/dfae539a07399fbd9ff5ccd9abb23facbc00126e", "committedDate": "2020-10-27T23:21:51Z", "message": "Wire, fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d57b2093e574a3f0a14820f4864c14b1fca6956", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/3d57b2093e574a3f0a14820f4864c14b1fca6956", "committedDate": "2020-11-02T15:24:37Z", "message": "Merge with develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae11a448e24690d135fcca45e706864e0cd27d0e", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/ae11a448e24690d135fcca45e706864e0cd27d0e", "committedDate": "2020-11-02T15:51:55Z", "message": "WAT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1becc89efa3706116afba5e787462308a48d90b", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/d1becc89efa3706116afba5e787462308a48d90b", "committedDate": "2020-11-02T16:27:38Z", "message": "Some cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46df1f5a2bd4e1372914cd634554cef3f71efc34", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/46df1f5a2bd4e1372914cd634554cef3f71efc34", "committedDate": "2020-11-02T17:12:30Z", "message": "Bleh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/a0197b482cfbfd3c67221c61f1166b0b58279047", "committedDate": "2020-11-03T10:05:15Z", "message": "Merge branch 'develop' into le/duration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMzQ3OTE0", "url": "https://github.com/palantir/atlasdb/pull/5088#pullrequestreview-522347914", "createdAt": "2020-11-03T10:11:06Z", "commit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDoxMTowN1rOHsn6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMDozNDoxM1rOHsox4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1MzIzOA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID old, UUID next) {\n          \n          \n            \n                private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID oldLeader, UUID newLeader) {", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516553238", "createdAt": "2020-11-03T10:11:07Z", "author": {"login": "Jolyon-S"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -352,10 +354,13 @@ public void statisticsCausesMetricRegistryToBeReset() {\n         verifyNoMoreInteractions(mockedTimer);\n     }\n \n-    private void assertExpectedDuration(Instant instant, Instant instant2) {\n-        Optional<Duration> estimatedDuration = timelockService.calculateLastLeaderElectionDuration();\n-        assertThat(estimatedDuration).isPresent();\n-        assertThat(estimatedDuration.get()).isEqualTo(Duration.between(instant, instant2));\n+    private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID old, UUID next) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1NDk4Nw==", "bodyText": "nit: can we extract a constant for this number? Possibly above too although for some reason I don't mind as much for the reservoir.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516554987", "createdAt": "2020-11-03T10:13:44Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionMetricAggregator.java", "diffHunk": "@@ -16,39 +16,41 @@\n \n package com.palantir.atlasdb.timelock.adjudicate;\n \n-import com.palantir.atlasdb.util.CurrentValueMetric;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n import com.palantir.atlasdb.util.MetricsManager;\n import com.palantir.atlasdb.util.SlidingWindowWeightedMeanGauge;\n-import com.palantir.conjure.java.lib.SafeLong;\n import com.palantir.timelock.feedback.LeaderElectionStatistics;\n+import java.util.concurrent.TimeUnit;\n \n public final class LeaderElectionMetricAggregator {\n     private final SlidingWindowWeightedMeanGauge weightedGaugeP99;\n     private final SlidingWindowWeightedMeanGauge weightedGaugeP95;\n     private final SlidingWindowWeightedMeanGauge weightedGaugeMean;\n-    private final CurrentValueMetric<Long> leaderElectionEstimate;\n+    private final LeaderElectionDurationAccumulator leaderElectionDurationAccumulator;\n \n     public LeaderElectionMetricAggregator(MetricsManager metricsManager) {\n         weightedGaugeP99 = SlidingWindowWeightedMeanGauge.create();\n         weightedGaugeP95 = SlidingWindowWeightedMeanGauge.create();\n         weightedGaugeMean = SlidingWindowWeightedMeanGauge.create();\n-        leaderElectionEstimate = new CurrentValueMetric<>();\n         metricsManager.registerMetric(\n                 LeaderElectionMetricAggregator.class, \"leaderElectionImpactMean\", weightedGaugeMean);\n         metricsManager.registerMetric(\n                 LeaderElectionMetricAggregator.class, \"leaderElectionImpactP95\", weightedGaugeP95);\n         metricsManager.registerMetric(\n                 LeaderElectionMetricAggregator.class, \"leaderElectionImpactP99\", weightedGaugeP99);\n-        metricsManager.registerMetric(\n-                LeaderElectionMetricAggregator.class, \"leaderElectionEstimate\", leaderElectionEstimate);\n+        Histogram leaderElectionHistogram = metricsManager.registerOrGetHistogram(\n+                LeaderElectionMetricAggregator.class,\n+                \"leaderElectionDurationEstimate\",\n+                () -> new Histogram(new SlidingTimeWindowArrayReservoir(5, TimeUnit.MINUTES)));\n+        leaderElectionDurationAccumulator = new LeaderElectionDurationAccumulator(leaderElectionHistogram::update, 10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1NjI5MA==", "bodyText": "nit: rename to something informative, like metricsConsumer or updateConsumer etc.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516556290", "createdAt": "2020-11-03T10:15:46Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MDQzMQ==", "bodyText": "I'm not a fan of using of here, given that they have the same type - this is one of the places where I would strongly prefer a builder despite there being only two params.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516560431", "createdAt": "2020-11-03T10:22:41Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MjY3Mw==", "bodyText": "I think this is cleaner (with proper indentation, of course)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (alreadyReportedLeaderElections.contains(leadersContext)) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n                    currentlySoaking.compute(\n          \n          \n            \n                            leadersContext,\n          \n          \n            \n                            (context, previous) -> increaseConfidence(\n          \n          \n            \n                                    context, previous, duration.getDuration().longValue()));\n          \n          \n            \n                    if (!alreadyReportedLeaderElections.contains(leadersContext)) {\n          \n          \n            \n                               currentlySoaking.compute(\n          \n          \n            \n                                        leadersContext,\n          \n          \n            \n                                       (context, previous) -> increaseConfidence(\n          \n          \n            \n                                        context, previous, duration.getDuration().longValue()));\n          \n          \n            \n                    }", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516562673", "createdAt": "2020-11-03T10:26:18Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MzI0NA==", "bodyText": "nit: can you add a newline between these if statements? they feel very crowded", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516563244", "createdAt": "2020-11-03T10:27:16Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDA5Nw==", "bodyText": "nit: would it be cleaner to add a method on SoakingDuration where you just pass a duration and it creates it with 1 set?", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516564097", "createdAt": "2020-11-03T10:28:46Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDIwMw==", "bodyText": "nit: inline?", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516564203", "createdAt": "2020-11-03T10:28:57Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDg1Mw==", "bodyText": "I feel like you should increase the count and duration together", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516564853", "createdAt": "2020-11-03T10:29:49Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzM2MA==", "bodyText": "I think it would be best if the range of values for each pair (other than the repeated ones) should be non-intersecting - i.e. for leader (2,3) you should set the min to say 200 to make 100% certain that you aren't getting a spurious result.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516567360", "createdAt": "2020-11-03T10:33:58Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzUyMw==", "bodyText": "The comment above is especially important here, IMO.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516567523", "createdAt": "2020-11-03T10:34:13Z", "author": {"login": "Jolyon-S"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 7);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(15L);\n+        verify(mockConsumer).accept(7L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNDE2NDA0", "url": "https://github.com/palantir/atlasdb/pull/5088#pullrequestreview-522416404", "createdAt": "2020-11-03T11:44:16Z", "commit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMTo0NDoxNlrOHsrKrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTowODozNFrOHszKvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYwNjYzOQ==", "bodyText": "nit: Maybe a style preference. I'd prefer just getting it and then asserting on the present value.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516606639", "createdAt": "2020-11-03T11:44:16Z", "author": {"login": "jeremyk-91"}, "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -352,10 +354,13 @@ public void statisticsCausesMetricRegistryToBeReset() {\n         verifyNoMoreInteractions(mockedTimer);\n     }\n \n-    private void assertExpectedDuration(Instant instant, Instant instant2) {\n-        Optional<Duration> estimatedDuration = timelockService.calculateLastLeaderElectionDuration();\n-        assertThat(estimatedDuration).isPresent();\n-        assertThat(estimatedDuration.get()).isEqualTo(Duration.between(instant, instant2));\n+    private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID old, UUID next) {\n+        Optional<LeaderElectionDuration> estimate = timelockService.calculateLastLeaderElectionDuration();\n+        assertThat(estimate).isPresent();\n+        assertThat(estimate.get().getDuration())\n+                .isEqualTo(SafeLong.of(Duration.between(instant, instant2).toNanos()));\n+        assertThat(estimate.get().getOldLeader()).isEqualTo(old);\n+        assertThat(estimate.get().getNewLeader()).isEqualTo(next);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyNTQzNw==", "bodyText": "Can we either specify the units or have this be the Java duration type? I realise this is a change from the original review, but find this a bit awkward to read", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516725437", "createdAt": "2020-11-03T14:51:53Z", "author": {"login": "jeremyk-91"}, "path": "timelock-api/src/main/conjure/timelock-feedback.yml", "diffHunk": "@@ -17,13 +17,18 @@ types:\n           p99: double\n           oneMin: double\n           errorRate: optional<double>\n+      LeaderElectionDuration:\n+        fields:\n+          oldLeader: uuid\n+          newLeader: uuid\n+          duration: safelong", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyODU0NQ==", "bodyText": "Hmm... this is fine, but is it that bad to have this be immutable and just have compute do an allocation? If I'm parsing this correctly it happens only updatesToAchieveConfidence times per election", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516728545", "createdAt": "2020-11-03T14:56:02Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);\n+        return accumulatedSoakingDuration;\n+    }\n+\n+    @Value.Immutable\n+    interface LeadersContext {\n+        @Parameter\n+        UUID previous();\n+\n+        @Parameter\n+        UUID next();\n+\n+        static LeadersContext of(UUID previous, UUID next) {\n+            return ImmutableLeadersContext.of(previous, next);\n+        }\n+    }\n+\n+    @Value.Modifiable\n+    interface SoakingDuration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyOTE2Mw==", "bodyText": "sampleMinimum or something like that?", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516729163", "createdAt": "2020-11-03T14:56:51Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);\n+        return accumulatedSoakingDuration;\n+    }\n+\n+    @Value.Immutable\n+    interface LeadersContext {\n+        @Parameter\n+        UUID previous();\n+\n+        @Parameter\n+        UUID next();\n+\n+        static LeadersContext of(UUID previous, UUID next) {\n+            return ImmutableLeadersContext.of(previous, next);\n+        }\n+    }\n+\n+    @Value.Modifiable\n+    interface SoakingDuration {\n+        @Parameter\n+        long value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyOTMyOA==", "bodyText": "See later comment: do we really have to use modifiables?", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516729328", "createdAt": "2020-11-03T14:57:05Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDg1Mw=="}, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMTI2Nw==", "bodyText": "It would be clearer, yes. I think it is fine as written under the assumption each election is only done once: only L1->L3 could have generated the 7, which means only L1 -> L2 could have generated the 10 (L1 -> L3 already used) and so on.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516731267", "createdAt": "2020-11-03T14:59:41Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzM2MA=="}, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMjE2NQ==", "bodyText": "I think it's still technically okay (assuming each election generates one thing) because the 1L could only have come from the first call and so on, though it is probably clearer in terms of readability to have non-overlapping ranges.", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516732165", "createdAt": "2020-11-03T15:00:53Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 7);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(15L);\n+        verify(mockConsumer).accept(7L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzUyMw=="}, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMzc0MA==", "bodyText": "I'm possibly confused: how do we guarantee zero is processed in the first five\nAh, this test has an accumulator with 5000. What you have is fine, don't really like that it relies on 5000 being 50 * 100 (maybe introduce some local variables so that it's obvious?) / if you change line 129 to 60 the test breaks, so maybe we could change that slightly", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516733740", "createdAt": "2020-11-03T15:03:07Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 7);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(15L);\n+        verify(mockConsumer).accept(7L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 300, 17));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 300, 76));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(17L);\n+        verify(mockConsumer).accept(76L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingWithPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_2, LEADER_3, 300, 17));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_3, 300, 76));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(17L);\n+        verify(mockConsumer).accept(76L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testManyUpdatesForSameLeaders() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(50);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5_000);\n+        List<Integer> durationBuckets =\n+                IntStream.range(0, 100).map(x -> x * 100).boxed().collect(Collectors.toList());\n+        Collections.shuffle(durationBuckets);\n+\n+        durationBuckets.forEach(duration ->\n+                executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_2, 50, duration)));\n+\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNzcyNQ==", "bodyText": "Looks like this grows unbounded. Is this a problem / should we consider using some kind of cache with an ExpiryAfterWrite/Access?", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516737725", "createdAt": "2020-11-03T15:08:34Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0160de64915fe31d135bbdaeeed7fe747b794e70", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/0160de64915fe31d135bbdaeeed7fe747b794e70", "committedDate": "2020-11-03T16:20:17Z", "message": "action comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08c65ac46226324bf4fa2b708c428ecd8fea5e28", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/08c65ac46226324bf4fa2b708c428ecd8fea5e28", "committedDate": "2020-11-03T16:22:55Z", "message": "resolve merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca5fa29189dde7664593bd4578da060bf71aa38f", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/ca5fa29189dde7664593bd4578da060bf71aa38f", "committedDate": "2020-11-03T16:23:44Z", "message": "revert spooky diff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjc0MDEz", "url": "https://github.com/palantir/atlasdb/pull/5088#pullrequestreview-522674013", "createdAt": "2020-11-03T16:31:06Z", "commit": {"oid": "ca5fa29189dde7664593bd4578da060bf71aa38f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozMTowNlrOHs25vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozMTowNlrOHs25vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5ODkxMA==", "bodyText": "nit: I realise it's the same as the original test, though really the second multiplicand seems like it shouldn't be tied to numBuckets but requestsPerBucket (and I guess if you want a bit of additional space that's fine).", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516798910", "createdAt": "2020-11-03T16:31:06Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 25);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 37);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(25L);\n+        verify(mockConsumer).accept(37L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 300, 1017));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 300, 2076));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(1017L);\n+        verify(mockConsumer).accept(2076L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingWithPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_2, LEADER_3, 300, 1017));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_3, 300, 2076));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(1017L);\n+        verify(mockConsumer).accept(2076L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testManyUpdatesForSameLeaders() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(50);\n+        int numBuckets = 100;\n+        int requestsPerBucket = 50;\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, numBuckets * requestsPerBucket);\n+        List<Integer> durationBuckets =\n+                IntStream.range(0, numBuckets).map(x -> x * numBuckets).boxed().collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5fa29189dde7664593bd4578da060bf71aa38f"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b01d63ced907d3a4a7444da336b1f711fabe9256", "author": {"user": {"login": "Jolyon-S", "name": "Jolyon"}}, "url": "https://github.com/palantir/atlasdb/commit/b01d63ced907d3a4a7444da336b1f711fabe9256", "committedDate": "2020-11-03T17:26:10Z", "message": "fix test bug"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2448, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}