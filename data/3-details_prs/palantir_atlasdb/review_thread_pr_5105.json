{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2OTMyODkw", "number": 5105, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxMzowNFrOE274YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDowNDoxN1rOE3JquA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDM5NjQ5OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxMzowNFrOHv_38g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMTo0NDozNFrOHwIfXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MTYzNA==", "bodyText": "do we want a max size on this cache to limit memory footprint?", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520091634", "createdAt": "2020-11-09T20:13:04Z", "author": {"login": "schlosna"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjc5OA==", "bodyText": "I don't think so, considering the default is to pre-warm the cache with all tables. The intended use case is that there won't be very many tables. If we had a max size here it seems like you could get very bad sweep perf once you have more than that amount of tables.", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520232798", "createdAt": "2020-11-10T01:44:34Z", "author": {"login": "berler"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MTYzNA=="}, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDQwMzE1OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxNDo0OVrOHv_72g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMTo0NzowM1rOHwIiYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MjYzNA==", "bodyText": "How much value is there in having a separate LIMITED mode between FULL and NONE? If we set to NONE and just let the cache warm up on its own based on requests, what behavior would we see? How did we pick 50? Are the first 50 tables actually the ones we want cached?", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520092634", "createdAt": "2020-11-09T20:14:49Z", "author": {"login": "schlosna"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -84,9 +94,18 @@ public static SweepStrategyManager completelyConservative() {\n         return tableRef -> SweepStrategy.from(TableMetadataPersistence.SweepStrategy.CONSERVATIVE);\n     }\n \n-    private static Map<TableReference, SweepStrategy> getSweepStrategies(KeyValueService kvs) {\n-        return ImmutableMap.copyOf(\n-                Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy));\n+    private static Map<TableReference, SweepStrategy> getSweepStrategiesForWarmingCache(\n+            KeyValueService kvs, CacheWarming cacheWarming) {\n+        switch (cacheWarming) {\n+            case FULL:\n+                return Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy);\n+            case LIMITED:\n+                return Maps.transformValues(\n+                        kvs.getLimitedMetadataForTables(50), SweepStrategyManagers::getSweepStrategy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMzU2OA==", "bodyText": "50 was recommended I believe by @jeremyk-91 when this was discussed a while ago internally", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520233568", "createdAt": "2020-11-10T01:47:03Z", "author": {"login": "berler"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -84,9 +94,18 @@ public static SweepStrategyManager completelyConservative() {\n         return tableRef -> SweepStrategy.from(TableMetadataPersistence.SweepStrategy.CONSERVATIVE);\n     }\n \n-    private static Map<TableReference, SweepStrategy> getSweepStrategies(KeyValueService kvs) {\n-        return ImmutableMap.copyOf(\n-                Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy));\n+    private static Map<TableReference, SweepStrategy> getSweepStrategiesForWarmingCache(\n+            KeyValueService kvs, CacheWarming cacheWarming) {\n+        switch (cacheWarming) {\n+            case FULL:\n+                return Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy);\n+            case LIMITED:\n+                return Maps.transformValues(\n+                        kvs.getLimitedMetadataForTables(50), SweepStrategyManagers::getSweepStrategy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MjYzNA=="}, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDQxNTU4OnYy", "diffSide": "RIGHT", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxODoyM1rOHwADWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0MzozNFrOHwUIcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA==", "bodyText": "Should this be a paged result? What is the epoch for concurrent consistency (e.g. tables created while this is executing)? What happens if one specifies various values for maxResults, say 0, -1, Integer.MAX_VALUE? I'm a little skeptical we even need these methods, but wondering if we actually do should instead consider something like Stream<TableReference> getTableNames() and let consumers filter/limit/transform/collect as desired.", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520094554", "createdAt": "2020-11-09T20:18:23Z", "author": {"login": "schlosna"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -524,6 +524,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Set<TableReference> getAllTableNames();\n \n+    /**\n+     * Returns a list of up to {@code maxResults} tables stored in this key value service.\n+     *\n+     * This should be preferred over {@link #getAllTableNames()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Iterable<TableReference> getLimitedTableNames(int maxResults);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTY1Mg==", "bodyText": "I was thinking about that, but it is significantly more complicated to implement correctly. Additionally the caller would need to call close() on the Stream, which is not something that is usually done in general (calling .collect() etc doesn't do it), so it would be really easy for people to leak resources if we made this a Stream.\nCloseableIterator or something similar might make more sense, but it would also be more complicated to implement.\nIn general I think we should be discouraging anything that would try to enumerate all tables in the system. Clients can only interact with tables if they know about some Schema, and clients should be using the Schema to know what tables it needs to care about.", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520171652", "createdAt": "2020-11-09T22:50:47Z", "author": {"login": "berler"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -524,6 +524,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Set<TableReference> getAllTableNames();\n \n+    /**\n+     * Returns a list of up to {@code maxResults} tables stored in this key value service.\n+     *\n+     * This should be preferred over {@link #getAllTableNames()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Iterable<TableReference> getLimitedTableNames(int maxResults);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA=="}, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMzUzNg==", "bodyText": "The guarantees are exactly the same as with getAllTableNames, so I'm OK with that", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520423536", "createdAt": "2020-11-10T09:43:34Z", "author": {"login": "gmaretic"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -524,6 +524,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Set<TableReference> getAllTableNames();\n \n+    /**\n+     * Returns a list of up to {@code maxResults} tables stored in this key value service.\n+     *\n+     * This should be preferred over {@link #getAllTableNames()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Iterable<TableReference> getLimitedTableNames(int maxResults);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA=="}, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDQxNjM0OnYy", "diffSide": "RIGHT", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxODozOVrOHwAD0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxODozOVrOHwAD0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDY3Mg==", "bodyText": "same comment as above", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520094672", "createdAt": "2020-11-09T20:18:39Z", "author": {"login": "schlosna"}, "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -543,6 +551,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Map<TableReference, byte[]> getMetadataForTables();\n \n+    /**\n+     * Gets the metadata for up to {@code maxResults} tables.\n+     *\n+     * This should be preferred over {@link #getMetadataForTables()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDQyMDI2OnYy", "diffSide": "RIGHT", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxOTo0MVrOHwAGJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDoxOTo0MVrOHwAGJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NTI2OQ==", "bodyText": "Similar to above, should these lines (same as in getAllTableNames())  be pulled out to a separate method that returns Stream<TableReference>?", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520095269", "createdAt": "2020-11-09T20:19:41Z", "author": {"login": "schlosna"}, "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -1481,6 +1481,16 @@ public void createTables(final Map<TableReference, byte[]> tablesToMetadata) {\n                 .collect(Collectors.toSet());\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        // Note: This is not optimal since getTableReferencesWithoutFiltering() loads *all* names, even though it\n+        // returns a Stream. Getting a partial list of table names might not be possible with cassandra thrift.\n+        return cassandraTables\n+                .getTableReferencesWithoutFiltering()\n+                .filter(tr -> !HiddenTables.isHidden(tr))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjYwNjM5OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo1MzowOVrOHwUh5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjozODo0MFrOHwyYrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMDA1Mw==", "bodyText": "This comment seems to have been wron all along, has nothing to do with async initialisation?", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520430053", "createdAt": "2020-11-10T09:53:09Z", "author": {"login": "gmaretic"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)\n                             .build(tableRef -> getSweepStrategy(kvs.getMetadataForTable(tableRef)));\n \n-                    // On async initialization, add all tables to optimize for cases when using mostly non-dynamic\n-                    // tables.\n-                    cache.putAll(getSweepStrategies(kvs));\n+                    // On async initialization, add a possibly limited number of tables to the cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxOTIxNQ==", "bodyText": "things do init async -- this happens the first time it attempts to be used because this is inside a RecomputingSupplier", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520919215", "createdAt": "2020-11-10T22:38:40Z", "author": {"login": "berler"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)\n                             .build(tableRef -> getSweepStrategy(kvs.getMetadataForTable(tableRef)));\n \n-                    // On async initialization, add all tables to optimize for cases when using mostly non-dynamic\n-                    // tables.\n-                    cache.putAll(getSweepStrategies(kvs));\n+                    // On async initialization, add a possibly limited number of tables to the cache.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMDA1Mw=="}, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjY0MTczOnYy", "diffSide": "RIGHT", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDowMTowM1rOHwU36A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNzo1ODo1NVrOHwou3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTY4OA==", "bodyText": "Any reason why not to slab on a \"LIMIT maxResults\"?", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520435688", "createdAt": "2020-11-10T10:01:03Z", "author": {"login": "gmaretic"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1137,6 +1138,26 @@ public void createTable(TableReference tableRef, byte[] tableMetadata) {\n         });\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyList();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name FROM \" + config.metadataTable().getQualifiedName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTA1Mw==", "bodyText": "The limit syntax is completely different in postgres and oracle. We cannot just add a limit clause here unless we do something completely different for postgres and oracle.\nFrom a perf standpoint there shouldn't be very much difference between using a limit and only iterating through the ResultSet part way unless the configured prefetch is huge -- the AgnosticIterator impl in AgnosticLightResultSetImpl always sets the initial prefetch to 10, and doubles it (up to a max) after each batch is fetched.", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520761053", "createdAt": "2020-11-10T17:58:55Z", "author": {"login": "berler"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1137,6 +1138,26 @@ public void createTable(TableReference tableRef, byte[] tableMetadata) {\n         });\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyList();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name FROM \" + config.metadataTable().getQualifiedName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTY4OA=="}, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjY0NTE1OnYy", "diffSide": "RIGHT", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDowMTo1MlrOHwU6Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDowMTo1MlrOHwU6Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNjI1OQ==", "bodyText": "Same as above", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520436259", "createdAt": "2020-11-10T10:01:52Z", "author": {"login": "gmaretic"}, "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1163,6 +1184,26 @@ public void putMetadataForTable(TableReference tableRef, byte[] metadata) {\n         });\n     }\n \n+    @Override\n+    public Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyMap();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name, value FROM \" + config.metadataTable().getQualifiedName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjY1NTI4OnYy", "diffSide": "RIGHT", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDowNDoxN1rOHwVAcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDowNDoxN1rOHwVAcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNzg3Mg==", "bodyText": "Pretty clever \ud83d\udc4d", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520437872", "createdAt": "2020-11-10T10:04:17Z", "author": {"login": "gmaretic"}, "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java", "diffHunk": "@@ -195,6 +195,23 @@ public void dropTables(Set<TableReference> tableRefs) {\n         return ret;\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        Set<TableReference> ret = new HashSet<>();\n+        for (KeyValueService delegate : delegates) {\n+            // Note that this looks suboptimal, but there could be some overlap to the tables in each delegate.\n+            // If there is some overlap, we should at least reach maxResults (or the true total) by requesting\n+            // maxResults from each underlying KVS.\n+            for (TableReference tableRef : delegate.getLimitedTableNames(maxResults)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2492, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}