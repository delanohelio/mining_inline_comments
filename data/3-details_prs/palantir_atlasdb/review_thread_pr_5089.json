{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExNDY2Mjc2", "number": 5089, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0MToyNlrOEy2IUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MzoyNVrOE0WAIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzUxMTIyOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0MToyNlrOHptiAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0MToyNlrOHptiAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTY0OA==", "bodyText": "nit: final class?", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513499648", "createdAt": "2020-10-28T14:41:26Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzUxMjc5OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0MTo0NVrOHptjBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0MTo0NVrOHptjBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTkwOA==", "bodyText": "nit: test name is hard to parse", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513499908", "createdAt": "2020-10-28T14:41:45Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzU0NzQwOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0ODozMlrOHpt5bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0ODozMlrOHpt5bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNTY0NQ==", "bodyText": "prefer Multimap", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513505645", "createdAt": "2020-10-28T14:48:32Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzU1MTMzOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0OToxNVrOHpt77A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1MzoxOVrOHpuJfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNjI4NA==", "bodyText": "minor nit: assertViolationsDetected", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513506284", "createdAt": "2020-10-28T14:49:15Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwOTc1OQ==", "bodyText": "also, split into two methods: some violations (and maybe can be specific), or no violation.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513509759", "createdAt": "2020-10-28T14:53:19Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNjI4NA=="}, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzU5NDExOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1NzoxMlrOHpuXFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1NzoxMlrOHpuXFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxMzIzNw==", "bodyText": "chatted offline - I personally don't like this structure of using abstract classes; would prefer if this was a final class that you call methods on directly.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513513237", "createdAt": "2020-10-28T14:57:12Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzYwMTgyOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1ODo0N1rOHpucJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1ODo0N1rOHpucJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNDUzNA==", "bodyText": "please remove this", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513514534", "createdAt": "2020-10-28T14:58:47Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzYwMzk4OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1OToxMVrOHpudlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1OToxMVrOHpudlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNDkwMQ==", "bodyText": "IntelliJ is your friend; these probably? don't have to be protected", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513514901", "createdAt": "2020-10-28T14:59:11Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa636be9a4844829b9d5aaad25c61428d1c701d6"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQzOTE1OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyODo0OVrOHrO_Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzoyODo0OVrOHrO_Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5NjM1OA==", "bodyText": "nit: can we call this TimelockCorruptionTestConstants or similar? I know it is in the test project, but I'm wary of such a generic name here", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515096358", "createdAt": "2020-10-30T13:28:49Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock;\n+\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+\n+public class Constants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ1MzkwOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMjoyNVrOHrPIMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMjoyNVrOHrPIMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5ODY3NQ==", "bodyText": "the javadoc is a note, of sorts. I'd recommend refactoring this line as follows:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n          \n          \n            \n             * All tests only induce and detect ACCEPTED_VALUE_GREATER_THAN_LEARNED corruption.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515098675", "createdAt": "2020-10-30T13:32:25Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ1NjI1OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMzowN1rOHrPJwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozMzowN1rOHrPJwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTA3NA==", "bodyText": "nit: no need to hyphenate here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n          \n          \n            \n                    // We write logs in range [1, 500]. The first range of sequences for corruption detection = [0, 499] since", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515099074", "createdAt": "2020-10-30T13:33:07Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ3NDEyOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNjozN1rOHrPVFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNjozN1rOHrPVFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMTk3Mg==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n          \n          \n            \n                private static NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515101972", "createdAt": "2020-10-30T13:36:37Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ3NTUyOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNjo1NlrOHrPV5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNjo1NlrOHrPV5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjE4Mw==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n          \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102183", "createdAt": "2020-10-30T13:36:56Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ3NjMxOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNzowOVrOHrPWWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNzowOVrOHrPWWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjI5Nw==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n          \n          \n            \n                private void corruptSeries(int namespaceAndUseCaseIndex) {", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102297", "createdAt": "2020-10-30T13:37:09Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ3NjkzOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNzoxN1rOHrPWvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzozNzoxN1rOHrPWvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjM5OQ==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n          \n          \n            \n                private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102399", "createdAt": "2020-10-30T13:37:17Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzQ5MzIxOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MToxNFrOHrPhEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0Mjo0MVrOHrPkfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA0Mw==", "bodyText": "nit: remove empty line\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515105043", "createdAt": "2020-10-30T13:41:14Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTkxOA==", "bodyText": "With this method, either 1 or 0 detected violations are passed, which I'm not a fan of at all. I'd prefer if you separate out to two methods: one that takes a single violation and confirms it is there, and a second where the logic is essentially:\nassertThat(getViolationsToNamespaceToUseCaseMultimap()).isEmpty();", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515105918", "createdAt": "2020-10-30T13:42:41Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA0Mw=="}, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUwMDQyOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MzoxNlrOHrPlvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0MzoxNlrOHrPlvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjIzOQ==", "bodyText": "you can inline this variable - the method call is actually shorter than the variable!", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515106239", "createdAt": "2020-10-30T13:43:16Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUwNjA3OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NDo0MVrOHrPpQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMToxOToyMlrOHsAUAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzEzOA==", "bodyText": "IntelliJ tells me that there are a number of methods that can be private - please make them private, then re-order so that they are after the non-private ones.\nAlso, there are definitely some methods that can be static - for example writeLogsOnServer. Please make static the methods that can be.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515107138", "createdAt": "2020-10-30T13:44:41Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNDUxNQ==", "bodyText": "Made the methods package-private.\nDone.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515904515", "createdAt": "2020-11-02T11:19:22Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzEzOA=="}, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUwNzE1OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NDo1OFrOHrPp5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NDo1OFrOHrPp5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzMwMw==", "bodyText": "We discussed - remove stream()\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n          \n          \n            \n                    servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515107303", "createdAt": "2020-10-30T13:44:58Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUxMjEwOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NjowM1rOHrPs6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NjowM1rOHrPs6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODA3NQ==", "bodyText": "Interesting - if we get an exception on startup, we don't want to do anything? I'd have thought we'd do:\nthrow new RuntimeException(throwable, \"failed on startup\");", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515108075", "createdAt": "2020-10-30T13:46:03Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUxNjY5OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NzowOFrOHrPvug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo1NTo0NlrOHrS08w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODc5NA==", "bodyText": "Same as elsewhere: this and other methods don't need to be public.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515108794", "createdAt": "2020-10-30T13:47:08Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1OTI4Mw==", "bodyText": "also: StatLog?", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515159283", "createdAt": "2020-10-30T14:55:46Z", "author": {"login": "jeremyk-91"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODc5NA=="}, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzUxODI1OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0NzozOVrOHrPwzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMzo0Nzo0OFrOHrPxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTA2OQ==", "bodyText": "nit: static?", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515109069", "createdAt": "2020-10-30T13:47:39Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    public List<StateLogComponents> getDefaultServerList() {\n+        return ImmutableList.<StateLogComponents>builder()\n+                .add(defaultLocalServer)\n+                .addAll(defaultRemoteServerList)\n+                .build();\n+    }\n+\n+    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n+        return paxosLogHistoryProvider;\n+    }\n+\n+    public StateLogComponents getDefaultLocalServer() {\n+        return defaultLocalServer;\n+    }\n+\n+    public List<StateLogComponents> getDefaultRemoteServerList() {\n+        return defaultRemoteServerList;\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTE3Nw==", "bodyText": "there are others in this class too", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515109177", "createdAt": "2020-10-30T13:47:48Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    public List<StateLogComponents> getDefaultServerList() {\n+        return ImmutableList.<StateLogComponents>builder()\n+                .add(defaultLocalServer)\n+                .addAll(defaultRemoteServerList)\n+                .build();\n+    }\n+\n+    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n+        return paxosLogHistoryProvider;\n+    }\n+\n+    public StateLogComponents getDefaultLocalServer() {\n+        return defaultLocalServer;\n+    }\n+\n+    public List<StateLogComponents> getDefaultRemoteServerList() {\n+        return defaultRemoteServerList;\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTA2OQ=="}, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzgyODQwOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo1NTo1MlrOHrS1PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo1NTo1MlrOHrS1PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1OTM1Nw==", "bodyText": "name - add 'inclusive'", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515159357", "createdAt": "2020-10-30T14:55:52Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzEyMDM5OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMToxMzo1MFrOHsAJEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMToxMzo1MFrOHsAJEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwMTcxNQ==", "bodyText": "It is only used in one place but I think this signature makes sense.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515901715", "createdAt": "2020-11-02T11:13:50Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    void writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c98a19528671d72189cb240ffd3fb9cd2e9de1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzIxMjM4OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MToyMVrOHsA--A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjozODowOFrOHsColQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTUxMg==", "bodyText": "As far as I can tell, every test uses the params 1, 10. Perhaps you should mix this up a bit? Can these numbers be large (e.g. 10k)? Might help to catch any funny errors to have at least one test with large numbers - if that makes sense in prod.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515915512", "createdAt": "2020-11-02T11:41:21Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -18,178 +18,72 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-public class HistoryAnalyzerTest {\n+public final class HistoryAnalyzerTest {\n     @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    private static final String USE_CASE_LEARNER =\n-            LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n-    private static final String USE_CASE_ACCEPTOR =\n-            AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n-\n-    private StateLogComponents localStateLogComponents;\n-    private List<StateLogComponents> remoteStateLogComponents;\n-    PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localStateLogComponents = createLogComponentsForServer(\"randomFile1\");\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(\"randomFile2\"), createLogComponentsForServer(\"randomFile3\"));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 10));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase()\n-                        .isEmpty())\n-                .isTrue();\n+        helper.assertNoCorruptionViolations();\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                localStateLogComponents.learnerLog(),\n+                helper.getDefaultLocalServer().learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        remoteStateLogComponents.forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n-                server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        helper.getDefaultRemoteServerList()\n+                .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n+                        server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.DIVERGED_LEARNERS);\n+        helper.assertViolationDetected(CorruptionCheckViolation.DIVERGED_LEARNERS);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n+        helper.writeLogsOnDefaultLocalServer(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n+        helper.assertViolationDetected(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        writeLogsOnServer(localStateLogComponents, 1, 5);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 5));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c3a14899679cf2d29c838fad2a3dd01ca51529"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0MjU0OQ==", "bodyText": "First part is done. For the second part I can add a (stress?) test in CorruptionDetectionIntegrationTest.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515942549", "createdAt": "2020-11-02T12:38:08Z", "author": {"login": "sudiksha27"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -18,178 +18,72 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-public class HistoryAnalyzerTest {\n+public final class HistoryAnalyzerTest {\n     @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    private static final String USE_CASE_LEARNER =\n-            LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n-    private static final String USE_CASE_ACCEPTOR =\n-            AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n-\n-    private StateLogComponents localStateLogComponents;\n-    private List<StateLogComponents> remoteStateLogComponents;\n-    PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localStateLogComponents = createLogComponentsForServer(\"randomFile1\");\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(\"randomFile2\"), createLogComponentsForServer(\"randomFile3\"));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 10));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase()\n-                        .isEmpty())\n-                .isTrue();\n+        helper.assertNoCorruptionViolations();\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                localStateLogComponents.learnerLog(),\n+                helper.getDefaultLocalServer().learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        remoteStateLogComponents.forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n-                server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        helper.getDefaultRemoteServerList()\n+                .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n+                        server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.DIVERGED_LEARNERS);\n+        helper.assertViolationDetected(CorruptionCheckViolation.DIVERGED_LEARNERS);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n+        helper.writeLogsOnDefaultLocalServer(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n+        helper.assertViolationDetected(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        writeLogsOnServer(localStateLogComponents, 1, 5);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 5));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTUxMg=="}, "originalCommit": {"oid": "43c3a14899679cf2d29c838fad2a3dd01ca51529"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzIxNTYxOnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MjoxOVrOHsBBCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MjoxOVrOHsBBCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNjA0MA==", "bodyText": "nit: reorder the methods so that public is at the top, private at the bottom (and if it makes sense to group static methods, feel free to do that too).", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515916040", "createdAt": "2020-11-02T11:42:19Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c3a14899679cf2d29c838fad2a3dd01ca51529"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzIxODg5OnYy", "diffSide": "RIGHT", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MzoyNVrOHsBDJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMTo0MzoyNVrOHsBDJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNjU4Mw==", "bodyText": "nit: In other tests, you statically imported this. Either do the same here, or remove the static imports elsewhere.", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515916583", "createdAt": "2020-11-02T11:43:25Z", "author": {"login": "Jolyon-S"}, "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java", "diffHunk": "@@ -16,20 +16,16 @@\n \n package com.palantir.timelock.history.utils;\n \n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n import com.palantir.timelock.history.HistoryQuery;\n import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n \n public class HistoryQueries {\n-    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n-    public static final String DEFAULT_USE_CASE = \"useCase\";\n-    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n+                TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c3a14899679cf2d29c838fad2a3dd01ca51529"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2462, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}