{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDI0Nzk3", "number": 4821, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoyMzo0NlrOECdPFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMToyNDozM1rOEChGwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDExNjA0OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/NameMetadataDescription.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoyMzo0NlrOGe7Ffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODo1OTo1NFrOGe8asw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3ODUyNg==", "bodyText": "nit: I think there were two spaces after the full stop\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Only JSON objects can be deserialized into parsed byte arrays.  Passed json was: %s\",\n          \n          \n            \n                                \"Only JSON objects can be deserialized into parsed byte arrays. Passed json was: %s\",", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435078526", "createdAt": "2020-06-04T08:23:46Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/NameMetadataDescription.java", "diffHunk": "@@ -183,8 +185,13 @@ public String renderToJson(byte[] name) {\n \n     public byte[] parseFromJson(String json, boolean allowPrefix) {\n         try {\n-            JSONObject obj = (JSONObject) new JSONParser().parse(json);\n-            int numDefinedFields = countNumDefinedFields(obj);\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            Preconditions.checkState(jsonNode.isObject(),\n+                    \"Only JSON objects can be deserialized into parsed byte arrays.  Passed json was: %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5Nzc1OA==", "bodyText": "I wouldn't normally write this, but this is intentional given the other error messages also have this.", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435097758", "createdAt": "2020-06-04T08:55:43Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/NameMetadataDescription.java", "diffHunk": "@@ -183,8 +185,13 @@ public String renderToJson(byte[] name) {\n \n     public byte[] parseFromJson(String json, boolean allowPrefix) {\n         try {\n-            JSONObject obj = (JSONObject) new JSONParser().parse(json);\n-            int numDefinedFields = countNumDefinedFields(obj);\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            Preconditions.checkState(jsonNode.isObject(),\n+                    \"Only JSON objects can be deserialized into parsed byte arrays.  Passed json was: %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3ODUyNg=="}, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDMzOQ==", "bodyText": "Ah well, whatever.", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435100339", "createdAt": "2020-06-04T08:59:54Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/NameMetadataDescription.java", "diffHunk": "@@ -183,8 +185,13 @@ public String renderToJson(byte[] name) {\n \n     public byte[] parseFromJson(String json, boolean allowPrefix) {\n         try {\n-            JSONObject obj = (JSONObject) new JSONParser().parse(json);\n-            int numDefinedFields = countNumDefinedFields(obj);\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            Preconditions.checkState(jsonNode.isObject(),\n+                    \"Only JSON objects can be deserialized into parsed byte arrays.  Passed json was: %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3ODUyNg=="}, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDEzNDk1OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/ValueType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoyODo1N1rOGe7RqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTowNDozOFrOGe8mBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MTY0MQ==", "bodyText": "To make sure I understand: before, you would get SafeIllegalArgumentExceptions if this was not a string, but now you just get a plain RuntimeException that wraps an IOException. Is my understanding correct, and is this behaviour OK?", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435081641", "createdAt": "2020-06-04T08:28:57Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/ValueType.java", "diffHunk": "@@ -464,9 +463,7 @@ public String convertToJava(byte[] value, int offset) {\n \n         @Override\n         public byte[] convertFromJson(String jsonValue) {\n-            Object s = JSONValue.parse(jsonValue);\n-            Preconditions.checkArgument(s instanceof String, \"%s must be a json string\", jsonValue);\n-            return convertFromString((String) s);\n+            return convertFromString(ValueType.readJson(jsonValue, String.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMzIzNg==", "bodyText": "That's mostly correct (strictly speaking: it used Google, not Palantir Preconditions, so you'd just get a regular IllegalArgumentException). That's a good call: I think that is fine, but I'll change it back.", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435103236", "createdAt": "2020-06-04T09:04:38Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/table/description/ValueType.java", "diffHunk": "@@ -464,9 +463,7 @@ public String convertToJava(byte[] value, int offset) {\n \n         @Override\n         public byte[] convertFromJson(String jsonValue) {\n-            Object s = JSONValue.parse(jsonValue);\n-            Preconditions.checkArgument(s instanceof String, \"%s must be a json string\", jsonValue);\n-            return convertFromString((String) s);\n+            return convertFromString(ValueType.readJson(jsonValue, String.class));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MTY0MQ=="}, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDE1MzU3OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODozMzo1MFrOGe7ddg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxMDowOVrOGe8zbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NDY2Mg==", "bodyText": "I can't quite understand this test - it implies to me that you could get either result non-deterministically. Is this really the case currently?", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435084662", "createdAt": "2020-06-04T08:33:50Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): This looks ridiculous, but I don't wish to change existing behaviour.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMzQ0MA==", "bodyText": "Currently you'll always get robert (in general, the last key-value mapping). This is dependent on the JSON library, though - while we could write just that assertion I don't think it's something we can guarantee.\nI think my comment was probably a bit misleading in that \"don't wish to change\" referred to \"tolerate duplicate fields\", not specifically which key gets returned.", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435103440", "createdAt": "2020-06-04T09:04:55Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): This looks ridiculous, but I don't wish to change existing behaviour.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NDY2Mg=="}, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNjY2OQ==", "bodyText": "I think the comments you have provided make this a lot clearer. Thanks!", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435106669", "createdAt": "2020-06-04T09:10:09Z", "author": {"login": "Jolyon-S"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): This looks ridiculous, but I don't wish to change existing behaviour.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NDY2Mg=="}, "originalCommit": {"oid": "9ffd37065ddf8da843df39ecff27ecd6a2b5cdbf"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDc1MDA5OnYy", "diffSide": "RIGHT", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMToyNDozM1rOGfBW-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMjozMDoxNlrOGfDbpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MTMwNg==", "bodyText": "I think the flag should be true for it to be in prefix mode?", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435181306", "createdAt": "2020-06-04T11:24:33Z", "author": {"login": "sudiksha27"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): Tolerating duplicate fields was permitted, even though it is a bit dubious.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        \n+        // Which value is selected is an implementation detail - we should not guarantee this.\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));\n+    }\n+\n+    @Test\n+    public void throwsIfNoRelevantFieldsProvided() {\n+        String missingFields = \"{\\\"type\\\": \\\"string\\\"}\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(missingFields, false))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"JSON object needs a field named: string.\");\n+    }\n+\n+    @Test\n+    public void throwsOnRawJsonString() {\n+        String jsonString = \"\\\"string\\\"\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(jsonString, false))\n+                .isInstanceOf(IllegalStateException.class)\n+                .hasMessageContaining(\"Only JSON objects can be deserialized into parsed byte arrays.\");\n+    }\n+\n+    @Test\n+    public void throwsOnArrays() {\n+        String jsonString = \"[\\\"string\\\"]\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(jsonString, false))\n+                .isInstanceOf(IllegalStateException.class)\n+                .hasMessageContaining(\"Only JSON objects can be deserialized into parsed byte arrays.\");\n+    }\n+\n+    @Test\n+    public void throwsOnNonJsonInput() {\n+        String gobbledygook = \"]q2!a0v-_13r\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(gobbledygook, false))\n+                .isInstanceOf(PalantirRuntimeException.class)\n+                .hasMessageContaining(\"Unexpected close marker\");\n+    }\n+\n+    @Test\n+    public void parseAndRenderAreInverses_MultiPart() {\n+        assertThat(MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW), false)).containsExactly(SAMPLE_ROW);\n+    }\n+\n+    @Test\n+    public void missingFieldsAreNotToleratedWithoutPrefix() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"gamma\", \"omega\"));\n+\n+        assertThatThrownBy(() -> MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), false))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"JSON object has 2 defined fields, but the number of row components is 4.\");\n+    }\n+\n+    @Test\n+    public void missingSuffixFieldsAreToleratedInPrefixMode() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"gamma\", \"omega\"));\n+\n+        byte[] bytes = MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), true);\n+        assertThat(bytes).containsExactly(SAMPLE_ROW_PREFIX);\n+    }\n+\n+    @Test\n+    public void missingNonSuffixFieldsAreNotToleratedInPrefixMode() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"alpha\", \"omega\"));\n+\n+        assertThatThrownBy(() -> MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), false))\n+                .isInstanceOf(IllegalArgumentException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0cba74c5de8e6fb234f867dd7929a4cdd3aab37"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxNTI2OQ==", "bodyText": "Well spotted! I'll fix this", "url": "https://github.com/palantir/atlasdb/pull/4821#discussion_r435215269", "createdAt": "2020-06-04T12:30:16Z", "author": {"login": "jeremyk-91"}, "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/table/description/NameMetadataDescriptionTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.table.description;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.protos.generated.TableMetadataPersistence;\n+import com.palantir.atlasdb.ptobject.EncodingUtils;\n+import com.palantir.common.exception.PalantirRuntimeException;\n+\n+public class NameMetadataDescriptionTest {\n+    private static final NameMetadataDescription SIMPLE_NAME_METADATA_DESCRIPTION = NameMetadataDescription.safe(\n+            \"string\", ValueType.STRING);\n+\n+    private static final NameMetadataDescription MULTIPART_NAME_METADATA_DESCRIPTION = NameMetadataDescription.create(\n+            ImmutableList.of(\n+                    new NameComponentDescription.Builder()\n+                            .componentName(\"alpha\")\n+                            .type(ValueType.VAR_LONG)\n+                            .byteOrder(TableMetadataPersistence.ValueByteOrder.DESCENDING)\n+                            .build(),\n+                    NameComponentDescription.safe(\"beta\", ValueType.SIZED_BLOB),\n+                    NameComponentDescription.safe(\"gamma\", ValueType.VAR_STRING),\n+                    NameComponentDescription.safe(\"omega\", ValueType.STRING)));\n+\n+    private static final byte[] SAMPLE_ALPHA = EncodingUtils.flipAllBits(ValueType.VAR_LONG.convertFromJava(42L));\n+    private static final byte[] SAMPLE_BETA = ValueType.SIZED_BLOB.convertFromJava(new byte[5]);\n+    private static final byte[] SAMPLE_GAMMA = ValueType.VAR_STRING.convertFromString(\"boo\");\n+    private static final byte[] SAMPLE_OMEGA = ValueType.STRING.convertFromString(\"O(n)\");\n+    private static final byte[] SAMPLE_ROW = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA, SAMPLE_GAMMA, SAMPLE_OMEGA);\n+    private static final byte[] SAMPLE_ROW_PREFIX = EncodingUtils.add(SAMPLE_ALPHA, SAMPLE_BETA);\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+    @Test\n+    public void parseAndRenderAreInverses_Simple() {\n+        byte[] row = PtBytes.toBytes(\"theData\");\n+        assertThat(SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                SIMPLE_NAME_METADATA_DESCRIPTION.renderToJson(row), false)).containsExactly(row);\n+    }\n+\n+    @Test\n+    public void extraFieldsAreTolerated() {\n+        String extraFieldJson = \"{\\\"string\\\": \\\"tom\\\", \\\"extraneous\\\": \\\"another\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(extraFieldJson, false);\n+        assertThat(result).containsExactly(PtBytes.toBytes(\"tom\"));\n+    }\n+\n+    @Test\n+    // TODO (jkong): Tolerating duplicate fields was permitted, even though it is a bit dubious.\n+    public void duplicateFieldsAreTolerated() {\n+        String invalidJson = \"{\\\"string\\\": \\\"tom\\\", \\\"string\\\": \\\"robert\\\"}\";\n+        byte[] result = SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(invalidJson, false);\n+        \n+        // Which value is selected is an implementation detail - we should not guarantee this.\n+        assertThat(result).satisfiesAnyOf(\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"tom\")),\n+                (bytes) -> assertThat(bytes).containsExactly(PtBytes.toBytes(\"robert\")));\n+    }\n+\n+    @Test\n+    public void throwsIfNoRelevantFieldsProvided() {\n+        String missingFields = \"{\\\"type\\\": \\\"string\\\"}\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(missingFields, false))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"JSON object needs a field named: string.\");\n+    }\n+\n+    @Test\n+    public void throwsOnRawJsonString() {\n+        String jsonString = \"\\\"string\\\"\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(jsonString, false))\n+                .isInstanceOf(IllegalStateException.class)\n+                .hasMessageContaining(\"Only JSON objects can be deserialized into parsed byte arrays.\");\n+    }\n+\n+    @Test\n+    public void throwsOnArrays() {\n+        String jsonString = \"[\\\"string\\\"]\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(jsonString, false))\n+                .isInstanceOf(IllegalStateException.class)\n+                .hasMessageContaining(\"Only JSON objects can be deserialized into parsed byte arrays.\");\n+    }\n+\n+    @Test\n+    public void throwsOnNonJsonInput() {\n+        String gobbledygook = \"]q2!a0v-_13r\";\n+\n+        assertThatThrownBy(() -> SIMPLE_NAME_METADATA_DESCRIPTION.parseFromJson(gobbledygook, false))\n+                .isInstanceOf(PalantirRuntimeException.class)\n+                .hasMessageContaining(\"Unexpected close marker\");\n+    }\n+\n+    @Test\n+    public void parseAndRenderAreInverses_MultiPart() {\n+        assertThat(MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(\n+                MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW), false)).containsExactly(SAMPLE_ROW);\n+    }\n+\n+    @Test\n+    public void missingFieldsAreNotToleratedWithoutPrefix() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"gamma\", \"omega\"));\n+\n+        assertThatThrownBy(() -> MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), false))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"JSON object has 2 defined fields, but the number of row components is 4.\");\n+    }\n+\n+    @Test\n+    public void missingSuffixFieldsAreToleratedInPrefixMode() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"gamma\", \"omega\"));\n+\n+        byte[] bytes = MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), true);\n+        assertThat(bytes).containsExactly(SAMPLE_ROW_PREFIX);\n+    }\n+\n+    @Test\n+    public void missingNonSuffixFieldsAreNotToleratedInPrefixMode() throws JsonProcessingException {\n+        JsonNode jsonNode = OBJECT_MAPPER.readTree(MULTIPART_NAME_METADATA_DESCRIPTION.renderToJson(SAMPLE_ROW));\n+        ((ObjectNode) jsonNode).remove(ImmutableList.of(\"alpha\", \"omega\"));\n+\n+        assertThatThrownBy(() -> MULTIPART_NAME_METADATA_DESCRIPTION.parseFromJson(jsonNode.toString(), false))\n+                .isInstanceOf(IllegalArgumentException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4MTMwNg=="}, "originalCommit": {"oid": "e0cba74c5de8e6fb234f867dd7929a4cdd3aab37"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2928, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}