{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzg1MTA3", "number": 4790, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxNTo0OFrOD_nF3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxOTozN1rOD_nKsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDI3MzU4OnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/ConjureLockV1Resource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxNTo0OFrOGaXx3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxNTo0OFrOGaXx3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMwNTc1OA==", "bodyText": "Rename to toLegacyTokens?", "url": "https://github.com/palantir/atlasdb/pull/4790#discussion_r430305758", "createdAt": "2020-05-26T10:15:48Z", "author": {"login": "gmaretic"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/ConjureLockV1Resource.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.atlasdb.http.RedirectRetryTargeter;\n+import com.palantir.conjure.java.undertow.lib.UndertowService;\n+import com.palantir.lock.ConjureLockRefreshToken;\n+import com.palantir.lock.ConjureLockV1Service;\n+import com.palantir.lock.ConjureLockV1ServiceEndpoints;\n+import com.palantir.lock.ConjureSimpleHeldLocksToken;\n+import com.palantir.lock.LockRefreshToken;\n+import com.palantir.lock.LockService;\n+import com.palantir.lock.SimpleHeldLocksToken;\n+import com.palantir.lock.UndertowConjureLockV1Service;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class ConjureLockV1Resource implements UndertowConjureLockV1Service {\n+    private final ConjureResourceExceptionHandler exceptionHandler;\n+    private final Function<String, LockService> lockServices;\n+\n+    private ConjureLockV1Resource(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        this.exceptionHandler = new ConjureResourceExceptionHandler(redirectRetryTargeter);\n+        this.lockServices = lockServices;\n+    }\n+\n+    public static UndertowService undertow(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return ConjureLockV1ServiceEndpoints.of(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    public static ConjureLockV1ShimService jersey(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return new ConjureLockV1Resource.JerseyAdapter(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    @Override\n+    public ListenableFuture<Set<ConjureLockRefreshToken>> refreshLockRefreshTokens(AuthHeader authHeader,\n+            String namespace, List<ConjureLockRefreshToken> request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            ListenableFuture<Set<LockRefreshToken>> serviceTokens = Futures.immediateFuture(\n+                    lockServices.apply(namespace).refreshLockRefreshTokens(getLegacyTokens(request)));\n+            return Futures.transform(\n+                    serviceTokens,\n+                    ConjureLockV1Resource::getConjureTokens,\n+                    MoreExecutors.directExecutor());\n+        });\n+    }\n+\n+    @Override\n+    public ListenableFuture<Boolean> unlockSimple(AuthHeader authHeader, String namespace,\n+            ConjureSimpleHeldLocksToken request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            SimpleHeldLocksToken serverToken = new SimpleHeldLocksToken(\n+                    request.getTokenId(), request.getCreationDateMs());\n+            return Futures.immediateFuture(lockServices.apply(namespace).unlockSimple(serverToken));\n+        });\n+    }\n+\n+    @VisibleForTesting\n+    static List<LockRefreshToken> getLegacyTokens(List<ConjureLockRefreshToken> request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78ecc2642c7b94a0b0bb2a845a311456bfad8111"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDI3Mzg4OnYy", "diffSide": "RIGHT", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/ConjureLockV1Resource.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxNTo1NlrOGaXyHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMDoxMjowNVrOGcFErA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMwNTgyMQ==", "bodyText": "as above", "url": "https://github.com/palantir/atlasdb/pull/4790#discussion_r430305821", "createdAt": "2020-05-26T10:15:56Z", "author": {"login": "gmaretic"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/ConjureLockV1Resource.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.atlasdb.http.RedirectRetryTargeter;\n+import com.palantir.conjure.java.undertow.lib.UndertowService;\n+import com.palantir.lock.ConjureLockRefreshToken;\n+import com.palantir.lock.ConjureLockV1Service;\n+import com.palantir.lock.ConjureLockV1ServiceEndpoints;\n+import com.palantir.lock.ConjureSimpleHeldLocksToken;\n+import com.palantir.lock.LockRefreshToken;\n+import com.palantir.lock.LockService;\n+import com.palantir.lock.SimpleHeldLocksToken;\n+import com.palantir.lock.UndertowConjureLockV1Service;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class ConjureLockV1Resource implements UndertowConjureLockV1Service {\n+    private final ConjureResourceExceptionHandler exceptionHandler;\n+    private final Function<String, LockService> lockServices;\n+\n+    private ConjureLockV1Resource(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        this.exceptionHandler = new ConjureResourceExceptionHandler(redirectRetryTargeter);\n+        this.lockServices = lockServices;\n+    }\n+\n+    public static UndertowService undertow(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return ConjureLockV1ServiceEndpoints.of(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    public static ConjureLockV1ShimService jersey(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return new ConjureLockV1Resource.JerseyAdapter(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    @Override\n+    public ListenableFuture<Set<ConjureLockRefreshToken>> refreshLockRefreshTokens(AuthHeader authHeader,\n+            String namespace, List<ConjureLockRefreshToken> request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            ListenableFuture<Set<LockRefreshToken>> serviceTokens = Futures.immediateFuture(\n+                    lockServices.apply(namespace).refreshLockRefreshTokens(getLegacyTokens(request)));\n+            return Futures.transform(\n+                    serviceTokens,\n+                    ConjureLockV1Resource::getConjureTokens,\n+                    MoreExecutors.directExecutor());\n+        });\n+    }\n+\n+    @Override\n+    public ListenableFuture<Boolean> unlockSimple(AuthHeader authHeader, String namespace,\n+            ConjureSimpleHeldLocksToken request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            SimpleHeldLocksToken serverToken = new SimpleHeldLocksToken(\n+                    request.getTokenId(), request.getCreationDateMs());\n+            return Futures.immediateFuture(lockServices.apply(namespace).unlockSimple(serverToken));\n+        });\n+    }\n+\n+    @VisibleForTesting\n+    static List<LockRefreshToken> getLegacyTokens(List<ConjureLockRefreshToken> request) {\n+        return request.stream()\n+                .map(token -> new LockRefreshToken(token.getTokenId(), token.getExpirationDateMs()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    @VisibleForTesting\n+    static Set<ConjureLockRefreshToken> getConjureTokens(Set<LockRefreshToken> serverTokens) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78ecc2642c7b94a0b0bb2a845a311456bfad8111"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMwNjgxNQ==", "bodyText": "Also, these two methods should just live in a separate utility class and be public imo", "url": "https://github.com/palantir/atlasdb/pull/4790#discussion_r430306815", "createdAt": "2020-05-26T10:17:47Z", "author": {"login": "gmaretic"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/ConjureLockV1Resource.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.atlasdb.http.RedirectRetryTargeter;\n+import com.palantir.conjure.java.undertow.lib.UndertowService;\n+import com.palantir.lock.ConjureLockRefreshToken;\n+import com.palantir.lock.ConjureLockV1Service;\n+import com.palantir.lock.ConjureLockV1ServiceEndpoints;\n+import com.palantir.lock.ConjureSimpleHeldLocksToken;\n+import com.palantir.lock.LockRefreshToken;\n+import com.palantir.lock.LockService;\n+import com.palantir.lock.SimpleHeldLocksToken;\n+import com.palantir.lock.UndertowConjureLockV1Service;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class ConjureLockV1Resource implements UndertowConjureLockV1Service {\n+    private final ConjureResourceExceptionHandler exceptionHandler;\n+    private final Function<String, LockService> lockServices;\n+\n+    private ConjureLockV1Resource(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        this.exceptionHandler = new ConjureResourceExceptionHandler(redirectRetryTargeter);\n+        this.lockServices = lockServices;\n+    }\n+\n+    public static UndertowService undertow(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return ConjureLockV1ServiceEndpoints.of(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    public static ConjureLockV1ShimService jersey(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return new ConjureLockV1Resource.JerseyAdapter(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    @Override\n+    public ListenableFuture<Set<ConjureLockRefreshToken>> refreshLockRefreshTokens(AuthHeader authHeader,\n+            String namespace, List<ConjureLockRefreshToken> request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            ListenableFuture<Set<LockRefreshToken>> serviceTokens = Futures.immediateFuture(\n+                    lockServices.apply(namespace).refreshLockRefreshTokens(getLegacyTokens(request)));\n+            return Futures.transform(\n+                    serviceTokens,\n+                    ConjureLockV1Resource::getConjureTokens,\n+                    MoreExecutors.directExecutor());\n+        });\n+    }\n+\n+    @Override\n+    public ListenableFuture<Boolean> unlockSimple(AuthHeader authHeader, String namespace,\n+            ConjureSimpleHeldLocksToken request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            SimpleHeldLocksToken serverToken = new SimpleHeldLocksToken(\n+                    request.getTokenId(), request.getCreationDateMs());\n+            return Futures.immediateFuture(lockServices.apply(namespace).unlockSimple(serverToken));\n+        });\n+    }\n+\n+    @VisibleForTesting\n+    static List<LockRefreshToken> getLegacyTokens(List<ConjureLockRefreshToken> request) {\n+        return request.stream()\n+                .map(token -> new LockRefreshToken(token.getTokenId(), token.getExpirationDateMs()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    @VisibleForTesting\n+    static Set<ConjureLockRefreshToken> getConjureTokens(Set<LockRefreshToken> serverTokens) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMwNTgyMQ=="}, "originalCommit": {"oid": "78ecc2642c7b94a0b0bb2a845a311456bfad8111"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5NjQyOA==", "bodyText": "That's a good call. I will do this refactor", "url": "https://github.com/palantir/atlasdb/pull/4790#discussion_r432096428", "createdAt": "2020-05-28T20:12:05Z", "author": {"login": "jeremyk-91"}, "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/ConjureLockV1Resource.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.atlasdb.http.RedirectRetryTargeter;\n+import com.palantir.conjure.java.undertow.lib.UndertowService;\n+import com.palantir.lock.ConjureLockRefreshToken;\n+import com.palantir.lock.ConjureLockV1Service;\n+import com.palantir.lock.ConjureLockV1ServiceEndpoints;\n+import com.palantir.lock.ConjureSimpleHeldLocksToken;\n+import com.palantir.lock.LockRefreshToken;\n+import com.palantir.lock.LockService;\n+import com.palantir.lock.SimpleHeldLocksToken;\n+import com.palantir.lock.UndertowConjureLockV1Service;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class ConjureLockV1Resource implements UndertowConjureLockV1Service {\n+    private final ConjureResourceExceptionHandler exceptionHandler;\n+    private final Function<String, LockService> lockServices;\n+\n+    private ConjureLockV1Resource(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        this.exceptionHandler = new ConjureResourceExceptionHandler(redirectRetryTargeter);\n+        this.lockServices = lockServices;\n+    }\n+\n+    public static UndertowService undertow(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return ConjureLockV1ServiceEndpoints.of(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    public static ConjureLockV1ShimService jersey(\n+            RedirectRetryTargeter redirectRetryTargeter,\n+            Function<String, LockService> lockServices) {\n+        return new ConjureLockV1Resource.JerseyAdapter(new ConjureLockV1Resource(redirectRetryTargeter, lockServices));\n+    }\n+\n+    @Override\n+    public ListenableFuture<Set<ConjureLockRefreshToken>> refreshLockRefreshTokens(AuthHeader authHeader,\n+            String namespace, List<ConjureLockRefreshToken> request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            ListenableFuture<Set<LockRefreshToken>> serviceTokens = Futures.immediateFuture(\n+                    lockServices.apply(namespace).refreshLockRefreshTokens(getLegacyTokens(request)));\n+            return Futures.transform(\n+                    serviceTokens,\n+                    ConjureLockV1Resource::getConjureTokens,\n+                    MoreExecutors.directExecutor());\n+        });\n+    }\n+\n+    @Override\n+    public ListenableFuture<Boolean> unlockSimple(AuthHeader authHeader, String namespace,\n+            ConjureSimpleHeldLocksToken request) {\n+        return exceptionHandler.handleExceptions(() -> {\n+            SimpleHeldLocksToken serverToken = new SimpleHeldLocksToken(\n+                    request.getTokenId(), request.getCreationDateMs());\n+            return Futures.immediateFuture(lockServices.apply(namespace).unlockSimple(serverToken));\n+        });\n+    }\n+\n+    @VisibleForTesting\n+    static List<LockRefreshToken> getLegacyTokens(List<ConjureLockRefreshToken> request) {\n+        return request.stream()\n+                .map(token -> new LockRefreshToken(token.getTokenId(), token.getExpirationDateMs()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    @VisibleForTesting\n+    static Set<ConjureLockRefreshToken> getConjureTokens(Set<LockRefreshToken> serverTokens) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMwNTgyMQ=="}, "originalCommit": {"oid": "78ecc2642c7b94a0b0bb2a845a311456bfad8111"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDI4NTkyOnYy", "diffSide": "RIGHT", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxOTozN1rOGaX5rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMDoxOTozN1rOGaX5rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMwNzc1Ng==", "bodyText": "Test is a bit verbose, but thorough \ud83c\udf89", "url": "https://github.com/palantir/atlasdb/pull/4790#discussion_r430307756", "createdAt": "2020-05-26T10:19:37Z", "author": {"login": "gmaretic"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -320,6 +326,42 @@ public void canGetAllNamespaces() {\n                 .collect(Collectors.toSet());\n     }\n \n+    @Test\n+    public void directLegacyAndConjureLockServicesInteractCorrectly() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78ecc2642c7b94a0b0bb2a845a311456bfad8111"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2859, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}