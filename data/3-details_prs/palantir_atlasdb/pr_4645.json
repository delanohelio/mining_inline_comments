{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NjYxNTYy", "number": 4645, "title": "[PDS-113120] Block Enforcing (Client-Side) Lock Service", "bodyText": "Goals (and why):\n\nThe V2 lock service has a point of fragility: if you ever make a lock request that blocks for longer than any underlying timeout we have in the remoting stack and can't acquire the lock, you'll get a runtime exception.\nThis was addressed with the BlockingTimeoutException mechanism in V1, but remains an open bug in V2.\n\nImplementation Description (bullets):\n\nRetry timed-out responses and SocketTimeoutExceptions up until the full duration of a user's blocking timeout, as measured from the client side.\n\nTesting (What was existing testing like?  What have you done to improve it?):\n\nAdded tests for the key retrying piece, and two previously failing integration tests.\n\nConcerns (what feedback would you like?):\n\nI went for a different design than in V1 because that created a lot of unpleasant coupling between remote timeout values and the actual lock service.\nI think there is no starvation risk even if we replay some requests, because lock requests have UUIDs and so retrying the same lock request at this level is fine (compare: retrying above from outside Atlas code is not ok because the request id will be different), but we should sanity check this.\nThere is a bit of an edge case where we don't actually spend the full blocking timeout blocking on the server because of the mechanism I use to calculate timeouts.\nWill this cause more load on TimeLock than we like?\nI shoved WaitForLocksRequest through the LockLeaseService, otherwise we need to have the BlockEnforcing one in two places.\n\nWhere should we start reviewing?: RemoteTimeoutRetryer\nPriority (whenever / two weeks / yesterday): this week please", "createdAt": "2020-03-11T12:30:52Z", "url": "https://github.com/palantir/atlasdb/pull/4645", "merged": true, "mergeCommit": {"oid": "ded3ef53566d8f6096fab1a635571adc52a59715"}, "closed": true, "closedAt": "2020-03-16T17:50:40Z", "author": {"login": "jeremyk-91"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMYgbfgH2gAyMzg2NjYxNTYyOmY3Mzc5NmRhZjNkNzBkZTZmNTY4ODkzYTIyNjBiMzYzMDc0ZTBjZTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOR3w3gFqTM3NTQ1MDUwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f73796daf3d70de6f568893a2260b363074e0ce2", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/f73796daf3d70de6f568893a2260b363074e0ce2", "committedDate": "2020-03-10T20:26:19Z", "message": "Failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fe325bfc485617097e6c57ad9dad7c9a9bcabf4", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/6fe325bfc485617097e6c57ad9dad7c9a9bcabf4", "committedDate": "2020-03-10T21:28:17Z", "message": "ASLS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "433aa13bc52bf14572b213930c4c33a0331bc5fe", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/433aa13bc52bf14572b213930c4c33a0331bc5fe", "committedDate": "2020-03-10T21:28:23Z", "message": "simplify multinode test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "480e6ae566de5933e26f04a54367a558a5aea628", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/480e6ae566de5933e26f04a54367a558a5aea628", "committedDate": "2020-03-10T22:08:47Z", "message": "Wait for locks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "689082f5788493cb9c4549965939f9420c906d22", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/689082f5788493cb9c4549965939f9420c906d22", "committedDate": "2020-03-11T11:16:45Z", "message": "Patch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "712d2673ab4e2da0193ca23bed1c6d2a2aabad82", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/712d2673ab4e2da0193ca23bed1c6d2a2aabad82", "committedDate": "2020-03-11T12:19:03Z", "message": "Refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "committedDate": "2020-03-11T12:19:10Z", "message": "Test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b10d7d671fdca3d522c4ceee0f2333ff16a09e4", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/9b10d7d671fdca3d522c4ceee0f2333ff16a09e4", "committedDate": "2020-03-11T12:19:10Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1082550b641dcbf62db9c80b14480c879e4fac42", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/1082550b641dcbf62db9c80b14480c879e4fac42", "committedDate": "2020-03-11T13:15:19Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51200b2a3194a1e260ba12e2e7a53bb2387182c7", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/51200b2a3194a1e260ba12e2e7a53bb2387182c7", "committedDate": "2020-03-11T13:17:01Z", "message": "Merge branch 'jkong/compensating-lock-requests' of github.com:palantir/atlasdb into jkong/compensating-lock-requests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNzE3ODQx", "url": "https://github.com/palantir/atlasdb/pull/4645#pullrequestreview-372717841", "createdAt": "2020-03-11T12:36:54Z", "commit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMjozNjo1NVrOF01E7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzoyMzoxMVrOF02o-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzOTg4Nw==", "bodyText": "retrying unsuccessful responses?? is it possible to make this less general?", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390939887", "createdAt": "2020-03-11T12:36:55Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {\n+        Instant now = clock.instant();\n+        Instant deadline = now.plus(durationExtractor.apply(request));\n+\n+        while (now.isBefore(deadline)) {\n+            Duration remainingTime = Duration.between(now, deadline);\n+            S durationLimitedInput = durationLimiter.apply(request, remainingTime);\n+\n+            try {\n+                T response = query.apply(durationLimitedInput);\n+                if (successfulResponseEvaluator.test(response)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MDYxMw==", "bodyText": "nit: move the comment to this part here", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390940613", "createdAt": "2020-03-11T12:38:20Z", "author": {"login": "felixdesouza"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -193,4 +197,29 @@ public void canCreateNewClientsDynamically() {\n         }\n     }\n \n+    @Test\n+    public void lockRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.\n+        LockToken token = client.lock(LockRequest.of(LOCKS, DEFAULT_LOCK_TIMEOUT_MS)).getToken();\n+\n+        try {\n+            LockResponse response = client.lock(LockRequest.of(LOCKS, 15_000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MDY2Ng==", "bodyText": "same as below", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390940666", "createdAt": "2020-03-11T12:38:26Z", "author": {"login": "felixdesouza"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -193,4 +197,29 @@ public void canCreateNewClientsDynamically() {\n         }\n     }\n \n+    @Test\n+    public void lockRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.\n+        LockToken token = client.lock(LockRequest.of(LOCKS, DEFAULT_LOCK_TIMEOUT_MS)).getToken();\n+\n+        try {\n+            LockResponse response = client.lock(LockRequest.of(LOCKS, 15_000));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MDYxMw=="}, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MjUxNw==", "bodyText": "just pass in req.getAcquireTimeoutMs()?", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390942517", "createdAt": "2020-03-11T12:42:02Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.ImmutableLockRequest;\n+import com.palantir.lock.v2.ImmutableWaitForLocksRequest;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                request,\n+                req -> Duration.ofMillis(req.getAcquireTimeoutMs()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzExMA==", "bodyText": "so I've reread, and I think I understand, it's only because you've clamped the deadline, and that an unsuccessful response is still actually potentially successful/not a failure.\nThis class isn't and shouldn't be general imo, short of locks I'm struggling to see where else it applies.", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390947110", "createdAt": "2020-03-11T12:50:40Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {\n+        Instant now = clock.instant();\n+        Instant deadline = now.plus(durationExtractor.apply(request));\n+\n+        while (now.isBefore(deadline)) {\n+            Duration remainingTime = Duration.between(now, deadline);\n+            S durationLimitedInput = durationLimiter.apply(request, remainingTime);\n+\n+            try {\n+                T response = query.apply(durationLimitedInput);\n+                if (successfulResponseEvaluator.test(response)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzOTg4Nw=="}, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzgyOQ==", "bodyText": "if keeping this general, shouldn't this technically be applied on the previous durationLimitedInput instead of on the original request?", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390947829", "createdAt": "2020-03-11T12:52:01Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {\n+        Instant now = clock.instant();\n+        Instant deadline = now.plus(durationExtractor.apply(request));\n+\n+        while (now.isBefore(deadline)) {\n+            Duration remainingTime = Duration.between(now, deadline);\n+            S durationLimitedInput = durationLimiter.apply(request, remainingTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0OTQzOA==", "bodyText": "default is misleading here, if anything it should be timedOutResponse or something that communicates that we failed in the way we expected etc. Either that or we save the response if the successfulResultEvaluator fails and then return that.\nEither way, making this about locks instead of being general would go a long way imo.", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390949438", "createdAt": "2020-03-11T12:55:05Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MDYxNw==", "bodyText": "why times(3) here? seems pretty non-obvious", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390950617", "createdAt": "2020-03-11T12:57:14Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/test/java/com/palantir/lock/client/RemoteTimeoutRetryerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+@SuppressWarnings(\"unchecked\") // Mocks with generic types\n+public class RemoteTimeoutRetryerTest {\n+    private static final int DEFAULT_VALUE = -1;\n+    private static final int QUERY_VALUE = 3;\n+    private static final int FORTY_TWO = 42;\n+    private static final Exception TIMEOUT_EXCEPTION = new RuntimeException(new SocketTimeoutException(\"timeout\"));\n+    private static final Exception RUNTIME_EXCEPTION = new RuntimeException();\n+\n+    private final Clock clock = mock(Clock.class);\n+    private final RemoteTimeoutRetryer retryer = new RemoteTimeoutRetryer(clock);\n+    private final Function<IntAndDuration, Integer> query = mock(Function.class);\n+\n+    @Test\n+    public void returnsRequestImmediatelyIfSuccessful() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(FORTY_TWO);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(FORTY_TWO);\n+\n+        verify(query).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void returnsDefaultIfAlwaysFailing() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(DEFAULT_VALUE);\n+\n+        verify(query, times(3)).apply(any(IntAndDuration.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MzE1Ng==", "bodyText": "this is a bit weird, I think if you have to have this, have something along the lines of:\nList<Duration> durations = captor.getAllValues().stream().map(IntAndDuration::duration).collect(toList());\nassertThat(durations)\n  .as(\"duration is decreasing\")\n  .isSortedAccordingTo(Comparator.reverseOrder())", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390953156", "createdAt": "2020-03-11T13:02:06Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/test/java/com/palantir/lock/client/RemoteTimeoutRetryerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+@SuppressWarnings(\"unchecked\") // Mocks with generic types\n+public class RemoteTimeoutRetryerTest {\n+    private static final int DEFAULT_VALUE = -1;\n+    private static final int QUERY_VALUE = 3;\n+    private static final int FORTY_TWO = 42;\n+    private static final Exception TIMEOUT_EXCEPTION = new RuntimeException(new SocketTimeoutException(\"timeout\"));\n+    private static final Exception RUNTIME_EXCEPTION = new RuntimeException();\n+\n+    private final Clock clock = mock(Clock.class);\n+    private final RemoteTimeoutRetryer retryer = new RemoteTimeoutRetryer(clock);\n+    private final Function<IntAndDuration, Integer> query = mock(Function.class);\n+\n+    @Test\n+    public void returnsRequestImmediatelyIfSuccessful() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(FORTY_TWO);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(FORTY_TWO);\n+\n+        verify(query).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void returnsDefaultIfAlwaysFailing() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(DEFAULT_VALUE);\n+\n+        verify(query, times(3)).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void blockingDurationsDecreaseAsTimePasses() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        retryForTenMillisAcceptingOnlyFortyTwo();\n+\n+        ArgumentCaptor<IntAndDuration> captor = ArgumentCaptor.forClass(IntAndDuration.class);\n+        verify(query, times(3)).apply(captor.capture());\n+        assertThat(captor.getAllValues()).containsExactly(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2MjA0MA==", "bodyText": "the tests here are weird because there is nothing tying together a request timing out and the actual time, one is handled by the setupDefaultClock and the other is just if the query returns a correct response, as such it makes this example a bti contrived and hard to follow.\nIf anything, I'd probably have a method which was like: returnResponseAfterDuration(T response, Duration duration). That sets up the clock and also the query mock.\nprivate static BoolAndDuration successfulAfter(Duration duration) { ... }\nprivate static BoolAndDuration failedAfter(Duration duration) { ... }\nprivate static void setupStuff(BoolAndDuration... durations) {\n  // create arrays of the flag and stick it into the query mock\n  // create arrays of the duration and stick it into the clock mock\n}\n\npublic void test() {\n  setupStuff(\n    failedAfter(Duration.ofMillis(4)), \n    successfullAfter(Duration.ofMillis(5));\n\n  bool result = retryForTenMillisWaitingForSuccess();\n  ...\n}\nI'd probably go further and get rid of ints and just do this purely on booleans.", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390962040", "createdAt": "2020-03-11T13:17:48Z", "author": {"login": "felixdesouza"}, "path": "lock-api/src/test/java/com/palantir/lock/client/RemoteTimeoutRetryerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+@SuppressWarnings(\"unchecked\") // Mocks with generic types\n+public class RemoteTimeoutRetryerTest {\n+    private static final int DEFAULT_VALUE = -1;\n+    private static final int QUERY_VALUE = 3;\n+    private static final int FORTY_TWO = 42;\n+    private static final Exception TIMEOUT_EXCEPTION = new RuntimeException(new SocketTimeoutException(\"timeout\"));\n+    private static final Exception RUNTIME_EXCEPTION = new RuntimeException();\n+\n+    private final Clock clock = mock(Clock.class);\n+    private final RemoteTimeoutRetryer retryer = new RemoteTimeoutRetryer(clock);\n+    private final Function<IntAndDuration, Integer> query = mock(Function.class);\n+\n+    @Test\n+    public void returnsRequestImmediatelyIfSuccessful() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(FORTY_TWO);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(FORTY_TWO);\n+\n+        verify(query).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void returnsDefaultIfAlwaysFailing() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(DEFAULT_VALUE);\n+\n+        verify(query, times(3)).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void blockingDurationsDecreaseAsTimePasses() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        retryForTenMillisAcceptingOnlyFortyTwo();\n+\n+        ArgumentCaptor<IntAndDuration> captor = ArgumentCaptor.forClass(IntAndDuration.class);\n+        verify(query, times(3)).apply(captor.capture());\n+        assertThat(captor.getAllValues()).containsExactly(\n+                ImmutableIntAndDuration.of(QUERY_VALUE, Duration.ofMillis(10)),\n+                ImmutableIntAndDuration.of(QUERY_VALUE, Duration.ofMillis(6)),\n+                ImmutableIntAndDuration.of(QUERY_VALUE, Duration.ofMillis(2)));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void recoversFromFailureIfWeBecomeSuccessful() {\n+        setupDefaultClock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NDkwOA==", "bodyText": "bit obscure, is there a way we can refer to ClientOptions.NON_BLOCKING_READ_TIMEOUT.plus(Duration.ofSeconds(1)) as the lock timeout here?", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390964908", "createdAt": "2020-03-11T13:22:21Z", "author": {"login": "felixdesouza"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -193,4 +197,29 @@ public void canCreateNewClientsDynamically() {\n         }\n     }\n \n+    @Test\n+    public void lockRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.\n+        LockToken token = client.lock(LockRequest.of(LOCKS, DEFAULT_LOCK_TIMEOUT_MS)).getToken();\n+\n+        try {\n+            LockResponse response = client.lock(LockRequest.of(LOCKS, 15_000));\n+            assertThat(response.wasSuccessful()).isFalse();\n+        } finally {\n+            client.unlock(token);\n+        }\n+    }\n+\n+    @Test\n+    public void waitForLocksRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NTQ5Ng==", "bodyText": "as an aside, whilst trying to find that option, it's unclear to me why we have clientQoS enabled as a default, why is that?", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390965496", "createdAt": "2020-03-11T13:23:11Z", "author": {"login": "felixdesouza"}, "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -193,4 +197,29 @@ public void canCreateNewClientsDynamically() {\n         }\n     }\n \n+    @Test\n+    public void lockRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.\n+        LockToken token = client.lock(LockRequest.of(LOCKS, DEFAULT_LOCK_TIMEOUT_MS)).getToken();\n+\n+        try {\n+            LockResponse response = client.lock(LockRequest.of(LOCKS, 15_000));\n+            assertThat(response.wasSuccessful()).isFalse();\n+        } finally {\n+            client.unlock(token);\n+        }\n+    }\n+\n+    @Test\n+    public void waitForLocksRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NDkwOA=="}, "originalCommit": {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13c83228caaeb542fbd58a8af9d7ca6115553bff", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/13c83228caaeb542fbd58a8af9d7ca6115553bff", "committedDate": "2020-03-11T20:06:53Z", "message": "update tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/f922840ffd3192badbf10c817bf068e5cd8885fb", "committedDate": "2020-03-11T20:19:32Z", "message": "cs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MTk1ODUy", "url": "https://github.com/palantir/atlasdb/pull/4645#pullrequestreview-374195852", "createdAt": "2020-03-13T10:33:05Z", "commit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozMzowNVrOF1-yvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozMzowNVrOF1-yvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NzY0Ng==", "bodyText": "waitForLocks should not need to be handled here", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392147646", "createdAt": "2020-03-13T10:33:05Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Ints;\n+import com.palantir.atlasdb.timelock.api.ConjureLockRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+final class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        // The addition of a UUID takes place only at the Conjure level, so we must retry the same request.\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleLockRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    WaitForLocksResponse waitForLocks(WaitForLocksRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MTk2NDc0", "url": "https://github.com/palantir/atlasdb/pull/4645#pullrequestreview-374196474", "createdAt": "2020-03-13T10:34:02Z", "commit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNDowMlrOF1-0sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNDowMlrOF1-0sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE0Nw==", "bodyText": "can we Ints.checkedCast this? This is only likely to be a long if we have a bug.", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392148147", "createdAt": "2020-03-13T10:34:02Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Ints;\n+import com.palantir.atlasdb.timelock.api.ConjureLockRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+final class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        // The addition of a UUID takes place only at the Conjure level, so we must retry the same request.\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleLockRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    WaitForLocksResponse waitForLocks(WaitForLocksRequest request) {\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleWaitForLocksRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    private static ConjureLockRequest clampLockRequestToDeadline(ConjureLockRequest request, Duration remainingTime) {\n+        return ConjureLockRequest.builder()\n+                .from(request)\n+                .acquireTimeoutMs(Ints.saturatedCast(remainingTime.toMillis()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MTk3Njkz", "url": "https://github.com/palantir/atlasdb/pull/4645#pullrequestreview-374197693", "createdAt": "2020-03-13T10:36:04Z", "commit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNjowNVrOF1-4Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNjowNVrOF1-4Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTA3MQ==", "bodyText": "can this be a RuntimeException? Should not see any checked exceptions", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392149071", "createdAt": "2020-03-13T10:36:05Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Ints;\n+import com.palantir.atlasdb.timelock.api.ConjureLockRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+final class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        // The addition of a UUID takes place only at the Conjure level, so we must retry the same request.\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleLockRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    WaitForLocksResponse waitForLocks(WaitForLocksRequest request) {\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleWaitForLocksRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    private static ConjureLockRequest clampLockRequestToDeadline(ConjureLockRequest request, Duration remainingTime) {\n+        return ConjureLockRequest.builder()\n+                .from(request)\n+                .acquireTimeoutMs(Ints.saturatedCast(remainingTime.toMillis()))\n+                .build();\n+    }\n+\n+    private LockResponse performSingleLockRequest(ConjureLockRequest request) {\n+        return namespacedConjureTimelockService\n+                .lock(request)\n+                .accept(ToLeasedLockResponse.INSTANCE);\n+    }\n+\n+    private WaitForLocksResponse performSingleWaitForLocksRequest(ConjureLockRequest request) {\n+        return ConjureLockRequests.fromConjure(namespacedConjureTimelockService.waitForLocks(request));\n+    }\n+\n+    private enum ToLeasedLockResponse implements ConjureLockResponse.Visitor<LockResponse> {\n+        INSTANCE;\n+\n+        @Override\n+        public LockResponse visitSuccessful(SuccessfulLockResponse value) {\n+            return LockResponse.successful(LeasedLockToken.of(value.getLockToken(), value.getLease()));\n+        }\n+\n+        @Override\n+        public LockResponse visitUnsuccessful(UnsuccessfulLockResponse value) {\n+            return LockResponse.timedOut();\n+        }\n+\n+        @Override\n+        public LockResponse visitUnknown(String unknownType) {\n+            throw new SafeIllegalStateException(\"Unknown response type\", SafeArg.of(\"type\", unknownType));\n+        }\n+    }\n+\n+    static class RemoteTimeoutRetryer {\n+        private final Clock clock;\n+\n+        @VisibleForTesting\n+        RemoteTimeoutRetryer(Clock clock) {\n+            this.clock = clock;\n+        }\n+\n+        static BlockEnforcingLockService.RemoteTimeoutRetryer createDefault() {\n+            return new BlockEnforcingLockService.RemoteTimeoutRetryer(Clock.systemUTC());\n+        }\n+\n+        <S, T> T attemptUntilTimeLimitOrException(\n+                S request,\n+                Duration duration,\n+                BiFunction<S, Duration, S> durationLimiter,\n+                Function<S, T> query,\n+                Predicate<T> isTimedOutResponse) {\n+            Instant now = clock.instant();\n+            Instant deadline = now.plus(duration);\n+            S currentRequest = request;\n+            T currentResponse = null;\n+\n+            while (now.isBefore(deadline)) {\n+                Duration remainingTime = Duration.between(now, deadline);\n+                currentRequest = durationLimiter.apply(currentRequest, remainingTime);\n+\n+                try {\n+                    currentResponse = query.apply(currentRequest);\n+                    if (!isTimedOutResponse.test(currentResponse)) {\n+                        return currentResponse;\n+                    }\n+                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MTk4MzI5", "url": "https://github.com/palantir/atlasdb/pull/4645#pullrequestreview-374198329", "createdAt": "2020-03-13T10:37:08Z", "commit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNzowOFrOF1-6RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNzowOFrOF1-6RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTU3Mw==", "bodyText": "is the line above also broken?", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392149573", "createdAt": "2020-03-13T10:37:08Z", "author": {"login": "j-baker"}, "path": "lock-api/src/main/java/com/palantir/lock/client/ConjureLockRequests.java", "diffHunk": "@@ -47,7 +47,7 @@ public static ConjureLockRequest toConjure(WaitForLocksRequest request) {\n         return ConjureLockRequest.builder()\n                 .lockDescriptors(toConjure(request.getLockDescriptors()))\n                 .clientDescription(request.getClientDescription())\n-                .requestId(UUID.randomUUID())\n+                .requestId(request.getRequestId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46d7cb4d52fe404761e243f0a862594c6bba085d", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/46d7cb4d52fe404761e243f0a862594c6bba085d", "committedDate": "2020-03-13T16:26:44Z", "message": "James PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783524d87c7d8f7c76fd88d565dc46dc760e49ea", "author": {"user": {"login": "jeremyk-91", "name": "Jeremy Kong"}}, "url": "https://github.com/palantir/atlasdb/commit/783524d87c7d8f7c76fd88d565dc46dc760e49ea", "committedDate": "2020-03-13T19:39:32Z", "message": "one ete"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NDUwNTAx", "url": "https://github.com/palantir/atlasdb/pull/4645#pullrequestreview-375450501", "createdAt": "2020-03-16T17:50:20Z", "commit": {"oid": "783524d87c7d8f7c76fd88d565dc46dc760e49ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3138, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}