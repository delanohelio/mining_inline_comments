{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0Nzk2Nzc5", "number": 4758, "title": "[PaxosStateLog] Parallel reads and processing", "bodyText": "Goals (and why):\nReading entries one by one is going to be too slow for our migration, at least if we wish to proceed with migration on startup. This PR allows us to parallelise the reads.\nImplementation Description (bullets):\nWe use a fixed thread pool for the lifetime of reader, and do the reads in parallel\nTesting (What was existing testing like?  What have you done to improve it?):\nUnit tests\nConcerns (what feedback would you like?):\nShould we be more defensive, not allow specifying the number of threads? Anything else?\nWhere should we start reviewing?:\nTests?\nPriority (whenever / two weeks / yesterday):\nEarly next week", "createdAt": "2020-05-07T16:35:32Z", "url": "https://github.com/palantir/atlasdb/pull/4758", "merged": true, "mergeCommit": {"oid": "4c3ffbe4c2156096538126e32d652c87b319a2c2"}, "closed": true, "closedAt": "2020-05-12T10:16:12Z", "author": {"login": "gmaretic"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce_mxrgH2gAyNDE0Nzk2Nzc5OmZmNzI4YmExMTRkOWFlYzdiODEzN2ZlZWE1NzZhMWZmZmNjZTZhYzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgSN_hAFqTQwOTMzMTIzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ff728ba114d9aec7b8137feea576a1fffcce6ac9", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/ff728ba114d9aec7b8137feea576a1fffcce6ac9", "committedDate": "2020-05-07T16:10:11Z", "message": "Read faster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/34f4ddabca168b2b5e1da64357db323ebb3b479c", "committedDate": "2020-05-07T16:35:19Z", "message": "Nits"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTYxOTU2", "url": "https://github.com/palantir/atlasdb/pull/4758#pullrequestreview-408161956", "createdAt": "2020-05-08T11:00:29Z", "commit": {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMTowMDoyOVrOGShyDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMTowMDoyOVrOGShyDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MTAzOQ==", "bodyText": "Doesn't #readRound have a exclusive lock in PaxosStateLogImpl? How are you going to rewire this stuff, will there be a different impl just for reading the files that doesn't log?", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r422081039", "createdAt": "2020-05-08T11:00:29Z", "author": {"login": "jkozlowski"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogBatchReader.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.persist.Persistable;\n+\n+public class PaxosStateLogBatchReader<V extends Persistable & Versionable> implements AutoCloseable {\n+    private final PaxosStateLog<V> delegate;\n+    private final Persistable.Hydrator<V> hydrator;\n+    private final ListeningExecutorService executor;\n+\n+    public PaxosStateLogBatchReader(PaxosStateLog<V> delegate, Persistable.Hydrator<V> hydrator, int numThreads) {\n+        this.delegate = delegate;\n+        this.hydrator = hydrator;\n+        this.executor = MoreExecutors.listeningDecorator(\n+                PTExecutors.newFixedThreadPool(numThreads, new NamedThreadFactory(\"psl-reader\", true)));\n+    }\n+\n+    /**\n+     * Reads entries from startSequence (inclusive) to startSequence + numEntries (exclusive) from the delegate log.\n+     *\n+     * @param startSequence first sequence to read\n+     * @param numEntries number of entries to read\n+     * @return a list of paxos rounds for all the present entries in the delegate log\n+     */\n+    public List<PaxosRound<V>> readBatch(long startSequence, int numEntries) {\n+        return AtlasFutures.getUnchecked(\n+                Futures.allAsList(\n+                        LongStream.range(startSequence, startSequence + numEntries)\n+                                .mapToObj(sequence -> executor.submit(() -> singleRead(sequence)))\n+                                .collect(Collectors.toList())))\n+                .stream()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Optional<PaxosRound<V>> singleRead(long sequence) {\n+        try {\n+            return Optional.ofNullable(delegate.readRound(sequence))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MjA4OTkw", "url": "https://github.com/palantir/atlasdb/pull/4758#pullrequestreview-409208990", "createdAt": "2020-05-11T14:10:23Z", "commit": {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNDoxMDoyM1rOGTd_6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNDoxMTo1N1rOGTeD5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2NzYyNw==", "bodyText": "nit: might be worth extracting a local predicate", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r423067627", "createdAt": "2020-05-11T14:10:23Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/test/java/com/palantir/paxos/PaxosStateLogBatchReaderTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+public class PaxosStateLogBatchReaderTest {\n+    private static final int START_SEQUENCE = 123;\n+    private static final int BATCH_SIZE = 250;\n+    private static final List<PaxosRound<PaxosValue>> EXPECTED_ROUNDS = LongStream\n+            .range(START_SEQUENCE, START_SEQUENCE + BATCH_SIZE)\n+            .mapToObj(PaxosStateLogBatchReaderTest::valueForRound)\n+            .map(value -> PaxosRound.of(value.seq, value))\n+            .collect(Collectors.toList());\n+\n+    private PaxosStateLog<PaxosValue> mockLog = mock(PaxosStateLog.class);\n+\n+    @Test\n+    public void readConsecutiveBatch() throws IOException {\n+        when(mockLog.readRound(anyLong()))\n+                .thenAnswer(invocation -> valueForRound((long) invocation.getArguments()[0]).persistToBytes());\n+\n+        try (PaxosStateLogBatchReader<PaxosValue> reader = createReader()) {\n+            assertThat(reader.readBatch(START_SEQUENCE, BATCH_SIZE)).isEqualTo(EXPECTED_ROUNDS);\n+        }\n+    }\n+\n+    @Test\n+    public void exceptionsArePropagated() throws IOException {\n+        IOException ioException = new IOException(\"test\");\n+        when(mockLog.readRound(anyLong()))\n+                .thenAnswer(invocation -> {\n+                    long sequence = (long) invocation.getArguments()[0];\n+                    if (sequence == 200) {\n+                        throw ioException;\n+                    }\n+                    return valueForRound(sequence).persistToBytes();\n+                });\n+\n+        try (PaxosStateLogBatchReader<PaxosValue> reader = createReader()) {\n+            assertThatThrownBy(() -> reader.readBatch(START_SEQUENCE, BATCH_SIZE)).isInstanceOf(RuntimeException.class);\n+        }\n+    }\n+\n+    @Test\n+    public void readBatchFiltersOutNulls() throws IOException {\n+        when(mockLog.readRound(anyLong()))\n+                .thenAnswer(invocation -> {\n+                    long sequence = (long) invocation.getArguments()[0];\n+                    if (sequence % 2 == 0) {\n+                        return null;\n+                    }\n+                    return valueForRound(sequence).persistToBytes();\n+                });\n+\n+        try (PaxosStateLogBatchReader<PaxosValue> reader = createReader()) {\n+            assertThat(reader.readBatch(START_SEQUENCE, BATCH_SIZE))\n+                    .isEqualTo(EXPECTED_ROUNDS.stream()\n+                            .filter(round -> round.sequence() % 2 != 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA2ODY0Ng==", "bodyText": "Yep, I think we should be good to change that to a R/W lock (though be careful when reading that class to make sure it's safe!)", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r423068646", "createdAt": "2020-05-11T14:11:57Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogBatchReader.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.common.persist.Persistable;\n+\n+public class PaxosStateLogBatchReader<V extends Persistable & Versionable> implements AutoCloseable {\n+    private final PaxosStateLog<V> delegate;\n+    private final Persistable.Hydrator<V> hydrator;\n+    private final ListeningExecutorService executor;\n+\n+    public PaxosStateLogBatchReader(PaxosStateLog<V> delegate, Persistable.Hydrator<V> hydrator, int numThreads) {\n+        this.delegate = delegate;\n+        this.hydrator = hydrator;\n+        this.executor = MoreExecutors.listeningDecorator(\n+                PTExecutors.newFixedThreadPool(numThreads, new NamedThreadFactory(\"psl-reader\", true)));\n+    }\n+\n+    /**\n+     * Reads entries from startSequence (inclusive) to startSequence + numEntries (exclusive) from the delegate log.\n+     *\n+     * @param startSequence first sequence to read\n+     * @param numEntries number of entries to read\n+     * @return a list of paxos rounds for all the present entries in the delegate log\n+     */\n+    public List<PaxosRound<V>> readBatch(long startSequence, int numEntries) {\n+        return AtlasFutures.getUnchecked(\n+                Futures.allAsList(\n+                        LongStream.range(startSequence, startSequence + numEntries)\n+                                .mapToObj(sequence -> executor.submit(() -> singleRead(sequence)))\n+                                .collect(Collectors.toList())))\n+                .stream()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Optional<PaxosRound<V>> singleRead(long sequence) {\n+        try {\n+            return Optional.ofNullable(delegate.readRound(sequence))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4MTAzOQ=="}, "originalCommit": {"oid": "34f4ddabca168b2b5e1da64357db323ebb3b479c"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e6658fbfef28e7c3073b1f6afc8a371dfbbf5d3", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/2e6658fbfef28e7c3073b1f6afc8a371dfbbf5d3", "committedDate": "2020-05-11T14:33:34Z", "message": "Fix locking in PSLImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e", "committedDate": "2020-05-11T14:33:34Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5Mjc3MTE3", "url": "https://github.com/palantir/atlasdb/pull/4758#pullrequestreview-409277117", "createdAt": "2020-05-11T15:22:37Z", "commit": {"oid": "89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNToyMjozN1rOGThMjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNToyMjozN1rOGThMjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzEyMDAxNQ==", "bodyText": "Hmm. Could we put @GuardedBy(\"lock.writeLock()\"), or more defensively and probably better make this a concurrent hash map? Right now it's fine, but if later on a reader tries to use this (e.g. for caching) then memory visibility becomes a bit tricky.", "url": "https://github.com/palantir/atlasdb/pull/4758#discussion_r423120015", "createdAt": "2020-05-11T15:22:37Z", "author": {"login": "jeremyk-91"}, "path": "leader-election-impl/src/main/java/com/palantir/paxos/PaxosStateLogImpl.java", "diffHunk": "@@ -50,7 +51,7 @@\n \n public class PaxosStateLogImpl<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n \n-    private final ReentrantLock lock = new ReentrantLock();\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n     private final Map<Long, Long> seqToVersionMap = Maps.newHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e8a0dfb7f7c82aa6072b1d0bbab992bb45729e"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85f1f93c8f04bddbb2dd9473635e92eeb0c0d936", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/85f1f93c8f04bddbb2dd9473635e92eeb0c0d936", "committedDate": "2020-05-11T15:49:28Z", "message": "CR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a36f88888bd34221993e807c701abea8fc690f31", "author": {"user": {"login": "gmaretic", "name": null}}, "url": "https://github.com/palantir/atlasdb/commit/a36f88888bd34221993e807c701abea8fc690f31", "committedDate": "2020-05-11T16:19:48Z", "message": "Make map concurrent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzMxMjM2", "url": "https://github.com/palantir/atlasdb/pull/4758#pullrequestreview-409331236", "createdAt": "2020-05-11T16:25:14Z", "commit": {"oid": "a36f88888bd34221993e807c701abea8fc690f31"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2819, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}