{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMTY0MDA3", "number": 1523, "title": "Query Engine and Aggregation Store Changes for Multi Data Source Support", "bodyText": "One of the multiple PRs that will resolve #1465\nDescription\nAggregation DataStore: Use JDBC instead of JPA and support multiple datasources.\nMotivation and Context\nPlease refer #1465\nHow Has This Been Tested?\nExisting Tests Pass\nNew Tests included.\nLicense\nI confirm that this contribution is made under an Apache 2.0 license and that I have the authority necessary to make this contribution on behalf of its copyright owner.", "createdAt": "2020-09-08T16:31:37Z", "url": "https://github.com/yahoo/elide/pull/1523", "merged": true, "mergeCommit": {"oid": "39cd981fe2f8ecb473bf35f01b254898fbc091eb"}, "closed": true, "closedAt": "2020-09-17T18:09:10Z", "author": {"login": "rishi-aga"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG6q_fAFqTQ4NDMzMjU4Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJz-OsgFqTQ5MDgwNDU5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzMyNTg3", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-484332587", "createdAt": "2020-09-08T17:02:13Z", "commit": {"oid": "33066ea45b06474cf68125d9bea8663fc9406d15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzowMjoxM1rOHOmQhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzowMjoxM1rOHOmQhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2ODkzNA==", "bodyText": "I think ENUM would be better in the long run.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485068934", "createdAt": "2020-09-08T17:02:13Z", "author": {"login": "moizarafat"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/resources/elideDBConfigSchema.json", "diffHunk": "@@ -70,9 +70,9 @@\n                         \"type\": \"string\",\n                         \"title\": \"Elide Dialect\",\n                         \"description\": \"The Elide Dialect to use for query generation.\",\n-                        \"pattern\": \"^([0-9A-Za-z_]+[.]?)+$\",\n+                        \"pattern\": \"^([h|H]2|[h|H][i|I][v|V][e|E]|[p|P][r|R][e|E][s|S][t|T][o|O])$\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33066ea45b06474cf68125d9bea8663fc9406d15"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzQwMTM1", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-484340135", "createdAt": "2020-09-08T17:12:40Z", "commit": {"oid": "33066ea45b06474cf68125d9bea8663fc9406d15"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzoxMjo0MFrOHOmnNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzoxMjo0MFrOHOmnNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3NDc0MA==", "bodyText": "since there are no plans to support this, we can remove it from here and the abstract class.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485074740", "createdAt": "2020-09-08T17:12:40Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLEntityHydrator.java", "diffHunk": "@@ -9,78 +9,37 @@\n import com.yahoo.elide.datastores.aggregation.QueryEngine;\n import com.yahoo.elide.datastores.aggregation.query.Query;\n import com.yahoo.elide.datastores.aggregation.queryengines.AbstractEntityHydrator;\n-import com.yahoo.elide.utils.coerce.CoerceUtil;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n \n-import java.util.AbstractMap;\n+import java.sql.ResultSet;\n import java.util.Collections;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.persistence.EntityManager;\n \n /**\n  * {@link SQLEntityHydrator} hydrates the entity loaded by\n  * {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}.\n  */\n public class SQLEntityHydrator extends AbstractEntityHydrator {\n \n-    @Getter(AccessLevel.PRIVATE)\n-    private final EntityManager entityManager;\n-\n     /**\n      * Constructor.\n      *\n      * @param results The loaded objects from {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}\n      * @param query  The query passed to {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)} to load the\n      *               objects\n      * @param entityDictionary  An object that sets entity instance values and provides entity metadata info\n-     * @param entityManager  An service that issues JPQL queries to load relationship objects\n      */\n     public SQLEntityHydrator(\n-            List<Object> results,\n+            ResultSet results,\n             Query query,\n-            EntityDictionary entityDictionary,\n-            EntityManager entityManager\n+            EntityDictionary entityDictionary\n     ) {\n         super(results, query, entityDictionary);\n-        this.entityManager = entityManager;\n     }\n \n     @Override\n-    protected Map<Object, Object> getRelationshipValues(\n-            Class<?> relationshipType,\n-            List<Object> joinFieldIds\n-    ) {\n-        if (joinFieldIds.isEmpty()) {\n-            return Collections.emptyMap();\n-        }\n-\n-        List<Object> uniqueIds = joinFieldIds.stream()\n-                .distinct()\n-                .collect(Collectors.toCollection(LinkedList::new));\n-\n-        List<Object> loaded = getEntityManager()\n-                .createQuery(\n-                        String.format(\n-                                \"SELECT e FROM %s e WHERE %s IN (:idList)\",\n-                                relationshipType.getCanonicalName(),\n-                                getEntityDictionary().getIdFieldName(relationshipType)\n-                        )\n-                )\n-                .setParameter(\"idList\", uniqueIds)\n-                .getResultList();\n-\n-        return loaded.stream()\n-                .map(obj -> new AbstractMap.SimpleImmutableEntry<>(\n-                        CoerceUtil.coerce(\n-                                (Object) getEntityDictionary().getId(obj),\n-                                getEntityDictionary().getIdType(relationshipType)\n-                        ),\n-                        obj))\n-                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    protected Map<Object, Object> getRelationshipValues(Class<?> relationshipType, List<Object> joinFieldIds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33066ea45b06474cf68125d9bea8663fc9406d15"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTU4NzIy", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-484558722", "createdAt": "2020-09-08T23:24:48Z", "commit": {"oid": "33066ea45b06474cf68125d9bea8663fc9406d15"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMzoyNDo0OFrOHOxOlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMzo1OToxNVrOHOx3GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0ODY2Mw==", "bodyText": "should we close the connection before throwing the exception or connection close is going to be handled some place else?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485248663", "createdAt": "2020-09-08T23:24:48Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +144,209 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private final Connection conn;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+        private final SQLDialect dialect;\n+\n+        SqlTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n+            stmts.forEach(stmt -> {\n+                try {\n+                    if (stmt != null && !stmt.isClosed()) {\n+                        stmt.close();\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33066ea45b06474cf68125d9bea8663fc9406d15"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1MDA3MA==", "bodyText": "Same as above, we should close the connection as well.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485250070", "createdAt": "2020-09-08T23:29:31Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +144,209 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private final Connection conn;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+        private final SQLDialect dialect;\n+\n+        SqlTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n+            stmts.forEach(stmt -> {\n+                try {\n+                    if (stmt != null && !stmt.isClosed()) {\n+                        stmt.close();\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+            try {\n+                if (conn != null) {\n+                    conn.close();\n+                }\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> {\n+                try {\n+                    if (stmt != null && !stmt.isClosed()) {\n+                        stmt.cancel();\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalStateException(e);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDE5OA==", "bodyText": "Lets check with Aaron, I think this method seems very specific to SQLQueryEngine, so not a good candidate to be included in the interface here. We can just have it created and used in SQLQuery Engine itself.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485254198", "createdAt": "2020-09-08T23:43:02Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -167,6 +167,8 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n \n     public abstract Transaction beginTransaction();\n \n+    public abstract Transaction beginTransaction(String dbConnectionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDI1NQ==", "bodyText": "Same comment as other method.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485254255", "createdAt": "2020-09-08T23:43:16Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -219,4 +221,13 @@ public Table getTable(TableId tableId) {\n      */\n     public abstract List<String> explain(Query query);\n \n+    /**\n+     * Returns the actual query string(s) that would be executed for the input {@link Query}.\n+     *\n+     * @param query The query customized for a particular persistent storage or storage client.\n+     * @param connectionName Connection Name for this storage\n+     * @return List of SQL string(s) corresponding to the given query.\n+     */\n+    public abstract List<String> explain(Query query, String connectionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NTYxNg==", "bodyText": "\" OFFSET \"  and \" LIMIT \" can be made static variables and reused.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485255616", "createdAt": "2020-09-08T23:47:47Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/AbstractSqlDialect.java", "diffHunk": "@@ -14,7 +14,13 @@ public boolean useAliasForOrderByClause() {\n         return false;\n     }\n \n+    @Override\n     public String generateCountDistinctClause(String dimensions) {\n         return String.format(\"COUNT(DISTINCT(%s))\", dimensions);\n     }\n+\n+    @Override\n+    public String appendOffsetLimit(String sql, int offset, int limit) {\n+        return sql + \" OFFSET \" + offset + \" LIMIT \" + limit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1Nzk2OA==", "bodyText": "this could call the constructor with 4 args instead.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485257968", "createdAt": "2020-09-08T23:55:42Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/AggregationDataStoreTestHarness.java", "diffHunk": "@@ -11,31 +11,49 @@\n import com.yahoo.elide.datastores.aggregation.core.NoopQueryLogger;\n import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n import com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.SQLDialectFactory;\n import com.yahoo.elide.datastores.jpa.JpaDataStore;\n import com.yahoo.elide.datastores.jpa.transaction.NonJtaTransaction;\n import com.yahoo.elide.datastores.multiplex.MultiplexManager;\n \n import org.hibernate.Session;\n \n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.function.Consumer;\n \n import javax.persistence.EntityManager;\n import javax.persistence.EntityManagerFactory;\n+import javax.sql.DataSource;\n \n+@AllArgsConstructor\n public class AggregationDataStoreTestHarness implements DataStoreTestHarness {\n     private EntityManagerFactory entityManagerFactory;\n+    private DataSource defaultDataSource;\n+    private Map<String, DataSource> dataSourceMap;\n+    private String defaultDialect;\n+    private Map<String, String> dialectMap;\n+\n+    public AggregationDataStoreTestHarness(EntityManagerFactory entityManagerFactory, DataSource defaultDataSource) {\n+        this(entityManagerFactory, defaultDataSource, Collections.emptyMap(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTAzMw==", "bodyText": "This can still take Argument of Type SQLDialect", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485259033", "createdAt": "2020-09-08T23:59:15Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -298,14 +299,19 @@ public Query getQuery() {\n \n     protected Pattern repeatedWhitespacePattern = Pattern.compile(\"\\\\s\\\\s*\");\n \n-    public static void init(SQLDialect sqlDialect) {\n+    public static void init(String sqlDialect) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MDE4NDM0", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-486018434", "createdAt": "2020-09-10T14:50:39Z", "commit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDo1MDozOVrOHP36PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyMToxN1rOHP5UgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwNjcxNw==", "bodyText": "Cleaner to have a single map that stores a new class that includes both the data source and its dialect.  Then there is no way for state to get out of sync.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486406717", "createdAt": "2020-09-10T14:50:39Z", "author": {"login": "aklish"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ElideDynamicEntityCompiler.java", "diffHunk": "@@ -41,6 +47,8 @@\n \n     private Map<String, String> tableClasses = new HashMap<String, String>();\n     private Map<String, String> securityClasses = new HashMap<String, String>();\n+    @Getter private final Map<String, DataSource> dataSourceMap = new HashMap<String, DataSource>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwODYwMA==", "bodyText": "A fixed enum makes this hard to extend if someone wants to customize for their own database.  I would recommend we configure the elide Dialect class here.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486408600", "createdAt": "2020-09-10T14:53:08Z", "author": {"login": "aklish"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/resources/elideDBConfigSchema.json", "diffHunk": "@@ -70,9 +70,13 @@\n                         \"type\": \"string\",\n                         \"title\": \"Elide Dialect\",\n                         \"description\": \"The Elide Dialect to use for query generation.\",\n-                        \"pattern\": \"^([0-9A-Za-z_]+[.]?)+$\",\n+                        \"enum\": [\n+                            \"HIVE\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMTcyMQ==", "bodyText": "I tend to agree with Moiz.  Everything inside dynamic config is tightly coupled with with the SQLQueryEngine.  Other query engines might have a totally different configuration (like Fili for example).", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486411721", "createdAt": "2020-09-10T14:57:15Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -167,6 +167,8 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n \n     public abstract Transaction beginTransaction();\n \n+    public abstract Transaction beginTransaction(String dbConnectionName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDE5OA=="}, "originalCommit": {"oid": "2cb30cf498da691be1dec47cbf872296f18249cc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMjM5OQ==", "bodyText": "I don't think we need the stitchList anymore - that was for populating relationships.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486412399", "createdAt": "2020-09-10T14:58:10Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/AbstractEntityHydrator.java", "diffHunk": "@@ -86,48 +88,37 @@ public AbstractEntityHydrator(List<Object> results, Query query, EntityDictionar\n         });\n     }\n \n-    /**\n-     * Loads a map of relationship object ID to relationship object instance.\n-     * <p>\n-     * Note the relationship cannot be toMany. This method will be invoked for every relationship field of the\n-     * requested entity. Its implementation should return the result of the following query\n-     * <p>\n-     * <b>Given a relationship with type {@code relationshipType} in an entity, loads all relationship\n-     * objects whose foreign keys are one of the specified list, {@code joinFieldIds}</b>.\n-     * <p>\n-     * For example, when the relationship is loaded from SQL and we have the following example identity:\n-     * <pre>\n-     * public class PlayerStats {\n-     *     private String id;\n-     *     private Country country;\n-     *\n-     *     &#64;OneToOne\n-     *     &#64;JoinColumn(name = \"country_id\")\n-     *     public Country getCountry() {\n-     *         return country;\n-     *     }\n-     * }\n-     * </pre>\n-     * In this case {@code relationshipType = Country.class}. If {@code country} is\n-     * requested in {@code PlayerStats} query and 3 stats, for example, are found in database whose country ID's are\n-     * {@code joinFieldIds = [840, 344, 840]}, then this method should effectively run the following query (JPQL as\n-     * example)\n-     * <pre>\n-     * {@code\n-     *     SELECT e FROM country_table e WHERE country_id IN (840, 344);\n-     * }\n-     * </pre>\n-     * and returns the map of [840: Country(id:840), 344: Country(id:344)]\n-     *\n-     * @param relationshipType  The type of relationship\n-     * @param joinFieldIds  The specified list of join ID's against the relationship\n-     *\n-     * @return a list of hydrating values\n-     */\n-    protected abstract Map<Object, Object> getRelationshipValues(\n-            Class<?> relationshipType,\n-            List<Object> joinFieldIds\n-    );\n+    public AbstractEntityHydrator(ResultSet rs, Query query, EntityDictionary entityDictionary) {\n+        this.stitchList = new StitchList(entityDictionary);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMzk0MQ==", "bodyText": "Why do we still need an entityManagerFactory if we are using Hikari and JDBC directly?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486413941", "createdAt": "2020-09-10T15:00:14Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/AggregationDataStoreTestHarness.java", "diffHunk": "@@ -11,31 +11,48 @@\n import com.yahoo.elide.datastores.aggregation.core.NoopQueryLogger;\n import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n import com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.SQLDialectFactory;\n import com.yahoo.elide.datastores.jpa.JpaDataStore;\n import com.yahoo.elide.datastores.jpa.transaction.NonJtaTransaction;\n import com.yahoo.elide.datastores.multiplex.MultiplexManager;\n \n import org.hibernate.Session;\n \n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.function.Consumer;\n \n import javax.persistence.EntityManager;\n import javax.persistence.EntityManagerFactory;\n+import javax.sql.DataSource;\n \n+@AllArgsConstructor\n public class AggregationDataStoreTestHarness implements DataStoreTestHarness {\n     private EntityManagerFactory entityManagerFactory;\n+    private DataSource defaultDataSource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjM5NQ==", "bodyText": "Maybe we can merge this with AbstractEntityHyrdator now that this doesn't do anything.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486416395", "createdAt": "2020-09-10T15:03:36Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLEntityHydrator.java", "diffHunk": "@@ -9,78 +9,28 @@\n import com.yahoo.elide.datastores.aggregation.QueryEngine;\n import com.yahoo.elide.datastores.aggregation.query.Query;\n import com.yahoo.elide.datastores.aggregation.queryengines.AbstractEntityHydrator;\n-import com.yahoo.elide.utils.coerce.CoerceUtil;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n \n-import java.util.AbstractMap;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.persistence.EntityManager;\n+import java.sql.ResultSet;\n \n /**\n  * {@link SQLEntityHydrator} hydrates the entity loaded by\n  * {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}.\n  */\n public class SQLEntityHydrator extends AbstractEntityHydrator {\n \n-    @Getter(AccessLevel.PRIVATE)\n-    private final EntityManager entityManager;\n-\n     /**\n      * Constructor.\n      *\n      * @param results The loaded objects from {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}\n      * @param query  The query passed to {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)} to load the\n      *               objects\n      * @param entityDictionary  An object that sets entity instance values and provides entity metadata info\n-     * @param entityManager  An service that issues JPQL queries to load relationship objects\n      */\n     public SQLEntityHydrator(\n-            List<Object> results,\n+            ResultSet results,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjg1Mg==", "bodyText": "We can just call it EntityHydrator.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486416852", "createdAt": "2020-09-10T15:04:14Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLEntityHydrator.java", "diffHunk": "@@ -9,78 +9,28 @@\n import com.yahoo.elide.datastores.aggregation.QueryEngine;\n import com.yahoo.elide.datastores.aggregation.query.Query;\n import com.yahoo.elide.datastores.aggregation.queryengines.AbstractEntityHydrator;\n-import com.yahoo.elide.utils.coerce.CoerceUtil;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n \n-import java.util.AbstractMap;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.persistence.EntityManager;\n+import java.sql.ResultSet;\n \n /**\n  * {@link SQLEntityHydrator} hydrates the entity loaded by\n  * {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}.\n  */\n public class SQLEntityHydrator extends AbstractEntityHydrator {\n \n-    @Getter(AccessLevel.PRIVATE)\n-    private final EntityManager entityManager;\n-\n     /**\n      * Constructor.\n      *\n      * @param results The loaded objects from {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}\n      * @param query  The query passed to {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)} to load the\n      *               objects\n      * @param entityDictionary  An object that sets entity instance values and provides entity metadata info\n-     * @param entityManager  An service that issues JPQL queries to load relationship objects\n      */\n     public SQLEntityHydrator(\n-            List<Object> results,\n+            ResultSet results,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjM5NQ=="}, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyMzAyNg==", "bodyText": "You could commonize this code with a template function that takes another function with a result set argument\n<T> runQuery(String query, Function<ResultSet, T> resultSetMapper)\nor something along those lines.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486423026", "createdAt": "2020-09-10T15:12:27Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +144,187 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private final Connection conn;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+        private final SQLDialect dialect;\n+\n+        SqlTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction(defaultDataSource, defaultDialect);\n+    }\n+\n+    @Override\n+    public Transaction beginTransaction(String dbConnectionName) {\n+        DataSource dataSource = Optional.ofNullable(dataSourceMap.get(dbConnectionName))\n+                        .orElseThrow(() -> new IllegalStateException(\n+                                        \"DataSource or DB Configuration undefined for DB Connection Name: \"\n+                                                        + dbConnectionName));\n+        SQLDialect dialect = Optional.ofNullable(dialectMap.get(dbConnectionName))\n+                        .orElseThrow(() -> new IllegalStateException(\n+                                        \"SQL Dialect Type undefined for DB Connection Name: \"\n+                                                        + dbConnectionName));\n+        return new SqlTransaction(dataSource, dialect);\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+        SQLDialect dialect = sqlTransaction.dialect;\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());\n             if (pagination.returnPageTotals()) {\n-                resultBuilder.pageTotals(getPageTotal(query, sql, entityManager));\n+                resultBuilder.pageTotals(getPageTotal(query, sql, sqlTransaction));\n             }\n         }\n \n+        log.debug(\"SQL Query: \" + queryString);\n+        stmt = sqlTransaction.initializeStatement(queryString);\n+\n         // Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, jpaQuery);\n+        supplyFilterQueryParameters(query, stmt);\n \n         // Run the primary query and log the time spent.\n-        List<Object> results = new TimedFunction<List<Object>>(\n-                () -> jpaQuery.setHint(QueryHints.HINT_READONLY, true).getResultList(),\n-                \"Running Query: \" + queryString).get();\n+        ResultSet resultSet = new TimedFunction<ResultSet>(() -> {\n+            try {\n+                return stmt.executeQuery();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + queryString\n+        ).get();\n \n-        resultBuilder.data(new SQLEntityHydrator(results, query, getMetadataDictionary(), entityManager).hydrate());\n+        resultBuilder.data(new SQLEntityHydrator(resultSet, query, getMetadataDictionary()).hydrate());\n         return resultBuilder.build();\n     }\n \n-    private long getPageTotal(Query query, SQLQuery sql, EntityManager entityManager) {\n-        String paginationSQL = toPageTotalSQL(sql, dialect).toString();\n-\n-        javax.persistence.Query pageTotalQuery =\n-                entityManager.createNativeQuery(paginationSQL)\n-                        .setHint(QueryHints.HINT_READONLY, true);\n+    private long getPageTotal(Query query, SQLQuery sql, SqlTransaction sqlTransaction) {\n+        String paginationSQL = toPageTotalSQL(sql, sqlTransaction.dialect).toString();\n \n-        //Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, pageTotalQuery);\n+        NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(paginationSQL);\n \n-        //Run the Pagination query and log the time spent.\n-        return new TimedFunction<>(\n-                () -> CoerceUtil.coerce(pageTotalQuery.getSingleResult(), Long.class),\n-                \"Running Query: \" + paginationSQL\n+        // Supply the query parameters to the query\n+        supplyFilterQueryParameters(query, stmt);\n+\n+        // Run the Pagination query and log the time spent.\n+        return new TimedFunction<>(() -> {\n+            try {\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    return rs.getLong(1);\n+                } else {\n+                    return null;\n+                }\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + paginationSQL\n         ).get();\n     }\n \n     @Override\n     public String getTableVersion(Table table, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n \n         String tableVersion = null;\n         Class<?> tableClass = getMetadataDictionary().getEntityClass(table.getName(), table.getVersion());\n         VersionQuery versionAnnotation = tableClass.getAnnotation(VersionQuery.class);\n         if (versionAnnotation != null) {\n             String versionQueryString = versionAnnotation.sql();\n-            javax.persistence.Query versionQuery =\n-                    entityManager.createNativeQuery(versionQueryString)\n-                            .setHint(QueryHints.HINT_READONLY, true);\n-            tableVersion = new TimedFunction<>(\n-                    () -> CoerceUtil.coerce(versionQuery.getSingleResult(), String.class),\n-                    \"Running Query: \" + versionQueryString\n+            NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(versionQueryString);\n+            tableVersion = new TimedFunction<>(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNDU1Ng==", "bodyText": "Instead of instantiation via string name, we could pass the class name here and use reflection to load the dialect like a plugin.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486424556", "createdAt": "2020-09-10T15:14:33Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/SQLDialectFactory.java", "diffHunk": "@@ -13,19 +13,36 @@\n  * A class with static methods to create an instance of all Dialects.\n  */\n public class SQLDialectFactory {\n+\n+    private static final SQLDialect H2_DIALECT = new H2Dialect();\n+    private static final SQLDialect HIVE_DIALECT = new HiveDialect();\n+    private static final SQLDialect PRESTO_DIALECT = new PrestoDialect();\n+\n     public static SQLDialect getDefaultDialect() {\n-        return new H2Dialect();\n+        return getH2Dialect();\n     }\n \n     public static SQLDialect getH2Dialect() {\n-        return new H2Dialect();\n+        return H2_DIALECT;\n     }\n \n     public static SQLDialect getHiveDialect() {\n-        return new HiveDialect();\n+        return HIVE_DIALECT;\n     }\n \n     public static SQLDialect getPrestoDialect() {\n-        return new PrestoDialect();\n+        return PRESTO_DIALECT;\n+    }\n+\n+    public static SQLDialect getDialect(String type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNjIxNQ==", "bodyText": "Can you explain what this is for?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486426215", "createdAt": "2020-09-10T15:16:44Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -74,8 +76,10 @@ public static void beforeAllTests() {\n     }\n \n     @BeforeEach\n-    public void setUp() {\n-        when(queryEngine.beginTransaction()).thenReturn(qeTransaction);\n+    public void setUp(TestInfo info) {\n+        if (!info.getTags().contains(\"SkipBeforeEach\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ==", "bodyText": "It would be nice if we removed all the entity manager factory code from Aggregation Store and its tests.  We should just use JDBC directly.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486428565", "createdAt": "2020-09-10T15:19:39Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -298,14 +299,19 @@ public Query getQuery() {\n \n     protected Pattern repeatedWhitespacePattern = Pattern.compile(\"\\\\s\\\\s*\");\n \n-    public static void init(SQLDialect sqlDialect) {\n+    public static void init(String sqlDialect) {\n         emf = Persistence.createEntityManagerFactory(\"aggregationStore\");\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n         em.createNativeQuery(\"DROP ALL OBJECTS;\").executeUpdate();\n         em.createNativeQuery(\"RUNSCRIPT FROM 'classpath:create_tables.sql'\").executeUpdate();\n         em.getTransaction().commit();\n \n+        HikariConfig config = new HikariConfig();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyOTgyNQ==", "bodyText": "This looks like a problem.  EntityManager had a way to cancel a query and tear down the resources.  Is there a way to do something similar with JDBC?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486429825", "createdAt": "2020-09-10T15:21:17Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -321,8 +327,8 @@ public static void init(SQLDialect sqlDialect) {\n         filterParser = new RSQLFilterDialect(dictionary);\n \n         metaDataStore.populateEntityDictionary(dictionary);\n-        Consumer<EntityManager> txCancel = (entityManager) -> { entityManager.unwrap(Session.class).cancelQuery(); };\n-        engine = new SQLQueryEngine(metaDataStore, emf, txCancel, sqlDialect);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTM1MDA2", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-486935006", "createdAt": "2020-09-11T16:03:50Z", "commit": {"oid": "a9c968d8f1496f42508f6faeed562104aafa97c9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjowMzo1MFrOHQk0_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjoxMjoyM1rOHQlHug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjY1Mw==", "bodyText": "I can see why you switched to enums earlier.  \"com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.impl.HiveDialect\" is a beast to type in.\nMaybe we can have the best of both worlds - an enum for dialects we support - and the ability to override with a custom class.  I'm fine if we want to make that work a separate PR.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487142653", "createdAt": "2020-09-11T16:03:50Z", "author": {"login": "aklish"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/resources/elideDBConfigSchema.json", "diffHunk": "@@ -128,7 +128,7 @@\n                     \"url\": \"jdbc:mysql://localhost/elide?serverTimezone=UTC\",\n                     \"driver\": \"com.mysql.jdbc.Driver\",\n                     \"user\": \"guest1\",\n-                    \"dialect\": \"org.hibernate.dialect.MySQL5Dialect\"\n+                    \"dialect\": \"com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.impl.HiveDialect\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9c968d8f1496f42508f6faeed562104aafa97c9"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NDM0MA==", "bodyText": "Why are we doing this here?  I don't think we want AggregationDataStore to know about its subclasses.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487144340", "createdAt": "2020-09-11T16:06:42Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/AggregationDataStore.java", "diffHunk": "@@ -63,6 +65,9 @@ public void populateEntityDictionary(EntityDictionary dictionary) {\n \n     @Override\n     public DataStoreTransaction beginTransaction() {\n-        return new AggregationDataStoreTransaction(queryEngine, cache, queryLogger);\n+        if (queryEngine.getClass().equals(SQLQueryEngine.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9c968d8f1496f42508f6faeed562104aafa97c9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NjI1Nw==", "bodyText": "Can we use an HJSON config for that?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487146257", "createdAt": "2020-09-11T16:10:09Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -298,14 +299,19 @@ public Query getQuery() {\n \n     protected Pattern repeatedWhitespacePattern = Pattern.compile(\"\\\\s\\\\s*\");\n \n-    public static void init(SQLDialect sqlDialect) {\n+    public static void init(String sqlDialect) {\n         emf = Persistence.createEntityManagerFactory(\"aggregationStore\");\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n         em.createNativeQuery(\"DROP ALL OBJECTS;\").executeUpdate();\n         em.createNativeQuery(\"RUNSCRIPT FROM 'classpath:create_tables.sql'\").executeUpdate();\n         em.getTransaction().commit();\n \n+        HikariConfig config = new HikariConfig();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ=="}, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0Njk1Nw==", "bodyText": "If persistence.xml is just using H2 database, there is a way to run scripts using H2 script runner - or alternatively you can run a script in the JDBC connection URL.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487146957", "createdAt": "2020-09-11T16:11:29Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -298,14 +299,19 @@ public Query getQuery() {\n \n     protected Pattern repeatedWhitespacePattern = Pattern.compile(\"\\\\s\\\\s*\");\n \n-    public static void init(SQLDialect sqlDialect) {\n+    public static void init(String sqlDialect) {\n         emf = Persistence.createEntityManagerFactory(\"aggregationStore\");\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n         em.createNativeQuery(\"DROP ALL OBJECTS;\").executeUpdate();\n         em.createNativeQuery(\"RUNSCRIPT FROM 'classpath:create_tables.sql'\").executeUpdate();\n         em.getTransaction().commit();\n \n+        HikariConfig config = new HikariConfig();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ=="}, "originalCommit": {"oid": "1dea9221e4970c498c5b51e96ca6a46302f2ba75"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzQ1MA==", "bodyText": "What does this do?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487147450", "createdAt": "2020-09-11T16:12:23Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -255,6 +260,7 @@ public void loadObjectsExceptionThrownTest() throws Exception {\n     }\n \n     @Test\n+    @MockitoSettings(strictness = Strictness.LENIENT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9c968d8f1496f42508f6faeed562104aafa97c9"}, "originalPosition": 54}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "deed5daef302ec92db7b3ae36855326741823d2a", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/deed5daef302ec92db7b3ae36855326741823d2a", "committedDate": "2020-09-11T18:12:05Z", "message": "Revert changes to AggregationDataStore and AggregationDataStoreTransaction"}, "afterCommit": {"oid": "4a6ebd4628c5c937e91081de9405ab861f97e366", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/4a6ebd4628c5c937e91081de9405ab861f97e366", "committedDate": "2020-09-11T21:55:40Z", "message": "Rebased and fix MetaDataStoreIntegrationTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTQ5NTMz", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-488949533", "createdAt": "2020-09-15T18:23:47Z", "commit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODoyMzo0OFrOHSOg2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODoyMzo0OFrOHSOg2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NDIwMg==", "bodyText": "May be the dialect should be renamed to PrestoDB dialect to highlight the fact that we have 2 flavors of Presto?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488874202", "createdAt": "2020-09-15T18:23:48Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/impl/PrestoDialect.java", "diffHunk": "@@ -20,4 +20,10 @@ public String getDialectType() {\n     public boolean useAliasForOrderByClause() {\n         return true;\n     }\n+\n+    @Override\n+    public String appendOffsetLimit(String sql, int offset, int limit) {\n+        // offset is supported in prestosql but not in prestodb", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTg2NTMz", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-488986533", "createdAt": "2020-09-15T19:09:37Z", "commit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTowOTozN1rOHSQU5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTowOTozN1rOHSQU5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMzkxMA==", "bodyText": "instead of asking user to put new/duplicate dialect property can we use from the JPAProperties?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488903910", "createdAt": "2020-09-15T19:09:37Z", "author": {"login": "moizarafat"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -64,28 +69,49 @@\n     @Autowired(required = false)\n     private MeterRegistry meterRegistry;\n \n+    @Value(\"${spring.dialect}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTg5NjYx", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-488989661", "createdAt": "2020-09-15T19:14:20Z", "commit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOToxNDoyMFrOHSQejw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOToxNDoyMFrOHSQejw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNjM4Mw==", "bodyText": "Instead of 2 return statements, We can have 1 return. In this block, we can populate the Map else the default Empty map is passed.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488906383", "createdAt": "2020-09-15T19:14:20Z", "author": {"login": "moizarafat"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -159,18 +185,18 @@ public void inject(Object entity) {\n     @Bean\n     @ConditionalOnMissingBean\n     @ConditionalOnProperty(name = \"elide.aggregation-store.enabled\", havingValue = \"true\")\n-    public QueryEngine buildQueryEngine(EntityManagerFactory entityManagerFactory,\n+    public QueryEngine buildQueryEngine(DataSource defaultDataSource,\n             ObjectProvider<ElideDynamicEntityCompiler> dynamicCompiler, ElideConfigProperties settings)\n             throws ClassNotFoundException {\n \n-        MetaDataStore metaDataStore = null;\n         if (isDynamicConfigEnabled(settings)) {\n-            metaDataStore = new MetaDataStore(dynamicCompiler.getIfAvailable());\n+            MetaDataStore metaDataStore = new MetaDataStore(dynamicCompiler.getIfAvailable());\n+            return new SQLQueryEngine(metaDataStore, defaultDataSource, defaultDialect,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDM5Mzk3", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-489039397", "createdAt": "2020-09-15T20:19:38Z", "commit": {"oid": "9d0f414511b474f4d7cdb49dcc356ebf6d4c6de7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDoxOTozOVrOHSTESQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMToxNjowNFrOHSU1kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0ODgwOQ==", "bodyText": "static", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488948809", "createdAt": "2020-09-15T20:19:39Z", "author": {"login": "aklish"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ElideDynamicEntityCompiler.java", "diffHunk": "@@ -75,6 +87,44 @@ public ElideDynamicEntityCompiler(String path) throws Exception {\n                 new ElideDynamicInMemoryClassLoader(ClassLoader.getSystemClassLoader(),\n                         Sets.newHashSet(classNames)));\n         compile();\n+\n+        elideSQLDBConfig.getDbconfigs().forEach(config -> {\n+            connectionDetailsMap.put(config.getName(),\n+                            new ConnectionDetails(getDataSource(config, dbPasswordExtractor), config.getDialect()));\n+        });\n+\n+    }\n+\n+    /**\n+     * Parse dynamic config path and provides default implementation for DB Password Extractor.\n+     * @param path : Dynamic config hjsons root location.\n+     * @throws Exception Exception thrown.\n+     */\n+    public ElideDynamicEntityCompiler(String path) throws Exception {\n+        this(path, new DBPasswordExtractor() {\n+            @Override\n+            public String getDBPassword(DBConfig config) {\n+                return StringUtils.EMPTY;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Generates DataSource for provided configuration.\n+     * @param dbConfig DB Configuration pojo.\n+     * @param dbPasswordExtractor DB Password Extractor Implementation.\n+     * @return DataSource Object.\n+     */\n+    private DataSource getDataSource(DBConfig dbConfig, DBPasswordExtractor dbPasswordExtractor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d0f414511b474f4d7cdb49dcc356ebf6d4c6de7"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTA5NA==", "bodyText": "You can use @value to make this immutable.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488949094", "createdAt": "2020-09-15T20:20:06Z", "author": {"login": "aklish"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ConnectionDetails.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.contrib.dynamicconfighelpers.compile;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+import javax.sql.DataSource;\n+\n+/**\n+ * Custom class to abstract {@link DataSource} and name of Dialect class.\n+ */\n+@AllArgsConstructor\n+@Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d0f414511b474f4d7cdb49dcc356ebf6d4c6de7"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1NjYxOA==", "bodyText": "Why not use ConnectionDetails here?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488956618", "createdAt": "2020-09-15T20:34:21Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -41,45 +43,72 @@\n import com.yahoo.elide.request.Pagination;\n import com.yahoo.elide.utils.coerce.CoerceUtil;\n \n-import org.hibernate.jpa.QueryHints;\n-\n import lombok.extern.slf4j.Slf4j;\n \n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n-import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n-import javax.persistence.EntityManager;\n-import javax.persistence.EntityManagerFactory;\n-import javax.persistence.EntityTransaction;\n+import javax.sql.DataSource;\n \n /**\n  * QueryEngine for SQL backed stores.\n  */\n @Slf4j\n public class SQLQueryEngine extends QueryEngine {\n-    private final EntityManagerFactory entityManagerFactory;\n-    private final Consumer<EntityManager> transactionCancel;\n     private final SQLReferenceTable referenceTable;\n-    private final SQLDialect dialect;\n-\n-    public SQLQueryEngine(MetaDataStore metaDataStore, EntityManagerFactory eMFactory, Consumer<EntityManager> txC) {\n-        this(metaDataStore, eMFactory, txC, SQLDialectFactory.getDefaultDialect());\n-    }\n+    private final DataSource defaultDataSource;\n+    private final Map<String, DataSource> dataSourceMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1NzIyMw==", "bodyText": "I wonder if we should make this SQLDialect instead of String.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488957223", "createdAt": "2020-09-15T20:35:29Z", "author": {"login": "aklish"}, "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ConnectionDetails.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.contrib.dynamicconfighelpers.compile;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+import javax.sql.DataSource;\n+\n+/**\n+ * Custom class to abstract {@link DataSource} and name of Dialect class.\n+ */\n+@AllArgsConstructor\n+@Getter\n+public class ConnectionDetails {\n+    private DataSource dataSource;\n+    private String dialect;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1OTcwNg==", "bodyText": "Now that we are adding offset and limit directly, I feel like this functionality (appending the offset & limit string) should move to the SQLQueryConstructor", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488959706", "createdAt": "2020-09-15T20:40:12Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MDcxOQ==", "bodyText": "Same comment.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488960719", "createdAt": "2020-09-15T20:42:12Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());\n             if (pagination.returnPageTotals()) {\n-                resultBuilder.pageTotals(getPageTotal(query, sql, entityManager));\n+                resultBuilder.pageTotals(getPageTotal(query, sql, sqlTransaction));\n             }\n         }\n \n+        log.debug(\"SQL Query: \" + queryString);\n+        stmt = sqlTransaction.initializeStatement(queryString);\n+\n         // Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, jpaQuery);\n+        supplyFilterQueryParameters(query, stmt);\n \n         // Run the primary query and log the time spent.\n-        List<Object> results = new TimedFunction<List<Object>>(\n-                () -> jpaQuery.setHint(QueryHints.HINT_READONLY, true).getResultList(),\n-                \"Running Query: \" + queryString).get();\n+        ResultSet resultSet = new TimedFunction<>(() -> {\n+            try {\n+                return stmt.executeQuery();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + queryString\n+        ).get();\n \n-        resultBuilder.data(new SQLEntityHydrator(results, query, getMetadataDictionary(), entityManager).hydrate());\n+        resultBuilder.data(new EntityHydrator(resultSet, query, getMetadataDictionary()).hydrate());\n         return resultBuilder.build();\n     }\n \n-    private long getPageTotal(Query query, SQLQuery sql, EntityManager entityManager) {\n-        String paginationSQL = toPageTotalSQL(sql, dialect).toString();\n+    private long getPageTotal(Query query, SQLQuery sql, SqlTransaction sqlTransaction) {\n+        String paginationSQL = toPageTotalSQL(sql, sqlTransaction.dialect).toString();\n \n-        javax.persistence.Query pageTotalQuery =\n-                entityManager.createNativeQuery(paginationSQL)\n-                        .setHint(QueryHints.HINT_READONLY, true);\n+        NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(paginationSQL);\n \n-        //Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, pageTotalQuery);\n+        // Supply the query parameters to the query\n+        supplyFilterQueryParameters(query, stmt);\n \n-        //Run the Pagination query and log the time spent.\n-        return new TimedFunction<>(\n-                () -> CoerceUtil.coerce(pageTotalQuery.getSingleResult(), Long.class),\n-                \"Running Query: \" + paginationSQL\n-        ).get();\n+        // Run the Pagination query and log the time spent.\n+        return CoerceUtil.coerce(runQuery(stmt, paginationSQL, SINGLE_RESULT_MAPPER), Long.class);\n     }\n \n     @Override\n     public String getTableVersion(Table table, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n \n         String tableVersion = null;\n         Class<?> tableClass = getMetadataDictionary().getEntityClass(table.getName(), table.getVersion());\n         VersionQuery versionAnnotation = tableClass.getAnnotation(VersionQuery.class);\n         if (versionAnnotation != null) {\n             String versionQueryString = versionAnnotation.sql();\n-            javax.persistence.Query versionQuery =\n-                    entityManager.createNativeQuery(versionQueryString)\n-                            .setHint(QueryHints.HINT_READONLY, true);\n-            tableVersion = new TimedFunction<>(\n-                    () -> CoerceUtil.coerce(versionQuery.getSingleResult(), String.class),\n-                    \"Running Query: \" + versionQueryString\n-            ).get();\n+            String connectionName = table.getDbConnectionName();\n+            sqlTransaction.initializeTransaction(getDataSource(connectionName), getSQLDialect(connectionName));\n+            NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(versionQueryString);\n+            tableVersion = CoerceUtil.coerce(runQuery(stmt, versionQueryString, SINGLE_RESULT_MAPPER), String.class);\n         }\n         return tableVersion;\n     }\n \n-    @Override\n-    public List<String> explain(Query query) {\n+    private <R> R runQuery(NamedParamPreparedStatement stmt, String queryString, Function<ResultSet, R> resultMapper) {\n+\n+        // Run the query and log the time spent.\n+        return new TimedFunction<>(() -> {\n+            try {\n+                ResultSet rs = stmt.executeQuery();\n+                return resultMapper.apply(rs);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + queryString\n+        ).get();\n+    }\n+\n+    /**\n+     * Returns the actual query string(s) that would be executed for the input {@link Query}.\n+     *\n+     * @param query The query customized for a particular persistent storage or storage client.\n+     * @param dialect SQL dialect to use for this storage.\n+     * @return List of SQL string(s) corresponding to the given query.\n+     */\n+    public List<String> explain(Query query, SQLDialect dialect) {\n         List<String> queries = new ArrayList<String>();\n         SQLQuery sql = toSQL(query, dialect);\n \n         Pagination pagination = query.getPagination();\n-        if (pagination != null && pagination.returnPageTotals()) {\n-            queries.add(toPageTotalSQL(sql, dialect).toString());\n+        if (pagination != null) {\n+            if (pagination.returnPageTotals()) {\n+                queries.add(toPageTotalSQL(sql, dialect).toString());\n+            }\n+            queries.add(appendOffsetLimit(sql.toString(), dialect, pagination.getOffset(), pagination.getLimit()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MTg4Mg==", "bodyText": "Why doesn't this use the new runQuery method you added with an identity mapper?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488961882", "createdAt": "2020-09-15T20:44:37Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());\n             if (pagination.returnPageTotals()) {\n-                resultBuilder.pageTotals(getPageTotal(query, sql, entityManager));\n+                resultBuilder.pageTotals(getPageTotal(query, sql, sqlTransaction));\n             }\n         }\n \n+        log.debug(\"SQL Query: \" + queryString);\n+        stmt = sqlTransaction.initializeStatement(queryString);\n+\n         // Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, jpaQuery);\n+        supplyFilterQueryParameters(query, stmt);\n \n         // Run the primary query and log the time spent.\n-        List<Object> results = new TimedFunction<List<Object>>(\n-                () -> jpaQuery.setHint(QueryHints.HINT_READONLY, true).getResultList(),\n-                \"Running Query: \" + queryString).get();\n+        ResultSet resultSet = new TimedFunction<>(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NTgwMA==", "bodyText": "InitializeTransaction is called twice in this file (once here and once to get the table version).  The transaction should only be initialized once because it involves getting a DB connection.  I recommend we have state about whether or not  the transaction is initialized.  One other possibility is to do the initialization lazily inside the Transaction when a new statement is created.  Then you could remove the need to initialize both the transaction and the statement in multiple places.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488965800", "createdAt": "2020-09-15T20:52:10Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NzE0OQ==", "bodyText": "It might be better to do the appending outside the dialect.  If there are nested subqueries, we may want to apply offset and limit on an inner query.  The calling code will know how to stitch in the fragment.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488967149", "createdAt": "2020-09-15T20:54:49Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/AbstractSqlDialect.java", "diffHunk": "@@ -9,12 +9,22 @@\n  * Common code for {@link SQLDialect} implementations.\n  */\n public abstract class AbstractSqlDialect implements SQLDialect {\n+\n+    public static final String OFFSET = \" OFFSET \";\n+    public static final String LIMIT = \" LIMIT \";\n+\n     @Override\n     public boolean useAliasForOrderByClause() {\n         return false;\n     }\n \n+    @Override\n     public String generateCountDistinctClause(String dimensions) {\n         return String.format(\"COUNT(DISTINCT(%s))\", dimensions);\n     }\n+\n+    @Override\n+    public String appendOffsetLimit(String sql, int offset, int limit) {\n+        return sql + OFFSET + offset + LIMIT + limit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2Nzg0OA==", "bodyText": "TestInfo looks unused.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488967848", "createdAt": "2020-09-15T20:56:11Z", "author": {"login": "aklish"}, "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -74,7 +76,7 @@ public static void beforeAllTests() {\n     }\n \n     @BeforeEach\n-    public void setUp() {\n+    public void setUp(TestInfo info) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3MDg4NQ==", "bodyText": "Let's move all of this test infrastructure into AggregationStore instead of duplicating it in Spring and Standalone.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488970885", "createdAt": "2020-09-15T21:02:06Z", "author": {"login": "aklish"}, "path": "elide-standalone/src/test/resources/configs/models/tables/SalesView.hjson", "diffHunk": "@@ -0,0 +1,75 @@\n+{\n+  tables:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NjAzMg==", "bodyText": "Why does Async need the DBPassword config?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488976032", "createdAt": "2020-09-15T21:12:21Z", "author": {"login": "aklish"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/test/java/example/tests/AsyncTest.java", "diffHunk": "@@ -39,6 +39,7 @@\n                 + \"\\t\\t('com.example.repository','Example Repository','The code for this project', false);\")\n @Sql(executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD,\n         statements = \"DELETE FROM ArtifactVersion; DELETE FROM ArtifactProduct; DELETE FROM ArtifactGroup;\")\n+@Import(DBPasswordExtractorSetup.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3Njc1MQ==", "bodyText": "The dialects are different classes though.  I think the spring dialect is a JPA dialect, whereas our default dialect is an Elide concept.  I'm not sure we can do this.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488976751", "createdAt": "2020-09-15T21:13:58Z", "author": {"login": "aklish"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -64,28 +69,49 @@\n     @Autowired(required = false)\n     private MeterRegistry meterRegistry;\n \n+    @Value(\"${spring.dialect}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMzkxMA=="}, "originalCommit": {"oid": "ee7efe7046771fdab838716f7f2289b3b14d0c5f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NzgwOA==", "bodyText": "Does Spring provide the DataSource for us?", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488977808", "createdAt": "2020-09-15T21:16:04Z", "author": {"login": "aklish"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -159,18 +185,18 @@ public void inject(Object entity) {\n     @Bean\n     @ConditionalOnMissingBean\n     @ConditionalOnProperty(name = \"elide.aggregation-store.enabled\", havingValue = \"true\")\n-    public QueryEngine buildQueryEngine(EntityManagerFactory entityManagerFactory,\n+    public QueryEngine buildQueryEngine(DataSource defaultDataSource,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd81a5da0873e15cb613e74945aeccbb574bc9"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTg5NjI5", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-489989629", "createdAt": "2020-09-16T20:18:54Z", "commit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoxODo1NFrOHTCwaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoxODo1NFrOHTCwaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMDE1Mg==", "bodyText": "Indentation is off", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489730152", "createdAt": "2020-09-16T20:18:54Z", "author": {"login": "moizarafat"}, "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -66,31 +63,30 @@\n @Slf4j\n public class SQLQueryEngine extends QueryEngine {\n     private final SQLReferenceTable referenceTable;\n-    private final DataSource defaultDataSource;\n-    private final Map<String, DataSource> dataSourceMap = new HashMap<>();\n-    private final SQLDialect defaultDialect;\n-    private final Map<String, SQLDialect> dialectMap = new HashMap<>();\n+    private final ConnectionDetails defaultConnectionDetails;\n+    private final Map<String, ConnectionDetails> connectionDetailsMap = new HashMap<>();\n \n-    public SQLQueryEngine(MetaDataStore metaDataStore, DataSource defaultDataSource, String defaultDialect) {\n+    public SQLQueryEngine(MetaDataStore metaDataStore,\n+                    com.yahoo.elide.contrib.dynamicconfighelpers.compile.ConnectionDetails defaultConnectionDetails) {\n         super(metaDataStore);\n         this.referenceTable = new SQLReferenceTable(metaDataStore);\n-        this.defaultDataSource = defaultDataSource;\n-        this.defaultDialect = SQLDialectFactory.getDialect(defaultDialect);\n+        this.defaultConnectionDetails = new ConnectionDetails(defaultConnectionDetails.getDataSource(),\n+                        SQLDialectFactory.getDialect(defaultConnectionDetails.getDialect()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTkzMTY3", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-489993167", "createdAt": "2020-09-16T20:24:24Z", "commit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNDoyNFrOHTC7CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNDoyNFrOHTC7CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjg3Mw==", "bodyText": "This import is unused.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489732873", "createdAt": "2020-09-16T20:24:24Z", "author": {"login": "moizarafat"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AggregationStoreProperties.java", "diffHunk": "@@ -5,6 +5,8 @@\n  */\n package com.yahoo.elide.spring.config;\n \n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.SQLDialect;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTkzMzAx", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-489993301", "createdAt": "2020-09-16T20:24:37Z", "commit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNDozN1rOHTC7dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNDozN1rOHTC7dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjk4MQ==", "bodyText": "We should set to one of the supported values.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489732981", "createdAt": "2020-09-16T20:24:37Z", "author": {"login": "moizarafat"}, "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AggregationStoreProperties.java", "diffHunk": "@@ -18,4 +20,8 @@\n      */\n     private boolean enabled = false;\n \n+    /**\n+     * {@link SQLDialect} type for default DataSource Object.\n+     */\n+    private String defaultDialect = \"MYSQL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTkzODkz", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-489993893", "createdAt": "2020-09-16T20:25:32Z", "commit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNTozMlrOHTC9fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDoyNTozMlrOHTC9fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMzUwMA==", "bodyText": "use one of the supported types.", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489733500", "createdAt": "2020-09-16T20:25:32Z", "author": {"login": "moizarafat"}, "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -375,6 +376,15 @@ public String getDBPassword(DBConfig config) {\n         };\n     }\n \n+    /**\n+     * Provides the default SQLDialect type.\n+     *\n+     * @return {@link SQLDialect} type for default DataSource Object.\n+     */\n+    default String getDefaultDialect() {\n+        return \"MYSQL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3458c01de2508bd2c25469357512292f585f7706"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8be2b7ffe2aff0309c0d31f8fd9588245a1575dc", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/8be2b7ffe2aff0309c0d31f8fd9588245a1575dc", "committedDate": "2020-09-16T21:25:41Z", "message": "Query Engine and Aggregation Store Changes for Multi Data Source Support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9533291c7c0459182cb5d3b2a5806628348bc1c", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/d9533291c7c0459182cb5d3b2a5806628348bc1c", "committedDate": "2020-09-16T21:25:41Z", "message": "minor updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c663a02f086186aa8e22b374b8061ecc235fe9a1", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/c663a02f086186aa8e22b374b8061ecc235fe9a1", "committedDate": "2020-09-16T21:25:41Z", "message": "Review Comments: Change Dialect to Enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa95290812c67c8b7bf2fbebebd3f5ffdfc6d252", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/fa95290812c67c8b7bf2fbebebd3f5ffdfc6d252", "committedDate": "2020-09-16T21:25:41Z", "message": "Review Comment: Remove references for getRelationshipValues from EntityHydrator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "664ed6b057089f2015af078948af6d6d7d7a2a58", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/664ed6b057089f2015af078948af6d6d7d7a2a58", "committedDate": "2020-09-16T21:25:41Z", "message": "Review Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b9f9aed822872dc4639271d5fe69f1e6496b60f", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/2b9f9aed822872dc4639271d5fe69f1e6496b60f", "committedDate": "2020-09-16T21:25:41Z", "message": "Review Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4709e99c004bdf9713e59e9c6cf4e09251a3dc4a", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/4709e99c004bdf9713e59e9c6cf4e09251a3dc4a", "committedDate": "2020-09-16T21:25:41Z", "message": "Revert changes to AggregationDataStore and AggregationDataStoreTransaction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42fcc4f783bff6be0334a35793d1c5e12686cee2", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/42fcc4f783bff6be0334a35793d1c5e12686cee2", "committedDate": "2020-09-16T21:26:20Z", "message": "Rebased and fix MetaDataStoreIntegrationTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "286b895c6160dec8eccb54d4dc962ed4c7a2f56b", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/286b895c6160dec8eccb54d4dc962ed4c7a2f56b", "committedDate": "2020-09-16T21:26:20Z", "message": "Elide StandAlone Changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69854b2d7b710de47d2d6541a443558f6c865a95", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/69854b2d7b710de47d2d6541a443558f6c865a95", "committedDate": "2020-09-16T21:26:20Z", "message": "Refactoring and Spring changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ded581ce81830bdfc13e1d4379a7d7f6ebe84196", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/ded581ce81830bdfc13e1d4379a7d7f6ebe84196", "committedDate": "2020-09-16T21:26:20Z", "message": "Minor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4591d599576816c58f6cafb0ad03e404ea0e7b6", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/e4591d599576816c58f6cafb0ad03e404ea0e7b6", "committedDate": "2020-09-16T21:26:20Z", "message": "Final Pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c8f7edc74bb95eb371d9ed3809942a7ab2c79aa", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/7c8f7edc74bb95eb371d9ed3809942a7ab2c79aa", "committedDate": "2020-09-16T21:27:21Z", "message": "Remove emf from SQLUNIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e50b44ec2b0c5241e688ca40b32166fde8f1f0d9", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/e50b44ec2b0c5241e688ca40b32166fde8f1f0d9", "committedDate": "2020-09-16T21:27:21Z", "message": "Add missing file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98328e3419976c6b9deb6f7f4ce0d28825286710", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/98328e3419976c6b9deb6f7f4ce0d28825286710", "committedDate": "2020-09-16T21:27:22Z", "message": "Review Comments: Refactor Connection Details, Remove duplicate tests from Slring and Standalone"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae647b5050b99f6129f4810329d9114408a3c25f", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/ae647b5050b99f6129f4810329d9114408a3c25f", "committedDate": "2020-09-16T21:27:22Z", "message": "Review Comments: Lazily Initialize Transaction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8774463648ef8593cd6c069933effe65e79b73d", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/f8774463648ef8593cd6c069933effe65e79b73d", "committedDate": "2020-09-16T21:27:22Z", "message": "Minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "861ddacd41352e79a7a90ac99f8d1f330c8c731e", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/861ddacd41352e79a7a90ac99f8d1f330c8c731e", "committedDate": "2020-09-16T21:27:22Z", "message": "Review Comments: Move Offset/Limit to SQLQueryConstructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "083c4cc27a896d73fcd8456379d014f07c56f304", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/083c4cc27a896d73fcd8456379d014f07c56f304", "committedDate": "2020-09-16T21:27:22Z", "message": "Minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03f02a317999ef082bbc8a57e4ceba337b008fd5", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/03f02a317999ef082bbc8a57e4ceba337b008fd5", "committedDate": "2020-09-16T21:27:22Z", "message": "Minor changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "committedDate": "2020-09-16T21:27:22Z", "message": "Minor changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3458c01de2508bd2c25469357512292f585f7706", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/3458c01de2508bd2c25469357512292f585f7706", "committedDate": "2020-09-16T20:08:38Z", "message": "Minor changes"}, "afterCommit": {"oid": "7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "committedDate": "2020-09-16T21:27:22Z", "message": "Minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwNzU3NDE5", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-490757419", "createdAt": "2020-09-17T16:02:37Z", "commit": {"oid": "7a9b1a27a8a2bfb24748962037b7380e1e251a9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eee714a83a300b5bb33dbcdecd0c6939e39db7c", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/7eee714a83a300b5bb33dbcdecd0c6939e39db7c", "committedDate": "2020-09-17T16:20:30Z", "message": "Review Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODA0NTk0", "url": "https://github.com/yahoo/elide/pull/1523#pullrequestreview-490804594", "createdAt": "2020-09-17T16:55:41Z", "commit": {"oid": "7eee714a83a300b5bb33dbcdecd0c6939e39db7c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 815, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}