{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4ODQ3MTU2", "number": 1576, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Mzo0MlrOErOCFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Nzo0M1rOErOJmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzU0MTMyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/export/TableExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Mzo0MlrOHd3bpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Mzo0MlrOHd3bpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3ODk0OQ==", "bodyText": "IOExceptions are handled by throwing a TransactionException in Elide.  We should be consistent here.", "url": "https://github.com/yahoo/elide/pull/1576#discussion_r501078949", "createdAt": "2020-10-07T14:53:42Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/export/TableExporter.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.export;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.PersistentResource;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.exceptions.InvalidValueException;\n+import com.yahoo.elide.graphql.GraphQLRequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+import com.yahoo.elide.security.User;\n+\n+import io.reactivex.Observable;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.UUID;\n+\n+/**\n+ * Class for Table Export functionality.\n+ */\n+public class TableExporter {\n+\n+    private Elide elide;\n+    private String apiVersion;\n+    private User user;\n+    private GraphQLParser graphQLParser;\n+\n+    public TableExporter(Elide elide, String apiVersion, User user) {\n+        this(elide, apiVersion, user, new GraphQLParser(elide, apiVersion));\n+    }\n+\n+    public TableExporter(Elide elide, String apiVersion, User user, GraphQLParser graphQLParser) {\n+        this.elide = elide;\n+        this.apiVersion = apiVersion;\n+        this.user = user;\n+        this.graphQLParser = graphQLParser;\n+    }\n+\n+    /**\n+     * Exports the Data based on AsyncQuery.\n+     * @param query AsyncQuery object.\n+     * @return Observable of PersistentResource.\n+     */\n+    public Observable<PersistentResource> export(AsyncQuery query) {\n+        Observable<PersistentResource> results = Observable.empty();\n+\n+        UUID requestId = UUID.fromString(query.getRequestId());\n+\n+        try (DataStoreTransaction tx = elide.getDataStore().beginTransaction()) {\n+            elide.getTransactionRegistry().addRunningTransaction(requestId, tx);\n+\n+            EntityProjection projection = null;\n+            RequestScope requestScope = null;\n+\n+            if (query.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                projection = graphQLParser.parse(query);\n+                //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+                //TODO - Can we have projectionInfo as null?\n+                requestScope = new GraphQLRequestScope(\"\", tx, user, apiVersion, elide.getElideSettings(), null,\n+                        requestId);\n+            } else {\n+                //TODO - Add JSON Support\n+                throw new InvalidValueException(\"QueryType not supported\");\n+            }\n+\n+            if (projection != null) {\n+                results = PersistentResource.loadRecords(projection, Collections.emptyList(), requestScope);\n+            }\n+\n+            tx.preCommit();\n+            requestScope.runQueuedPreSecurityTriggers();\n+            requestScope.getPermissionExecutor().executeCommitChecks();\n+\n+            tx.flush(requestScope);\n+\n+            requestScope.runQueuedPreCommitTriggers();\n+\n+            elide.getAuditLogger().commit();\n+            tx.commit(requestScope);\n+\n+            requestScope.runQueuedPostCommitTriggers();\n+        } catch (IOException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01bd142543e14cf8e99ebd372492d4479af9fbb0"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzU2MDU3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/test/java/com/yahoo/elide/async/export/TableExporterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Nzo0M1rOHd3n-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDo1Nzo0M1rOHd3n-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA4MjEwNg==", "bodyText": "I feel like mocking all of these objects make the tests brittle.  Also, most mocks are likely not global and should be created per test.  I would focus on mocking only the challenging objects (like the data store or something).  Everything else should use real objects.", "url": "https://github.com/yahoo/elide/pull/1576#discussion_r501082106", "createdAt": "2020-10-07T14:57:43Z", "author": {"login": "aklish"}, "path": "elide-async/src/test/java/com/yahoo/elide/async/export/TableExporterTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.export;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettings;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.audit.AuditLogger;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.PersistentResource;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.request.EntityProjection;\n+import com.yahoo.elide.security.User;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import io.reactivex.Observable;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.UUID;\n+\n+public class TableExporterTest {\n+\n+    private DataStoreTransaction tx = mock(DataStoreTransaction.class);\n+    private Elide elide;\n+    private User user;\n+    private GraphQLParser graphQLParser;\n+    private AsyncQuery asyncQuery;\n+\n+    @BeforeEach\n+    public void beforeTest() {\n+        reset(tx);\n+        elide = mock(Elide.class);\n+        user = mock(User.class);\n+        asyncQuery = mock(AsyncQuery.class);\n+        graphQLParser = mock(GraphQLParser.class);\n+\n+        TransactionRegistry transactionRegistry = mock(TransactionRegistry.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01bd142543e14cf8e99ebd372492d4479af9fbb0"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 884, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}