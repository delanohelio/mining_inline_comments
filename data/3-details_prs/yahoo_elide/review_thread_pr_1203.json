{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTQzOTQz", "number": 1203, "reviewThreads": {"totalCount": 77, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjoyNjo0NFrODjhZGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMToxNToxMVrODz7TWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTczODQ5OnYy", "diffSide": "RIGHT", "path": "elide-async/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjoyNjo0NFrOFvYAbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjoyNjo0NFrOFvYAbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyMDcxOQ==", "bodyText": "Are all of these dependencies really needed or was this copied from another pom?  Why do we need antlr?  Can we slim this down to just the direct dependencies?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385220719", "createdAt": "2020-02-27T16:26:44Z", "author": {"login": "aklish"}, "path": "elide-async/pom.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<!--\n+  ~ Copyright 2020, Yahoo Inc.\n+  ~ Licensed under the Apache License, Version 2.0\n+  ~ See LICENSE file in project root for terms.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>elide-async</artifactId>\n+    <packaging>jar</packaging>\n+    <name>Elide Async</name>\n+    <description>Elide Async</description>\n+    <url>https://github.com/yahoo/elide</url>\n+    <parent>\n+        <groupId>com.yahoo.elide</groupId>\n+        <artifactId>elide-parent-pom</artifactId>\n+        <version>5.0.0-pr7-SNAPSHOT</version>\n+    </parent>\n+\n+    <licenses>\n+        <license>\n+            <name>The Apache Software License, Version 2.0</name>\n+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+            <distribution>repo</distribution>\n+        </license>\n+    </licenses>\n+\n+    <organization>\n+        <name>Yahoo! Inc.</name>\n+        <url>http://www.yahoo.com</url>\n+    </organization>\n+\n+    <developers>\n+        <developer>\n+            <name>Yahoo Inc.</name>\n+            <url>https://github.com/yahoo</url>\n+        </developer>\n+    </developers>\n+\n+    <scm>\n+        <developerConnection>scm:git:ssh://git@github.com/yahoo/elide.git</developerConnection>\n+        <url>https://github.com/yahoo/elide.git</url>\n+        <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+        <junit.version>5.5.2</junit.version>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-annotations</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-graphql</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.projectlombok</groupId>\n+            <artifactId>lombok</artifactId>\n+            <version>1.18.10</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.antlr</groupId>\n+            <artifactId>antlr4-runtime</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTc0MTIwOnYy", "diffSide": "RIGHT", "path": "elide-async/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjoyNzoyM1rOFvYCMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjoyNzoyM1rOFvYCMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyMTE2OA==", "bodyText": "Start with a clean pom and add plugins and dependencies as needed.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385221168", "createdAt": "2020-02-27T16:27:23Z", "author": {"login": "aklish"}, "path": "elide-async/pom.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<!--\n+  ~ Copyright 2020, Yahoo Inc.\n+  ~ Licensed under the Apache License, Version 2.0\n+  ~ See LICENSE file in project root for terms.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>elide-async</artifactId>\n+    <packaging>jar</packaging>\n+    <name>Elide Async</name>\n+    <description>Elide Async</description>\n+    <url>https://github.com/yahoo/elide</url>\n+    <parent>\n+        <groupId>com.yahoo.elide</groupId>\n+        <artifactId>elide-parent-pom</artifactId>\n+        <version>5.0.0-pr7-SNAPSHOT</version>\n+    </parent>\n+\n+    <licenses>\n+        <license>\n+            <name>The Apache Software License, Version 2.0</name>\n+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+            <distribution>repo</distribution>\n+        </license>\n+    </licenses>\n+\n+    <organization>\n+        <name>Yahoo! Inc.</name>\n+        <url>http://www.yahoo.com</url>\n+    </organization>\n+\n+    <developers>\n+        <developer>\n+            <name>Yahoo Inc.</name>\n+            <url>https://github.com/yahoo</url>\n+        </developer>\n+    </developers>\n+\n+    <scm>\n+        <developerConnection>scm:git:ssh://git@github.com/yahoo/elide.git</developerConnection>\n+        <url>https://github.com/yahoo/elide.git</url>\n+        <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+        <junit.version>5.5.2</junit.version>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-annotations</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-graphql</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.projectlombok</groupId>\n+            <artifactId>lombok</artifactId>\n+            <version>1.18.10</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.antlr</groupId>\n+            <artifactId>antlr4-runtime</artifactId>\n+            <version>${version.antlr4}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax.ws.rs</groupId>\n+            <artifactId>javax.ws.rs-api</artifactId>\n+            <version>2.1.1</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax.persistence</groupId>\n+            <artifactId>javax.persistence-api</artifactId>\n+            <version>2.2</version>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.commons</groupId>\n+            <artifactId>commons-lang3</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.commons</groupId>\n+            <artifactId>commons-collections4</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>commons-beanutils</groupId>\n+            <artifactId>commons-beanutils</artifactId>\n+            <version>1.9.4</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax.inject</groupId>\n+            <artifactId>javax.inject</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-databind</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>cz.jirutka.rsql</groupId>\n+            <artifactId>rsql-parser</artifactId>\n+            <version>2.1.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.reactivex.rxjava2</groupId>\n+            <artifactId>rxjava</artifactId>\n+            <version>2.2.16</version>\n+        </dependency>\n+\n+        <!-- JSR 303 Validation -->\n+        <dependency>\n+            <groupId>javax.validation</groupId>\n+            <artifactId>validation-api</artifactId>\n+            <version>2.0.1.Final</version>\n+        </dependency>\n+\n+        <!-- Logging -->\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-api</artifactId>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>de.odysseus.juel</groupId>\n+            <artifactId>juel-impl</artifactId>\n+            <version>2.2.7</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>de.odysseus.juel</groupId>\n+            <artifactId>juel-api</artifactId>\n+            <version>2.2.7</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.fusesource.jansi</groupId>\n+            <artifactId>jansi</artifactId>\n+            <version>1.14</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>io.github.classgraph</groupId>\n+            <artifactId>classgraph</artifactId>\n+            <version>4.8.60</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.owasp.encoder</groupId>\n+            <artifactId>encoder</artifactId>\n+            <version>1.2.2</version>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.apache.httpcomponents</groupId>\n+            <artifactId>httpclient</artifactId>\n+            <version>4.5.3</version>\n+        </dependency>\n+\n+        <!--\n+            ============================\n+            Test dependencies\n+            ============================\n+        -->\n+\n+        <!-- JUnit -->\n+        <dependency>\n+            <groupId>org.junit.jupiter</groupId>\n+            <artifactId>junit-jupiter-api</artifactId>\n+            <version>${junit.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.junit.jupiter</groupId>\n+            <artifactId>junit-jupiter-params</artifactId>\n+            <version>${junit.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.junit.jupiter</groupId>\n+            <artifactId>junit-jupiter-engine</artifactId>\n+            <version>${junit.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>ch.qos.logback</groupId>\n+            <artifactId>logback-classic</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>ch.qos.logback</groupId>\n+            <artifactId>logback-core</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.mockito</groupId>\n+            <artifactId>mockito-core</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.eclipse.jetty</groupId>\n+            <artifactId>jetty-webapp</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.glassfish.jersey.containers</groupId>\n+            <artifactId>jersey-container-servlet</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+    <pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.antlr</groupId>\n+                <artifactId>antlr4-maven-plugin</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTc3NTcyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjozNTozMVrOFvYXUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjozNTozMVrOFvYXUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyNjU3OA==", "bodyText": "You can use lombok @Data and remove a lot of boilerplate.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385226578", "createdAt": "2020-02-27T16:35:31Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTc5MTE4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjozOTowN1rOFvYglg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjowNDoyNlrOFy-Gfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyODk1MA==", "bodyText": "GraphQL can return response codes of 200 and still have errors.  Let's discuss with UI and figure out what we want to do in this case.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385228950", "createdAt": "2020-02-27T16:39:07Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwODgzMw==", "bodyText": "@jkusa", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385908833", "createdAt": "2020-02-28T20:32:15Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyODk1MA=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5MDU5MQ==", "bodyText": "If we can fetch the query status (whether the query failed or succeeded) we should return a 200.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r388990591", "createdAt": "2020-03-06T16:04:26Z", "author": {"login": "jkusa"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyODk1MA=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTc5NDc4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjo0MDowNVrOFvYi4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTozNTo0MlrOFveh_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyOTUzOQ==", "bodyText": "We need to put this in a try block to make sure the tx gets closed if there is an exception.  Otherwise we may leak DB connections.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385229539", "createdAt": "2020-02-27T16:40:05Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNzYxNA==", "bodyText": "Right now this method throws a exception and is caught by the surrounding try - catch block in the processQuery method. That try catch block should catch any of the leaked leak DB connections cause by the database transactions. Should we put a try catch block in each of the DB transactions methods separately?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385327614", "createdAt": "2020-02-27T19:35:42Z", "author": {"login": "Abhino"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyOTUzOQ=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTgwNDAzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjo0MjoxOVrOFvYohw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjo0MjoxOVrOFvYohw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzMDk4Mw==", "bodyText": "Instead of setting these parameters to null, I would Mimic elide.get:\n            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n            RequestScope requestScope = new RequestScope(path, jsonApiDoc, tx, user, queryParams, elideSettings);\nThe user should be set to the principal object.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385230983", "createdAt": "2020-02-27T16:42:19Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTgxNTYzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNjo0NTozMlrOFvYv4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTo0OTo1OVrOFve_GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzMjg2Nw==", "bodyText": "Rather than duplicate the transaction setup and teardown, make a general function 'updateAsynQuery' and pass a function argument to it that actually updates the AsyncQuery object.  Then you can reuse the logic for all of your updates.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385232867", "createdAt": "2020-02-27T16:45:32Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzNTA2NA==", "bodyText": "Right now we have a overloaded method for updateAsyncQueryStatus - one of them is used to update Query Status and the other one is used to add the AsyncQueryResult Object. We do it this way because at any instance we only need to update either the query status or add the result object.  Could you please elaborate on how we can create this generic updateAsyncQuery function ?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385335064", "createdAt": "2020-02-27T19:49:59Z", "author": {"login": "Abhino"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzMjg2Nw=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTg5OTgwOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzowNjoxOVrOFvZjzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzowNjoxOVrOFvZjzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NjE1OA==", "bodyText": "Can we use lombok and get rid of all the boilerplate getters & setters?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385246158", "createdAt": "2020-02-27T17:06:19Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n+    @Override\n+\tpublic String getPrincipalName() {\n+\t\treturn principalName;\n+\t}\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n+    }\n+\n+    public void setResult(AsyncQueryResult result) {\n+        this.result = result;\n+    }\n+\n+    public Date getUpdatedOn() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTkwNDA0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzowNzozMFrOFvZmcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTowNzoyNVrOFvdnVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NjgzMw==", "bodyText": "What about DeletePermission?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385246833", "createdAt": "2020-02-27T17:07:30Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxMjU5OA==", "bodyText": "Will make the DeletePermission as None?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385312598", "createdAt": "2020-02-27T19:07:25Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NjgzMw=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTkwNTI4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzowNzo0OVrOFvZnNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTowODoxM1rOFvdoug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NzAzMQ==", "bodyText": "What about DeletePermission", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385247031", "createdAt": "2020-02-27T17:07:49Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+public class AsyncQueryResult implements PrincipalOwned {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxMjk1NA==", "bodyText": "Should we set the DeletePermission as None for the AsyncQueryResult ?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385312954", "createdAt": "2020-02-27T19:08:13Z", "author": {"login": "Abhino"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+public class AsyncQueryResult implements PrincipalOwned {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NzAzMQ=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTkwNjQ5OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzowODoxM1rOFvZn_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzowODoxM1rOFvZn_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NzIyOQ==", "bodyText": "Let's use lombok to remove getters & setters.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385247229", "createdAt": "2020-02-27T17:08:13Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @OneToOne\n+    private AsyncQuery query;\n+\n+    @Exclude\n+    public String getPrincipalName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTkxMzU5OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxMDowNVrOFvZscw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMToxODo0N1rOFvmsvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0ODM3MQ==", "bodyText": "Cast to PrincipalOwned.  Then you don't need to handle the two cases differently.\nAlso - let's file a ticket to move this to a FilterExpressionCheck", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385248371", "createdAt": "2020-02-27T17:10:05Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models.security;\n+\n+import java.security.Principal;\n+import java.util.Optional;\n+\n+import com.yahoo.elide.annotation.SecurityCheck;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.security.ChangeSpec;\n+import com.yahoo.elide.security.RequestScope;\n+import com.yahoo.elide.security.checks.OperationCheck;\n+\n+/**\n+ * Operation Checks on the Async Query and Result objects.\n+ */\n+public class AsyncQueryOperationChecks {\n+    @SecurityCheck(AsyncQueryOwner.PRINCIPAL_IS_OWNER)\n+    public static class AsyncQueryOwner extends OperationCheck<Object> {\n+\n+        public static final String PRINCIPAL_IS_OWNER = \"Principal is Owner\";\n+\n+        @Override\n+        public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n+            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n+\n+            if(object.getClass().equals(AsyncQuery.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2MTQzNw==", "bodyText": "I can not remember the reason, but can you explain what will be the advantage of moving this to FilterExpressionCheck vs the OperationCheck?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385461437", "createdAt": "2020-02-28T01:18:47Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models.security;\n+\n+import java.security.Principal;\n+import java.util.Optional;\n+\n+import com.yahoo.elide.annotation.SecurityCheck;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.security.ChangeSpec;\n+import com.yahoo.elide.security.RequestScope;\n+import com.yahoo.elide.security.checks.OperationCheck;\n+\n+/**\n+ * Operation Checks on the Async Query and Result objects.\n+ */\n+public class AsyncQueryOperationChecks {\n+    @SecurityCheck(AsyncQueryOwner.PRINCIPAL_IS_OWNER)\n+    public static class AsyncQueryOwner extends OperationCheck<Object> {\n+\n+        public static final String PRINCIPAL_IS_OWNER = \"Principal is Owner\";\n+\n+        @Override\n+        public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n+            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n+\n+            if(object.getClass().equals(AsyncQuery.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0ODM3MQ=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTkzMDE1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxNDoxOVrOFvZ3TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxNDoxOVrOFvZ3TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MTE0OA==", "bodyText": "Move all this math to a separate function:\nboolean isTimedOut(AsyncQuery query) { .. }", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385251148", "createdAt": "2020-02-27T17:14:19Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTkzMTM1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxNDo0NFrOFvZ4KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxNDo0NFrOFvZ4KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MTM2OA==", "bodyText": "Do the date.getTime outside the loop once.  There could be a lot of records.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385251368", "createdAt": "2020-02-27T17:14:44Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk0MDA2OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxNzowN1rOFvZ9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODo1MjozMFrOFvdH0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1Mjc0Mw==", "bodyText": "This thread should delete the query rather than timing it out.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385252743", "createdAt": "2020-02-27T17:17:07Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwNDUzMQ==", "bodyText": "If we delete the Query entry on the restart, it will confuse the user where the query went because an application crash or restart will not be known to him.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385304531", "createdAt": "2020-02-27T18:52:30Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1Mjc0Mw=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk0Mjc0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoxNzo1OFrOFvZ_Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOToxMzo0MVrOFvd0Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MzE4Mg==", "bodyText": "Let's make these configurable.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385253182", "createdAt": "2020-02-27T17:17:58Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxNTg4Mg==", "bodyText": "interruptTime is set when the elide instance comes up based on the properties/settings set by the user in application.yaml/settings.java and it gets applied to all the queries. If the user does not set it, its defaulted to 60 minutes.  Do you mean it should be an attribute in AsyncQuery and every query should have its own timeout provided by the user? if not provided, we default it.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385315882", "createdAt": "2020-02-27T19:13:41Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MzE4Mg=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk1MDgzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyMDoxMVrOFvaEVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyMDoxMVrOFvaEVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NDQ4NQ==", "bodyText": "Instead of sleeping here, just wait on the future with the given timeout:\nfuture.get(long\u00a0timeout,\u00a0TimeUnit\u00a0unit)\nIf the task returns early, this thread can exit early too.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385254485", "createdAt": "2020-02-27T17:20:11Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk1NTA4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyMToxNVrOFvaGyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyMToxNVrOFvaGyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NTExNQ==", "bodyText": "Let's commonize all of this logic to load an AsyncQuery and do something (pass in a function that manipulates the query).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385255115", "createdAt": "2020-02-27T17:21:15Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);\n+            }\n+\n+            if(!task.isDone()) {\n+                log.debug(\"Interrupting the task\");\n+                task.cancel(true);\n+                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            }\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     */\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk2NzkyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyNDo1NFrOFvaO2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxMzo1MVrOFwlmww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw==", "bodyText": "All of the Elide models should implement hashcode & equals.  There are some best practices around how to make this work with ORMs.  You can look at BaseId in Elide to get one of the approaches.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385257177", "createdAt": "2020-02-27T17:24:54Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTA0OA==", "bodyText": "We are adding @Data for AsyncQuery.java which internally includes @EqualsAndHashCode. Do we need to add these separately for the models?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385351048", "createdAt": "2020-02-27T20:22:27Z", "author": {"login": "Abhino"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MDkwMw==", "bodyText": "@Data should be sufficient.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386490903", "createdAt": "2020-03-02T16:12:06Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MjA5OQ==", "bodyText": "@Data equals & hashcode is not sufficient for use with ORMs.  Go check out BaseId in Elide.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386492099", "createdAt": "2020-03-02T16:13:51Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk3MDgyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyNTo0NVrOFvaQpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxMTo0OVrOFwlhcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzYzOA==", "bodyText": "To be on the safe side, I would add lombok hashcode and equals to all threads that are being managed by a thread pool.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385257638", "createdAt": "2020-02-27T17:25:45Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MjY1MA==", "bodyText": "We are already adding @Data for AsyncQueryCleanerThread.java which internally includes @EqualsAndHashCode. Do we need to add these separately for the threads?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385352650", "createdAt": "2020-02-27T20:26:01Z", "author": {"login": "Abhino"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzYzOA=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MDczNg==", "bodyText": "@Data should be sufficient.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386490736", "createdAt": "2020-03-02T16:11:49Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzYzOA=="}, "originalCommit": {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDIxNDE4OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxODo0MlrOFwlziw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxODo0MlrOFwlziw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NTM3MQ==", "bodyText": "The list of modules specifies the order of the build.  elide-async should be moved higher up so we can use it in other places (like spring and standalone).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386495371", "createdAt": "2020-03-02T16:18:42Z", "author": {"login": "aklish"}, "path": "pom.xml", "diffHunk": "@@ -25,6 +25,7 @@\n         <module>elide-contrib</module>\n         <module>elide-standalone</module>\n         <module>elide-spring</module>\n+        <module>elide-async</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490d1a1437efd4347ce2b6ca3d0876b53b0d7c20"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDIxODEzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxOTozOFrOFwl1_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxOTozOFrOFwl1_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NTk5OA==", "bodyText": "My comments about using functional style here still applies.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386495998", "createdAt": "2020-03-02T16:19:38Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+public class AsyncDbUtil {\n+\n+\tprivate Elide elide;\n+\tprivate static AsyncDbUtil asyncUtil;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+\tprotected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+\t}\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param updatedAttribute Attribute from asyncQuery which needs to be updated\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(Object updatedAttribute, UUID asyncQueryId) throws IOException {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        if (updatedAttribute.getClass().getSimpleName().equals(\"QueryStatus\")) {\n+            query.setStatus((QueryStatus) updatedAttribute);\n+        }\n+        else if (updatedAttribute.getClass().getSimpleName().equals(\"AsyncQueryResult\")) {\n+            query.setResult((AsyncQueryResult)updatedAttribute);\n+        }\n+        tx.save(query, scope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490d1a1437efd4347ce2b6ca3d0876b53b0d7c20"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDIxOTQwOnYy", "diffSide": "RIGHT", "path": "elide-async/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoxOTo1OFrOFwl2wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOToxMjoyMFrOFwrw-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NjE5NA==", "bodyText": "What dependency do we have on http client?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386496194", "createdAt": "2020-03-02T16:19:58Z", "author": {"login": "aklish"}, "path": "elide-async/pom.xml", "diffHunk": "@@ -0,0 +1,97 @@\n+<!--\n+  ~ Copyright 2020, Yahoo Inc.\n+  ~ Licensed under the Apache License, Version 2.0\n+  ~ See LICENSE file in project root for terms.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>elide-async</artifactId>\n+    <packaging>jar</packaging>\n+    <name>Elide Async</name>\n+    <description>Elide Async</description>\n+    <url>https://github.com/yahoo/elide</url>\n+    <parent>\n+        <groupId>com.yahoo.elide</groupId>\n+        <artifactId>elide-parent-pom</artifactId>\n+        <version>5.0.0-pr7-SNAPSHOT</version>\n+    </parent>\n+\n+    <licenses>\n+        <license>\n+            <name>The Apache Software License, Version 2.0</name>\n+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+            <distribution>repo</distribution>\n+        </license>\n+    </licenses>\n+\n+    <organization>\n+        <name>Yahoo! Inc.</name>\n+        <url>http://www.yahoo.com</url>\n+    </organization>\n+\n+    <developers>\n+        <developer>\n+            <name>Yahoo Inc.</name>\n+            <url>https://github.com/yahoo</url>\n+        </developer>\n+    </developers>\n+\n+    <scm>\n+        <developerConnection>scm:git:ssh://git@github.com/yahoo/elide.git</developerConnection>\n+        <url>https://github.com/yahoo/elide.git</url>\n+        <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+        <junit.version>5.5.2</junit.version>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-graphql</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax.persistence</groupId>\n+            <artifactId>javax.persistence-api</artifactId>\n+            <version>2.2</version>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents</groupId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490d1a1437efd4347ce2b6ca3d0876b53b0d7c20"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MzAxNw==", "bodyText": "For URI Builder used at  \n  \n    \n      elide/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n    \n    \n         Line 110\n      in\n      7058821\n    \n    \n    \n    \n\n        \n          \n           URIBuilder uri;", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386593017", "createdAt": "2020-03-02T19:12:20Z", "author": {"login": "moizarafat"}, "path": "elide-async/pom.xml", "diffHunk": "@@ -0,0 +1,97 @@\n+<!--\n+  ~ Copyright 2020, Yahoo Inc.\n+  ~ Licensed under the Apache License, Version 2.0\n+  ~ See LICENSE file in project root for terms.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>elide-async</artifactId>\n+    <packaging>jar</packaging>\n+    <name>Elide Async</name>\n+    <description>Elide Async</description>\n+    <url>https://github.com/yahoo/elide</url>\n+    <parent>\n+        <groupId>com.yahoo.elide</groupId>\n+        <artifactId>elide-parent-pom</artifactId>\n+        <version>5.0.0-pr7-SNAPSHOT</version>\n+    </parent>\n+\n+    <licenses>\n+        <license>\n+            <name>The Apache Software License, Version 2.0</name>\n+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>\n+            <distribution>repo</distribution>\n+        </license>\n+    </licenses>\n+\n+    <organization>\n+        <name>Yahoo! Inc.</name>\n+        <url>http://www.yahoo.com</url>\n+    </organization>\n+\n+    <developers>\n+        <developer>\n+            <name>Yahoo Inc.</name>\n+            <url>https://github.com/yahoo</url>\n+        </developer>\n+    </developers>\n+\n+    <scm>\n+        <developerConnection>scm:git:ssh://git@github.com/yahoo/elide.git</developerConnection>\n+        <url>https://github.com/yahoo/elide.git</url>\n+        <tag>HEAD</tag>\n+    </scm>\n+\n+    <properties>\n+        <junit.version>5.5.2</junit.version>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-graphql</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>javax.persistence</groupId>\n+            <artifactId>javax.persistence-api</artifactId>\n+            <version>2.2</version>\n+            <scope>provided</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.httpcomponents</groupId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NjE5NA=="}, "originalCommit": {"oid": "490d1a1437efd4347ce2b6ca3d0876b53b0d7c20"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjAzMTQ0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxNjo1OVrOFz0CbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxNjo1OVrOFz0CbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3NDI4NA==", "bodyText": "Can we move this inside the try block?  Elide does something like:\n        try (DataStoreTransaction tx = transaction.get()) {", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389874284", "createdAt": "2020-03-09T18:16:59Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+@Slf4j\n+public class AsyncDbUtil {\n+\n+    private Elide elide;\n+    private static AsyncDbUtil asyncUtil;\n+    private DataStore dataStore;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+    protected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+        this.dataStore = elide.getDataStore();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n+     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n+     */\n+    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n+        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n+            AsyncQueryResult queryResult = query.getResult();\n+            if(queryResult != null) {\n+                tx.delete(queryResult, scope);\n+            }\n+            if(query != null) {\n+                tx.delete(query, scope);\n+            }\n+            return queryResult;\n+        });\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQueryResult.setQuery(asyncQuery);\n+            tx.createObject(asyncQueryResult, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        DataStoreTransaction tx = dataStore.beginTransaction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjAzOTY4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxOTozM1rOFz0Hzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxOTozM1rOFz0Hzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3NTY2Mg==", "bodyText": "You could simplify this by changing the ORM data model for AsyncQuery to cascade deletes to the AsyncQueryResult.  Then you can simply delete the query here.\nCheck out the @Cascade annotation.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389875662", "createdAt": "2020-03-09T18:19:33Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+@Slf4j\n+public class AsyncDbUtil {\n+\n+    private Elide elide;\n+    private static AsyncDbUtil asyncUtil;\n+    private DataStore dataStore;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+    protected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+        this.dataStore = elide.getDataStore();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n+     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n+     */\n+    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n+        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n+            AsyncQueryResult queryResult = query.getResult();\n+            if(queryResult != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjA1ODQ3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoyNToxM1rOFz0Tuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoyNTo1MFrOFz0U7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3ODcxNQ==", "bodyText": "Copyright is needed.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389878715", "createdAt": "2020-03-09T18:25:13Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.yahoo.elide.async.service;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3OTAyMA==", "bodyText": "Javadoc is missing.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389879020", "createdAt": "2020-03-09T18:25:50Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.yahoo.elide.async.service;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3ODcxNQ=="}, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjA1OTA3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoyNToyN1rOFz0UGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoyNToyN1rOFz0UGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3ODgxMQ==", "bodyText": "Copyright is needed as is javadoc for the class", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389878811", "createdAt": "2020-03-09T18:25:27Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.yahoo.elide.async.service;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjE5MzE0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTowNDo0OFrOFz1nMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDo0MjowOFrOF0R_tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMDA4Mg==", "bodyText": "The principalName should be set by a lifecycle (OnCreatePreCommit) hook automatically rather than having the user provide it in the API request.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389900082", "createdAt": "2020-03-09T19:04:48Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NTExMQ==", "bodyText": "Had to use OnCreatePreSecurity as using OnCreatePreCommit threw Null Pointer Exception.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r390365111", "createdAt": "2020-03-10T14:42:08Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMDA4Mg=="}, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjIxMDU1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxMDoxMVrOFz1yPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTowMjozNlrOFz5Q1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMjkxMQ==", "bodyText": "An alternative way to generate dates is:\n    @Generated(GenerationTime.INSERT)\n    @Column(updatable = false, insertable = false, columnDefinition = \"timestamp default current_timestamp\")\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date createdOn;\n\n    @Generated(GenerationTime.ALWAYS)\n    @Column(updatable = false, insertable = false, columnDefinition = \"timestamp default current_timestamp\")\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date updatedOn;", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389902911", "createdAt": "2020-03-09T19:10:11Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTg5Mw==", "bodyText": "As discussed, we will keep as is since @Generated is hibernate annotations.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389959893", "createdAt": "2020-03-09T21:02:36Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMjkxMQ=="}, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjIxNDAzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxMToxNlrOFz10jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxMToxNlrOFz10jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMzUwMQ==", "bodyText": "The natural key needs to be persisted to get hashCode & equals to work correctly.  hashCode & equals only uses the natural key or comparisons.  Remove Transient and add Exclude.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389903501", "createdAt": "2020-03-09T19:11:16Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n+    @Transient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjIxOTExOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxMzowMVrOFz133A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxMzowMVrOFz133A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwNDM0OA==", "bodyText": "Why not just pass the Query object in here instead of breaking out params for it.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389904348", "createdAt": "2020-03-09T19:13:01Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n+    @Transient\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @Override\n+    public String getPrincipalName() {\n+        return principalName;\n+    }\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n+    }\n+\n+    @OnCreatePostCommit\n+    public void executeQueryFromExecutor(RequestScope scope) {\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjIyMjU5OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxNDowOFrOFz16Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToxNDowOFrOFz16Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwNDg5OA==", "bodyText": "Change to @Exclude", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389904898", "createdAt": "2020-03-09T19:14:08Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+import lombok.Data;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Transient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI0NTU5OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyMToyOVrOFz2IQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyMToyOVrOFz2IQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwODU0NQ==", "bodyText": "Do we need both a a Cleaner and a CleanerService?  Why not just combine these into a single concept?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389908545", "createdAt": "2020-03-09T19:21:29Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Cleaner.\n+ */\n+@Singleton\n+class AsyncQueryCleaner {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI0ODI1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyMjoyMFrOFz2J4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyMjoyMFrOFz2J4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwODk2Mw==", "bodyText": "Do we need both an Executor and an ExecutorService?  Can we combine them?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389908963", "createdAt": "2020-03-09T19:22:20Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Executor.\n+ */\n+@Singleton\n+class AsyncQueryExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI1MzMzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyMzo1OFrOFz2NHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyMzo1OFrOFz2NHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwOTc4OA==", "bodyText": "You can move a lot of this setup code outside the closure (and hence outside the transaction).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389909788", "createdAt": "2020-03-09T19:23:58Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI2ODk1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyODo1OFrOFz2WwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOToyODo1OFrOFz2WwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxMjI1Ng==", "bodyText": "This is where using the DataStoreTransaction interface in Elide is less than ideal.  There is no bulk edit interface.  This will generate lots of round trips to the database to delete objects one at a time (rather than delete them in bulk).  We should at least change the DbUtil.deleteAsync function take a list of objects to delete - and to remove them in a single transaction.  DdUtil should be an interface that can be created and overridden (as a Spring bean) if there are performance problems with this general approach.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389912256", "createdAt": "2020-03-09T19:28:58Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI3ODU3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozMTo1NlrOFz2cuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozMTo1NlrOFz2cuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxMzc4NA==", "bodyText": "Multiplying maxRunTimeMinutes by 2 should be done in a single place across all the code.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389913784", "createdAt": "2020-03-09T19:31:56Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n+    }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI4NzkwOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozNDo1MlrOFz2ibw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozNDo1MlrOFz2ibw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNTI0Nw==", "bodyText": "We can push this logic into the RSQL filter expression.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389915247", "createdAt": "2020-03-09T19:34:52Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n+    }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjI5NDE2OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozNjozOVrOFz2mJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozNjozOVrOFz2mJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNjE5OA==", "bodyText": "The two functions can generalized with a common function that does a load and takes an FilterExpression to filter the results.\nThe two functions can call the generalized function to do a filtered load and then either update or delete the queries respectively.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389916198", "createdAt": "2020-03-09T19:36:39Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMwMTkwOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozODo1M1rOFz2qwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozODo1M1rOFz2qwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNzM3Nw==", "bodyText": "Can this be combined with the Interruptor service?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389917377", "createdAt": "2020-03-09T19:38:53Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Interruptor.\n+ */\n+@Singleton\n+class AsyncQueryInterruptor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMwMzU1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozOTozMVrOFz2r7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozOTozMVrOFz2r7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNzY3OQ==", "bodyText": "Remove.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389917679", "createdAt": "2020-03-09T19:39:31Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMwNDgyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozOTo1N1rOFz2swQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTozOTo1N1rOFz2swQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNzg4OQ==", "bodyText": "It would be good to log the entire query object here.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389917889", "createdAt": "2020-03-09T19:39:57Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMwOTkxOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0MTozMlrOFz2v1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0MTozMlrOFz2v1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxODY3OQ==", "bodyText": "Can we collapse these log lines into one?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389918679", "createdAt": "2020-03-09T19:41:32Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMxMDQ4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0MTo0M1rOFz2wKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0MTo0M1rOFz2wKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxODc2MQ==", "bodyText": "Cab we collapse these log lines into one?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389918761", "createdAt": "2020-03-09T19:41:43Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMxMzUyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0Mjo0NlrOFz2yGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0Mjo0NlrOFz2yGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTI1Ng==", "bodyText": "Creating the response and updating the status should be done inside a single transaction to the database.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389919256", "createdAt": "2020-03-09T19:42:46Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n+\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMxODI3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0NDoxMFrOFz209A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0NDoxMFrOFz209A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTk4OA==", "bodyText": "If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389919988", "createdAt": "2020-03-09T19:44:10Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n+\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n+            } else {\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // No AsyncQueryResult will be set for this case\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMxOTY3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0NDozM1rOFz21wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo0NDozM1rOFz21wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMDE5Mg==", "bodyText": "Remove log statement.  Let's consolidate logging into fewer (more complete log statements).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389920192", "createdAt": "2020-03-09T19:44:33Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n+\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n+            } else {\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // No AsyncQueryResult will be set for this case\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzc4NTQwOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyNToxNlrOF0-vjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyNjozOVrOF0-zRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5ODI1NA==", "bodyText": "I would move all of this common code to a base class like BaseId", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391098254", "createdAt": "2020-03-11T16:25:16Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+import lombok.Data;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @OneToOne\n+    private AsyncQuery query;\n+\n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @Exclude\n+    public String getPrincipalName() {\n+        return query.getPrincipalName();\n+    }\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updatedOn = new Date();\n+    }\n+\n+    @Override\n+    public int hashCode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5OTIwNA==", "bodyText": "You can even move the createdOn, updatedOn, and owner fields to a common super class.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391099204", "createdAt": "2020-03-11T16:26:39Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+import lombok.Data;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @OneToOne\n+    private AsyncQuery query;\n+\n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @Exclude\n+    public String getPrincipalName() {\n+        return query.getPrincipalName();\n+    }\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updatedOn = new Date();\n+    }\n+\n+    @Override\n+    public int hashCode() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5ODI1NA=="}, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzc5NDE0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyNzoxN1rOF0-06g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyNzoxN1rOF0-06g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5OTYyNg==", "bodyText": "Spacing is off in this function.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391099626", "createdAt": "2020-03-11T16:27:17Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Random;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Slf4j\n+@Singleton\n+public class AsyncCleanerService {\n+\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n+\n+    @Inject\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgwMTU1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyODo1NVrOF0-5WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyODo1NVrOF0-5WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwMDc2MA==", "bodyText": "This seems like a constructor argument rather than an interface contract.  I would remove.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391100760", "createdAt": "2020-03-11T16:28:55Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgwMzA0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyOToxOFrOF0-6Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjoyOToxOFrOF0-6Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwMTAxNA==", "bodyText": "Same comment.  We don't need this in the interface.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391101014", "createdAt": "2020-03-11T16:29:18Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgyMjQyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNDowMVrOF0_GbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNDowMVrOF0_GbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNDEwOQ==", "bodyText": "I don't think we should expose implementation details like UpdateQuery in a DAO interface.\nWe should have methods like updateStatus(UUID asyncQueryId, QueryStatus status)", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391104109", "createdAt": "2020-03-11T16:34:01Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgyNDAxOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNDoyM1rOF0_HZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNDoyM1rOF0_HZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNDM1OQ==", "bodyText": "Remove - see earlier comment.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391104359", "createdAt": "2020-03-11T16:34:23Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgyNzkzOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNToyNFrOF0_KHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNToyNFrOF0_KHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNTA1Mg==", "bodyText": "Let's not use Object here.  This should delete a collection of AsyncQuery objects.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391105052", "createdAt": "2020-03-11T16:35:24Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgyOTAwOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNTozN1rOF0_K0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNTozN1rOF0_K0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNTIzMw==", "bodyText": "Remove or replace with more specific functions.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391105233", "createdAt": "2020-03-11T16:35:37Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzgzOTQwOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozODowNFrOF0_RjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1MToyNVrOGInKZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjk1Ng==", "bodyText": "Spacing is off.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391106956", "createdAt": "2020-03-11T16:38:04Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+        log.debug(\"deleteAsyncQueryAndResultCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n+                }\n+            }\n+\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setQuery(asyncQuery);\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQuery.setResult(asyncQueryResult);\n+            tx.createObject(asyncQueryResult, scope);\n+            tx.save(asyncQuery, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    @Override\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        Object result = null;\n+        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n+\t        JsonApiDocument jsonApiDoc = new JsonApiDocument();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzQzMQ==", "bodyText": "Spacing is still off.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411683431", "createdAt": "2020-04-20T20:51:25Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+        log.debug(\"deleteAsyncQueryAndResultCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n+                }\n+            }\n+\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setQuery(asyncQuery);\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQuery.setResult(asyncQueryResult);\n+            tx.createObject(asyncQueryResult, scope);\n+            tx.save(asyncQuery, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    @Override\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        Object result = null;\n+        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n+\t        JsonApiDocument jsonApiDoc = new JsonApiDocument();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjk1Ng=="}, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzg0ODY3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0MDoxNVrOF0_XqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0MDoxNVrOF0_XqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwODUyMQ==", "bodyText": "Separate the load and delete.  This function should only delete (and not load anything).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391108521", "createdAt": "2020-03-11T16:40:15Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzg1Mjg2OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0MTowOFrOF0_aPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMToxOToyN1rOF7Df4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwOTE4Mw==", "bodyText": "I don't think this function should load anything.  Load can be a separate function.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391109183", "createdAt": "2020-03-11T16:41:08Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NzYxOA==", "bodyText": "Same comment still applies.  All of these objects have already been loaded.  This will result in a lot of unnecessary calls to the DB.\nInstead of loading them, just call the updateFunction and save.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397467618", "createdAt": "2020-03-24T21:19:27Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwOTE4Mw=="}, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzg2NzY3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0NDo1MVrOF0_j3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0NDo1MVrOF0_j3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMTY0Ng==", "bodyText": "Add a function (see later comments):\nCollection<AsyncQuery> loadQueries(FilterExpression filter)", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391111646", "createdAt": "2020-03-11T16:44:51Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzg4MzkxOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo0ODozOFrOF0_tug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1MDoyNlrOF0_ygw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDE3MA==", "bodyText": "We are logging the response above before we check for null here.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391114170", "createdAt": "2020-03-11T16:48:38Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            ElideResponse response = null;\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            if (response != null){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDkzOQ==", "bodyText": "Technically, I don't think this ever returns null.  I think it either returns non-null or throws an exception.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391114939", "createdAt": "2020-03-11T16:49:50Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            ElideResponse response = null;\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            if (response != null){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDE3MA=="}, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNTM5NQ==", "bodyText": "Instead of checking for null, we can just add an assert here that will throw an exception if response is null.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391115395", "createdAt": "2020-03-11T16:50:26Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            ElideResponse response = null;\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            if (response != null){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDE3MA=="}, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzkwNjk4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1Mzo1MFrOF0_7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1Mzo1MFrOF0_7uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNzc1Mw==", "bodyText": "There is some duplicate code here with the prior function.   We should write a utility function to consolidate it.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391117753", "createdAt": "2020-03-11T16:53:50Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzkwODUxOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1NDoxNVrOF0_8wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1NDoxNVrOF0_8wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExODAxNg==", "bodyText": "Shouldn't this be TIMEDOUT instead of PROCESSING?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391118016", "createdAt": "2020-03-11T16:54:15Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n+            asyncQuery.setStatus(QueryStatus.PROCESSING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzkyMTU0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1NzoyNlrOF1AFAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1NzoyNlrOF1AFAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMDEyOA==", "bodyText": "This doesn't look right to me.  I don't think a Constructor should be calling the a factory method for itself (the singleton).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391120128", "createdAt": "2020-03-11T16:57:26Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Random;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Slf4j\n+@Singleton\n+public class AsyncCleanerService {\n+\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n+\n+    @Inject\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n+    \t\n+        // Setting up query cleaner that marks long running query as TIMEDOUT.\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzkyNDY1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1ODowOVrOF1AG_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1ODowOVrOF1AG_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMDYzOQ==", "bodyText": "Why do we have the two constructors?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391120639", "createdAt": "2020-03-11T16:58:09Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Random;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Slf4j\n+@Singleton\n+public class AsyncCleanerService {\n+\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n+\n+    @Inject\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n+    \t\n+        // Setting up query cleaner that marks long running query as TIMEDOUT.\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+\n+        // Since there will be multiple hosts running the elide service,\n+        // setting up random delays to avoid all of them trying to cleanup at the same time.\n+        Random random = new Random();\n+        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n+\n+        //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+    }\n+\n+    private static AsyncCleanerService getInstance() {\n+        if (asyncCleanerService == null) {\n+          synchronized (AsyncCleanerService.class) {\n+        \t  asyncCleanerService = new AsyncCleanerService();\n+          }\n+        }\n+        return asyncCleanerService;\n+    }\n+\n+    private AsyncCleanerService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzkyNzA2OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1ODo0MlrOF1AIjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1ODo0MlrOF1AIjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTAzOQ==", "bodyText": "Why do we need these two constructors?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391121039", "createdAt": "2020-03-11T16:58:42Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Date;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Singleton\n+public class AsyncExecutorService {\n+\n+    private final int DEFAULT_THREADPOOL_SIZE = 6;\n+\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private ExecutorService executor;\n+    private ExecutorService interruptor;\n+    private int maxRunTime;\n+    private static AsyncExecutorService asyncExecutorService;\n+    private AsyncQueryDAO asyncQueryDao;\n+    \n+\n+    @Inject\n+    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+        this.elide = elide;\n+        this.runner = new QueryRunner(elide);\n+        this.maxRunTime = maxRunTime;\n+        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n+        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        this.asyncQueryDao = asyncQueryDao;\n+    }\n+\n+    public void executeQuery(AsyncQuery queryObj, User user) {\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+        // Change async query in Datastore to queued\n+        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n+            });\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n+                maxRunTime, asyncQueryDao);\n+        interruptor.execute(queryInterruptWorker);\n+    }\n+\n+    private static AsyncExecutorService getInstance(int threadPoolSize) {\n+        if (asyncExecutorService == null) {\n+          synchronized (AsyncExecutorService.class) {\n+        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n+            }\n+          }\n+        return asyncExecutorService;\n+    }\n+\n+    private AsyncExecutorService(int threadPoolSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzkyOTE4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1OToxNlrOF1AJ9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjo1OToxNlrOF1AJ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTM5Nw==", "bodyText": "This looks wrong to me.  A constructor should not call a factory method on itself.  Maybe we should just eliminate all the singletons?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391121397", "createdAt": "2020-03-11T16:59:16Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Date;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Singleton\n+public class AsyncExecutorService {\n+\n+    private final int DEFAULT_THREADPOOL_SIZE = 6;\n+\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private ExecutorService executor;\n+    private ExecutorService interruptor;\n+    private int maxRunTime;\n+    private static AsyncExecutorService asyncExecutorService;\n+    private AsyncQueryDAO asyncQueryDao;\n+    \n+\n+    @Inject\n+    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+        this.elide = elide;\n+        this.runner = new QueryRunner(elide);\n+        this.maxRunTime = maxRunTime;\n+        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzY5ODM3OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDoyNDo0NVrOF7Brrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDoyNDo0NVrOF7Brrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQzNzg3MA==", "bodyText": "let's check that the object classes are also equal.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397437870", "createdAt": "2020-03-24T20:24:45Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.Exclude;\n+\n+import lombok.Getter;\n+\n+@MappedSuperclass\n+public abstract class AsyncBase {\n+\n+    @Getter private Date createdOn;\n+\n+    @Getter private Date updatedOn;\n+\n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncBase)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mzg2NTc4OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMToxMjo0MlrOF7DSuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1Mzo1NFrOGInQWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDI1MQ==", "bodyText": "This one line can be moved outside the transaction.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397464251", "createdAt": "2020-03-24T21:12:42Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -127,8 +149,38 @@ public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBo\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0NjEwNA==", "bodyText": "If we move this line outside the anonymous function - we would have to put it in a try catch block and move the filter variable as a class level variable else we get: Local variable filter defined in an enclosing scope must be final or effectively final. Do you want this variable to be a class level variable?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397546104", "createdAt": "2020-03-25T00:43:27Z", "author": {"login": "Abhino"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -127,8 +149,38 @@ public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBo\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDI1MQ=="}, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4NDk1Mw==", "bodyText": "You can make filter final inside the loadQueries function.  Then you can move outside the try/catch block.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411684953", "createdAt": "2020-04-20T20:53:54Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -127,8 +149,38 @@ public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBo\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDI1MQ=="}, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mzg2OTMyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMToxMzo0NVrOF7DU2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMToxMzo0NVrOF7DU2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDc5Mw==", "bodyText": "I wonder if this will swallow exceptions that would have been caught and handled by the outer transaction function.  Would it be better to let that function handle the exceptions?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397464793", "createdAt": "2020-03-24T21:13:45Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -127,8 +149,38 @@ public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBo\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mzg5NDkyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMToyMTo1NlrOF7Dk2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjoyODowNVrOF7KA1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2ODg4OA==", "bodyText": "Same comment about the load below.  The objects can be assumed to have already been loaded.  This function can just call tx.delete.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397468888", "createdAt": "2020-03-24T21:21:56Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -87,14 +109,14 @@ public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction\n     }\n \n     @Override\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n         executeInTransaction(dataStore, (tx, scope) -> {\n             EntityProjection asyncQueryCollection = EntityProjection.builder()\n                     .type(AsyncQuery.class)\n                     .build();\n \n-            Iterator<Object> itr = asyncQueryList.iterator();\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NDM1OQ==", "bodyText": "We are able to remove the load object logic for the update, but does not work with delete. Even calling save before delete does not work. It throws TransactionException trying to remove a detached entity.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397574359", "createdAt": "2020-03-25T02:28:05Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -87,14 +109,14 @@ public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction\n     }\n \n     @Override\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n         executeInTransaction(dataStore, (tx, scope) -> {\n             EntityProjection asyncQueryCollection = EntityProjection.builder()\n                     .type(AsyncQuery.class)\n                     .build();\n \n-            Iterator<Object> itr = asyncQueryList.iterator();\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2ODg4OA=="}, "originalCommit": {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzU1Njk0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoyNDoxOFrOGImLHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDoyNDo0M1rOGImMGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NzIyOA==", "bodyText": "Copyright.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411667228", "createdAt": "2020-04-20T20:24:18Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.yahoo.elide.async.models;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NzQ4Mg==", "bodyText": "My guess is elide-async is not running checkstyles.  Otherwise the build would break and catch this.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411667482", "createdAt": "2020-04-20T20:24:43Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.yahoo.elide.async.models;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NzIyOA=="}, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzYyNTkyOnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0MToyOFrOGImzQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0MToyOFrOGImzQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3NzUwNA==", "bodyText": "I don't remember the reason - but why don't we pass a filter expression here (instead of a collection) and then filter and update in single DAO call?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411677504", "createdAt": "2020-04-20T20:41:28Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n+     */\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+\n+    /**\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n+     */\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzYzNjg0OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0NDoxN1rOGIm51w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0NDoxN1rOGIm51w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3OTE5MQ==", "bodyText": "We should only update to COMPLETE after we've created the response.  Swap this line with the next.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411679191", "createdAt": "2020-04-20T20:44:17Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            ElideResponse response = null;\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzY0OTAxOnYy", "diffSide": "RIGHT", "path": "elide-spring/elide-spring-boot-autoconfigure/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0NzozMlrOGInBIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0NzozMlrOGInBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MTA1Ng==", "bodyText": "Needs optional true", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411681056", "createdAt": "2020-04-20T20:47:32Z", "author": {"login": "aklish"}, "path": "elide-spring/elide-spring-boot-autoconfigure/pom.xml", "diffHunk": "@@ -93,6 +93,12 @@\n             <optional>true</optional>\n         </dependency>\n \n+        <dependency>\n+            <groupId>com.yahoo.elide</groupId>\n+            <artifactId>elide-async</artifactId>\n+            <version>5.0.0-pr7-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzY4MDk5OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1NToyNlrOGInTyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMzozNzoxNFrOGIw9dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4NTgzNA==", "bodyText": "This can be moved outside the try block (by making it final).", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411685834", "createdAt": "2020-04-20T20:55:26Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n+\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n+    }\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status) {\n+        return updateAsyncQueryCollection(asyncQueryList, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                updateFunction.update(query);\n+                tx.save(query, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+        log.debug(\"deleteAsyncQueryAndResultCollection\");\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg0Mzk1Ng==", "bodyText": "We are unable to move this outside the try block because the ParseException is thrown by the filterParser.parseFilterExpression method itself.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411843956", "createdAt": "2020-04-21T03:37:14Z", "author": {"login": "moizarafat"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n+\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n+    }\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status) {\n+        return updateAsyncQueryCollection(asyncQueryList, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                updateFunction.update(query);\n+                tx.save(query, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+        log.debug(\"deleteAsyncQueryAndResultCollection\");\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4NTgzNA=="}, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzY4ODM1OnYy", "diffSide": "RIGHT", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1NzoyNFrOGInYLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo1NzoyNFrOGInYLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4Njk1OQ==", "bodyText": "Spacing is off.", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411686959", "createdAt": "2020-04-20T20:57:24Z", "author": {"login": "aklish"}, "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n+\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n+    }\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzc1NTc5OnYy", "diffSide": "RIGHT", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMToxNToxMVrOGIn_1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMToxNToxMVrOGIn_1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5NzExMQ==", "bodyText": "Maybe return the default one here?", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411697111", "createdAt": "2020-04-20T21:15:11Z", "author": {"login": "aklish"}, "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -167,6 +168,60 @@ default boolean enableJSONAPI() {\n     default boolean enableGraphQL() {\n         return true;\n     }\n+    \n+    /**\n+     * Enable the support for Async querying feature. If false, the async feature will be disabled.\n+     *\n+     * @return Default: False\n+     */\n+    default boolean enableAsync() {\n+        return false;\n+    }\n+\n+    /**\n+     * Enable the support for cleaning up Async query history. If false, the async cleanup feature will be disabled.\n+     *\n+     * @return Default: False\n+     */\n+    default boolean enableAsyncCleanup() {\n+        return false;\n+    }\n+\n+    /**\n+     * Thread Size for Async queries to run in parallel.\n+     *\n+     * @return Default: 5\n+     */\n+    default Integer getAsyncThreadSize() {\n+        return 5;\n+    }\n+\n+    /**\n+     * Maximum Query Run time for Async Queries to mark as TIMEDOUT.\n+     *\n+     * @return Default: 60\n+     */\n+    default Integer getAsyncMaxRunTimeMinutes() {\n+        return 60;\n+    }\n+\n+    /**\n+     * Number of days history to retain for async query executions and results.\n+     *\n+     * @return Default: 7\n+     */\n+    default Integer getAsyncQueryCleanupDays() {\n+        return 7;\n+    }\n+\n+    /**\n+     * Implementation of AsyncQueryDAO to use.\n+     *\n+     * @return AsyncQueryDAO type object.\n+     */\n+    default AsyncQueryDAO getAsyncQueryDAO() {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1064, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}