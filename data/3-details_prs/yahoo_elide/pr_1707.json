{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxOTg0NzYx", "number": 1707, "title": "Dynamic Model Extends: Inherit Table Properties", "bodyText": "Description\nWhen extending Models in Dynamic Config, we need to inherit Table Properties.\nHow Has This Been Tested?\nExisting and new test cases.\nLicense\nI confirm that this contribution is made under an Apache 2.0 license and that I have the authority necessary to make this contribution on behalf of its copyright owner.", "createdAt": "2020-12-03T18:21:28Z", "url": "https://github.com/yahoo/elide/pull/1707", "merged": true, "mergeCommit": {"oid": "bbdfd1a083baaafd92224b8b1d5a5251d4302387"}, "closed": true, "closedAt": "2020-12-07T23:17:50Z", "author": {"login": "moizarafat"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdinW8SgBqjQwNjkwMDE5ODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj9x7sAFqTU0NjYxMTQ4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c962b6625cd4c01e43f0d640d4227cbc3f88c90f", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/c962b6625cd4c01e43f0d640d4227cbc3f88c90f", "committedDate": "2020-12-03T18:21:07Z", "message": "Initial"}, "afterCommit": {"oid": "eacb473893827885805b37a6e54cf4ab665a7fcc", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/eacb473893827885805b37a6e54cf4ab665a7fcc", "committedDate": "2020-12-03T18:21:43Z", "message": "Initial"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/5fae23633206107b6dba14479623499d7c28bd9d", "committedDate": "2020-12-04T16:50:01Z", "message": "Initial"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eacb473893827885805b37a6e54cf4ab665a7fcc", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/eacb473893827885805b37a6e54cf4ab665a7fcc", "committedDate": "2020-12-03T18:21:43Z", "message": "Initial"}, "afterCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/5fae23633206107b6dba14479623499d7c28bd9d", "committedDate": "2020-12-04T16:50:01Z", "message": "Initial"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NTk3ODgz", "url": "https://github.com/yahoo/elide/pull/1707#pullrequestreview-545597883", "createdAt": "2020-12-05T16:09:11Z", "commit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNjowOToxMVrOH_8mTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQxNjoyOTozMFrOH_8yPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTE4MA==", "bodyText": "Don't use object here.  We should use generics.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815180", "createdAt": "2020-12-05T16:09:11Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getDbConnectionName();\n+                        }, true\n+                );\n+                table.setDbConnectionName(dbConnectionName);\n+\n+                String readAccess = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getReadAccess();\n+                        }, true\n+                );\n+                table.setReadAccess(readAccess);\n+\n+                String sql = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSql();\n+                        }, true\n+                );\n+                table.setSql(sql);\n+\n+                String tableName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getTable();\n+                        }, true\n+                );\n+                table.setTable(tableName);\n             }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedMeasures(table.getParent(this.elideTableConfig), measures);\n         }\n-        return measures;\n     }\n \n-    private Map<String, Dimension> getInheritedDimensions(Table table, Map<String, Dimension> dimensions) {\n-        table.getDimensions().forEach(dim -> {\n-            if (!dimensions.containsKey(dim.getName())) {\n-                dimensions.put(dim.getName(), dim);\n-            }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedDimensions(table.getParent(this.elideTableConfig), dimensions);\n-        }\n-        return dimensions;\n-    }\n \n-    private Map<String, Join> getInheritedJoins(Table table, Map<String, Join> joins) {\n-        table.getJoins().forEach(join -> {\n-            if (!joins.containsKey(join.getName())) {\n-                joins.put(join.getName(), join);\n-            }\n-        });\n+    private Object getInheritedAttribute(Table table, Object result, Inheritance action, boolean recurseOnlyIfNull) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTMxMw==", "bodyText": "We should leave the methods getInheritedMeasures and getInheritedDimensions, etc.  They improve readability.  Those functions can return the correct type and in turn call getInheritedAttribute with the appropriate Inherit method.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815313", "createdAt": "2020-12-05T16:10:07Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTc3OQ==", "bodyText": "There are two standard ways to ensure ancestors are processed before decedents:\n\nStandard DFS algorithm with a visited set and toVisit stack.\nTail Recursion.\n\nLet's not do this with a single data structure that we both add and remove from.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815779", "createdAt": "2020-12-05T16:13:18Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTk3NQ==", "bodyText": "Why not just call parent.hasParent here?  It improves readability", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815975", "createdAt": "2020-12-05T16:14:23Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjM2Mw==", "bodyText": "You technically don't need to add a table parameter (tab) here because it is available through closure.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816363", "createdAt": "2020-12-05T16:16:57Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjQyNw==", "bodyText": "Having both tab and table looks odd.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816427", "createdAt": "2020-12-05T16:17:09Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjM2Mw=="}, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjcwOQ==", "bodyText": "These should all be separate functions.  Having embedded lambdas all together like this in one function makes this hard to read.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816709", "createdAt": "2020-12-05T16:19:18Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjgyOA==", "bodyText": "null as second parameter seems like the abstraction to commonize this code is not working.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816828", "createdAt": "2020-12-05T16:19:58Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjcwOQ=="}, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNzMwNg==", "bodyText": "The last parameter recurseOnlyIfNull is a tell that this really ought to be two separate functions.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536817306", "createdAt": "2020-12-05T16:23:00Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getDbConnectionName();\n+                        }, true\n+                );\n+                table.setDbConnectionName(dbConnectionName);\n+\n+                String readAccess = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getReadAccess();\n+                        }, true\n+                );\n+                table.setReadAccess(readAccess);\n+\n+                String sql = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSql();\n+                        }, true\n+                );\n+                table.setSql(sql);\n+\n+                String tableName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getTable();\n+                        }, true\n+                );\n+                table.setTable(tableName);\n             }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedMeasures(table.getParent(this.elideTableConfig), measures);\n         }\n-        return measures;\n     }\n \n-    private Map<String, Dimension> getInheritedDimensions(Table table, Map<String, Dimension> dimensions) {\n-        table.getDimensions().forEach(dim -> {\n-            if (!dimensions.containsKey(dim.getName())) {\n-                dimensions.put(dim.getName(), dim);\n-            }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedDimensions(table.getParent(this.elideTableConfig), dimensions);\n-        }\n-        return dimensions;\n-    }\n \n-    private Map<String, Join> getInheritedJoins(Table table, Map<String, Join> joins) {\n-        table.getJoins().forEach(join -> {\n-            if (!joins.containsKey(join.getName())) {\n-                joins.put(join.getName(), join);\n-            }\n-        });\n+    private Object getInheritedAttribute(Table table, Object result, Inheritance action, boolean recurseOnlyIfNull) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNzUzOA==", "bodyText": "Lots of casting like this makes the code hard to read (and generally can be removed through other means).", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536817538", "createdAt": "2020-12-05T16:24:43Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODA3Ng==", "bodyText": "I thought there was already a test for this.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818076", "createdAt": "2020-12-05T16:28:21Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/test/resources/validator/infinite_loop_cyclic_dependency_inheritance/models/tables/tableA.hjson", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: A\n+      extend: B\n+      description: A extends B (which extends A) - an invalid cycle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODA4NA==", "bodyText": "Same comment.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818084", "createdAt": "2020-12-05T16:28:34Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/test/resources/validator/infinite_loop_cyclic_dependency_inheritance/models/tables/tableB.hjson", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: B\n+      extend: A\n+      description: B extends A (which extends B) - an invalid cycle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODEyOQ==", "bodyText": "Same comment.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818129", "createdAt": "2020-12-05T16:28:48Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/test/resources/validator/infinite_loop_missing_parent_inheritance/models/tables/tableA.hjson", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: A\n+      extend: B\n+      description: A extends B (which doesn't exist)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODIzOQ==", "bodyText": "Don't we already have an extends test?  I'm confused why we needed to create so many new HJSON test files.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818239", "createdAt": "2020-12-05T16:29:30Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/test/resources/validator/table_sql_both_inheritance/models/tables/player_stats_extends.hjson", "diffHunk": "@@ -0,0 +1,36 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: PlayerStatsChild\n+      extend: PlayerStats", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fae23633206107b6dba14479623499d7c28bd9d"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf1d1d84cf0581c3b6a17cda450cc4b4d948cff1", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/bf1d1d84cf0581c3b6a17cda450cc4b4d948cff1", "committedDate": "2020-12-07T03:34:42Z", "message": "Review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecb4de91751bfc42b4138715c60c12cd4a8ab0df", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/ecb4de91751bfc42b4138715c60c12cd4a8ab0df", "committedDate": "2020-12-07T03:38:12Z", "message": "Update pom.xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc099d8931088345b54c2b444ea02f376baeb671", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/dc099d8931088345b54c2b444ea02f376baeb671", "committedDate": "2020-12-07T18:21:32Z", "message": "Merge branch 'elide-5.x' into extends_features"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "committedDate": "2020-12-07T18:24:46Z", "message": "review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MzcyNTUw", "url": "https://github.com/yahoo/elide/pull/1707#pullrequestreview-546372550", "createdAt": "2020-12-07T17:28:25Z", "commit": {"oid": "ecb4de91751bfc42b4138715c60c12cd4a8ab0df"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNzoyODoyNlrOIAx_cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTozMzoxMlrOIA3IEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4OTk2OQ==", "bodyText": "Why do we need this dependency?", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537689969", "createdAt": "2020-12-07T17:28:26Z", "author": {"login": "aklish"}, "path": "elide-spring/elide-spring-boot-autoconfigure/pom.xml", "diffHunk": "@@ -209,6 +209,12 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecb4de91751bfc42b4138715c60c12cd4a8ab0df"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NDI0NQ==", "bodyText": "Nitpick - but I would invert this if condition and return early if the opposite is true.  Then the entire function doesn't have to be nested inside this if block (it helps with line length and readability).", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537764245", "createdAt": "2020-12-07T19:19:04Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTg0NQ==", "bodyText": "shouldn't this be called on the parent rather than table?  Similar comment for other calls below.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537769845", "createdAt": "2020-12-07T19:27:46Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {\n+            Table parent = table.getParent(this.elideTableConfig);\n+            // If parent also extends, ensure parent is processed first.\n+            if (parent.hasParent()) {\n+                populateInheritance(parent, processed);\n             }\n+\n+            Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3NDA5OA==", "bodyText": "Do we really need to cast to String here?", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537774098", "createdAt": "2020-12-07T19:33:12Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {\n+            Table parent = table.getParent(this.elideTableConfig);\n+            // If parent also extends, ensure parent is processed first.\n+            if (parent.hasParent()) {\n+                populateInheritance(parent, processed);\n             }\n+\n+            Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+            table.setMeasures(new ArrayList<Measure>(measures.values()));\n+\n+            Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+            table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+\n+            Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+            table.setJoins(new ArrayList<Join>(joins.values()));\n+\n+            String schema = getInheritedSchema(table);\n+            table.setSchema(schema);\n+\n+            String dbConnectionName = (String) getInheritedConnection(table);\n+            table.setDbConnectionName(dbConnectionName);\n+\n+            String sql = (String) getInheritedSql(table);\n+            table.setSql(sql);\n+\n+            String tableName = (String) getInheritedTable(table);\n+            table.setTable(tableName);\n+\n+            // isFact, isHidden, ReadAccess have default Values in schema, so can not be inherited.\n+            // Other properties (tags, cardinality, etc.) have been categorized as non-inheritable too.\n         }\n+        processed.add(table);\n+    }\n+\n+\n+    @FunctionalInterface\n+    public interface Inheritance<T> {\n+        public T inherit();\n     }\n \n     private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n-            }\n-        });\n+        Inheritance action = () -> {\n+                table.getMeasures().forEach(measure -> {\n+                    if (!measures.containsKey(measure.getName())) {\n+                        measures.put(measure.getName(), measure);\n+                    }\n+                });\n+                return measures;\n+        };\n+\n+        action.inherit();\n         if (table.hasParent()) {\n-            getInheritedMeasures(table.getParent(this.elideTableConfig), measures);\n+            getInheritedMeasures(table.getParent(elideTableConfig), measures);\n         }\n         return measures;\n     }\n \n     private Map<String, Dimension> getInheritedDimensions(Table table, Map<String, Dimension> dimensions) {\n-        table.getDimensions().forEach(dim -> {\n-            if (!dimensions.containsKey(dim.getName())) {\n-                dimensions.put(dim.getName(), dim);\n-            }\n-        });\n+        Inheritance action = () -> {\n+            table.getDimensions().forEach(dimension -> {\n+                if (!dimensions.containsKey(dimension.getName())) {\n+                    dimensions.put(dimension.getName(), dimension);\n+                }\n+            });\n+            return dimensions;\n+        };\n+        action.inherit();\n         if (table.hasParent()) {\n-            getInheritedDimensions(table.getParent(this.elideTableConfig), dimensions);\n+            getInheritedDimensions(table.getParent(elideTableConfig), dimensions);\n         }\n         return dimensions;\n     }\n \n     private Map<String, Join> getInheritedJoins(Table table, Map<String, Join> joins) {\n-        table.getJoins().forEach(join -> {\n-            if (!joins.containsKey(join.getName())) {\n-                joins.put(join.getName(), join);\n-            }\n-        });\n+        Inheritance action = () -> {\n+            table.getJoins().forEach(join -> {\n+                if (!joins.containsKey(join.getName())) {\n+                    joins.put(join.getName(), join);\n+                }\n+            });\n+            return joins;\n+        };\n+        action.inherit();\n         if (table.hasParent()) {\n-            getInheritedJoins(table.getParent(this.elideTableConfig), joins);\n+            getInheritedJoins(table.getParent(elideTableConfig), joins);\n         }\n         return joins;\n     }\n \n+    private String getInheritedSchema(Table table) {\n+        Inheritance action = () -> {\n+            return table.getSchema();\n+        };\n+\n+        String schema = (String) action.inherit();\n+\n+        if (schema == null && table.hasParent()) {\n+            schema = getInheritedSchema(table.getParent(elideTableConfig));\n+        }\n+        return schema;\n+    }\n+\n+    private String getInheritedConnection(Table table) {\n+        Inheritance action = () -> {\n+            return table.getDbConnectionName();\n+        };\n+\n+        String conn = (String) action.inherit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTEzMTQz", "url": "https://github.com/yahoo/elide/pull/1707#pullrequestreview-546513143", "createdAt": "2020-12-07T20:33:11Z", "commit": {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDozMzoxMVrOIA5fGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDozMzoxMVrOIA5fGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxMjc2Mw==", "bodyText": "But we shouldn't need to add the measures for the current table (as they are already defined in the table).  We only need to add the inherited measures.  This reads like we are duplicating what's already defined in the current table.", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537812763", "createdAt": "2020-12-07T20:33:11Z", "author": {"login": "aklish"}, "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {\n+            Table parent = table.getParent(this.elideTableConfig);\n+            // If parent also extends, ensure parent is processed first.\n+            if (parent.hasParent()) {\n+                populateInheritance(parent, processed);\n             }\n+\n+            Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTg0NQ=="}, "originalCommit": {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3218a3290b789fa6792becda0da1843308ddbcef", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/3218a3290b789fa6792becda0da1843308ddbcef", "committedDate": "2020-12-07T21:33:49Z", "message": "review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f01c8ed3d835d286128b643d36013048087d40d3", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/f01c8ed3d835d286128b643d36013048087d40d3", "committedDate": "2020-12-07T21:37:47Z", "message": "review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35960f69ba7eda1f050996602c72b47504f468fc", "author": {"user": {"login": "moizarafat", "name": "Moiz Arafat"}}, "url": "https://github.com/yahoo/elide/commit/35960f69ba7eda1f050996602c72b47504f468fc", "committedDate": "2020-12-07T22:08:39Z", "message": "review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTgwMjQ2", "url": "https://github.com/yahoo/elide/pull/1707#pullrequestreview-546580246", "createdAt": "2020-12-07T22:10:34Z", "commit": {"oid": "35960f69ba7eda1f050996602c72b47504f468fc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fe50d0bf2565fc8ea2f2ea5dd048b231584fecb", "author": {"user": {"login": "rishi-aga", "name": null}}, "url": "https://github.com/yahoo/elide/commit/4fe50d0bf2565fc8ea2f2ea5dd048b231584fecb", "committedDate": "2020-12-07T22:52:59Z", "message": "CVE errors for tomcat embed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjExNDgx", "url": "https://github.com/yahoo/elide/pull/1707#pullrequestreview-546611481", "createdAt": "2020-12-07T23:03:20Z", "commit": {"oid": "4fe50d0bf2565fc8ea2f2ea5dd048b231584fecb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 707, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}