{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MzY3MzIx", "number": 1305, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo1ODoyNVrOD6FwDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo1OToxOVrOD6FwyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjM4MjIwOnYy", "diffSide": "RIGHT", "path": "elide-graphql/src/main/java/com/yahoo/elide/graphql/PersistentResourceFetcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo1ODoyNVrOGRuawA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo1ODoyNVrOGRuawA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzOTQ4OA==", "bodyText": "Unnecessary initialization.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String errorMessage = \"\";\n          \n          \n            \n                        String errorMessage;", "url": "https://github.com/yahoo/elide/pull/1305#discussion_r421239488", "createdAt": "2020-05-07T04:58:25Z", "author": {"login": "wcekan"}, "path": "elide-graphql/src/main/java/com/yahoo/elide/graphql/PersistentResourceFetcher.java", "diffHunk": "@@ -563,22 +562,38 @@ private ConnectionContainer replaceObjects(Environment context) {\n         return sort.map(Sorting::parseSortRule);\n     }\n \n+    private MultivaluedHashMap<String, String> getQueryParams(Optional<String> typeName, String filterStr) {\n+        return new MultivaluedHashMap<String, String>() {\n+            {\n+                String filterKey = \"filter\";\n+                if (typeName.isPresent()) {\n+                    filterKey += \"[\" + typeName + \"]\";\n+                }\n+                put(filterKey, Arrays.asList(filterStr));\n+            }\n+        };\n+    }\n+\n     private Optional<FilterExpression> buildFilter(String typeName,\n                                                    Optional<String> filter,\n                                                    RequestScope requestScope) {\n         // TODO: Refactor FilterDialect interfaces to accept string or List<String> instead of (or in addition to?)\n         // query params.\n         return filter.map(filterStr -> {\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>() {\n-                {\n-                    put(\"filter[\" + typeName + \"]\", Arrays.asList(filterStr));\n-                }\n-            };\n+            String errorMessage = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd79b8a9efd998a1d8f0c458f4b4bfa3dcccc41"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjM4NDA5OnYy", "diffSide": "RIGHT", "path": "elide-graphql/src/main/java/com/yahoo/elide/graphql/PersistentResourceFetcher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDo1OToxOVrOGRub1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNTozOToyNlrOGSEkbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzOTc2Nw==", "bodyText": "@aklish will this conflict with #1304?", "url": "https://github.com/yahoo/elide/pull/1305#discussion_r421239767", "createdAt": "2020-05-07T04:59:19Z", "author": {"login": "wcekan"}, "path": "elide-graphql/src/main/java/com/yahoo/elide/graphql/PersistentResourceFetcher.java", "diffHunk": "@@ -563,22 +562,38 @@ private ConnectionContainer replaceObjects(Environment context) {\n         return sort.map(Sorting::parseSortRule);\n     }\n \n+    private MultivaluedHashMap<String, String> getQueryParams(Optional<String> typeName, String filterStr) {\n+        return new MultivaluedHashMap<String, String>() {\n+            {\n+                String filterKey = \"filter\";\n+                if (typeName.isPresent()) {\n+                    filterKey += \"[\" + typeName + \"]\";\n+                }\n+                put(filterKey, Arrays.asList(filterStr));\n+            }\n+        };\n+    }\n+\n     private Optional<FilterExpression> buildFilter(String typeName,\n                                                    Optional<String> filter,\n                                                    RequestScope requestScope) {\n         // TODO: Refactor FilterDialect interfaces to accept string or List<String> instead of (or in addition to?)\n         // query params.\n         return filter.map(filterStr -> {\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>() {\n-                {\n-                    put(\"filter[\" + typeName + \"]\", Arrays.asList(filterStr));\n-                }\n-            };\n+            String errorMessage = \"\";\n+            try {\n+                return requestScope.getFilterDialect()\n+                        .parseGlobalExpression(typeName, getQueryParams(Optional.empty(), filterStr));\n+            } catch (ParseException e) {\n+                errorMessage = e.getMessage();\n+            }\n+\n             try {\n-                return requestScope.getFilterDialect().parseTypedExpression(typeName, queryParams).get(typeName);\n+                return requestScope.getFilterDialect()\n+                        .parseTypedExpression(typeName, getQueryParams(Optional.of(typeName), filterStr))\n+                        .get(typeName);\n             } catch (ParseException e) {\n-                log.debug(\"Filter parse exception caught\", e);\n-                throw new InvalidPredicateException(\"Could not parse filter for type: \" + typeName);\n+                throw new InvalidPredicateException(errorMessage + \"\\n\" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfd79b8a9efd998a1d8f0c458f4b4bfa3dcccc41"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYwMjQxMw==", "bodyText": "It will - but should be simple to merge.", "url": "https://github.com/yahoo/elide/pull/1305#discussion_r421602413", "createdAt": "2020-05-07T15:39:26Z", "author": {"login": "aklish"}, "path": "elide-graphql/src/main/java/com/yahoo/elide/graphql/PersistentResourceFetcher.java", "diffHunk": "@@ -563,22 +562,38 @@ private ConnectionContainer replaceObjects(Environment context) {\n         return sort.map(Sorting::parseSortRule);\n     }\n \n+    private MultivaluedHashMap<String, String> getQueryParams(Optional<String> typeName, String filterStr) {\n+        return new MultivaluedHashMap<String, String>() {\n+            {\n+                String filterKey = \"filter\";\n+                if (typeName.isPresent()) {\n+                    filterKey += \"[\" + typeName + \"]\";\n+                }\n+                put(filterKey, Arrays.asList(filterStr));\n+            }\n+        };\n+    }\n+\n     private Optional<FilterExpression> buildFilter(String typeName,\n                                                    Optional<String> filter,\n                                                    RequestScope requestScope) {\n         // TODO: Refactor FilterDialect interfaces to accept string or List<String> instead of (or in addition to?)\n         // query params.\n         return filter.map(filterStr -> {\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>() {\n-                {\n-                    put(\"filter[\" + typeName + \"]\", Arrays.asList(filterStr));\n-                }\n-            };\n+            String errorMessage = \"\";\n+            try {\n+                return requestScope.getFilterDialect()\n+                        .parseGlobalExpression(typeName, getQueryParams(Optional.empty(), filterStr));\n+            } catch (ParseException e) {\n+                errorMessage = e.getMessage();\n+            }\n+\n             try {\n-                return requestScope.getFilterDialect().parseTypedExpression(typeName, queryParams).get(typeName);\n+                return requestScope.getFilterDialect()\n+                        .parseTypedExpression(typeName, getQueryParams(Optional.of(typeName), filterStr))\n+                        .get(typeName);\n             } catch (ParseException e) {\n-                log.debug(\"Filter parse exception caught\", e);\n-                throw new InvalidPredicateException(\"Could not parse filter for type: \" + typeName);\n+                throw new InvalidPredicateException(errorMessage + \"\\n\" + e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzOTc2Nw=="}, "originalCommit": {"oid": "cfd79b8a9efd998a1d8f0c458f4b4bfa3dcccc41"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1033, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}