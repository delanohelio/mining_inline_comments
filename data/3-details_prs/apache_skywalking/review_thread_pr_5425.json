{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MTYwNjYz", "number": 5425, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1MzowNVrOEe-E4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NzoyNVrOEe-M-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTA5NzkyOnYy", "diffSide": "LEFT", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1MzowNVrOHK9C-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo1NjozM1rOHLJqCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI0Nzk5NA==", "bodyText": "Do you remove this for accepting different labels in 2 instances?", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481247994", "createdAt": "2020-09-01T15:53:05Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "diffHunk": "@@ -83,33 +84,39 @@ public void accept(final MeterEntity entity, final BucketedValues value) {\n \n         this.entityId = entity.id();\n \n+        String template = \"%s\";\n+        if (!Strings.isNullOrEmpty(value.getGroup())) {\n+            template   = value.getGroup() + \":%s\";\n+        }\n         final long[] values = value.getValues();\n         for (int i = 0; i < values.length; i++) {\n-            String bucketName = String.valueOf(value.getBuckets()[i]);\n-            summation.valueAccumulation(bucketName, values[i]);\n-            count.valueAccumulation(bucketName, 1L);\n+            long bucket = value.getBuckets()[i];\n+            String bucketName = bucket == Long.MIN_VALUE ? Bucket.INFINITE_NEGATIVE : String.valueOf(bucket);\n+            String key = String.format(template, bucketName);\n+            summation.valueAccumulation(key, values[i]);\n+            count.valueAccumulation(key, 1L);\n         }\n     }\n \n     @Override\n     public void combine(final Metrics metrics) {\n         AvgHistogramFunction histogram = (AvgHistogramFunction) metrics;\n-\n-        if (!summation.keysEqual(histogram.getSummation())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NDYwMQ==", "bodyText": "exactly.", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481454601", "createdAt": "2020-09-01T21:56:33Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "diffHunk": "@@ -83,33 +84,39 @@ public void accept(final MeterEntity entity, final BucketedValues value) {\n \n         this.entityId = entity.id();\n \n+        String template = \"%s\";\n+        if (!Strings.isNullOrEmpty(value.getGroup())) {\n+            template   = value.getGroup() + \":%s\";\n+        }\n         final long[] values = value.getValues();\n         for (int i = 0; i < values.length; i++) {\n-            String bucketName = String.valueOf(value.getBuckets()[i]);\n-            summation.valueAccumulation(bucketName, values[i]);\n-            count.valueAccumulation(bucketName, 1L);\n+            long bucket = value.getBuckets()[i];\n+            String bucketName = bucket == Long.MIN_VALUE ? Bucket.INFINITE_NEGATIVE : String.valueOf(bucket);\n+            String key = String.format(template, bucketName);\n+            summation.valueAccumulation(key, values[i]);\n+            count.valueAccumulation(key, 1L);\n         }\n     }\n \n     @Override\n     public void combine(final Metrics metrics) {\n         AvgHistogramFunction histogram = (AvgHistogramFunction) metrics;\n-\n-        if (!summation.keysEqual(histogram.getSummation())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI0Nzk5NA=="}, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTEwMjY5OnYy", "diffSide": "RIGHT", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NDoxNFrOHK9F7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NDoxNFrOHK9F7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI0ODc1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Set<String> keys = summation.keys();\n          \n          \n            \n                    for (String key : keys) {\n          \n          \n            \n                    for (String key : summation.keys()) {", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481248750", "createdAt": "2020-09-01T15:54:14Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "diffHunk": "@@ -83,33 +84,39 @@ public void accept(final MeterEntity entity, final BucketedValues value) {\n \n         this.entityId = entity.id();\n \n+        String template = \"%s\";\n+        if (!Strings.isNullOrEmpty(value.getGroup())) {\n+            template   = value.getGroup() + \":%s\";\n+        }\n         final long[] values = value.getValues();\n         for (int i = 0; i < values.length; i++) {\n-            String bucketName = String.valueOf(value.getBuckets()[i]);\n-            summation.valueAccumulation(bucketName, values[i]);\n-            count.valueAccumulation(bucketName, 1L);\n+            long bucket = value.getBuckets()[i];\n+            String bucketName = bucket == Long.MIN_VALUE ? Bucket.INFINITE_NEGATIVE : String.valueOf(bucket);\n+            String key = String.format(template, bucketName);\n+            summation.valueAccumulation(key, values[i]);\n+            count.valueAccumulation(key, 1L);\n         }\n     }\n \n     @Override\n     public void combine(final Metrics metrics) {\n         AvgHistogramFunction histogram = (AvgHistogramFunction) metrics;\n-\n-        if (!summation.keysEqual(histogram.getSummation())) {\n-            log.warn(\"Incompatible input [{}}] for current HistogramFunction[{}], entity {}\",\n-                     histogram, this, entityId\n-            );\n-            return;\n-        }\n         this.summation.append(histogram.summation);\n         this.count.append(histogram.count);\n     }\n \n     @Override\n     public void calculate() {\n-        final List<String> sortedKeys = summation.sortedKeys(Comparator.comparingInt(Integer::parseInt));\n-        for (String key : sortedKeys) {\n-            dataset.put(key, summation.get(key) / count.get(key));\n+        final Set<String> keys = summation.keys();\n+        for (String key : keys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTEwNTc0OnYy", "diffSide": "RIGHT", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NDo1M1rOHK9Huw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo1OToxNlrOHLJucg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI0OTIxMQ==", "bodyText": "Did you forget to serialize this field?", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481249211", "createdAt": "2020-09-01T15:54:53Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "diffHunk": "@@ -157,6 +165,7 @@ public void deserialize(final RemoteData remoteData) {\n \n         remoteBuilder.addDataObjectStrings(count.toStorageData());\n         remoteBuilder.addDataObjectStrings(summation.toStorageData());\n+        remoteBuilder.addDataObjectStrings(dataset.toStorageData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NTczMA==", "bodyText": "yep. With the unit test's help, I found this issue.", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481455730", "createdAt": "2020-09-01T21:59:16Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramFunction.java", "diffHunk": "@@ -157,6 +165,7 @@ public void deserialize(final RemoteData remoteData) {\n \n         remoteBuilder.addDataObjectStrings(count.toStorageData());\n         remoteBuilder.addDataObjectStrings(summation.toStorageData());\n+        remoteBuilder.addDataObjectStrings(dataset.toStorageData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI0OTIxMQ=="}, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTExMTA4OnYy", "diffSide": "RIGHT", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NTo1OVrOHK9K0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NTo1OVrOHK9K0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI1MDAwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        template   = value.getBucketedValues().getGroup() + \":%s\";\n          \n          \n            \n                        template  = value.getBucketedValues().getGroup() + \":%s\";", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481250003", "createdAt": "2020-09-01T15:55:59Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "diffHunk": "@@ -125,11 +135,17 @@ public void accept(final MeterEntity entity, final AvgPercentileArgument value)\n \n         this.entityId = entity.id();\n \n+        String template = \"%s\";\n+        if (!Strings.isNullOrEmpty(value.getBucketedValues().getGroup())) {\n+            template   = value.getBucketedValues().getGroup() + \":%s\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTExMzUwOnYy", "diffSide": "RIGHT", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NjozMVrOHK9MQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjoxNDozNFrOHLKG2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI1MDM3MA==", "bodyText": "Could you add comments about how you format this key?", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481250370", "createdAt": "2020-09-01T15:56:31Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "diffHunk": "@@ -125,11 +135,17 @@ public void accept(final MeterEntity entity, final AvgPercentileArgument value)\n \n         this.entityId = entity.id();\n \n+        String template = \"%s\";\n+        if (!Strings.isNullOrEmpty(value.getBucketedValues().getGroup())) {\n+            template   = value.getBucketedValues().getGroup() + \":%s\";\n+        }\n         final long[] values = value.getBucketedValues().getValues();\n         for (int i = 0; i < values.length; i++) {\n-            String bucketName = String.valueOf(value.getBucketedValues().getBuckets()[i]);\n-            summation.valueAccumulation(bucketName, values[i]);\n-            count.valueAccumulation(bucketName, 1L);\n+            long bucket = value.getBucketedValues().getBuckets()[i];\n+            String bucketName = bucket == Long.MIN_VALUE ? Bucket.INFINITE_NEGATIVE : String.valueOf(bucket);\n+            String key = String.format(template, bucketName);\n+            summation.valueAccumulation(key, values[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MTk3Nw==", "bodyText": "It's <group>:<percentile> which is composed of some lines above.", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481461977", "createdAt": "2020-09-01T22:14:34Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "diffHunk": "@@ -125,11 +135,17 @@ public void accept(final MeterEntity entity, final AvgPercentileArgument value)\n \n         this.entityId = entity.id();\n \n+        String template = \"%s\";\n+        if (!Strings.isNullOrEmpty(value.getBucketedValues().getGroup())) {\n+            template   = value.getBucketedValues().getGroup() + \":%s\";\n+        }\n         final long[] values = value.getBucketedValues().getValues();\n         for (int i = 0; i < values.length; i++) {\n-            String bucketName = String.valueOf(value.getBucketedValues().getBuckets()[i]);\n-            summation.valueAccumulation(bucketName, values[i]);\n-            count.valueAccumulation(bucketName, 1L);\n+            long bucket = value.getBucketedValues().getBuckets()[i];\n+            String bucketName = bucket == Long.MIN_VALUE ? Bucket.INFINITE_NEGATIVE : String.valueOf(bucket);\n+            String key = String.format(template, bucketName);\n+            summation.valueAccumulation(key, values[i]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI1MDM3MA=="}, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTExODY3OnYy", "diffSide": "RIGHT", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTo1NzoyNVrOHK9Pfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjoxNTozOFrOHLKIvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI1MTE5OQ==", "bodyText": "So, according to this, the name:99 is formated from here, right?", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481251199", "createdAt": "2020-09-01T15:57:25Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "diffHunk": "@@ -168,38 +178,64 @@ public void combine(final Metrics metrics) {\n     @Override\n     public void calculate() {\n         if (!isCalculated) {\n-            final List<String> sortedKeys = summation.sortedKeys(Comparator.comparingInt(Integer::parseInt));\n-            for (String key : sortedKeys) {\n-                dataset.put(key, summation.get(key) / count.get(key));\n-            }\n-\n-            long total = dataset.sumOfValues();\n-\n-            int[] roofs = new int[ranks.size()];\n-            for (int i = 0; i < ranks.size(); i++) {\n-                roofs[i] = Math.round(total * ranks.get(i) * 1.0f / 100);\n-            }\n-\n-            int count = 0;\n-            int loopIndex = 0;\n-\n-            for (int i = 0; i < sortedKeys.size(); i++) {\n-                String key = sortedKeys.get(i);\n-                final Long value = dataset.get(key);\n-\n-                count += value;\n-                for (int rankIdx = loopIndex; rankIdx < roofs.length; rankIdx++) {\n-                    int roof = roofs[rankIdx];\n-\n-                    if (count >= roof) {\n-                        long latency = (i + 1 == sortedKeys.size()) ? Long.MAX_VALUE : Long.parseLong(sortedKeys.get(i + 1));\n-                        percentileValues.put(String.valueOf(ranks.get(rankIdx)), latency);\n-                        loopIndex++;\n-                    } else {\n-                        break;\n+            final Set<String> keys = summation.keys();\n+            for (String key : keys) {\n+                long value = 0;\n+                if (count.get(key) != 0) {\n+                    value = summation.get(key) / count.get(key);\n+                    if (value == 0L && summation.get(key) > 0L) {\n+                        value = 1;\n                     }\n                 }\n+                dataset.put(key, value);\n             }\n+            dataset.keys().stream()\n+                .map(key -> {\n+                    if (key.contains(\":\")) {\n+                        String[] kk = key.split(\":\");\n+                        return Tuple.of(kk[0], key);\n+                    } else {\n+                        return Tuple.of(DEFAULT_GROUP, key);\n+                    }\n+                })\n+                .collect(groupingBy(Tuple2::_1, mapping(Tuple2::_2, Collector.of(\n+                    DataTable::new,\n+                    (dt, key) -> dt.put(key.contains(\":\") ? key.split(\":\")[1] : key, dataset.get(key)),\n+                    DataTable::append))))\n+                .forEach((group, subDataset) -> {\n+                    long total;\n+                    total = subDataset.sumOfValues();\n+\n+                    int[] roofs = new int[ranks.size()];\n+                    for (int i = 0; i < ranks.size(); i++) {\n+                        roofs[i] = Math.round(total * ranks.get(i) * 1.0f / 100);\n+                    }\n+\n+                    int count = 0;\n+                    final List<String> sortedKeys = subDataset.sortedKeys(Comparator.comparingLong(Long::parseLong));\n+\n+                    int loopIndex = 0;\n+\n+                    for (String key : sortedKeys) {\n+                        final Long value = subDataset.get(key);\n+\n+                        count += value;\n+                        for (int rankIdx = loopIndex; rankIdx < roofs.length; rankIdx++) {\n+                            int roof = roofs[rankIdx];\n+\n+                            if (count >= roof) {\n+                                if (group.equals(DEFAULT_GROUP)) {\n+                                    percentileValues.put(String.valueOf(ranks.get(rankIdx)), Long.parseLong(key));\n+                                } else {\n+                                    percentileValues.put(String.format(\"%s:%s\", group, ranks.get(rankIdx)), Long.parseLong(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MjQ2MA==", "bodyText": "Exactly. : is the splitter.", "url": "https://github.com/apache/skywalking/pull/5425#discussion_r481462460", "createdAt": "2020-09-01T22:15:38Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/analysis/meter/function/AvgHistogramPercentileFunction.java", "diffHunk": "@@ -168,38 +178,64 @@ public void combine(final Metrics metrics) {\n     @Override\n     public void calculate() {\n         if (!isCalculated) {\n-            final List<String> sortedKeys = summation.sortedKeys(Comparator.comparingInt(Integer::parseInt));\n-            for (String key : sortedKeys) {\n-                dataset.put(key, summation.get(key) / count.get(key));\n-            }\n-\n-            long total = dataset.sumOfValues();\n-\n-            int[] roofs = new int[ranks.size()];\n-            for (int i = 0; i < ranks.size(); i++) {\n-                roofs[i] = Math.round(total * ranks.get(i) * 1.0f / 100);\n-            }\n-\n-            int count = 0;\n-            int loopIndex = 0;\n-\n-            for (int i = 0; i < sortedKeys.size(); i++) {\n-                String key = sortedKeys.get(i);\n-                final Long value = dataset.get(key);\n-\n-                count += value;\n-                for (int rankIdx = loopIndex; rankIdx < roofs.length; rankIdx++) {\n-                    int roof = roofs[rankIdx];\n-\n-                    if (count >= roof) {\n-                        long latency = (i + 1 == sortedKeys.size()) ? Long.MAX_VALUE : Long.parseLong(sortedKeys.get(i + 1));\n-                        percentileValues.put(String.valueOf(ranks.get(rankIdx)), latency);\n-                        loopIndex++;\n-                    } else {\n-                        break;\n+            final Set<String> keys = summation.keys();\n+            for (String key : keys) {\n+                long value = 0;\n+                if (count.get(key) != 0) {\n+                    value = summation.get(key) / count.get(key);\n+                    if (value == 0L && summation.get(key) > 0L) {\n+                        value = 1;\n                     }\n                 }\n+                dataset.put(key, value);\n             }\n+            dataset.keys().stream()\n+                .map(key -> {\n+                    if (key.contains(\":\")) {\n+                        String[] kk = key.split(\":\");\n+                        return Tuple.of(kk[0], key);\n+                    } else {\n+                        return Tuple.of(DEFAULT_GROUP, key);\n+                    }\n+                })\n+                .collect(groupingBy(Tuple2::_1, mapping(Tuple2::_2, Collector.of(\n+                    DataTable::new,\n+                    (dt, key) -> dt.put(key.contains(\":\") ? key.split(\":\")[1] : key, dataset.get(key)),\n+                    DataTable::append))))\n+                .forEach((group, subDataset) -> {\n+                    long total;\n+                    total = subDataset.sumOfValues();\n+\n+                    int[] roofs = new int[ranks.size()];\n+                    for (int i = 0; i < ranks.size(); i++) {\n+                        roofs[i] = Math.round(total * ranks.get(i) * 1.0f / 100);\n+                    }\n+\n+                    int count = 0;\n+                    final List<String> sortedKeys = subDataset.sortedKeys(Comparator.comparingLong(Long::parseLong));\n+\n+                    int loopIndex = 0;\n+\n+                    for (String key : sortedKeys) {\n+                        final Long value = subDataset.get(key);\n+\n+                        count += value;\n+                        for (int rankIdx = loopIndex; rankIdx < roofs.length; rankIdx++) {\n+                            int roof = roofs[rankIdx];\n+\n+                            if (count >= roof) {\n+                                if (group.equals(DEFAULT_GROUP)) {\n+                                    percentileValues.put(String.valueOf(ranks.get(rankIdx)), Long.parseLong(key));\n+                                } else {\n+                                    percentileValues.put(String.format(\"%s:%s\", group, ranks.get(rankIdx)), Long.parseLong(key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI1MTE5OQ=="}, "originalCommit": {"oid": "0bc490f21e5240893b2e250be5c955489ebf7b10"}, "originalPosition": 156}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 9, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}