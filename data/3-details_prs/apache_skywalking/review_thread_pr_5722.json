{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5NTQ4NDkx", "number": 5722, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzoxNDoxNFrOExoVzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjoxNTowN1rOEx36RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDc2NjIxOnYy", "diffSide": "RIGHT", "path": "CHANGES.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzoxNDoxNFrOHn3ACw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzoxNjo1MVrOHn3BKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NzY0Mw==", "bodyText": "fo? Typo?", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r511557643", "createdAt": "2020-10-25T07:14:14Z", "author": {"login": "wu-sheng"}, "path": "CHANGES.md", "diffHunk": "@@ -9,6 +9,7 @@ Release Notes.\n #### Java Agent\n \n #### OAP-Backend\n+* Improve Kubernetes service registry fo ALS analysis.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NzkyOQ==", "bodyText": "fo? Typo?\n\n\ud83e\udd23 definitely, fixed", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r511557929", "createdAt": "2020-10-25T07:16:51Z", "author": {"login": "kezhenxu94"}, "path": "CHANGES.md", "diffHunk": "@@ -9,6 +9,7 @@ Release Notes.\n #### Java Agent\n \n #### OAP-Backend\n+* Improve Kubernetes service registry fo ALS analysis.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU1NzY0Mw=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzMwNjc5OnYy", "diffSide": "RIGHT", "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjoxMjowN1rOHoMuLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMTowNTo1MVrOHpWWmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMzUxNg==", "bodyText": "We had better introduce a service name rule to format it. For instance, if some users want to append a version to the service name, they have to issue an expression, like ${service.name}-${pod.labels.version}\nIf they deploy bookinfo, the service name of the service productpage might be productpage-v1, producatpage-v2 and etc.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r511913516", "createdAt": "2020-10-26T12:12:07Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);\n+        listenPodEvents(coreV1Api, factory);\n+\n+        factory.startAllRegisteredInformers();\n+    }\n+\n+    private void listenEndpointsEvents(final CoreV1Api coreV1Api, final SharedInformerFactory factory) {\n+        factory.sharedIndexInformerFor(\n+            params -> coreV1Api.listEndpointsForAllNamespacesCall(\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                params.resourceVersion,\n+                params.timeoutSeconds,\n+                params.watch,\n+                null\n+            ),\n+            V1Endpoints.class,\n+            V1EndpointsList.class\n+        ).addEventHandler(new ResourceEventHandler<V1Endpoints>() {\n+            @Override\n+            public void onAdd(final V1Endpoints endpoints) {\n+                addEndpoints(endpoints);\n+            }\n+\n+            @Override\n+            public void onUpdate(final V1Endpoints oldEndpoints, final V1Endpoints newEndpoints) {\n+                addEndpoints(newEndpoints);\n+            }\n+\n+            @Override\n+            public void onDelete(final V1Endpoints endpoints, final boolean deletedFinalStateUnknown) {\n+                removeEndpoints(endpoints);\n+            }\n+        });\n+    }\n+\n+    private void listenPodEvents(final CoreV1Api coreV1Api, final SharedInformerFactory factory) {\n+        factory.sharedIndexInformerFor(\n+            params -> coreV1Api.listPodForAllNamespacesCall(\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                params.resourceVersion,\n+                params.timeoutSeconds,\n+                params.watch,\n+                null\n+            ),\n+            V1Pod.class,\n+            V1PodList.class\n+        ).addEventHandler(new ResourceEventHandler<V1Pod>() {\n+            @Override\n+            public void onAdd(final V1Pod pod) {\n+                addPod(pod);\n+            }\n+\n+            @Override\n+            public void onUpdate(final V1Pod oldPod, final V1Pod newPod) {\n+                addPod(newPod);\n+            }\n+\n+            @Override\n+            public void onDelete(final V1Pod pod, final boolean deletedFinalStateUnknown) {\n+                removePod(pod);\n+            }\n+        });\n+    }\n+\n+    private void removePod(final V1Pod pod) {\n+        log.debug(\"Removing pod {}\", pod);\n+\n+        Optional.ofNullable(pod.getStatus()).ifPresent(\n+            status -> ipServiceMap.remove(status.getPodIP())\n+        );\n+    }\n+\n+    private void addPod(final V1Pod pod) {\n+        log.debug(\"Adding pod {}\", pod);\n+\n+        Optional.ofNullable(pod.getStatus()).ifPresent(\n+            status -> {\n+                final String ip = status.getPodIP();\n+                final ServiceMetaInfo service = ipServiceMap.computeIfAbsent(ip, unused -> new ServiceMetaInfo());\n+\n+                final V1ObjectMeta podMeta = requireNonNull(pod.getMetadata());\n+                service.setServiceInstanceName(String.format(\"%s.%s\", podMeta.getName(), podMeta.getNamespace()));\n+                service.setTags(transformLabelsToTags(podMeta.getLabels()));\n+            }\n+        );\n+    }\n+\n+    private void addEndpoints(final V1Endpoints endpoints) {\n+        log.debug(\"Adding endpoints {}\", endpoints);\n+\n+        final String serviceName = requireNonNull(endpoints.getMetadata()).getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkyNTc4NA==", "bodyText": "I think the key is providing the format expression. Defaut should be only service name with version, correct?", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r511925784", "createdAt": "2020-10-26T12:34:55Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);\n+        listenPodEvents(coreV1Api, factory);\n+\n+        factory.startAllRegisteredInformers();\n+    }\n+\n+    private void listenEndpointsEvents(final CoreV1Api coreV1Api, final SharedInformerFactory factory) {\n+        factory.sharedIndexInformerFor(\n+            params -> coreV1Api.listEndpointsForAllNamespacesCall(\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                params.resourceVersion,\n+                params.timeoutSeconds,\n+                params.watch,\n+                null\n+            ),\n+            V1Endpoints.class,\n+            V1EndpointsList.class\n+        ).addEventHandler(new ResourceEventHandler<V1Endpoints>() {\n+            @Override\n+            public void onAdd(final V1Endpoints endpoints) {\n+                addEndpoints(endpoints);\n+            }\n+\n+            @Override\n+            public void onUpdate(final V1Endpoints oldEndpoints, final V1Endpoints newEndpoints) {\n+                addEndpoints(newEndpoints);\n+            }\n+\n+            @Override\n+            public void onDelete(final V1Endpoints endpoints, final boolean deletedFinalStateUnknown) {\n+                removeEndpoints(endpoints);\n+            }\n+        });\n+    }\n+\n+    private void listenPodEvents(final CoreV1Api coreV1Api, final SharedInformerFactory factory) {\n+        factory.sharedIndexInformerFor(\n+            params -> coreV1Api.listPodForAllNamespacesCall(\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                params.resourceVersion,\n+                params.timeoutSeconds,\n+                params.watch,\n+                null\n+            ),\n+            V1Pod.class,\n+            V1PodList.class\n+        ).addEventHandler(new ResourceEventHandler<V1Pod>() {\n+            @Override\n+            public void onAdd(final V1Pod pod) {\n+                addPod(pod);\n+            }\n+\n+            @Override\n+            public void onUpdate(final V1Pod oldPod, final V1Pod newPod) {\n+                addPod(newPod);\n+            }\n+\n+            @Override\n+            public void onDelete(final V1Pod pod, final boolean deletedFinalStateUnknown) {\n+                removePod(pod);\n+            }\n+        });\n+    }\n+\n+    private void removePod(final V1Pod pod) {\n+        log.debug(\"Removing pod {}\", pod);\n+\n+        Optional.ofNullable(pod.getStatus()).ifPresent(\n+            status -> ipServiceMap.remove(status.getPodIP())\n+        );\n+    }\n+\n+    private void addPod(final V1Pod pod) {\n+        log.debug(\"Adding pod {}\", pod);\n+\n+        Optional.ofNullable(pod.getStatus()).ifPresent(\n+            status -> {\n+                final String ip = status.getPodIP();\n+                final ServiceMetaInfo service = ipServiceMap.computeIfAbsent(ip, unused -> new ServiceMetaInfo());\n+\n+                final V1ObjectMeta podMeta = requireNonNull(pod.getMetadata());\n+                service.setServiceInstanceName(String.format(\"%s.%s\", podMeta.getName(), podMeta.getNamespace()));\n+                service.setTags(transformLabelsToTags(podMeta.getLabels()));\n+            }\n+        );\n+    }\n+\n+    private void addEndpoints(final V1Endpoints endpoints) {\n+        log.debug(\"Adding endpoints {}\", endpoints);\n+\n+        final String serviceName = requireNonNull(endpoints.getMetadata()).getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMzUxNg=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExOTg5OQ==", "bodyText": "Done", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r513119899", "createdAt": "2020-10-28T01:05:51Z", "author": {"login": "kezhenxu94"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);\n+        listenPodEvents(coreV1Api, factory);\n+\n+        factory.startAllRegisteredInformers();\n+    }\n+\n+    private void listenEndpointsEvents(final CoreV1Api coreV1Api, final SharedInformerFactory factory) {\n+        factory.sharedIndexInformerFor(\n+            params -> coreV1Api.listEndpointsForAllNamespacesCall(\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                params.resourceVersion,\n+                params.timeoutSeconds,\n+                params.watch,\n+                null\n+            ),\n+            V1Endpoints.class,\n+            V1EndpointsList.class\n+        ).addEventHandler(new ResourceEventHandler<V1Endpoints>() {\n+            @Override\n+            public void onAdd(final V1Endpoints endpoints) {\n+                addEndpoints(endpoints);\n+            }\n+\n+            @Override\n+            public void onUpdate(final V1Endpoints oldEndpoints, final V1Endpoints newEndpoints) {\n+                addEndpoints(newEndpoints);\n+            }\n+\n+            @Override\n+            public void onDelete(final V1Endpoints endpoints, final boolean deletedFinalStateUnknown) {\n+                removeEndpoints(endpoints);\n+            }\n+        });\n+    }\n+\n+    private void listenPodEvents(final CoreV1Api coreV1Api, final SharedInformerFactory factory) {\n+        factory.sharedIndexInformerFor(\n+            params -> coreV1Api.listPodForAllNamespacesCall(\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                params.resourceVersion,\n+                params.timeoutSeconds,\n+                params.watch,\n+                null\n+            ),\n+            V1Pod.class,\n+            V1PodList.class\n+        ).addEventHandler(new ResourceEventHandler<V1Pod>() {\n+            @Override\n+            public void onAdd(final V1Pod pod) {\n+                addPod(pod);\n+            }\n+\n+            @Override\n+            public void onUpdate(final V1Pod oldPod, final V1Pod newPod) {\n+                addPod(newPod);\n+            }\n+\n+            @Override\n+            public void onDelete(final V1Pod pod, final boolean deletedFinalStateUnknown) {\n+                removePod(pod);\n+            }\n+        });\n+    }\n+\n+    private void removePod(final V1Pod pod) {\n+        log.debug(\"Removing pod {}\", pod);\n+\n+        Optional.ofNullable(pod.getStatus()).ifPresent(\n+            status -> ipServiceMap.remove(status.getPodIP())\n+        );\n+    }\n+\n+    private void addPod(final V1Pod pod) {\n+        log.debug(\"Adding pod {}\", pod);\n+\n+        Optional.ofNullable(pod.getStatus()).ifPresent(\n+            status -> {\n+                final String ip = status.getPodIP();\n+                final ServiceMetaInfo service = ipServiceMap.computeIfAbsent(ip, unused -> new ServiceMetaInfo());\n+\n+                final V1ObjectMeta podMeta = requireNonNull(pod.getMetadata());\n+                service.setServiceInstanceName(String.format(\"%s.%s\", podMeta.getName(), podMeta.getNamespace()));\n+                service.setTags(transformLabelsToTags(podMeta.getLabels()));\n+            }\n+        );\n+    }\n+\n+    private void addEndpoints(final V1Endpoints endpoints) {\n+        log.debug(\"Adding endpoints {}\", endpoints);\n+\n+        final String serviceName = requireNonNull(endpoints.getMetadata()).getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMzUxNg=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzMxNzE3OnYy", "diffSide": "RIGHT", "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjoxNTowN1rOHoM0dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDoyMzo1NFrOHqVUow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ==", "bodyText": "Endpoint slice resources should be listened to either.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r511915125", "createdAt": "2020-10-26T12:15:07Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwMTUwMQ==", "bodyText": "@hanahmily even the latest kubernetes-client(10.0.0, 27th, Oct, 2020) doesn't support to listen to the EndpointSlice events. There is no such API to do this \ud83d\ude22 Let's postponed this resource until the newer version can do this.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r512401501", "createdAt": "2020-10-27T03:54:17Z", "author": {"login": "kezhenxu94"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5Nzk1NQ==", "bodyText": "If no listener, are you reading the data periodically like the old way?", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r512697955", "createdAt": "2020-10-27T13:38:08Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcyMDA5Ng==", "bodyText": "If no listener, are you reading the data periodically like the old way?\n\nNot now, as the doc says, EndpointSlice is to improve the performance of Endpoints, so I think it's OK to just ignore this kind of event for now, (p.s. EndpointSlice is still in beta now), is it OK @hanahmily ?", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r512720096", "createdAt": "2020-10-27T14:05:16Z", "author": {"login": "kezhenxu94"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMjE1OA==", "bodyText": "If java client doesn't support it right now, feel free to leave it alone. But we should mention it in our document and leave todo market in codes.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r513202158", "createdAt": "2020-10-28T06:14:04Z", "author": {"login": "hanahmily"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMjk2NA==", "bodyText": "How about submitting a request to k8s java client repo about listen to the EndpointSlice ?", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r513202964", "createdAt": "2020-10-28T06:16:34Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMzEzNw==", "bodyText": "They may need a scenario about which java codes need this.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r513203137", "createdAt": "2020-10-28T06:17:02Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0OTkxMQ==", "bodyText": "How about submitting a request to k8s java client repo about listen to the EndpointSlice ?\n\nI'm thinking that they don't support it only because EndpointSlice is still in beta(after stabilization, they will), and the methods to list/watch that resources are unstable now, (e.g. need the apiGroup, version, which are changing for an alpha/beta feature).\nIMO, ignoring EndpointSlice for now is safe because the docs says\n\nAlthough the EndpointSlice API is providing a newer and more scalable alternative to the Endpoints API, the Endpoints API will continue to be considered generally available and stable.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r514149911", "createdAt": "2020-10-29T10:20:52Z", "author": {"login": "kezhenxu94"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDQ0Nw==", "bodyText": "We can revamp this after the EndpointSlice API is stabilised", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r514150447", "createdAt": "2020-10-29T10:21:44Z", "author": {"login": "kezhenxu94"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MTU4Nw==", "bodyText": "My point is only creating an issue to track this todo as backlog.", "url": "https://github.com/apache/skywalking/pull/5722#discussion_r514151587", "createdAt": "2020-10-29T10:23:54Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/K8SServiceRegistry.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.receiver.envoy.als;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import io.kubernetes.client.informer.ResourceEventHandler;\n+import io.kubernetes.client.informer.SharedInformerFactory;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1Endpoints;\n+import io.kubernetes.client.openapi.models.V1EndpointsList;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNull;\n+\n+@Slf4j\n+class K8SServiceRegistry {\n+    final Map<String, ServiceMetaInfo> ipServiceMap;\n+\n+    final ExecutorService executor;\n+\n+    K8SServiceRegistry() {\n+        ipServiceMap = new ConcurrentHashMap<>();\n+        executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(\"K8SServiceRegistry-%d\")\n+                .setDaemon(true)\n+                .build()\n+        );\n+    }\n+\n+    void start() throws IOException {\n+        final ApiClient apiClient = Config.defaultClient();\n+        apiClient.setHttpClient(apiClient.getHttpClient()\n+                                         .newBuilder()\n+                                         .readTimeout(0, TimeUnit.SECONDS)\n+                                         .build());\n+\n+        final CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        final SharedInformerFactory factory = new SharedInformerFactory(executor);\n+\n+        listenEndpointsEvents(coreV1Api, factory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNTEyNQ=="}, "originalCommit": {"oid": "aeaa737115a085280a25ab9acb24cc351a16f48e"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4728, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}