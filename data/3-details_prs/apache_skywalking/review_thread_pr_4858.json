{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3Njc2MjAz", "number": 4858, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxOTowNlrOECee8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoyNzo0NFrOEKYOgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMyMDUwOnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/util/IOUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxOTowNlrOGe9IfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTozNTo1MFrOGfBtAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjA2MQ==", "bodyText": "Copying from JDK requires you to explain which JDK, what is original license.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r435112061", "createdAt": "2020-06-04T09:19:06Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/util/IOUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.util;\n+\n+/**\n+ * Copied from {@link org.apache.commons.io.IOUtils}\n+ */\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+public class IOUtils {\n+\n+    private static final int EOF = -1;\n+\n+    /**\n+     * The default buffer size ({@value}) to use for\n+     * {@link #copyLarge(InputStream, OutputStream)}\n+     */\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Get the contents of an <code>InputStream</code> as a <code>byte[]</code>.\n+     * <p>\n+     * This method buffers the input internally, so there is no need to use a\n+     * <code>BufferedInputStream</code>.\n+     *\n+     * @param input  the <code>InputStream</code> to read from\n+     * @return the requested byte array\n+     * @throws NullPointerException if the input is null\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static byte[] toByteArray(InputStream input) throws IOException {\n+        ByteArrayOutputStream output = new ByteArrayOutputStream();\n+        copy(input, output);\n+        return output.toByteArray();\n+    }\n+\n+\n+    /**\n+     * Copy bytes from an <code>InputStream</code> to an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e25b4f9f73c71fee8bc278dc0ba5df0db5d89976"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE3NzMxMA==", "bodyText": "IOUtils copy from commons-io-2.2, origin license is Apache 2.0", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r435177310", "createdAt": "2020-06-04T11:16:28Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/util/IOUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.util;\n+\n+/**\n+ * Copied from {@link org.apache.commons.io.IOUtils}\n+ */\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+public class IOUtils {\n+\n+    private static final int EOF = -1;\n+\n+    /**\n+     * The default buffer size ({@value}) to use for\n+     * {@link #copyLarge(InputStream, OutputStream)}\n+     */\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Get the contents of an <code>InputStream</code> as a <code>byte[]</code>.\n+     * <p>\n+     * This method buffers the input internally, so there is no need to use a\n+     * <code>BufferedInputStream</code>.\n+     *\n+     * @param input  the <code>InputStream</code> to read from\n+     * @return the requested byte array\n+     * @throws NullPointerException if the input is null\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static byte[] toByteArray(InputStream input) throws IOException {\n+        ByteArrayOutputStream output = new ByteArrayOutputStream();\n+        copy(input, output);\n+        return output.toByteArray();\n+    }\n+\n+\n+    /**\n+     * Copy bytes from an <code>InputStream</code> to an", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjA2MQ=="}, "originalCommit": {"oid": "e25b4f9f73c71fee8bc278dc0ba5df0db5d89976"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Njk0Ng==", "bodyText": "Then you need to update the License file in the root file. There are some included, learn from them.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r435186946", "createdAt": "2020-06-04T11:35:50Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/util/IOUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.util;\n+\n+/**\n+ * Copied from {@link org.apache.commons.io.IOUtils}\n+ */\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+public class IOUtils {\n+\n+    private static final int EOF = -1;\n+\n+    /**\n+     * The default buffer size ({@value}) to use for\n+     * {@link #copyLarge(InputStream, OutputStream)}\n+     */\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Get the contents of an <code>InputStream</code> as a <code>byte[]</code>.\n+     * <p>\n+     * This method buffers the input internally, so there is no need to use a\n+     * <code>BufferedInputStream</code>.\n+     *\n+     * @param input  the <code>InputStream</code> to read from\n+     * @return the requested byte array\n+     * @throws NullPointerException if the input is null\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static byte[] toByteArray(InputStream input) throws IOException {\n+        ByteArrayOutputStream output = new ByteArrayOutputStream();\n+        copy(input, output);\n+        return output.toByteArray();\n+    }\n+\n+\n+    /**\n+     * Copy bytes from an <code>InputStream</code> to an", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMjA2MQ=="}, "originalCommit": {"oid": "e25b4f9f73c71fee8bc278dc0ba5df0db5d89976"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMyNjkwOnYy", "diffSide": "RIGHT", "path": "docs/en/setup/service-agent/java-agent/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMDo1MlrOGe9Mkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMDo1MlrOGe9Mkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMzEwNw==", "bodyText": "Why need caching, and when should use. Those should be explained clearly in the document. People would quite confused about what is this config for.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r435113107", "createdAt": "2020-06-04T09:20:52Z", "author": {"login": "wu-sheng"}, "path": "docs/en/setup/service-agent/java-agent/README.md", "diffHunk": "@@ -78,6 +78,8 @@ property key | Description | Default |\n `agent.span_limit_per_segment`|The max number of spans in a single segment. Through this config item, SkyWalking keep your application memory cost estimated.|300 |\n `agent.ignore_suffix`|If the operation name of the first span is included in this set, this segment should be ignored.|Not set|\n `agent.is_open_debugging_class`|If true, skywalking agent will save all instrumented classes files in `/debugging` folder. SkyWalking team may ask for these files in order to resolve compatible problem.|Not set|\n+`agent.is_cache_enhanced_class`|If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode), allow other javaagent to enhance those classes that enhanced by SkyWalking agent.|Not set|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e25b4f9f73c71fee8bc278dc0ba5df0db5d89976"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDgwNzE0OnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/util/IOUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTo0MzowMVrOGfB7FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTo0MzowMVrOGfB7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDU0OA==", "bodyText": "This is not necessary, but OK. The key is License in the root folder of SkyWalking. We need to follow the License requirement, which require we add the explicit statement in the end of the license file.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r435190548", "createdAt": "2020-06-04T11:43:01Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/util/IOUtils.java", "diffHunk": "@@ -18,16 +18,17 @@\n \n package org.apache.skywalking.apm.agent.core.util;\n \n-/**\n- * Copied from {@link org.apache.commons.io.IOUtils}\n- */\n-\n import java.io.ByteArrayOutputStream;\n import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n \n+/**\n+ * Copied from commons-io-2.2 {@link org.apache.commons.io.IOUtils}\n+ * Origin license: http://www.apache.org/licenses/LICENSE-2.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b67f1a3aca000f4888604eec3159c047efc84e3d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzUzOTc0OnYy", "diffSide": "RIGHT", "path": "test/plugin/scenarios/retransform-class-scenario/src/main/java/org/apache/skywalking/apm/testcase/retransform_class/RetransformUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMjoyNjoyM1rOGhirWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMjo1NTowMVrOGiMzNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyNDM0Ng==", "bodyText": "author should be removed.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r437824346", "createdAt": "2020-06-10T02:26:23Z", "author": {"login": "wu-sheng"}, "path": "test/plugin/scenarios/retransform-class-scenario/src/main/java/org/apache/skywalking/apm/testcase/retransform_class/RetransformUtil.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.apache.skywalking.apm.testcase.retransform_class;\n+\n+import net.bytebuddy.agent.ByteBuddyAgent;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import test.org.apache.skywalking.apm.testcase.controller.TestController;\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.security.ProtectionDomain;\n+\n+/**\n+ * @author gongdewei 2020/6/7", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "906dc61c5428638b223fa548b4ca004d51aeaa68"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUxNDQ4Ng==", "bodyText": "done", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r438514486", "createdAt": "2020-06-11T02:55:01Z", "author": {"login": "kylixs"}, "path": "test/plugin/scenarios/retransform-class-scenario/src/main/java/org/apache/skywalking/apm/testcase/retransform_class/RetransformUtil.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.apache.skywalking.apm.testcase.retransform_class;\n+\n+import net.bytebuddy.agent.ByteBuddyAgent;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import test.org.apache.skywalking.apm.testcase.controller.TestController;\n+\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.security.ProtectionDomain;\n+\n+/**\n+ * @author gongdewei 2020/6/7", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyNDM0Ng=="}, "originalCommit": {"oid": "906dc61c5428638b223fa548b4ca004d51aeaa68"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTI3NjI4OnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent/src/main/java/org/apache/skywalking/apm/agent/SkyWalkingAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMDozOVrOGjWNZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMDozOVrOGjWNZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzIyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"SkyWalking agent setup class cache: {}\", Config.Agent.CLASS_CACHE_MODE);\n          \n          \n            \n                            logger.info(\"SkyWalking agent class cache [{}] activated.\", Config.Agent.CLASS_CACHE_MODE);", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439717220", "createdAt": "2020-06-13T07:20:39Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent/src/main/java/org/apache/skywalking/apm/agent/SkyWalkingAgent.java", "diffHunk": "@@ -99,6 +100,15 @@ public static void premain(String agentArgs, Instrumentation instrumentation) th\n             return;\n         }\n \n+        if (Config.Agent.IS_CACHE_ENHANCED_CLASS) {\n+            try {\n+                agentBuilder = agentBuilder.with(new CacheableTransformerDecorator(Config.Agent.CLASS_CACHE_MODE));\n+                logger.info(\"SkyWalking agent setup class cache: {}\", Config.Agent.CLASS_CACHE_MODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTI3Njc1OnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent/src/main/java/org/apache/skywalking/apm/agent/SkyWalkingAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMTowNlrOGjWNlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMTowNlrOGjWNlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzI3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.error(e, \"SkyWalking agent setup class cache failure.\");\n          \n          \n            \n                            logger.error(e, \"SkyWalking agent can't active class cache.\");", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439717270", "createdAt": "2020-06-13T07:21:06Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent/src/main/java/org/apache/skywalking/apm/agent/SkyWalkingAgent.java", "diffHunk": "@@ -99,6 +100,15 @@ public static void premain(String agentArgs, Instrumentation instrumentation) th\n             return;\n         }\n \n+        if (Config.Agent.IS_CACHE_ENHANCED_CLASS) {\n+            try {\n+                agentBuilder = agentBuilder.with(new CacheableTransformerDecorator(Config.Agent.CLASS_CACHE_MODE));\n+                logger.info(\"SkyWalking agent setup class cache: {}\", Config.Agent.CLASS_CACHE_MODE);\n+            } catch (Exception e) {\n+                logger.error(e, \"SkyWalking agent setup class cache failure.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTI3NzQ0OnYy", "diffSide": "RIGHT", "path": "apm-sniffer/config/agent.config", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMjo0OVrOGjWN6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMzo0ODoxNlrOGqqmbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzM1Mg==", "bodyText": "Both these are very advanced config, please keep these two in the documents only. Most users even can't understand what this is about, causing unnecessary confusion. I would like to recommend you adding a FAQ doc, including the error you were facing, and link to the agent set up the document and the config.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439717352", "createdAt": "2020-06-13T07:22:49Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/config/agent.config", "diffHunk": "@@ -38,6 +38,15 @@ agent.service_name=${SW_AGENT_NAME:Your_ApplicationName}\n # SkyWalking team may ask for these files in order to resolve compatible problem.\n # agent.is_open_debugging_class = ${SW_AGENT_OPEN_DEBUG:true}\n \n+# If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5MTM0Mg==", "bodyText": "Add class cache faq doc: Compatible with other javaagent bytecode processing", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r447391342", "createdAt": "2020-06-30T03:48:16Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/config/agent.config", "diffHunk": "@@ -38,6 +38,15 @@ agent.service_name=${SW_AGENT_NAME:Your_ApplicationName}\n # SkyWalking team may ask for these files in order to resolve compatible problem.\n # agent.is_open_debugging_class = ${SW_AGENT_OPEN_DEBUG:true}\n \n+# If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzM1Mg=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTI3OTA1OnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyNjowN1rOGjWOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDowNjoyMFrOGlHcfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw==", "bodyText": "File cache is a very sensitive and tricky thing, thinking in this way, once 2+ agents are sharing the agent.config, and open this feature, most likely they will share this dir. What will happen if they active file cache?\nIn most cases, file cache is meaning you need a dir lock, and generate the dir automatically.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439717563", "createdAt": "2020-06-13T07:26:07Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNTA1OQ==", "bodyText": "class cache dir is a auto generated random directory, different agents will isolate their respective class cache.\ncacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439905059", "createdAt": "2020-06-15T02:46:23Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNTY5Ng==", "bodyText": "Yes, but can't find the API using public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) . Do I miss anything?\nThe cacheDirBase seems never be used.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439905696", "createdAt": "2020-06-15T02:49:54Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNjI3MA==", "bodyText": "So, base on your codes, it uses the temp folder only.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439906270", "createdAt": "2020-06-15T02:52:33Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkxMDI5Mw==", "bodyText": "From my understanding, I think the folder should be in the agent folder, in order to make sure writable. Also, should be more friendly to docker and k8s users. They would expect log folder is writable and will be new files added.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439910293", "createdAt": "2020-06-15T03:12:49Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU1NDA2MQ==", "bodyText": "So, base on your codes, it uses the temp folder only.\n\nYes,  it uses the temp folder starts with 'class-cache' and with random suffix,  like 'class-cache23123131'", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r441554061", "createdAt": "2020-06-17T13:41:50Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU1NjQ0Nw==", "bodyText": "From my understanding, I think the folder should be in the agent folder, in order to make sure writable. Also, should be more friendly to docker and k8s users. They would expect log folder is writable and will be new files added.\n\nThe agent folder is writable?  Please give a sample path of class cache.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r441556447", "createdAt": "2020-06-17T13:44:58Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3MjQ3Ng==", "bodyText": "AgentPackagePath#getPath. WriterFactory(logging) is using this to write.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r441572476", "createdAt": "2020-06-17T14:06:20Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU2Mw=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTI3OTE4OnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyNjozM1rOGjWOzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMjo0NzoxOVrOGjhr9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU4Mg==", "bodyText": "Deleting file shares the same issue of cache dir confliction.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439717582", "createdAt": "2020-06-13T07:26:33Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNTI2OQ==", "bodyText": "different agents will isolate their respective class cache.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r439905269", "createdAt": "2020-06-15T02:47:19Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.nio.file.Files;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private String cacheDirBase;\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode, String cacheDirBase) throws IOException {\n+        this.cacheDirBase = cacheDirBase;\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            File cacheDir;\n+            if (this.cacheDirBase == null) {\n+                cacheDir = Files.createTempDirectory(\"class-cache\").toFile();\n+            } else {\n+                cacheDir = new File(this.cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            }\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzU4Mg=="}, "originalCommit": {"oid": "032305635a72f556b26609fa221b861a3d058125"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODk4NzQwOnYy", "diffSide": "RIGHT", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzo1NzowOVrOGqwX8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzowNTowNlrOGrVNnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg==", "bodyText": "You are putting all files in one folder, NOTICE potential issue\nFAT32: Maximum number of files per directory: 216 - 1 (65,535)\nNTFS:Maximum number of files: 2^32 - 1 (4,294,967,295)\next2/ext3:Maximum number of files per directory: ~1.3 \u00d7 1020 (performance issues past 10,000)\next4: Maximum number of files per directory: unlimited\nMaterial source, https://stackoverflow.com/questions/466521/how-many-files-can-i-put-in-a-directory", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r447485936", "createdAt": "2020-06-30T07:57:09Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NjYyMw==", "bodyText": "I don't think this is a block, as FAT32 is rarely to see now. But just want to inform you, this could happen.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r447486623", "createdAt": "2020-06-30T07:58:17Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ5Mjc4NA==", "bodyText": "Any suggestions?  Some dynamically generated classes may have a large number.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r447492784", "createdAt": "2020-06-30T08:08:06Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDY2NA==", "bodyText": "Usually, file could be generated based on classloader/package....name/class name.\nDo you want to change? I am sure how many people are still using FAT32.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r447510664", "createdAt": "2020-06-30T08:35:34Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1MDA3Ng==", "bodyText": "At the same time, I think you forgot the conflicts could happen when agents installed in several Services, but share the same folder?", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r447650076", "createdAt": "2020-06-30T12:40:00Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA3OTc3Ng==", "bodyText": "Each SkyWalking agent has a random directory like '/class-cache/class-cache-z3sdv3d4'\nFile cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448079776", "createdAt": "2020-07-01T02:23:45Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MDY2MA==", "bodyText": "Got it. Do I need to wait for folder structure change?", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448080660", "createdAt": "2020-07-01T02:27:28Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4OTUwMQ==", "bodyText": "It's done, save cache class file to structure directory.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448089501", "createdAt": "2020-07-01T03:05:06Z", "author": {"login": "kylixs"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/bytebuddy/CacheableTransformerDecorator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.plugin.bytebuddy;\n+\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.agent.builder.ResettableClassFileTransformer;\n+import net.bytebuddy.utility.RandomString;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackageNotFoundException;\n+import org.apache.skywalking.apm.agent.core.boot.AgentPackagePath;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.util.FileUtils;\n+import org.apache.skywalking.apm.agent.core.util.IOUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Wrapper classFileTransformer of ByteBuddy, save the enhanced bytecode to memory cache or file cache,\n+ * and automatically load the previously generated bytecode during the second retransform,\n+ * to solve the problem that ByteBuddy generates auxiliary classes with different random names every time.\n+ * Allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+ */\n+public class CacheableTransformerDecorator implements AgentBuilder.TransformerDecorator {\n+\n+    private static final ILog logger = LogManager.getLogger(CacheableTransformerDecorator.class);\n+\n+    private final ClassCacheMode cacheMode;\n+    private ClassCacheResolver cacheResolver;\n+\n+    public CacheableTransformerDecorator(ClassCacheMode cacheMode) throws IOException {\n+        this.cacheMode = cacheMode;\n+        initClassCache();\n+    }\n+\n+    private void initClassCache() throws IOException {\n+        if (this.cacheMode.equals(ClassCacheMode.FILE)) {\n+            String cacheDirBase = null;\n+            try {\n+                cacheDirBase = AgentPackagePath.getPath() + \"/class-cache\";\n+            } catch (AgentPackageNotFoundException e) {\n+                throw new IOException(\"Can't find the root path for creating /class-cache folder.\");\n+            }\n+            File cacheDir = new File(cacheDirBase + \"/class-cache-\" + RandomString.make());\n+            if (!cacheDir.exists()) {\n+                cacheDir.mkdirs();\n+            }\n+            if (!cacheDir.exists()) {\n+                throw new IOException(\"Create class cache dir failure\");\n+            }\n+\n+            cacheResolver = new FileCacheResolver(cacheDir);\n+        } else {\n+            cacheResolver = new MemoryCacheResolver();\n+        }\n+    }\n+\n+    @Override\n+    public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {\n+        return new ResettableClassFileTransformer.WithDelegation(classFileTransformer) {\n+\n+            @Override\n+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n+                // load from cache\n+                byte[] classCache = cacheResolver.getClassCache(loader, className);\n+                if (classCache != null) {\n+                    return classCache;\n+                }\n+\n+                //transform class\n+                classfileBuffer = classFileTransformer.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);\n+\n+                // save to cache\n+                if (classfileBuffer != null) {\n+                    cacheResolver.putClassCache(loader, className, classfileBuffer);\n+                }\n+\n+                return classfileBuffer;\n+            }\n+        };\n+    }\n+\n+    private static String getClassLoaderHash(ClassLoader loader) {\n+        String classloader;\n+        if (loader != null) {\n+            classloader = Integer.toHexString(loader.hashCode());\n+        } else {\n+            //classloader is null for BootstrapClassLoader\n+            classloader = \"00000000\";\n+        }\n+        return classloader;\n+    }\n+\n+    interface ClassCacheResolver {\n+\n+        byte[] getClassCache(ClassLoader loader, String className);\n+\n+        void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer);\n+    }\n+\n+    static class MemoryCacheResolver implements ClassCacheResolver {\n+        // classloaderHashcode@className -> class bytes\n+        private Map<String, byte[]> classCacheMap = new ConcurrentHashMap<String, byte[]>();\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            String cacheKey = getCacheKey(loader, className);\n+            return classCacheMap.get(cacheKey);\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            String cacheKey = getCacheKey(loader, className);\n+            classCacheMap.put(cacheKey, classfileBuffer);\n+        }\n+\n+        private String getCacheKey(ClassLoader loader, String className) {\n+            return getClassLoaderHash(loader) + \"@\" + className;\n+        }\n+    }\n+\n+    static class FileCacheResolver implements ClassCacheResolver {\n+\n+        private final File cacheDir;\n+\n+        FileCacheResolver(File cacheDir) {\n+            this.cacheDir = cacheDir;\n+\n+            //clean cache dir on exit\n+            FileUtils.deleteDirectoryOnExit(cacheDir);\n+        }\n+\n+        @Override\n+        public byte[] getClassCache(ClassLoader loader, String className) {\n+            // load from cache\n+            File cacheFile = getCacheFile(loader, className);\n+            if (cacheFile.exists()) {\n+                FileInputStream fileInputStream = null;\n+                try {\n+                    fileInputStream = new FileInputStream(cacheFile);\n+                    return IOUtils.toByteArray(fileInputStream);\n+                } catch (IOException e) {\n+                    logger.error(\"load class bytes from cache file failure\", e);\n+                } finally {\n+                    IOUtils.closeQuietly(fileInputStream);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void putClassCache(ClassLoader loader, String className, byte[] classfileBuffer) {\n+            File cacheFile = getCacheFile(loader, className);\n+            FileOutputStream output = null;\n+            try {\n+                output = new FileOutputStream(cacheFile);\n+                IOUtils.copy(new ByteArrayInputStream(classfileBuffer), output);\n+            } catch (IOException e) {\n+                logger.error(\"save class bytes to cache file failure\", e);\n+            } finally {\n+                IOUtils.closeQuietly(output);\n+            }\n+        }\n+\n+        private File getCacheFile(ClassLoader loader, String className) {\n+            String filename = getClassLoaderHash(loader) + \"@\" + className.replace('/', '.') + \".class\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NTkzNg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU2NzU1OnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyMTozM1rOGrSwIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyMTozM1rOGrSwIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0OTE4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. when use skywalking agent, arthas can't work well \n          \n          \n            \n            1. When use skywalking agent, some other agent, such as Arthas, can't work well", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448049184", "createdAt": "2020-07-01T00:21:33Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU3Mzg2OnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNToyNlrOGrSz_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzo0NTowMFrOGrVxUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDE3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Custom java agent retransform class fails with Skywalking agent  \n          \n          \n            \n             https://github.com/hengyunabc/skywalking-error-demo\n          \n          \n            \n            2. Java agent retransforming class fails with Skywalking agent, such as in this [demo](https://github.com/hengyunabc/skywalking-error-demo)\n          \n      \n    \n    \n  \n\nAlso, this code, would you like to push them into SkyAPMTest, I could create a repo for you and invite you in. The reason I recommend there is, we host unofficial tests and demo codes there, which need to be linked from the official repo.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448050172", "createdAt": "2020-07-01T00:25:26Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MDQ0OA==", "bodyText": "Yes, please create a repo: skywalking-retransform-demo", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448080448", "createdAt": "2020-07-01T02:26:33Z", "author": {"login": "kylixs"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDE3Mg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5ODY0Mw==", "bodyText": "Repo  https://github.com/SkyAPMTest/retransform-conflict-demo created, and sent the invitation to you.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448098643", "createdAt": "2020-07-01T03:45:00Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDE3Mg=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU3NDkxOnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNjowMVrOGrS0lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNjowMVrOGrS0lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDMyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n          \n          \n            \n            SkyWalking agent uses ByteBuddy to transform classes when the Java application starts.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448050325", "createdAt": "2020-07-01T00:26:01Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU3NTkzOnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNjozMVrOGrS1JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNjozMVrOGrS1JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDQ2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n          \n          \n            \n            When another java agent retransforms the same class, it triggers the SkyWalking agent to enhance the class again.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448050469", "createdAt": "2020-07-01T00:26:31Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU3OTEwOnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyODoyM1rOGrS3Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozOToxNlrOGrU2Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDk3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.\n          \n          \n            \n            The bytecode regenerated by ByteBuddy is changed, the fields and imported class names are modified, the JVM verifications about class bytecode fail, causing the retransform fails.\n          \n      \n    \n    \n  \n\nI think there is no imports in the byte codes level. All classes are in the full name.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448050971", "createdAt": "2020-07-01T00:28:23Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MTQ2Mw==", "bodyText": "The imports  will be converted to constant table items. ByteBuddy create random name auxiliary class, and add import item to origin class.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448081463", "createdAt": "2020-07-01T02:30:51Z", "author": {"login": "kylixs"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDk3MQ=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MzU0Mw==", "bodyText": "Update the expression.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448083543", "createdAt": "2020-07-01T02:39:16Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDk3MQ=="}, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU4MTY3OnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyOTo1NFrOGrS4nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyOTo1NFrOGrS4nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MTM1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If the class cahce feature is enabled, save the class bytecode of the ByteBuddy retransform to memory or a temporary file. \n          \n          \n            \n            If the class cache feature is enabled, save the instrumented class bytecode to memory or a temporary file.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448051357", "createdAt": "2020-07-01T00:29:54Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.\n+\n+\n+### Resolve\n+\n+**1.Enable the class cache feature**  \n+\n+Add JVM parameters:  \n+`-Dskywalking.agent.is_cache_enhanced_class=true -Dskywalking.agent.class_cache_mode=MEMORY`    \n+\n+Or uncomment options in `agent.conf`:\n+  \n+```\n+# If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode),\n+# allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+agent.is_cache_enhanced_class = ${SW_AGENT_CACHE_CLASS:false}\n+\n+# The instrumented classes cache mode: MEMORY or FILE\n+# MEMORY: cache class bytes to memory, if instrumented classes is too many or too large, it may take up more memory\n+# FILE: cache class bytes to user temp folder starts with 'class-cache', automatically clean up cached class files when the application exits\n+agent.class_cache_mode = ${SW_AGENT_CLASS_CACHE_MODE:MEMORY}\n+\n+```\n+\n+If the class cahce feature is enabled, save the class bytecode of the ByteBuddy retransform to memory or a temporary file. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU4MjQxOnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozMDoxOVrOGrS5EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozMDoxOVrOGrS5EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MTQ3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When other java agents retransform the same class, Skywalking agent first attempts to load from the cache.\n          \n          \n            \n            When other java agents retransform the same class, SkyWalking agent first attempts to load from the cache.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448051473", "createdAt": "2020-07-01T00:30:19Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.\n+\n+\n+### Resolve\n+\n+**1.Enable the class cache feature**  \n+\n+Add JVM parameters:  \n+`-Dskywalking.agent.is_cache_enhanced_class=true -Dskywalking.agent.class_cache_mode=MEMORY`    \n+\n+Or uncomment options in `agent.conf`:\n+  \n+```\n+# If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode),\n+# allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+agent.is_cache_enhanced_class = ${SW_AGENT_CACHE_CLASS:false}\n+\n+# The instrumented classes cache mode: MEMORY or FILE\n+# MEMORY: cache class bytes to memory, if instrumented classes is too many or too large, it may take up more memory\n+# FILE: cache class bytes to user temp folder starts with 'class-cache', automatically clean up cached class files when the application exits\n+agent.class_cache_mode = ${SW_AGENT_CLASS_CACHE_MODE:MEMORY}\n+\n+```\n+\n+If the class cahce feature is enabled, save the class bytecode of the ByteBuddy retransform to memory or a temporary file. \n+When other java agents retransform the same class, Skywalking agent first attempts to load from the cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU4NTYzOnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozMjoxMFrOGrS67A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozMjoxMFrOGrS67A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MTk0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It is recommended to put the cache class in memory, but if it takes up more memory, it should be placed in a temporary file. Set the class cache save mode through the following options:  \n          \n          \n            \n            It is recommended to put the cache class in memory, meanwhile if it costs more memory resources. Another option is using the local file system. Set the class cache mode through the following options:", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448051948", "createdAt": "2020-07-01T00:32:10Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.\n+\n+\n+### Resolve\n+\n+**1.Enable the class cache feature**  \n+\n+Add JVM parameters:  \n+`-Dskywalking.agent.is_cache_enhanced_class=true -Dskywalking.agent.class_cache_mode=MEMORY`    \n+\n+Or uncomment options in `agent.conf`:\n+  \n+```\n+# If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode),\n+# allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+agent.is_cache_enhanced_class = ${SW_AGENT_CACHE_CLASS:false}\n+\n+# The instrumented classes cache mode: MEMORY or FILE\n+# MEMORY: cache class bytes to memory, if instrumented classes is too many or too large, it may take up more memory\n+# FILE: cache class bytes to user temp folder starts with 'class-cache', automatically clean up cached class files when the application exits\n+agent.class_cache_mode = ${SW_AGENT_CLASS_CACHE_MODE:MEMORY}\n+\n+```\n+\n+If the class cahce feature is enabled, save the class bytecode of the ByteBuddy retransform to memory or a temporary file. \n+When other java agents retransform the same class, Skywalking agent first attempts to load from the cache.\n+\n+If the cached class is found, it will be used directly without regenerating a new random name auxiliary class, \n+which will not affect the processing of the subsequent java agent.\n+\n+**2.Class cache save mode**  \n+It is recommended to put the cache class in memory, but if it takes up more memory, it should be placed in a temporary file. Set the class cache save mode through the following options:  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU4NjA1OnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozMjoyMVrOGrS7Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozMjoyMVrOGrS7Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjAwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `-Dskywalking.agent.class_cache_mode=FILE` : save cache classes to Skywalking agent path '/class-cache'.  \n          \n          \n            \n            `-Dskywalking.agent.class_cache_mode=FILE` : save cache classes to SkyWalking agent path '/class-cache'.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448052006", "createdAt": "2020-07-01T00:32:21Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,53 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. when use skywalking agent, arthas can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Custom java agent retransform class fails with Skywalking agent  \n+ https://github.com/hengyunabc/skywalking-error-demo\n+ \n+### Reason\n+Skywalking agent uses ByteBuddy to retransform classes when java application starts. \n+ByteBuddy generates auxiliary classes with different random names every time. \n+\n+When other javaagent retransforms the same class, it will trigger the SkyWalking agent to enhance the class again. \n+The bytecode regenerated by ByteBuddy is changed, the fields and imports are modified, the jvm verifys class bytecode failed, and the retransform fails.\n+\n+\n+### Resolve\n+\n+**1.Enable the class cache feature**  \n+\n+Add JVM parameters:  \n+`-Dskywalking.agent.is_cache_enhanced_class=true -Dskywalking.agent.class_cache_mode=MEMORY`    \n+\n+Or uncomment options in `agent.conf`:\n+  \n+```\n+# If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode),\n+# allow other javaagent to enhance those classes that enhanced by SkyWalking agent.\n+agent.is_cache_enhanced_class = ${SW_AGENT_CACHE_CLASS:false}\n+\n+# The instrumented classes cache mode: MEMORY or FILE\n+# MEMORY: cache class bytes to memory, if instrumented classes is too many or too large, it may take up more memory\n+# FILE: cache class bytes to user temp folder starts with 'class-cache', automatically clean up cached class files when the application exits\n+agent.class_cache_mode = ${SW_AGENT_CLASS_CACHE_MODE:MEMORY}\n+\n+```\n+\n+If the class cahce feature is enabled, save the class bytecode of the ByteBuddy retransform to memory or a temporary file. \n+When other java agents retransform the same class, Skywalking agent first attempts to load from the cache.\n+\n+If the cached class is found, it will be used directly without regenerating a new random name auxiliary class, \n+which will not affect the processing of the subsequent java agent.\n+\n+**2.Class cache save mode**  \n+It is recommended to put the cache class in memory, but if it takes up more memory, it should be placed in a temporary file. Set the class cache save mode through the following options:  \n+`-Dskywalking.agent.class_cache_mode=MEMORY` : save cache classes to java memory.    \n+`-Dskywalking.agent.class_cache_mode=FILE` : save cache classes to Skywalking agent path '/class-cache'.  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjU5MDYyOnYy", "diffSide": "RIGHT", "path": "docs/en/setup/service-agent/java-agent/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozNTowM1rOGrS9zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDozNTowM1rOGrS9zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjY4Ng==", "bodyText": "I think you have a very clear explanation in the FAQ doc, please consider to add a link here. Such as\n..... you need to enable this feature. Read this FAQ for more details.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448052686", "createdAt": "2020-07-01T00:35:03Z", "author": {"login": "wu-sheng"}, "path": "docs/en/setup/service-agent/java-agent/README.md", "diffHunk": "@@ -78,6 +78,8 @@ property key | Description | Default |\n `agent.span_limit_per_segment`|The max number of spans in a single segment. Through this config item, SkyWalking keep your application memory cost estimated.|300 |\n `agent.ignore_suffix`|If the operation name of the first span is included in this set, this segment should be ignored.|Not set|\n `agent.is_open_debugging_class`|If true, skywalking agent will save all instrumented classes files in `/debugging` folder. SkyWalking team may ask for these files in order to resolve compatible problem.|Not set|\n+`agent.is_cache_enhanced_class`|If true, SkyWalking agent will cache all instrumented classes files to memory or disk files (decided by class cache mode), allow other javaagent to enhance those classes that enhanced by SkyWalking agent. To use some Java diagnostic tools (such as BTrace, Arthas) to diagnose applications or add a custom javaagent to enhance classes, you need to enable this feature.|`false`|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2326ab7bbc5f5751d189e568ec02015de3a49bab"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzE3ODg2OnYy", "diffSide": "RIGHT", "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoyNjozN1rOGrYYzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNzo0MDozOVrOGrafJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE0MTUxOA==", "bodyText": "Waiting for update at https://github.com/SkyAPMTest/retransform-conflict-demo", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448141518", "createdAt": "2020-07-01T06:26:37Z", "author": {"login": "wu-sheng"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,52 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. When use skywalking agent, some other agent, such as Arthas, can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Java agent retransforming class fails with Skywalking agent, such as in this [demo](https://github.com/hengyunabc/skywalking-error-demo)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f221261776e9656a6f45da8b930da8a853ae82de"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE3NTkxMQ==", "bodyText": "The demo project is submitted.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448175911", "createdAt": "2020-07-01T07:40:39Z", "author": {"login": "kylixs"}, "path": "docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md", "diffHunk": "@@ -0,0 +1,52 @@\n+## Compatible with other javaagent bytecode processing\n+\n+### Problem\n+1. When use skywalking agent, some other agent, such as Arthas, can't work well \n+https://github.com/apache/skywalking/pull/4858\n+\n+2. Java agent retransforming class fails with Skywalking agent, such as in this [demo](https://github.com/hengyunabc/skywalking-error-demo)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE0MTUxOA=="}, "originalCommit": {"oid": "f221261776e9656a6f45da8b930da8a853ae82de"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzE4MTQ2OnYy", "diffSide": "RIGHT", "path": "test/plugin/scenarios/retransform-class-scenario/configuration.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoyNzo0NFrOGrYaWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNjoyNzo0NFrOGrYaWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE0MTkxNA==", "bodyText": "Only found the jvm test, still, need your Tomcat test for different ClassLoader scenarios.", "url": "https://github.com/apache/skywalking/pull/4858#discussion_r448141914", "createdAt": "2020-07-01T06:27:44Z", "author": {"login": "wu-sheng"}, "path": "test/plugin/scenarios/retransform-class-scenario/configuration.yml", "diffHunk": "@@ -0,0 +1,22 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+type: jvm", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f221261776e9656a6f45da8b930da8a853ae82de"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 193, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}