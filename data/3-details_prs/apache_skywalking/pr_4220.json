{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxODMyNDQ5", "number": 4220, "title": "sniffer processing profile task and report status and snapshot", "bodyText": "Please answer these questions before submitting pull request\n\n\nWhy submit this pull request?\n\n\n Bug fix\n\n\n New feature provided\n\n\n Improve performance\n\n\nRelated issues\n#4104\n\n\n\nNew feature or improvement\n\nFollow the main issue step 3 and 4. Provide sniffer process profile task, report task finish and dump snapshot to the backend.", "createdAt": "2020-01-12T13:55:56Z", "url": "https://github.com/apache/skywalking/pull/4220", "merged": true, "mergeCommit": {"oid": "90f3c4de557b427426dc33a86f3223be6a831794"}, "closed": true, "closedAt": "2020-01-18T10:38:04Z", "author": {"login": "mrproliu"}, "timelineItems": {"totalCount": 56, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb5oBHZAH2gAyMzYxODMyNDQ5OjViZWU4OGVlN2JhMjNkZDFhMTlkZTZiZjI1NjhlZWYxN2E0YTNhMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7gFp8AFqTM0NDkzNTM3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5bee88ee7ba23dd1a19de6bf2568eef17a4a3a14", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/5bee88ee7ba23dd1a19de6bf2568eef17a4a3a14", "committedDate": "2020-01-12T13:46:02Z", "message": "sniffer processing profile task and report status and snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3ac8441f5dc612681c2f9bbc2e283a22b8c79d5", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/a3ac8441f5dc612681c2f9bbc2e283a22b8c79d5", "committedDate": "2020-01-12T13:56:11Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28b26712fd8b7415fd0b1f928de4fe313278c84c", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/28b26712fd8b7415fd0b1f928de4fe313278c84c", "committedDate": "2020-01-12T14:14:14Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "617f8d4dfe8fe7ff3aaffe285e8b3437bc388d51", "author": {"user": {"login": "wu-sheng", "name": "\u5434\u665f Wu Sheng"}}, "url": "https://github.com/apache/skywalking/commit/617f8d4dfe8fe7ff3aaffe285e8b3437bc388d51", "committedDate": "2020-01-13T00:59:32Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/3b051f5c72119fffaad513e0d6c07b787cc2f447", "committedDate": "2020-01-13T05:03:15Z", "message": "resolve testServiceDependencies test case error, use same register with `TraceSegmentServiceClient`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzA0OTEx", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-341704911", "createdAt": "2020-01-13T09:09:00Z", "commit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOTowOTowMFrOFcwaFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwOTo0MToxOVrOFcxNcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NzU1Nw==", "bodyText": "MAX_MONITOR_TIME -> MAX_DURATION", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365697557", "createdAt": "2020-01-13T09:09:00Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5ODA1NA==", "bodyText": "MAX_DUMP_STACK_DEPTH -> DUMP_MAX_STACK_DEPTH", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365698054", "createdAt": "2020-01-13T09:10:28Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5ODU4Nw==", "bodyText": "SEND -> TRANSPORT", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365698587", "createdAt": "2020-01-13T09:11:47Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;\n+\n+        /**\n+         * Snapshot send to backend channel size\n+         */\n+        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMDcwOA==", "bodyText": "Same about the name. And is 50 enough? From my understanding, we do thread dump every 10ms, then we could have 100 in one second. I think as we could collect 5 parallel, you will highly trigger queue abandon mode easily.\nI suggest at least 5 * 500. @kezhenxu94 What do you think?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365700708", "createdAt": "2020-01-13T09:17:33Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;\n+\n+        /**\n+         * Snapshot send to backend channel size\n+         */\n+        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+\n+        /**\n+         * Snapshot send to backend buffer size\n+         */\n+        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMzMxNQ==", "bodyText": "-> Check whether the new segment suitable for profiling.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365703315", "createdAt": "2020-01-13T09:24:16Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java", "diffHunk": "@@ -115,4 +115,10 @@\n      * @param span to be stopped.\n      */\n     void asyncStop(AsyncSpan span);\n+\n+    /**\n+     * Check current creating operation can add profiling, if true, it will start profiling", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNDEwOQ==", "bodyText": "Rename to prepareProfiling(String firstSpanOPName)", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365704109", "createdAt": "2020-01-13T09:26:05Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java", "diffHunk": "@@ -115,4 +115,10 @@\n      * @param span to be stopped.\n      */\n     void asyncStop(AsyncSpan span);\n+\n+    /**\n+     * Check current creating operation can add profiling, if true, it will start profiling\n+     * @param operationName\n+     */\n+    void checkAndAddProfiling(String operationName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNjIyMA==", "bodyText": "PARALLELS_THREAD_COUNT -> MAX_PARALLEL", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365706220", "createdAt": "2020-01-13T09:30:41Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwODk4NQ==", "bodyText": "Using PROFILING_THREAD_SELECTOR as index, I assume there is out of bound risk.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365708985", "createdAt": "2020-01-13T09:37:22Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +95,33 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {\n+            return false;\n+        }\n+\n+        // check has slot to add\n+        final ProfilingThread profilingThread = PROFILING_THREADS[PROFILING_THREAD_SELECTOR.getAndIncrement()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMDcwNQ==", "bodyText": "Are you creating so many threads for profiling tasks? I prefer to do this by using only one thread only. And don't create and dispose the thread every time. This is dangerous for JVM from my understanding. @kezhenxu94 @arugal what do you think?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365710705", "createdAt": "2020-01-13T09:41:19Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -38,13 +45,17 @@\n  * @author MrPro\n  */\n @DefaultImplementor\n-public class ProfileTaskExecutionService implements BootService {\n+public class ProfileTaskExecutionService implements BootService, TracingContextListener {\n \n     private static final ILog logger = LogManager.getLogger(ProfileTaskExecutionService.class);\n \n     // add a schedule while waiting for the task to start or finish\n     private final static ScheduledExecutorService PROFILE_TASK_SCHEDULE = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"PROFILE-TASK-SCHEDULE\"));\n \n+    // profiling segment thread array, Config.Profile.PARALLELS_THREAD_COUNT\n+    private final static ProfilingThread[] PROFILING_THREADS = new ProfilingThread[Config.Profile.PARALLELS_THREAD_COUNT];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "078f6b8a7994e386ca72c77627d96f2e97e3d0bb", "author": {"user": {"login": "kezhenxu94", "name": "kezhenxu94"}}, "url": "https://github.com/apache/skywalking/commit/078f6b8a7994e386ca72c77627d96f2e97e3d0bb", "committedDate": "2020-01-13T10:51:18Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a4eee23662706757ca46d0ce0837677b93251da", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/2a4eee23662706757ca46d0ce0837677b93251da", "committedDate": "2020-01-13T12:14:07Z", "message": "resolve names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44b6873eaacecc9fca954ad7a30d7cc270cd2dcd", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/44b6873eaacecc9fca954ad7a30d7cc270cd2dcd", "committedDate": "2020-01-13T12:15:21Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "286d221ea2b54023798ae863a0222cc7f28ad865", "author": {"user": {"login": "wu-sheng", "name": "\u5434\u665f Wu Sheng"}}, "url": "https://github.com/apache/skywalking/commit/286d221ea2b54023798ae863a0222cc7f28ad865", "committedDate": "2020-01-13T13:33:28Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "committedDate": "2020-01-13T16:28:14Z", "message": "change profile to single one thread run."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNTA0OTUx", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-342504951", "createdAt": "2020-01-14T12:46:03Z", "commit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMjo0NjowM1rOFdWRBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMzo0NTowNlrOFdX6iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxNzgzMA==", "bodyText": "Why use full class name?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366317830", "createdAt": "2020-01-14T12:46:03Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();\n+                    snapshotQueue.drainTo(buffer);\n+                    if (buffer.size() > 0) {\n+                        final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);\n+                        StreamObserver<org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot> snapshotStreamObserver = profileTaskStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collectSnapshot(new StreamObserver<Downstream>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxNzk1Mw==", "bodyText": "Same here.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366317953", "createdAt": "2020-01-14T12:46:24Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();\n+                    snapshotQueue.drainTo(buffer);\n+                    if (buffer.size() > 0) {\n+                        final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);\n+                        StreamObserver<org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot> snapshotStreamObserver = profileTaskStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collectSnapshot(new StreamObserver<Downstream>() {\n+                            @Override\n+                            public void onNext(Downstream downstream) {\n+                            }\n+\n+                            @Override\n+                            public void onError(Throwable throwable) {\n+                                status.finished();\n+                                if (logger.isErrorEnable()) {\n+                                    logger.error(throwable, \"Send profile segment snapshot to collector fail with a grpc internal exception.\");\n+                                }\n+                                ServiceManager.INSTANCE.findService(GRPCChannelManager.class).reportError(throwable);\n+                            }\n+\n+                            @Override\n+                            public void onCompleted() {\n+                                status.finished();\n+                            }\n+                        });\n+                        for (ProfileTaskSegmentSnapshot snapshot : buffer) {\n+                            final org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot transformSnapshot = snapshot.transform();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxODEzNQ==", "bodyText": "You have known the max size, using ArrayList please.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366318135", "createdAt": "2020-01-14T12:46:49Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyMzE3Mw==", "bodyText": "Don't use Config.Profile.MAX_DURATION in the initial codes. Move this initialization into the constructor. Because there may be a chance, someone accidentally loads this class before Config initialization.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366323173", "createdAt": "2020-01-14T12:58:51Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyMzQ4NQ==", "bodyText": "Don't use Config.Profile.MAX_DURATION in the initial codes. Move this initialization into the constructor. Because there may be a chance, someone accidentally loads this class before Config initialization.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366323485", "createdAt": "2020-01-14T12:59:38Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNDMxOQ==", "bodyText": "PROFILE-MONITOR-THREAD -> PROFILING-THREAD . We don't use the word monitor, because SkyWalking is monitoring many places :)", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366324319", "createdAt": "2020-01-14T13:01:41Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -108,36 +139,49 @@ public void run() {\n     /**\n      * stop profile task, remove context data\n      */\n-    private synchronized void stopCurrentProfileTask(ProfileTaskExecutionContext needToStop) {\n+    synchronized void stopCurrentProfileTask(ProfileTaskExecutionContext needToStop) {\n         // stop same context only\n         if (needToStop == null || !taskExecutionContext.compareAndSet(needToStop, null)) {\n             return;\n         }\n \n+        // current execution stop running\n+        needToStop.setRunning(false);\n+\n         // remove task\n         profileTaskList.remove(needToStop.getTask());\n \n-        // TODO notify OAP current profile task execute finish\n+        // notify profiling task has finished\n+        ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class).notifyProfileTaskFinish(needToStop.getTask());\n     }\n \n     @Override\n     public void prepare() throws Throwable {\n-\n     }\n \n     @Override\n     public void boot() throws Throwable {\n-\n+        // init PROFILE_THREAD and start\n+        profileThread = new ProfileThread();\n+        profileThread.setDaemon(true);\n+        profileThread.setName(\"PROFILE-MONITOR-THREAD\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNDkyNg==", "bodyText": "checkSegmentProfilingCanContinue -> isSegmentProfilingContinuable. Let's reduce the usage of check.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366324926", "createdAt": "2020-01-14T13:03:06Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNzYzOA==", "bodyText": "Why all these are full names?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366327638", "createdAt": "2020-01-14T13:09:20Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskSegmentSnapshot.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentStack;\n+\n+import java.util.List;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfileTaskSegmentSnapshot {\n+\n+    // profiling segment context\n+    private final ProfilingSegmentContext segmentContext;\n+\n+    // dump info\n+    private final int sequence;\n+    private final long time;\n+    private final List<String> stackList;\n+\n+    public ProfileTaskSegmentSnapshot(ProfilingSegmentContext segmentContext, int sequence, long time, List<String> stackList) {\n+        this.segmentContext = segmentContext;\n+        this.sequence = sequence;\n+        this.time = time;\n+        this.stackList = stackList;\n+    }\n+\n+    /**\n+     * transform to gRPC data\n+     * @return\n+     */\n+    public org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot transform() {\n+        final org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot.Builder builder = org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot.newBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyODMwMw==", "bodyText": "#profiling is inside #run, why check this again?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366328303", "createdAt": "2020-01-14T13:10:50Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyOTI0Mg==", "bodyText": "TracingContext#finish has a listener mechanism, you don't need to check every time, you should set up a listener, then you could remove when you get the notification.\nBut you should notice, there is a segment finish event right now, but tracing context has an async mode today, so you need to add a notification, named as notifyAfterMainThreadFinish.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366329242", "createdAt": "2020-01-14T13:12:43Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {\n+        // check segment still executing\n+        if (!context.getSegmentIsRunning()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzMDg0Ng==", "bodyText": "Don't check this every time, once you don't get the notification event(notifyAfterMainThreadFinish), it is safe to continue.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366330846", "createdAt": "2020-01-14T13:16:18Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {\n+        // check segment still executing\n+        if (!context.getSegmentIsRunning()) {\n+            return false;\n+        }\n+\n+        // check is out of limit monitor time\n+        if (System.currentTimeMillis() - context.getProfilingStartTime() > MAX_PROFILING_TIME_MILLS) {\n+            return false;\n+        }\n+\n+        // check segment executing thread is still running\n+        if (!context.getProfilingThread().isAlive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNjIxNA==", "bodyText": "Renaming to ThreadProfiler. Don't use context always. You need to avoid two similar names in one place, it is very confusing when reading the codes.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366336214", "createdAt": "2020-01-14T13:27:52Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNjMwNQ==", "bodyText": "Rename to nextSeq", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366336305", "createdAt": "2020-01-14T13:28:05Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ProfilingSegmentContext(TraceSegment segment, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.segment = segment;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingStartTime = System.currentTimeMillis();\n+    }\n+\n+    public TraceSegment getSegment() {\n+        return segment;\n+    }\n+\n+    public Thread getProfilingThread() {\n+        return profilingThread;\n+    }\n+\n+    public boolean getSegmentIsRunning() {\n+        return segmentIsRunning;\n+    }\n+\n+    public void setSegmentIsRunning(boolean segmentIsRunning) {\n+        this.segmentIsRunning = segmentIsRunning;\n+    }\n+\n+    public ProfileTaskExecutionContext getExecutionContext() {\n+        return executionContext;\n+    }\n+\n+    public long getProfilingStartTime() {\n+        return profilingStartTime;\n+    }\n+\n+    public boolean getStartDump() {\n+        return startDump;\n+    }\n+\n+    public void setStartDump(boolean startDump) {\n+        this.startDump = startDump;\n+    }\n+\n+    /**\n+     * get current sequence then increment it\n+     * @return\n+     */\n+    public int getCurrentAndIncrementSequence() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNzUyMQ==", "bodyText": "You should be able to use segment#equal, right? Also, you should begin to move the logic method into the entity.\nThis should be profilingSegmentSlot[slot].matchWith(segment.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366337521", "createdAt": "2020-01-14T13:30:33Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNzk3Ng==", "bodyText": "What is segmentIsRunning=false?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366337976", "createdAt": "2020-01-14T13:31:25Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzODc0NA==", "bodyText": "No matter how many times you check the thread#isAlive, you still could face the thread is not inactive or dead at here. Try/catch this, and remove all unnecessary check.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366338744", "createdAt": "2020-01-14T13:33:00Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzOTM1Nw==", "bodyText": "This doesn't match the profilingStartTime. Is that a bug?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366339357", "createdAt": "2020-01-14T13:34:15Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ProfilingSegmentContext(TraceSegment segment, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.segment = segment;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingStartTime = System.currentTimeMillis();\n+    }\n+\n+    public TraceSegment getSegment() {\n+        return segment;\n+    }\n+\n+    public Thread getProfilingThread() {\n+        return profilingThread;\n+    }\n+\n+    public boolean getSegmentIsRunning() {\n+        return segmentIsRunning;\n+    }\n+\n+    public void setSegmentIsRunning(boolean segmentIsRunning) {\n+        this.segmentIsRunning = segmentIsRunning;\n+    }\n+\n+    public ProfileTaskExecutionContext getExecutionContext() {\n+        return executionContext;\n+    }\n+\n+    public long getProfilingStartTime() {\n+        return profilingStartTime;\n+    }\n+\n+    public boolean getStartDump() {\n+        return startDump;\n+    }\n+\n+    public void setStartDump(boolean startDump) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzOTgxNg==", "bodyText": "This should compare to segment startTime. slot#startTIme is not necessary.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366339816", "createdAt": "2020-01-14T13:35:16Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MDQwMg==", "bodyText": "startDump -> enum profilingStatus, which has values(READY/PROFILING/STOPPED)", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366340402", "createdAt": "2020-01-14T13:36:24Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MDk2NA==", "bodyText": "checkAndAddSegmentContext -> attempProfiling", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366340964", "createdAt": "2020-01-14T13:37:30Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MTY5OQ==", "bodyText": "You should use TracingContext rather than segment as the parameter. segment is a collection of spans, only tracingContext has status.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366341699", "createdAt": "2020-01-14T13:38:57Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {\n+        if (segment.getProfiling()) {\n+            return;\n+        }\n+\n+        // update profiling status\n+        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        segment.setProfiling(profileTaskExecutionService.addProfiling(segment, firstSpanOPName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MTk1OQ==", "bodyText": "Why need this check?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366341959", "createdAt": "2020-01-14T13:39:29Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {\n+        if (segment.getProfiling()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDA3MA==", "bodyText": "Why need this method? I think we just need to add a parameter in the TracingContext constructor.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344070", "createdAt": "2020-01-14T13:43:28Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDU5Nw==", "bodyText": "If no available slot, you don't need the following steps.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344597", "createdAt": "2020-01-14T13:44:33Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +92,27 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDg0Mw==", "bodyText": "This is not must be endpoint name. This is only first span OP name.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344843", "createdAt": "2020-01-14T13:45:06Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +92,27 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDU5Nw=="}, "originalCommit": {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "committedDate": "2020-01-15T02:14:05Z", "message": "1. change to the ArrayList, because known the max size\n2. rename issue resolved"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40aaf568a866786d171915baf59f53ed688d6ea4", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/40aaf568a866786d171915baf59f53ed688d6ea4", "committedDate": "2020-01-15T02:37:36Z", "message": "add profiling status enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f1d8fcca5b8091cee094b6cc59400713960491b", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/3f1d8fcca5b8091cee094b6cc59400713960491b", "committedDate": "2020-01-15T02:54:19Z", "message": "change sniffer use full name issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "committedDate": "2020-01-15T09:15:37Z", "message": "1. remove `prepareProfiling` method, build profiling status when construct `TracingContext`\n2. add `TracingThreadListenerManager`, notify when tracing main thread finish\n3. change ProfileThread start when process new profile task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b7b5fc8bbe7192ac9ff00dec946e8c5d7bc8cc6", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/1b7b5fc8bbe7192ac9ff00dec946e8c5d7bc8cc6", "committedDate": "2020-01-15T09:31:26Z", "message": "remove unnecessary getter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98dca63fd760af13060c8c36aaa4505330c80dd6", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/98dca63fd760af13060c8c36aaa4505330c80dd6", "committedDate": "2020-01-15T09:52:44Z", "message": "add test assert error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e59c4e41fb77f2bf25ab1c600d18fc15aa3db52b", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/e59c4e41fb77f2bf25ab1c600d18fc15aa3db52b", "committedDate": "2020-01-15T10:09:48Z", "message": "adding `AgentServiceRule`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39a8b2eac33fc27007aed11ffee529143928de16", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/39a8b2eac33fc27007aed11ffee529143928de16", "committedDate": "2020-01-15T10:21:12Z", "message": "revert original assert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2275c99449726366732c65c1444f996796bc32b", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/c2275c99449726366732c65c1444f996796bc32b", "committedDate": "2020-01-15T12:16:20Z", "message": "remove unnecessary getter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/ff34355adf6cbb90b444a8543be816c55d3da913", "committedDate": "2020-01-15T12:25:34Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTg5NzY3", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-343189767", "createdAt": "2020-01-15T12:40:24Z", "commit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjo0MDoyNFrOFd2_PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoyNjo0MlrOFd4K0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1Mzk0OQ==", "bodyText": "You don't need to findService every time. Please add a field to hold the ref.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366853949", "createdAt": "2020-01-15T12:40:24Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -92,15 +93,27 @@\n \n     private volatile boolean running;\n \n+    private final long createTime;\n+\n+    /**\n+     * profiling status\n+     */\n+    private final boolean profiling;\n+\n     /**\n      * Initialize all fields with default value.\n      */\n-    TracingContext() {\n+    TracingContext(String firstOPName) {\n         this.segment = new TraceSegment();\n         this.spanIdGenerator = 0;\n         samplingService = ServiceManager.INSTANCE.findService(SamplingService.class);\n         isRunningInAsyncMode = false;\n+        createTime = System.currentTimeMillis();\n         running = true;\n+\n+        // profiling status\n+        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDQyMg==", "bodyText": "Notify current tracing context main thread has already execute finished. -> Notify after tracing finished in the main thread.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366854422", "createdAt": "2020-01-15T12:41:42Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -497,6 +510,11 @@ private void finish() {\n                 TracingContext.ListenerManager.notifyFinish(finishedSegment);\n \n                 running = false;\n+\n+                /**\n+                 * Notify current tracing context main thread has already execute finished.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDg1MQ==", "bodyText": "This notification should not be in (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)). The condition means async finished.  You just need activeSpanStack.isEmpty() && running.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366854851", "createdAt": "2020-01-15T12:42:52Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -497,6 +510,11 @@ private void finish() {\n                 TracingContext.ListenerManager.notifyFinish(finishedSegment);\n \n                 running = false;\n+\n+                /**\n+                 * Notify current tracing context main thread has already execute finished.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDQyMg=="}, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTMwNw==", "bodyText": "Why does the segment still need this? This should be moved into TracingContext.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366855307", "createdAt": "2020-01-15T12:44:10Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java", "diffHunk": "@@ -74,6 +74,9 @@\n \n     private final long createTime;\n \n+    // segment is profiling\n+    private volatile boolean profiling;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2MjEyNw==", "bodyText": "threadProfilerSlot  -> threadProfilerSlots", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366862127", "createdAt": "2020-01-15T13:00:55Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2Mjg3Mw==", "bodyText": "Why don't move this into L118, then you don't need find flag and related codes.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366862873", "createdAt": "2020-01-15T13:02:38Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     */\n+    public void stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean find = false;\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlot[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentProfiler.stopProfiling();\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentProfilingCount.addAndGet(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NDIyOA==", "bodyText": "As this method could be called in another thread, you need to set the whole array again, and add volatile, read solution 2, https://www.javamex.com/tutorials/volatile_arrays.shtml", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366864228", "createdAt": "2020-01-15T13:05:51Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     */\n+    public void stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean find = false;\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlot[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlot[slot] = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NzU3NQ==", "bodyText": "segment should not exist. Dump the executing thread stack.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366867575", "createdAt": "2020-01-15T13:13:39Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MjUyNw==", "bodyText": "Is this for shutdown process only?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366872527", "createdAt": "2020-01-15T13:25:00Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread implements Runnable {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // profiling task context\n+    private final ProfileTaskExecutionContext taskExecutionContext;\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread(ProfileTaskExecutionContext taskExecutionContext) {\n+        this.taskExecutionContext = taskExecutionContext;\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            profiling(taskExecutionContext);\n+        } catch (InterruptedException e) {\n+            // ignore interrupted\n+            // means current task has stopped", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MzI5OQ==", "bodyText": "I think you change this by mistake. Please revert.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366873299", "createdAt": "2020-01-15T13:26:42Z", "author": {"login": "wu-sheng"}, "path": "oap-server/server-bootstrap/src/main/resources/application.yml", "diffHunk": "@@ -98,33 +98,34 @@ storage:\n #    segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}\n #    profileTaskQueryMaxSize: ${SW_STORAGE_ES_QUERY_PROFILE_TASK_SIZE:200}\n #    advanced: ${SW_STORAGE_ES_ADVANCED:\"\"}\n-  elasticsearch7:\n-    nameSpace: ${SW_NAMESPACE:\"\"}\n-    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}\n-    protocol: ${SW_STORAGE_ES_HTTP_PROTOCOL:\"http\"}\n-    #trustStorePath: ${SW_SW_STORAGE_ES_SSL_JKS_PATH:\"../es_keystore.jks\"}\n-    #trustStorePass: ${SW_SW_STORAGE_ES_SSL_JKS_PASS:\"\"}\n-    user: ${SW_ES_USER:\"\"}\n-    password: ${SW_ES_PASSWORD:\"\"}\n-    indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:2}\n-    indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0}\n-    # Those data TTL settings will override the same settings in core module.\n-    recordDataTTL: ${SW_STORAGE_ES_RECORD_DATA_TTL:7} # Unit is day\n-    otherMetricsDataTTL: ${SW_STORAGE_ES_OTHER_METRIC_DATA_TTL:45} # Unit is day\n-    monthMetricsDataTTL: ${SW_STORAGE_ES_MONTH_METRIC_DATA_TTL:18} # Unit is month\n-    # Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html\n-    bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:1000} # Execute the bulk every 1000 requests\n-    flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10} # flush the bulk every 10 seconds whatever the number of requests\n-    concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2} # the number of concurrent requests\n-    resultWindowMaxSize: ${SW_STORAGE_ES_QUERY_MAX_WINDOW_SIZE:10000}\n-    metadataQueryMaxSize: ${SW_STORAGE_ES_QUERY_MAX_SIZE:5000}\n-    segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}\n-    advanced: ${SW_STORAGE_ES_ADVANCED:\"\"}\n-#  h2:\n-#    driver: ${SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource}\n-#    url: ${SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db}\n-#    user: ${SW_STORAGE_H2_USER:sa}\n-#    metadataQueryMaxSize: ${SW_STORAGE_H2_QUERY_MAX_SIZE:5000}\n+#  elasticsearch7:\n+#    nameSpace: ${SW_NAMESPACE:\"\"}\n+#    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}\n+#    protocol: ${SW_STORAGE_ES_HTTP_PROTOCOL:\"http\"}\n+#    #trustStorePath: ${SW_SW_STORAGE_ES_SSL_JKS_PATH:\"../es_keystore.jks\"}\n+#    #trustStorePass: ${SW_SW_STORAGE_ES_SSL_JKS_PASS:\"\"}\n+#    user: ${SW_ES_USER:\"\"}\n+#    password: ${SW_ES_PASSWORD:\"\"}\n+#    indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:2}\n+#    indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0}\n+#    # Those data TTL settings will override the same settings in core module.\n+#    recordDataTTL: ${SW_STORAGE_ES_RECORD_DATA_TTL:7} # Unit is day\n+#    otherMetricsDataTTL: ${SW_STORAGE_ES_OTHER_METRIC_DATA_TTL:45} # Unit is day\n+#    monthMetricsDataTTL: ${SW_STORAGE_ES_MONTH_METRIC_DATA_TTL:18} # Unit is month\n+#    # Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html\n+#    bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:1000} # Execute the bulk every 1000 requests\n+#    flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10} # flush the bulk every 10 seconds whatever the number of requests\n+#    concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2} # the number of concurrent requests\n+#    resultWindowMaxSize: ${SW_STORAGE_ES_QUERY_MAX_WINDOW_SIZE:10000}\n+#    metadataQueryMaxSize: ${SW_STORAGE_ES_QUERY_MAX_SIZE:5000}\n+#    segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}\n+#    profileTaskQueryMaxSize: ${SW_STORAGE_ES_QUERY_PROFILE_TASK_SIZE:200}\n+#    advanced: ${SW_STORAGE_ES_ADVANCED:\"\"}\n+  h2:\n+    driver: ${SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource}\n+    url: ${SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db}\n+    user: ${SW_STORAGE_H2_USER:sa}\n+    metadataQueryMaxSize: ${SW_STORAGE_H2_QUERY_MAX_SIZE:5000}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "committedDate": "2020-01-16T02:13:29Z", "message": "resolve issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "089245dedac4311d02abb431f9bd8a4224f88beb", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/089245dedac4311d02abb431f9bd8a4224f88beb", "committedDate": "2020-01-16T02:15:47Z", "message": "reduce findService invoke"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "901d867c2e2782f2ceaaf45e6ce9464c2296ec65", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/901d867c2e2782f2ceaaf45e6ce9464c2296ec65", "committedDate": "2020-01-16T02:25:21Z", "message": "resolve style error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "committedDate": "2020-01-16T06:07:18Z", "message": "recheck profiling when change first span operatin name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzE0MjAy", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-343714202", "createdAt": "2020-01-16T07:26:25Z", "commit": {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzoyNjoyNVrOFeQFLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNzo1MDoyN1rOFeQhJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NTA3MQ==", "bodyText": "tracingFinishInMainThread -> isFinishedInMainThread", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367265071", "createdAt": "2020-01-16T07:26:25Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,16 +485,34 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void profilingRecheck(AbstractSpan span, String operationName) {\n+        // only recheck first span\n+        if (span.getSpanId() != 0) {\n+            return;\n+        }\n+\n+        profiling = PROFILE_TASK_EXECUTION_SERVICE.profilingRecheck(this, segment.getTraceSegmentId(), operationName);\n+    }\n+\n     /**\n      * Finish this context, and notify all {@link TracingContextListener}s, managed by {@link\n-     * TracingContext.ListenerManager}\n+     * TracingContext.ListenerManager} and {@link TracingContext.TracingThreadListenerManager}\n      */\n     private void finish() {\n         if (isRunningInAsyncMode) {\n             asyncFinishLock.lock();\n         }\n         try {\n-            if (activeSpanStack.isEmpty() && running && (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)) {\n+            boolean tracingFinishInMainThread = activeSpanStack.isEmpty() && running;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NjAxMQ==", "bodyText": "I think we don't need ContextManager#profilingRecheck. There is a ref of tracingContext in the span, check AbstractTracingSpan. You should use it, it is better to keep profilingRecheck in private, right?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367266011", "createdAt": "2020-01-16T07:29:43Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java", "diffHunk": "@@ -203,6 +203,9 @@ public AbstractTracingSpan errorOccurred() {\n     public AbstractTracingSpan setOperationName(String operationName) {\n         this.operationName = operationName;\n         this.operationId = DictionaryUtil.nullValue();\n+\n+        // recheck profiling status\n+        ContextManager.profilingRecheck(this, operationName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3MjIzMA==", "bodyText": "I think you missed the profilingSegmentSlots resign to make volatile works.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367272230", "createdAt": "2020-01-16T07:50:27Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +163,20 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            if (profilingSegmentSlots[slot] == null) {\n+                profilingSegmentSlots[slot] = segmentContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eb35150e7e9b12b5db8da725b547ea805a66b10", "author": {"user": {"login": "kezhenxu94", "name": "kezhenxu94"}}, "url": "https://github.com/apache/skywalking/commit/2eb35150e7e9b12b5db8da725b547ea805a66b10", "committedDate": "2020-01-16T08:36:59Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9454d3fa28ca7469c1d5f04ef78a64d27144b11f", "author": {"user": {"login": "kezhenxu94", "name": "kezhenxu94"}}, "url": "https://github.com/apache/skywalking/commit/9454d3fa28ca7469c1d5f04ef78a64d27144b11f", "committedDate": "2020-01-16T13:10:19Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "committedDate": "2020-01-17T02:41:16Z", "message": "resolve issues\n1. remove `ContextManager#profilingRecheck`, only check on `TracingContext`\n2. rename comments\n3. resolve volatile array setting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MzM3OTA4", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344337908", "createdAt": "2020-01-17T02:47:37Z", "commit": {"oid": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMjo0NzozN1rOFetgNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMjo0NzozN1rOFetgNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NzEyNw==", "bodyText": "Don't put the link here. The article is just reference, we don't have the license to broadcast it.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367747127", "createdAt": "2020-01-17T02:47:37Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -174,6 +174,9 @@ private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSeg\n         for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n             if (profilingSegmentSlots[slot] == null) {\n                 profilingSegmentSlots[slot] = segmentContext;\n+\n+                // see https://www.javamex.com/tutorials/volatile_arrays.shtml, solution 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "committedDate": "2020-01-17T02:50:02Z", "message": "remove article link"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5945c884724387215f5d417e4763aa4c8dc61812", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/5945c884724387215f5d417e4763aa4c8dc61812", "committedDate": "2020-01-17T03:49:02Z", "message": "add `ProfileTask#maxSamplingCount` check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5279c53b8eb6770c2e9b557f2257370fb3e37267", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/5279c53b8eb6770c2e9b557f2257370fb3e37267", "committedDate": "2020-01-17T12:52:51Z", "message": "resolve conflict (Downstream -> Commands)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/ec08e2648fef30ccb477d72619fdcd787eaec713", "committedDate": "2020-01-17T12:53:49Z", "message": "Merge branch 'master' into profile_monitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTU0NTk5", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344554599", "createdAt": "2020-01-17T12:45:47Z", "commit": {"oid": "5945c884724387215f5d417e4763aa4c8dc61812"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMjo0NTo0N1rOFe38SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzoyNjoyMlrOFe44Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxODE1Mg==", "bodyText": "Same as before, don't use Config in the field initialization. Use it in the constructor.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367918152", "createdAt": "2020-01-17T12:45:47Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5945c884724387215f5d417e4763aa4c8dc61812"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNDc5Ng==", "bodyText": "Merge tryToAttemptProfiling -> attemptProfiling. Similar name, always use in the same time.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367924796", "createdAt": "2020-01-17T13:03:35Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTkwMg==", "bodyText": "Why does this check happen at the start stage? I think when totalStartedProfilingCount reaches max count, this profile should be at the profiling stage. Do I miss anything?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367929902", "createdAt": "2020-01-17T13:16:58Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {\n+                if (stopTracingProfile(tracingContext)) {\n+                    // reduce total started profiling count when status is profiling\n+                    totalStartedProfilingCount.addAndGet(-1);\n+                }\n+            }\n+            return false;\n+        } else if (alreadyProfiling) {\n+            return true;\n+        }\n+\n+        // not profiling, try to occupy slot\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     *\n+     * @return current profiler is already start profiling\n+     */\n+    public boolean stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean isProfilingStarted = false;\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlots[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlots[slot] = null;\n+\n+                // setting stop running\n+                isProfilingStarted = currentProfiler.stopProfiling();\n+                currentProfilingCount.addAndGet(-1);\n+\n+                profilingSegmentSlots = profilingSegmentSlots;\n+                break;\n+            }\n+        }\n+\n+        return isProfilingStarted;\n     }\n \n     public ProfileTask getTask() {\n         return task;\n     }\n \n-    public long getStartTime() {\n-        return startTime;\n+    public ThreadProfiler[] threadProfilerSlots() {\n+        return profilingSegmentSlots;\n     }\n \n+    public boolean isStartProfileable(ThreadProfiler profiler) {\n+        // check is out of max sampling count check\n+        if (totalStartedProfilingCount.incrementAndGet() > task.getMaxSamplingCount()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDMwNw==", "bodyText": "Once the profile starts, it should not stop.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367930307", "createdAt": "2020-01-17T13:18:02Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDU1Ng==", "bodyText": "Otherwise, if I set a profiling task targeting a Tomcat endpoint name, it will never execute as SpringMVC must override it", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367930556", "createdAt": "2020-01-17T13:18:40Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDMwNw=="}, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMzUxMA==", "bodyText": "This isn't segmentContext, please rename.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367933510", "createdAt": "2020-01-17T13:26:22Z", "author": {"login": "wu-sheng"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc86d725a8ea60be80e9b579c6e451ae50244933", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/dc86d725a8ea60be80e9b579c6e451ae50244933", "committedDate": "2020-01-17T14:44:31Z", "message": "1. change profilingSegmentSlots init on construct\n2. if is profiling, recheck dont need to stop\n3. total profiling count increment on first dump"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTg4OTc3", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344588977", "createdAt": "2020-01-17T13:50:44Z", "commit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMzo1MDo0NFrOFe5hOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDowNTo0NFrOFe573g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg==", "bodyText": "This line is really confusing, what does it do?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367943992", "createdAt": "2020-01-17T13:50:44Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {\n+                if (stopTracingProfile(tracingContext)) {\n+                    // reduce total started profiling count when status is profiling\n+                    totalStartedProfilingCount.addAndGet(-1);\n+                }\n+            }\n+            return false;\n+        } else if (alreadyProfiling) {\n+            return true;\n+        }\n+\n+        // not profiling, try to occupy slot\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     *\n+     * @return current profiler is already start profiling\n+     */\n+    public boolean stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean isProfilingStarted = false;\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlots[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlots[slot] = null;\n+\n+                // setting stop running\n+                isProfilingStarted = currentProfiler.stopProfiling();\n+                currentProfilingCount.addAndGet(-1);\n+\n+                profilingSegmentSlots = profilingSegmentSlots;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NDI3Nw==", "bodyText": "And this one", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367944277", "createdAt": "2020-01-17T13:51:23Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            if (profilingSegmentSlots[slot] == null) {\n+                profilingSegmentSlots[slot] = segmentContext;\n+\n+                profilingSegmentSlots = profilingSegmentSlots;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA==", "bodyText": "I prefer to let this method return an Exception, maybe java.lang.IllegalStateException, simply return a string is no so semantic, and you may want to print the stack trace there, since it's a kind of \"exception\", in some degree", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367947098", "createdAt": "2020-01-17T13:57:45Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -151,7 +202,7 @@ public long getLastCommandCreateTime() {\n      */\n     private String checkProfileTaskSuccess(ProfileTask task) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MDgxNA==", "bodyText": "You have so many JavaDocs like this, please add corresponding descriptions, or remove the @param and @return, although it can compile, it produces uncountable warnings in CI (javadoc:javadoc), and many many warnings in the IDE, making it hard to discover warnings that really matters:", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367950814", "createdAt": "2020-01-17T14:05:44Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b29dcad201c54295b4443bc53eaaad25db25d136", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/b29dcad201c54295b4443bc53eaaad25db25d136", "committedDate": "2020-01-17T15:00:51Z", "message": "remove unused return val"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "committedDate": "2020-01-17T15:08:44Z", "message": "remove some `@param` and `@return`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "914021a0f5611a3963b89b03cd2e54bb8157cefb", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/914021a0f5611a3963b89b03cd2e54bb8157cefb", "committedDate": "2020-01-18T02:42:20Z", "message": "add profile task check result data bean"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d455464c9a7d2977e803db2e99a7101ddb3cb452", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/d455464c9a7d2977e803db2e99a7101ddb3cb452", "committedDate": "2020-01-18T03:04:14Z", "message": "change profiler slot to `AtomicReferenceArray`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/01bfafb695de56c7cc13d9d92db93dbb194d0c19", "committedDate": "2020-01-18T03:22:14Z", "message": "resolved java doc error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTI0MTY0", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344924164", "createdAt": "2020-01-18T04:17:34Z", "commit": {"oid": "01bfafb695de56c7cc13d9d92db93dbb194d0c19"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwNDoxNzozNFrOFfJcRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwNDoxODowMVrOFfJcXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDg3MQ==", "bodyText": "You don't return anything at all", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368204871", "createdAt": "2020-01-18T04:17:34Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +38,129 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile AtomicReferenceArray<ThreadProfiler> profilingSegmentSlots;\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n+\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+        profilingSegmentSlots = new AtomicReferenceArray<>(Config.Profile.MAX_PARALLEL);\n+    }\n+\n+    /**\n+     * start profiling this task\n+     *\n+     * @param executorService start profiling to appoint thread pool\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     *\n+     * @param tracingContext need to profiling trace\n+     * @param traceSegmentId current trace segment id\n+     * @param firstSpanOPName first span operation name\n+     * @return is add profile success\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler threadProfiler = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        int slotLength = profilingSegmentSlots.length();\n+        for (int slot = 0; slot < slotLength; slot++) {\n+            if (profilingSegmentSlots.compareAndSet(slot, null, threadProfiler)) {\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     *\n+     * @return is recheck to add profile success\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // if started, keep profiling\n+        if (tracingContext.isProfiling()) {\n+            return true;\n+        }\n+\n+        return attemptProfiling(tracingContext, traceSegmentId, firstSpanOPName);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext stop profiling appoint trace\n+     * @return current profiler is already start profiling", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01bfafb695de56c7cc13d9d92db93dbb194d0c19"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDg5Mg==", "bodyText": "Same here", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368204892", "createdAt": "2020-01-18T04:18:01Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     *\n+     * @return current profiler is already start profiling", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01bfafb695de56c7cc13d9d92db93dbb194d0c19"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "committedDate": "2020-01-18T04:37:46Z", "message": "fix doc error, remove meaningless descriptions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTI2OTc5", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344926979", "createdAt": "2020-01-18T05:42:08Z", "commit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwNTo0MjowOFrOFfJpTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwNTo0MjowOFrOFfJpTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw==", "bodyText": "if Config.Profile.ACTIVE ==  false TracingThreadSnapshot should be ignored, right?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208207", "createdAt": "2020-01-18T05:42:08Z", "author": {"login": "arugal"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.network.language.profile.ThreadSnapshot;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<TracingThreadSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     */\n+    public void addProfilingSnapshot(TracingThreadSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTI5MTY0", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344929164", "createdAt": "2020-01-18T06:48:40Z", "commit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85f557c3790290d4a597e11eb84165b169cae032", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/85f557c3790290d4a597e11eb84165b169cae032", "committedDate": "2020-01-18T08:19:53Z", "message": "resolve missed profile receiver on oap starter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTMxNjEx", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344931611", "createdAt": "2020-01-18T08:02:03Z", "commit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwODowMjowNFrOFfJ-qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQwODoxNToyMFrOFfKBCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxMzY3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Re-check current trace need profiling, encase third part plugin change the operation name.\n          \n          \n            \n                 * Re-check current trace need profiling, in case that third-party plugins change the operation name.", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368213672", "createdAt": "2020-01-18T08:02:04Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,19 +90,46 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TracingContext} profiling\n+     */\n+    public boolean addProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // get current profiling task, check need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+\n+        return executionContext.attemptProfiling(tracingContext, traceSegmentId, firstSpanOPName);\n+    }\n+\n+    /**\n+     * Re-check current trace need profiling, encase third part plugin change the operation name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDA5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isProfilingProfilingContinuable() {\n          \n          \n            \n                private boolean isProfilingContinuable() {", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214095", "createdAt": "2020-01-18T08:12:33Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * matches profiling tracing context\n+     */\n+    public boolean matches(TracingContext context) {\n+        // match trace id\n+        return Objects.equal(context.getReadableGlobalTraceId(), tracingContext.getReadableGlobalTraceId());\n+    }\n+\n+    /**\n+     * check profiling is should continue\n+     *\n+     * @return if true means this thread profiling is continuable\n+     */\n+    private boolean isProfilingProfilingContinuable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDExMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * check profiling is should continue\n          \n          \n            \n                 * check whether profiling should continue", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214112", "createdAt": "2020-01-18T08:12:49Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * matches profiling tracing context\n+     */\n+    public boolean matches(TracingContext context) {\n+        // match trace id\n+        return Objects.equal(context.getReadableGlobalTraceId(), tracingContext.getReadableGlobalTraceId());\n+    }\n+\n+    /**\n+     * check profiling is should continue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg==", "bodyText": "Maybe take the case when element.getLineNumber() < 0 into consideration? Make it Unknown Source?", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214282", "createdAt": "2020-01-18T08:15:20Z", "author": {"login": "kezhenxu94"}, "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5eeed53b2126733b6a61db41a3e9920ef5117f", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/9c5eeed53b2126733b6a61db41a3e9920ef5117f", "committedDate": "2020-01-18T08:52:44Z", "message": "update comment\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "committedDate": "2020-01-18T08:57:42Z", "message": "update isProfilingContinuable method name\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "659d794b9ed25c916990f60802d500b4d163e54d", "author": {"user": {"login": "mrproliu", "name": null}}, "url": "https://github.com/apache/skywalking/commit/659d794b9ed25c916990f60802d500b4d163e54d", "committedDate": "2020-01-18T09:00:59Z", "message": "update comment\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d3dc9b7e90525f225b76b2ffc9caa057404efb7", "author": {"user": null}, "url": "https://github.com/apache/skywalking/commit/8d3dc9b7e90525f225b76b2ffc9caa057404efb7", "committedDate": "2020-01-18T09:08:53Z", "message": "resolve method invoke error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTM1MjYz", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344935263", "createdAt": "2020-01-18T09:36:38Z", "commit": {"oid": "8d3dc9b7e90525f225b76b2ffc9caa057404efb7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTM1Mzcx", "url": "https://github.com/apache/skywalking/pull/4220#pullrequestreview-344935371", "createdAt": "2020-01-18T09:39:36Z", "commit": {"oid": "8d3dc9b7e90525f225b76b2ffc9caa057404efb7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2562, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}