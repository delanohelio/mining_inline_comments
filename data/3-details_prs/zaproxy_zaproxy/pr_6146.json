{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NjExNjIx", "number": 6146, "title": "Add support for site modifiers", "bodyText": "Signed-off-by: Simon Bennetts psiinon@gmail.com", "createdAt": "2020-08-27T10:41:36Z", "url": "https://github.com/zaproxy/zaproxy/pull/6146", "merged": true, "mergeCommit": {"oid": "2227924809347ee3baf169bc657f80c5fd502335"}, "closed": true, "closedAt": "2020-09-15T13:32:36Z", "author": {"login": "psiinon"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdC-Z9QgBqjM2OTkxMDI5MjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJHqSsgFqTQ4ODY3MTc1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13205227f76f665801ad00129d0ad8e2035df687", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/13205227f76f665801ad00129d0ad8e2035df687", "committedDate": "2020-08-27T10:39:14Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "93960f15c1d7e2016bb68e94b50ec347accb8c33", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/93960f15c1d7e2016bb68e94b50ec347accb8c33", "committedDate": "2020-08-27T11:07:20Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93960f15c1d7e2016bb68e94b50ec347accb8c33", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/93960f15c1d7e2016bb68e94b50ec347accb8c33", "committedDate": "2020-08-27T11:07:20Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "77dbd016f196751c50148cd4f630301579ef9374", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/77dbd016f196751c50148cd4f630301579ef9374", "committedDate": "2020-08-27T11:55:53Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "77dbd016f196751c50148cd4f630301579ef9374", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/77dbd016f196751c50148cd4f630301579ef9374", "committedDate": "2020-08-27T11:55:53Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "c3c552d4322924a6f5270aada3262efd99837134", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/c3c552d4322924a6f5270aada3262efd99837134", "committedDate": "2020-08-27T15:36:00Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3c552d4322924a6f5270aada3262efd99837134", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/c3c552d4322924a6f5270aada3262efd99837134", "committedDate": "2020-08-27T15:36:00Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "89fb137b62dd2fb6b2e0ea8508d6b05b31248817", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/89fb137b62dd2fb6b2e0ea8508d6b05b31248817", "committedDate": "2020-08-27T16:01:28Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89fb137b62dd2fb6b2e0ea8508d6b05b31248817", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/89fb137b62dd2fb6b2e0ea8508d6b05b31248817", "committedDate": "2020-08-27T16:01:28Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "a86da660bf443e89fbce941e38aaef926c54801d", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/a86da660bf443e89fbce941e38aaef926c54801d", "committedDate": "2020-09-01T16:23:11Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a86da660bf443e89fbce941e38aaef926c54801d", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/a86da660bf443e89fbce941e38aaef926c54801d", "committedDate": "2020-09-01T16:23:11Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "720af16d68195f8065318c2e50a36771c6e7b9e6", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/720af16d68195f8065318c2e50a36771c6e7b9e6", "committedDate": "2020-09-02T09:03:30Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "720af16d68195f8065318c2e50a36771c6e7b9e6", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/720af16d68195f8065318c2e50a36771c6e7b9e6", "committedDate": "2020-09-02T09:03:30Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "f39a9f1df38ef6d8eab1be677a27cab9531faa4e", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/f39a9f1df38ef6d8eab1be677a27cab9531faa4e", "committedDate": "2020-09-02T09:38:11Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f39a9f1df38ef6d8eab1be677a27cab9531faa4e", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/f39a9f1df38ef6d8eab1be677a27cab9531faa4e", "committedDate": "2020-09-02T09:38:11Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "committedDate": "2020-09-02T12:53:05Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0ODQ0ODcx", "url": "https://github.com/zaproxy/zaproxy/pull/6146#pullrequestreview-484844871", "createdAt": "2020-09-09T09:50:36Z", "commit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "state": "COMMENTED", "comments": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwOTo1MDozN1rOHO_stg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzozNDoyMlrOHPHl9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4NTc1MA==", "bodyText": "UI \u2192 e.g. Sites map, not just about the UI. (Same comment for following UI usage and elsewhere.)", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485485750", "createdAt": "2020-09-09T09:50:37Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    private String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the UI.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4NTkyOQ==", "bodyText": "Needs to be changed to getLeafName. Worth adding tests to verify the scripts.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485485929", "createdAt": "2020-09-09T09:50:54Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Input Vector default template.js", "diffHunk": "@@ -72,3 +75,61 @@ function setParameter(helper, msg, param, value, escaped) {\n     //Set the parameters\n     msg.getRequestHeader().getURI().setEscapedQuery(query);\n }\n+\n+/**\n+ * Gets the parameters of the given {@code type} from the given {@code message}. Returning null\n+ * is taken to mean use the default methods for obtaining parameters.\n+ * The parameter names are shown in brackets after the site tree node names.\n+ *\n+ * The parameters are split using the key value pair separator(s) and each resulting\n+ * parameter is split into name/value pairs using key value separator(s).\n+ *\n+ * Parameters' names and values are in decoded form.\n+ *\n+ * @param msg the message whose parameters will be extracted from. This is an HttpMessage object.\n+ * @param type the type of parameters to extract. This is an HtmlParameter.Type enum which can be one of cookie, form, url, header, multipart\n+ * @param helper a helper class, currently unused\n+ * @return a {@code List} containing the parameters as DefaultNameValuePair objects\n+ * @throws IllegalArgumentException if the {@code msg} or {@code type} is {@code null}.\n+ */\n+function getParameters(msg, type, helper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MzkyOA==", "bodyText": "helper, msg", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485493928", "createdAt": "2020-09-09T10:04:32Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Input Vector default template.js", "diffHunk": "@@ -72,3 +75,61 @@ function setParameter(helper, msg, param, value, escaped) {\n     //Set the parameters\n     msg.getRequestHeader().getURI().setEscapedQuery(query);\n }\n+\n+/**\n+ * Gets the parameters of the given {@code type} from the given {@code message}. Returning null\n+ * is taken to mean use the default methods for obtaining parameters.\n+ * The parameter names are shown in brackets after the site tree node names.\n+ *\n+ * The parameters are split using the key value pair separator(s) and each resulting\n+ * parameter is split into name/value pairs using key value separator(s).\n+ *\n+ * Parameters' names and values are in decoded form.\n+ *\n+ * @param msg the message whose parameters will be extracted from. This is an HttpMessage object.\n+ * @param type the type of parameters to extract. This is an HtmlParameter.Type enum which can be one of cookie, form, url, header, multipart\n+ * @param helper a helper class, currently unused\n+ * @return a {@code List} containing the parameters as DefaultNameValuePair objects\n+ * @throws IllegalArgumentException if the {@code msg} or {@code type} is {@code null}.\n+ */\n+function getParameters(msg, type, helper) {\n+\tprint(\"get params \" + msg.getRequestHeader().getURI() + \" \" + type)\n+\tvar list = new ArrayList()\n+\tswitch (type.name()) {\n+\t\tcase 'url': \n+\t\t\tbreak\n+\t\tcase 'form': \n+\t\t\tbreak\n+\t\tdefault: \n+\t\t\tbreak\n+\t}\n+\tif (list.size() == 0) {\n+\t\treturn null\n+\t}\n+\treturn list\n+}\n+\n+/**\n+ * Returns the tree path elements for the given {@code message}. Returning null is taken to mean\n+ * use the default methods for obtaining tree path elements.\n+ * This will determine the position of this message in the sites tree.\n+ *\n+ * <p>By default the elements are returned for the following URL are:\n+ *\n+ * <ul>\n+ *   <li><i>http://example.org/path/to/element?aa=bb&cc==dd</i> : [\"path\", \"to\", \"element\"]\n+ *   <li><i>http://example.org/path/to/element</i> : [\"path\", \"to\", \"element\"]\n+ *   <li><i>http://example.org/path/to/</i> : [\"path\", \"to\"]\n+ *   <li><i>http://example.org/path/to</i> : [\"path\", \"to\"]\n+ * </ul>\n+ *\n+ * @param msg the message for which the tree path elements will be extracted from. This is an HttpMessage object.\n+ * @param helper a helper class, currently unused\n+ * @return a {@code List} containing the tree path elements\n+ */\n+function getTreePath(msg, helper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5Mzk5OQ==", "bodyText": "This is causing an error <eval>:129 ReferenceError: \"type\" is not defined.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485493999", "createdAt": "2020-09-09T10:04:38Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Site modifying JSON example.js", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+In addition to allowing you to specify exactly what can be attacked in a request,\n+input vector scripts now also allow you to change how requests are represented in the sites tree\n+This script decodes URL and post parameters that are represented by JSON\n+To demonstate this run the following curl commands from the command line with this script enabled:\n+\n+export http_proxy=http://localhost:8090/\n+curl http://www.example.com/page/?%5B%7B%22key%22:%22aa%22,%22value%22:%22bb%22%7D%5D\n+curl http://www.example.com/page/?%5B%7B%22key%22:%22aa%22,%22value%22:%22bb%22%7D,%7B%22key%22:%22cc%22,%22value%22:%22dd%22%7D%5D\n+curl -d '[{\"key\":\"aa\",\"value\":\"ee\"},{\"key\":\"cc\",\"value\":\"ff\"}]' -X POST http://www.example.com/page/\n+\n+It also changes the path of requests starting http://www.example.com/test/ so that every other path element after the initial 'test' is replaced by '<ddn>'\n+The built-in ZAP support for Data Driven Nodes (ie nodes where name is actually data rather than part of the application structure)\n+only supports one DDN per URL. This script shows that site modifier scripts can support an arbritrary number of them.\n+To demonstate this run the following curl commands from the command line with this script enabled:\n+\n+export http_proxy=http://localhost:8090/\n+curl http://www.example.com/test/aaa/test2/bbb/\n+curl http://www.example.com/test/ccc/test2/ddd/\n+curl http://www.example.com/test/ccc/test2/ddd/eee/fff/ggg/hhh\n+curl http://www.example.com/test/ccc/test2/eee/fff/ggg/hhh/iii\n+\n+Note that you should not actively scan www.example.com - use a site that you have permission to test instead.\n+*/\n+var ArrayList = Java.type('java.util.ArrayList')\n+var DefaultNameValuePair = Java.type('org.zaproxy.zap.model.DefaultNameValuePair')\n+\n+var target = 'http://www.example.com/'\n+\n+function parseParameters(helper, msg) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"parseParameters \" + uri + \" path=\" + uri.getPath())\n+\tif (!uri.toString().startsWith(target)) {\n+\t\tprint(\"  not target, ignoring\")\n+\t\treturn\n+\t}\n+\tvar q = uri.getEscapedQuery()\n+\tvar d = decodeURI(q)\n+\ttry {\n+\t\tvar json = JSON.parse(d)\n+\t\n+\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\tprint('  json[' + i + '] ' + json[i])\n+\t\t\tprint('  key in json ' + ('key' in json[i]))\n+\t\t\tif ('key' in json[i] && 'value' in json[i]) {\n+\t\t\t\tprint('  Adding ' + json[i]['key'] + '=' + json[i]['value'])\n+\t            helper.addParamQuery(json[i]['key'], json[i]['value']);\n+\t\t\t}\n+\t\t}\n+\t} catch (err) {\n+\t\t// Not JSON, not interested\n+\t\tprint('  URL params not JSON')\n+\t}\n+\tif (msg.getRequestHeader().getMethod() == \"POST\") {\n+\t\tvar body = decodeURI(msg.getRequestBody().toString())\n+\t\tprint(\"  body = \" + body)\n+\t\ttry {\n+\t\t\tjson = JSON.parse(body)\n+\t\t\tprint('  JSON length ' + json.length)\n+\t\t\n+\t\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\t\tprint('  json[' + i + '] ' + json[i])\n+\t\t\t\tprint('  key in json ' + ('key' in json[i]))\n+\t\t\t\tif ('key' in json[i] && 'value' in json[i]) {\n+\t\t\t\t\tprint('Adding ' + json[i]['key'] + '=' + json[i]['value'])\n+\t\t            helper.addParamPost(json[i]['key'], json[i]['value']);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (err) {\n+\t\t\t// Not JSON, not interested\n+\t\t\tprint('  Body not JSON')\n+\t\t}\n+\t}\n+}\n+\n+function setParameter(helper, msg, param, value, escaped) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"setParameter \" + uri + \" param=\" + param + \" value=\" + value)\n+\tif (!uri.toString().startsWith(target)) {\n+\t\tprint(\"uri    \" + uri.toString())\n+\t\tprint(\"target \" + target)\n+\t\tprint(\"  not target, ignoring\")\n+\t\treturn null;\n+\t}\n+    var cParam = helper.getCurrentParam();\n+\tif (cParam.getType() == 1) {\n+\t\t// Query param\n+\t\tvar q = uri.getEscapedQuery()\n+\t\tvar d = decodeURI(q)\n+\t\ttry {\n+\t\t\tvar json = JSON.parse(d)\n+\t\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\t\tif ('key' in json[i] && json[i]['key'] == param) {\n+\t\t\t\t\tjson[i]['value'] = value\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tprint('  setting query to ' + JSON.stringify(json))\n+\t\t\tmsg.getRequestHeader().getURI().setQuery(JSON.stringify(json))\t\t\t\n+\t\t} catch (err) {\n+\t\t\t// Not JSON, not interested\n+\t\t\tprint('  URL params not JSON, unexpectedly')\n+\t\t}\n+\n+\t} else if (cParam.getType() == 2) {\n+\t\t// Post param\n+\t\tvar body = decodeURI(msg.getRequestBody().toString())\n+\t\ttry {\n+\t\t\tvar json = JSON.parse(body)\n+\t\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\t\tif ('key' in json[i] && json[i]['key'] == param) {\n+\t\t\t\t\tjson[i]['value'] = value\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar body = JSON.stringify(json)\n+\t\t\tprint('  setting body to ' + body)\n+\t\t\tmsg.getRequestBody().setBody(body)\n+\t\t\tmsg.getRequestHeader().setContentLength(msg.getRequestBody().length)\t\t\t\n+\t\t} catch (err) {\n+\t\t\t// Not JSON, not interested\n+\t\t\tprint('  Body not JSON, unexpectedly')\n+\t\t}\n+\t}\n+}\n+\n+function getLeafName(helper, nodeName, msg) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"getLeafName \" + uri + \" type=\" + type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NDA0Ng==", "bodyText": "Causing an error as well (just debug anyway?).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485494046", "createdAt": "2020-09-09T10:04:42Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Site modifying JSON example.js", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+In addition to allowing you to specify exactly what can be attacked in a request,\n+input vector scripts now also allow you to change how requests are represented in the sites tree\n+This script decodes URL and post parameters that are represented by JSON\n+To demonstate this run the following curl commands from the command line with this script enabled:\n+\n+export http_proxy=http://localhost:8090/\n+curl http://www.example.com/page/?%5B%7B%22key%22:%22aa%22,%22value%22:%22bb%22%7D%5D\n+curl http://www.example.com/page/?%5B%7B%22key%22:%22aa%22,%22value%22:%22bb%22%7D,%7B%22key%22:%22cc%22,%22value%22:%22dd%22%7D%5D\n+curl -d '[{\"key\":\"aa\",\"value\":\"ee\"},{\"key\":\"cc\",\"value\":\"ff\"}]' -X POST http://www.example.com/page/\n+\n+It also changes the path of requests starting http://www.example.com/test/ so that every other path element after the initial 'test' is replaced by '<ddn>'\n+The built-in ZAP support for Data Driven Nodes (ie nodes where name is actually data rather than part of the application structure)\n+only supports one DDN per URL. This script shows that site modifier scripts can support an arbritrary number of them.\n+To demonstate this run the following curl commands from the command line with this script enabled:\n+\n+export http_proxy=http://localhost:8090/\n+curl http://www.example.com/test/aaa/test2/bbb/\n+curl http://www.example.com/test/ccc/test2/ddd/\n+curl http://www.example.com/test/ccc/test2/ddd/eee/fff/ggg/hhh\n+curl http://www.example.com/test/ccc/test2/eee/fff/ggg/hhh/iii\n+\n+Note that you should not actively scan www.example.com - use a site that you have permission to test instead.\n+*/\n+var ArrayList = Java.type('java.util.ArrayList')\n+var DefaultNameValuePair = Java.type('org.zaproxy.zap.model.DefaultNameValuePair')\n+\n+var target = 'http://www.example.com/'\n+\n+function parseParameters(helper, msg) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"parseParameters \" + uri + \" path=\" + uri.getPath())\n+\tif (!uri.toString().startsWith(target)) {\n+\t\tprint(\"  not target, ignoring\")\n+\t\treturn\n+\t}\n+\tvar q = uri.getEscapedQuery()\n+\tvar d = decodeURI(q)\n+\ttry {\n+\t\tvar json = JSON.parse(d)\n+\t\n+\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\tprint('  json[' + i + '] ' + json[i])\n+\t\t\tprint('  key in json ' + ('key' in json[i]))\n+\t\t\tif ('key' in json[i] && 'value' in json[i]) {\n+\t\t\t\tprint('  Adding ' + json[i]['key'] + '=' + json[i]['value'])\n+\t            helper.addParamQuery(json[i]['key'], json[i]['value']);\n+\t\t\t}\n+\t\t}\n+\t} catch (err) {\n+\t\t// Not JSON, not interested\n+\t\tprint('  URL params not JSON')\n+\t}\n+\tif (msg.getRequestHeader().getMethod() == \"POST\") {\n+\t\tvar body = decodeURI(msg.getRequestBody().toString())\n+\t\tprint(\"  body = \" + body)\n+\t\ttry {\n+\t\t\tjson = JSON.parse(body)\n+\t\t\tprint('  JSON length ' + json.length)\n+\t\t\n+\t\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\t\tprint('  json[' + i + '] ' + json[i])\n+\t\t\t\tprint('  key in json ' + ('key' in json[i]))\n+\t\t\t\tif ('key' in json[i] && 'value' in json[i]) {\n+\t\t\t\t\tprint('Adding ' + json[i]['key'] + '=' + json[i]['value'])\n+\t\t            helper.addParamPost(json[i]['key'], json[i]['value']);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (err) {\n+\t\t\t// Not JSON, not interested\n+\t\t\tprint('  Body not JSON')\n+\t\t}\n+\t}\n+}\n+\n+function setParameter(helper, msg, param, value, escaped) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"setParameter \" + uri + \" param=\" + param + \" value=\" + value)\n+\tif (!uri.toString().startsWith(target)) {\n+\t\tprint(\"uri    \" + uri.toString())\n+\t\tprint(\"target \" + target)\n+\t\tprint(\"  not target, ignoring\")\n+\t\treturn null;\n+\t}\n+    var cParam = helper.getCurrentParam();\n+\tif (cParam.getType() == 1) {\n+\t\t// Query param\n+\t\tvar q = uri.getEscapedQuery()\n+\t\tvar d = decodeURI(q)\n+\t\ttry {\n+\t\t\tvar json = JSON.parse(d)\n+\t\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\t\tif ('key' in json[i] && json[i]['key'] == param) {\n+\t\t\t\t\tjson[i]['value'] = value\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tprint('  setting query to ' + JSON.stringify(json))\n+\t\t\tmsg.getRequestHeader().getURI().setQuery(JSON.stringify(json))\t\t\t\n+\t\t} catch (err) {\n+\t\t\t// Not JSON, not interested\n+\t\t\tprint('  URL params not JSON, unexpectedly')\n+\t\t}\n+\n+\t} else if (cParam.getType() == 2) {\n+\t\t// Post param\n+\t\tvar body = decodeURI(msg.getRequestBody().toString())\n+\t\ttry {\n+\t\t\tvar json = JSON.parse(body)\n+\t\t\tfor (var i=0; i < json.length; i++) {\n+\t\t\t\tif ('key' in json[i] && json[i]['key'] == param) {\n+\t\t\t\t\tjson[i]['value'] = value\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tvar body = JSON.stringify(json)\n+\t\t\tprint('  setting body to ' + body)\n+\t\t\tmsg.getRequestBody().setBody(body)\n+\t\t\tmsg.getRequestHeader().setContentLength(msg.getRequestBody().length)\t\t\t\n+\t\t} catch (err) {\n+\t\t\t// Not JSON, not interested\n+\t\t\tprint('  Body not JSON, unexpectedly')\n+\t\t}\n+\t}\n+}\n+\n+function getLeafName(helper, nodeName, msg) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"getLeafName \" + uri + \" type=\" + type)\n+\tif (!uri.toString().startsWith(target)) {\n+\t\tprint(\"  not target, ignoring\")\n+\t\treturn null\n+\t}\n+\tparseParameters(helper, msg)\n+\treturn helper.getStandardLeafName(nodeName, msg, helper.getParamList())\n+}\n+\n+\n+function getTreePath(helper, msg) {\n+\tvar uri = msg.getRequestHeader().getURI()\n+\tprint(\"getTreePath \" + uri)\n+\t(new Java.type('java.util.ArrayList')).printStackTrace()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5Nzc0Mg==", "bodyText": "Dot at the end (same for following line).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485497742", "createdAt": "2020-09-09T10:10:49Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Site modifying JSON example.js", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+In addition to allowing you to specify exactly what can be attacked in a request,\n+input vector scripts now also allow you to change how requests are represented in the sites tree", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMDg2NQ==", "bodyText": "This could be replaced with the usage of JavaScript list, more idiomatic.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485510865", "createdAt": "2020-09-09T10:35:45Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Input Vector default template.js", "diffHunk": "@@ -8,6 +8,9 @@\n // in VariantCustom \n // https://github.com/zaproxy/zaproxy/blob/master/zap/src/main/java/org/parosproxy/paros/core/scanner/VariantCustom.java\n \n+var ArrayList = Java.type('java.util.ArrayList')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMTA5MQ==", "bodyText": "This could be removed, not actually used.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485511091", "createdAt": "2020-09-09T10:36:10Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Input Vector default template.js", "diffHunk": "@@ -8,6 +8,9 @@\n // in VariantCustom \n // https://github.com/zaproxy/zaproxy/blob/master/zap/src/main/java/org/parosproxy/paros/core/scanner/VariantCustom.java\n \n+var ArrayList = Java.type('java.util.ArrayList')\n+var DefaultNameValuePair = Java.type('org.zaproxy.zap.model.DefaultNameValuePair')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMTI2NQ==", "bodyText": "Same comments as in the above script.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485511265", "createdAt": "2020-09-09T10:36:34Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Site modifying JSON example.js", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+In addition to allowing you to specify exactly what can be attacked in a request,\n+input vector scripts now also allow you to change how requests are represented in the sites tree\n+This script decodes URL and post parameters that are represented by JSON\n+To demonstate this run the following curl commands from the command line with this script enabled:\n+\n+export http_proxy=http://localhost:8090/\n+curl http://www.example.com/page/?%5B%7B%22key%22:%22aa%22,%22value%22:%22bb%22%7D%5D\n+curl http://www.example.com/page/?%5B%7B%22key%22:%22aa%22,%22value%22:%22bb%22%7D,%7B%22key%22:%22cc%22,%22value%22:%22dd%22%7D%5D\n+curl -d '[{\"key\":\"aa\",\"value\":\"ee\"},{\"key\":\"cc\",\"value\":\"ff\"}]' -X POST http://www.example.com/page/\n+\n+It also changes the path of requests starting http://www.example.com/test/ so that every other path element after the initial 'test' is replaced by '<ddn>'\n+The built-in ZAP support for Data Driven Nodes (ie nodes where name is actually data rather than part of the application structure)\n+only supports one DDN per URL. This script shows that site modifier scripts can support an arbritrary number of them.\n+To demonstate this run the following curl commands from the command line with this script enabled:\n+\n+export http_proxy=http://localhost:8090/\n+curl http://www.example.com/test/aaa/test2/bbb/\n+curl http://www.example.com/test/ccc/test2/ddd/\n+curl http://www.example.com/test/ccc/test2/ddd/eee/fff/ggg/hhh\n+curl http://www.example.com/test/ccc/test2/eee/fff/ggg/hhh/iii\n+\n+Note that you should not actively scan www.example.com - use a site that you have permission to test instead.\n+*/\n+var ArrayList = Java.type('java.util.ArrayList')\n+var DefaultNameValuePair = Java.type('org.zaproxy.zap.model.DefaultNameValuePair')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDIyNw==", "bodyText": "This should be replaced with a call to the session, it's duplicating existing logic.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485584227", "createdAt": "2020-09-09T12:49:35Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantCustom.java", "diffHunk": "@@ -228,6 +231,35 @@ public String setEscapedParameter(\n         return setParameter(msg, originalPair, param, value, true);\n     }\n \n+    /**\n+     * The standard name given to nodes in the sites tree for the given parameters\n+     *\n+     * @param nodeName the name of the node, typically the last element of the path\n+     * @param msg the message\n+     * @param params the url and post parameters for the given message\n+     * @return the name to be used in the GUI\n+     */\n+    public String getStandardLeafName(\n+            String nodeName, HttpMessage msg, List<NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        String method = msg.getRequestHeader().getMethod();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(Session.getParamDisplayString(params, NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            String contentType = msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE);\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(Session.getParamDisplayString(params, NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NTY3OQ==", "bodyText": "Should this be in the Model(?) instead? Being in the Session (and as an instance variable) means that the factory is \"reset\" each time a new session is created, losing the hooked variants.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485585679", "createdAt": "2020-09-09T12:51:38Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -155,6 +161,8 @@\n \n     private ParameterParser defaultParamParser = new StandardParameterParser();\n \n+    private VariantFactory variantFactory = new VariantFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4Njk0OQ==", "bodyText": "This is not used anymore, remove?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485586949", "createdAt": "2020-09-09T12:53:32Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/NameValuePair.java", "diffHunk": "@@ -96,6 +99,23 @@ public int getType() {\n         return targetType;\n     }\n \n+    public boolean isType(HtmlParameter.Type hpType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzM1Ng==", "bodyText": "Needs to be removed.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485587356", "createdAt": "2020-09-09T12:54:11Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/network/HtmlParameter.java", "diffHunk": "@@ -118,7 +118,6 @@ public String getValue() {\n      * @throws IllegalArgumentException if the given parameter is {@code null}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzQ4NA==", "bodyText": "Still should decide which one is \"bigger\", shouldn't be both. Worth adding tests.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485587484", "createdAt": "2020-09-09T12:54:21Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/network/HtmlParameter.java", "diffHunk": "@@ -159,7 +158,12 @@ public int compareTo(HtmlParameter o) {\n         }\n         if (result == 0) {\n             // Same type and name\n-            result = this.value.compareTo(o.getValue());\n+            if (this.value != null && o.getValue() != null) {\n+                result = this.value.compareTo(o.getValue());\n+            } else if (this.value != null || o.getValue() != null) {\n+                // They can't both be null due to previous test\n+                return 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzkyNA==", "bodyText": "Still should decide which one is \"smaller\". Worth adding tests.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485587924", "createdAt": "2020-09-09T12:55:00Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/NameValuePair.java", "diffHunk": "@@ -186,4 +206,36 @@ public String toString() {\n         strBuilder.append(']');\n         return strBuilder.toString();\n     }\n+\n+    @Override\n+    public int compareTo(NameValuePair nvp) {\n+        if (nvp == null) {\n+            return -1;\n+        }\n+        if (nvp.targetType != targetType) {\n+            return nvp.targetType - targetType;\n+        }\n+        if (nvp.position != position) {\n+            return nvp.position - position;\n+        }\n+        int cmp;\n+        if (nvp.name != null && name != null) {\n+            cmp = nvp.name.compareTo(name);\n+            if (cmp != 0) {\n+                return cmp;\n+            }\n+        } else if (nvp.name == null || name == null) {\n+            // They can't both be null due to previous test\n+            return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4ODA5Nw==", "bodyText": "Should not need the abstract modifier.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485588097", "createdAt": "2020-09-09T12:55:14Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/Variant.java", "diffHunk": "@@ -23,12 +23,14 @@\n // ZAP: 2016/05/04 Add JavaDoc to getParamList()\n // ZAP: 2019/06/01 Normalise line endings.\n // ZAP: 2019/06/05 Normalise format/style.\n+// ZAP: 2020/08/27 Added default methods for modifying the Sites tree\n package org.parosproxy.paros.core.scanner;\n \n import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n import org.parosproxy.paros.network.HttpMessage;\n \n-public interface Variant {\n+public abstract interface Variant {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDU2OA==", "bodyText": "This could be moved to a ZAP package, most (if not all) the code is new (compared to original Paros code). The embed ZAP comments could also be removed.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590568", "createdAt": "2020-09-09T12:59:03Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDc1OQ==", "bodyText": "These are not actually being used for scanning, was that on purpose? That needs to be documented (and tested) if it was.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590759", "createdAt": "2020-09-09T12:59:20Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDgwMA==", "bodyText": "createVariants to be clear that's creating new instances.\nAbstractAppParamPlugin \u2192 HttpMessage, to remove the middle man.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590800", "createdAt": "2020-09-09T12:59:25Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDk3MQ==", "bodyText": "This could be removed (ZAP shouldn't care about RFC limitations, servers should and why ZAP should test anyway).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590971", "createdAt": "2020-09-09T12:59:41Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTA3MQ==", "bodyText": "This could be added as a custom variant by the ExtensionScript (assuming that the custom variants are going to be used for scanning).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591071", "createdAt": "2020-09-09T12:59:50Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = null;\n+\n+        if (getExtension() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTI5MA==", "bodyText": "UndeclaredThrowableException should be caught separately to check if the cause is of NoSuchMethodException for the method being called, not all script engines respect the default methods (might not be even aware of them) which would cause the script to be disabled (even if correct).\nWorth adding tests to verify the behaviour.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591290", "createdAt": "2020-09-09T13:00:07Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = null;\n+\n+        if (getExtension() != null) {\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        VariantScript vs = getExtension().getInterface(script, VariantScript.class);\n+                        name =\n+                                vs.getLeafName(\n+                                        new VariantCustom(script, getExtension()), nodeName, msg);\n+                        if (name != null) {\n+                            return name;\n+                        }\n+                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTMyNg==", "bodyText": "Same here regarding the handling of UndeclaredThrowableException.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591326", "createdAt": "2020-09-09T13:00:10Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = null;\n+\n+        if (getExtension() != null) {\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        VariantScript vs = getExtension().getInterface(script, VariantScript.class);\n+                        name =\n+                                vs.getLeafName(\n+                                        new VariantCustom(script, getExtension()), nodeName, msg);\n+                        if (name != null) {\n+                            return name;\n+                        }\n+                    } catch (Exception e) {\n+                        getExtension().handleScriptException(script, e);\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (Variant variant : this.customVariants) {\n+            name = variant.getLeafName(nodeName, msg);\n+            if (name != null) {\n+                return name;\n+            }\n+        }\n+        // Note that none of the built-in variants implement this method.\n+        // If any are changed to do so in the future then then need to be called here.\n+\n+        return null;\n+    }\n+\n+    public List<String> getTreePath(HttpMessage msg) throws URIException {\n+        List<String> list = null;\n+\n+        if (getExtension() != null) {\n+            // List the scripts and create as many custom variants as the scripts\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        VariantScript vs = getExtension().getInterface(script, VariantScript.class);\n+                        list = vs.getTreePath(new VariantCustom(script, getExtension()), msg);\n+                        if (list != null) {\n+                            return list;\n+                        }\n+                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTgxMw==", "bodyText": "to the {@code Session}'s ...?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591813", "createdAt": "2020-09-09T13:00:54Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/extension/ExtensionHook.java", "diffHunk": "@@ -506,4 +518,40 @@ public void addHttpSenderListener(HttpSenderListener httpSenderListener) {\n         }\n         return Collections.unmodifiableList(httpSenderListeners);\n     }\n+\n+    /**\n+     * Adds the given {@code variant} to the extension hook, to be later added to the {@link\n+     * org.parosproxy.paros.model.Session Session}.\n+     *\n+     * <p>By default, the {@code Variant}s added to this extension hook are removed from the {@code\n+     * Session} when the extension is unloaded.\n+     *\n+     * @param variant the Variant that will be added to the {@code VariantFactory}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjAxNg==", "bodyText": "Can be removed.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485592016", "createdAt": "2020-09-09T13:01:13Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/extension/ExtensionLoader.java", "diffHunk": "@@ -1514,6 +1531,18 @@ public void removeExtension(Extension extension) {\n             }\n         }\n \n+        for (Variant variant : hook.getVariants()) {\n+            try {\n+                model.getSession().getVariantFactory().removeVariant(variant);\n+                ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NzYxOA==", "bodyText": "IMO the factory should be responsible just for the creation of the variants, the getLeafName/getTreePath should be called by interested parties on the created variants (e.g. one can ask just for the custom variants).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485597618", "createdAt": "2020-09-09T13:09:26Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDU1Mg==", "bodyText": "Could the nulls be replaced with empty string and empty list, those are already invalid, right? (If not we should have tests showing the expected behaviour.)", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485600552", "createdAt": "2020-09-09T13:13:49Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/Variant.java", "diffHunk": "@@ -44,4 +46,39 @@ public String setParameter(\n \n     public String setEscapedParameter(\n             HttpMessage msg, NameValuePair originalPair, String param, String value);\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the UI. Returning null is\n+     * taken to mean use the default name. This is currently the last element of the path (given in\n+     * {@code nodeName}) followed by the url parameter names in brackets (if any) followed by the\n+     * form parameter names in brackets (if any).\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     */\n+    default String getLeafName(String nodeName, HttpMessage msg) {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the tree path elements for the given {@code message}. Returning null is taken to mean\n+     * use the default methods for obtaining tree path elements. This will determine the position of\n+     * this message in the sites tree.\n+     *\n+     * <p>By default the elements are returned for the following URL are:\n+     *\n+     * <ul>\n+     *   <li><i>http://example.org/path/to/element?aa=bb&cc==dd</i> : [\"path\", \"to\", \"element\"]\n+     *   <li><i>http://example.org/path/to/element</i> : [\"path\", \"to\", \"element\"]\n+     *   <li><i>http://example.org/path/to/</i> : [\"path\", \"to\"]\n+     *   <li><i>http://example.org/path/to</i> : [\"path\", \"to\"]\n+     * </ul>\n+     *\n+     * @param msg\n+     * @return a {@code List} containing the tree path elements\n+     * @throws URIException\n+     */\n+    default List<String> getTreePath(HttpMessage msg) throws URIException {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDkzMA==", "bodyText": "This should be private.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485600930", "createdAt": "2020-09-09T13:14:24Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    private String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the UI.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     * @return the name of the node to be used in the UI\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = variantFactory.getLeafName(nodeName, msg);\n+        if (name != null) {\n+            return name;\n+        }\n+\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                convertNVP(\n+                        model.getSession().getParameters(msg, Type.url),\n+                        org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING);\n+        if (msg.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            params.addAll(\n+                    convertNVP(\n+                            model.getSession().getParameters(msg, Type.form),\n+                            org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+        }\n+\n+        return getLeafName(\n+                nodeName,\n+                msg.getRequestHeader().getMethod(),\n+                msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE),\n+                params);\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given parameters in the UI.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param uri\n+     * @param method\n+     * @param postData\n+     * @return the name of the node to be used in the UI\n+     * @throws HttpMalformedHeaderException\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, URI uri, String method, String postData)\n+            throws HttpMalformedHeaderException {\n+        HttpMessage msg = new HttpMessage(uri);\n+        msg.getRequestHeader().setMethod(method);\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            msg.getRequestBody().setBody(postData);\n+            msg.getRequestHeader().setContentLength(msg.getRequestBody().length());\n+        }\n+        return getLeafName(nodeName, msg);\n+    }\n+\n+    private List<org.parosproxy.paros.core.scanner.NameValuePair> convertNVP(\n+            List<NameValuePair> nvpList, int type) {\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                new ArrayList<org.parosproxy.paros.core.scanner.NameValuePair>();\n+        for (NameValuePair nvp : nvpList) {\n+            params.add(\n+                    new org.parosproxy.paros.core.scanner.NameValuePair(\n+                            type, nvp.getName(), nvp.getValue(), -1));\n+        }\n+        return params;\n+    }\n+\n+    /**\n+     * Returns the names of the parameters in a form suitable to display in the UI\n+     *\n+     * @param list the full set of parameters\n+     * @param type the type of parameters to be included\n+     * @return the names of the given parameters\n+     * @since TODO add version\n+     */\n+    public static String getParamDisplayString(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMTU2NQ==", "bodyText": "Revert.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485601565", "createdAt": "2020-09-09T13:15:22Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1706,10 +1847,13 @@ public ParameterParser getFormParamParser(String url) {\n     }\n \n     public List<String> getTreePath(HttpMessage msg) throws URIException {\n+        List<String> params = variantFactory.getTreePath(msg);\n+        if (params != null) {\n+            return params;\n+        }\n         URI uri = msg.getRequestHeader().getURI();\n         return this.getUrlParamParser(uri.toString()).getTreePath(msg);\n     }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNDU5MQ==", "bodyText": "shown \u2192 represented?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485604591", "createdAt": "2020-09-09T13:19:47Z", "author": {"login": "thc202"}, "path": "zap/src/main/resources/org/zaproxy/zap/resources/Messages.properties", "diffHunk": "@@ -639,9 +639,9 @@ variant.options.rpc.dwr.label       = Direct Web Remoting\n \n variant.options.rpc.custom.label    = Enable Script Input Vectors\n variant.scripts.interface.variant.error = The provided Script Input Vector script ({0}) does not implement the required interface.\\nPlease refer to the provided templates for examples.\n-variant.scripts.type.variant        = Script Input Vector\n-variant.scripts.type.variant.desc   = Input Vector scripts run when you run the Active Scanner.\\n\\n\\\n-You must enable them before they will be used.\n+variant.scripts.type.variant        = Input Vector\n+variant.scripts.type.variant.desc   = Input Vector scripts run when you run the Active Scanner. They can also modify how nodes are shown in the Sites tree\\n\\n\\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNDY5NQ==", "bodyText": "There's a typo in variants.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485604695", "createdAt": "2020-09-09T13:19:55Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/parosproxy/paros/core/scanner/VariantFactoryUnitTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.extension.ExtensionLoader;\n+import org.parosproxy.paros.model.Model;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.ZapXmlConfiguration;\n+\n+public class VariantFactoryUnitTest {\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultVarients() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNjY1Mw==", "bodyText": "This could be moved to the when, that's part of the behaviour being tested.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485606653", "createdAt": "2020-09-09T13:22:45Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/parosproxy/paros/core/scanner/VariantFactoryUnitTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.extension.ExtensionLoader;\n+import org.parosproxy.paros.model.Model;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.ZapXmlConfiguration;\n+\n+public class VariantFactoryUnitTest {\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultVarients() {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = new ScannerParam();\n+        AbstractAppParamPlugin mockedPlugin =\n+                Mockito.mock(AbstractAppParamPlugin.class, withSettings().lenient());\n+        HttpMessage message = new HttpMessage();\n+        Mockito.when(mockedPlugin.getBaseMsg()).thenReturn(message);\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+\n+        // When\n+        List<Variant> variants = factory.getAllVariants(scanOptions, mockedPlugin);\n+        // Then\n+        assertThat(variants.size(), is(equalTo(10)));\n+        assertThat(variants.get(0).getClass(), is(equalTo(VariantURLQuery.class)));\n+        assertThat(variants.get(1).getClass(), is(equalTo(VariantODataIdQuery.class)));\n+        assertThat(variants.get(2).getClass(), is(equalTo(VariantODataFilterQuery.class)));\n+        assertThat(variants.get(3).getClass(), is(equalTo(VariantDdnPath.class)));\n+        assertThat(variants.get(4).getClass(), is(equalTo(VariantFormQuery.class)));\n+        assertThat(variants.get(5).getClass(), is(equalTo(VariantMultipartFormParameters.class)));\n+        assertThat(variants.get(6).getClass(), is(equalTo(VariantXMLQuery.class)));\n+        assertThat(variants.get(7).getClass(), is(equalTo(VariantJSONQuery.class)));\n+        assertThat(variants.get(8).getClass(), is(equalTo(VariantGWTQuery.class)));\n+        assertThat(variants.get(9).getClass(), is(equalTo(VariantDirectWebRemotingQuery.class)));\n+    }\n+\n+    @Test\n+    public void shouldReturnNoVarientsWhenUnset() {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = Mockito.mock(ScannerParam.class, withSettings().lenient());\n+        Mockito.when(scanOptions.getConfig()).thenReturn(new ZapXmlConfiguration());\n+        AbstractAppParamPlugin mockedPlugin =\n+                Mockito.mock(AbstractAppParamPlugin.class, withSettings().lenient());\n+        HttpMessage message = new HttpMessage();\n+        Mockito.when(mockedPlugin.getBaseMsg()).thenReturn(message);\n+\n+        scanOptions.setTargetParamsInjectable(0);\n+\n+        // When\n+        List<Variant> variants = factory.getAllVariants(scanOptions, mockedPlugin);\n+\n+        // Then\n+        assertThat(variants.size(), is(equalTo(0)));\n+    }\n+\n+    @Test\n+    public void shouldReturnAllVarientsWhenSet() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = Mockito.mock(ScannerParam.class, withSettings().lenient());\n+        Mockito.when(scanOptions.getConfig()).thenReturn(new ZapXmlConfiguration());\n+        Mockito.when(scanOptions.getTargetParamsInjectable()).thenReturn(-1);\n+        Mockito.when(scanOptions.getTargetParamsEnabledRPC()).thenReturn(-1);\n+        AbstractAppParamPlugin mockedPlugin =\n+                Mockito.mock(AbstractAppParamPlugin.class, withSettings().lenient());\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        Mockito.when(mockedPlugin.getBaseMsg()).thenReturn(message);\n+\n+        // When\n+        List<Variant> variants = factory.getAllVariants(scanOptions, mockedPlugin);\n+\n+        // Then\n+        assertThat(variants.size(), is(equalTo(13)));\n+        assertThat(variants.get(0).getClass(), is(equalTo(VariantURLQuery.class)));\n+        assertThat(variants.get(1).getClass(), is(equalTo(VariantODataIdQuery.class)));\n+        assertThat(variants.get(2).getClass(), is(equalTo(VariantODataFilterQuery.class)));\n+        assertThat(variants.get(3).getClass(), is(equalTo(VariantFormQuery.class)));\n+        assertThat(variants.get(4).getClass(), is(equalTo(VariantMultipartFormParameters.class)));\n+        assertThat(variants.get(5).getClass(), is(equalTo(VariantXMLQuery.class)));\n+        assertThat(variants.get(6).getClass(), is(equalTo(VariantJSONQuery.class)));\n+        assertThat(variants.get(7).getClass(), is(equalTo(VariantGWTQuery.class)));\n+        assertThat(variants.get(8).getClass(), is(equalTo(VariantDirectWebRemotingQuery.class)));\n+        assertThat(variants.get(9).getClass(), is(equalTo(VariantHeader.class)));\n+        assertThat(variants.get(10).getClass(), is(equalTo(VariantURLPath.class)));\n+        assertThat(variants.get(11).getClass(), is(equalTo(VariantCookie.class)));\n+        assertThat(variants.get(12).getClass(), is(equalTo(VariantUserDefined.class)));\n+    }\n+\n+    @Test\n+    public void shouldReturnNullLeafNameByDefault() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+\n+        // When\n+        String leafName = factory.getLeafName(\"path\", message);\n+\n+        // Then\n+        assertThat(leafName, is(equalTo(null)));\n+    }\n+\n+    @Test\n+    public void shouldReturnLeafNameWhenSet() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        String expectedLeafName = \"Test\";\n+        Variant variant =\n+                new Variant() {\n+\n+                    @Override\n+                    public String getLeafName(String nodeName, HttpMessage msg) {\n+                        return expectedLeafName;\n+                    }\n+\n+                    @Override\n+                    public void setMessage(HttpMessage msg) {}\n+\n+                    @Override\n+                    public List<NameValuePair> getParamList() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setEscapedParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+                };\n+        factory.addVariant(variant);\n+\n+        // When\n+        String actualLeafName = factory.getLeafName(\"path\", message);\n+\n+        // Then\n+        assertThat(actualLeafName, is(equalTo(expectedLeafName)));\n+    }\n+\n+    @Test\n+    public void shouldReturnNullTreePathByDefault() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+\n+        // When\n+        List<String> treePath = factory.getTreePath(message);\n+\n+        // Then\n+        assertThat(treePath, is(equalTo(null)));\n+    }\n+\n+    @Test\n+    public void shouldReturnTreePathWhenSet() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        List<String> expectedTreePath = new ArrayList<>();\n+        expectedTreePath.add(\"Path1\");\n+        expectedTreePath.add(\"Path2\");\n+        Variant variant =\n+                new Variant() {\n+\n+                    @Override\n+                    public List<String> getTreePath(HttpMessage msg) {\n+                        return expectedTreePath;\n+                    }\n+\n+                    @Override\n+                    public void setMessage(HttpMessage msg) {}\n+\n+                    @Override\n+                    public List<NameValuePair> getParamList() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setEscapedParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+                };\n+        factory.addVariant(variant);\n+\n+        // When\n+        List<String> actualTreePath = factory.getTreePath(message);\n+\n+        // Then\n+        assertThat(actualTreePath.size(), is(equalTo(expectedTreePath.size())));\n+        for (int i = 0; i < actualTreePath.size(); i++) {\n+            assertThat(actualTreePath.get(i), is(equalTo(expectedTreePath.get(i))));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReturnNullTreePathWhenVariantRemoved() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        List<String> expectedTreePath = new ArrayList<>();\n+        expectedTreePath.add(\"Path1\");\n+        expectedTreePath.add(\"Path2\");\n+        Variant variant =\n+                new Variant() {\n+\n+                    @Override\n+                    public List<String> getTreePath(HttpMessage msg) {\n+                        return expectedTreePath;\n+                    }\n+\n+                    @Override\n+                    public void setMessage(HttpMessage msg) {}\n+\n+                    @Override\n+                    public List<NameValuePair> getParamList() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setEscapedParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+                };\n+        factory.addVariant(variant);\n+        factory.removeVariant(variant);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNzgyMA==", "bodyText": "And", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485607820", "createdAt": "2020-09-09T13:24:20Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/parosproxy/paros/model/SessionUnitTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.model;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.NameValuePair;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.network.HttpHeader;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.I18N;\n+\n+public class SessionUnitTest {\n+\n+    private Session session;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;\n+        Control.initSingletonForTesting(Model.getSingleton());\n+\n+        session = new Session(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnGetLeafNameWithOneParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path?a=b\", true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"GET\", null);\n+        // Then\n+        assertThat(leafName, is(equalTo(\"GET:path(a)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnGetLeafNameWithTwoParams() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path?c=d&a=b\", true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"GET\", null);\n+        // Then\n+        assertThat(leafName, is(equalTo(\"GET:path(c,a)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnGetLeafNameWithTruncatedParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri =\n+                new URI(\n+                        \"https://www.example.com/path?averylongvariablenamewhichshouldbetruncated=b\",\n+                        true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"GET\", null);\n+        // Then\n+        assertThat(leafName, is(equalTo(\"GET:path(averylongvariablenamewhichshouldbetrunca)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnPostLeafNameWithOnePostParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path\", true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"POST\", \"a=b\");\n+        // Then\n+        assertThat(leafName, is(equalTo(\"POST:path(a)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnPostLeafNameWithTruncatedParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path\", true);\n+        // When\n+        String leafName =\n+                session.getLeafName(\n+                        nodeName, uri, \"POST\", \"averylongvariablenamewhichshouldbetruncated=b\");\n+        // Then\n+        assertThat(leafName, is(equalTo(\"POST:path(averylongvariablenamewhichshouldbetrunca)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnPostLeafNameWithOnePostandOneUrlParam() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNTA5Mw==", "bodyText": "This does not seem to be needed?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485615093", "createdAt": "2020-09-09T13:34:22Z", "author": {"login": "thc202"}, "path": "zap/zap.gradle.kts", "diffHunk": "@@ -142,7 +142,12 @@ val japicmp by tasks.registering(JapicmpTask::class) {\n     )\n \n     methodExcludes = listOf(\n-        \"org.parosproxy.paros.network.HttpMessage#getParamNameSet(org.parosproxy.paros.network.HtmlParameter\\$Type,java.lang.String)\"\n+        \"org.parosproxy.paros.network.HttpMessage#getLeafName(java.lang.String,org.parosproxy.paros.network.HttpMessage)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "committedDate": "2020-09-02T12:53:05Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "294990246282d2956a4856240fb949bd884f37d9", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/294990246282d2956a4856240fb949bd884f37d9", "committedDate": "2020-09-10T08:14:22Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "294990246282d2956a4856240fb949bd884f37d9", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/294990246282d2956a4856240fb949bd884f37d9", "committedDate": "2020-09-10T08:14:22Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "1c0a5c438b2baf8ae1d95f5f05f05b3e79b05fec", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/1c0a5c438b2baf8ae1d95f5f05f05b3e79b05fec", "committedDate": "2020-09-10T10:03:51Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c0a5c438b2baf8ae1d95f5f05f05b3e79b05fec", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/1c0a5c438b2baf8ae1d95f5f05f05b3e79b05fec", "committedDate": "2020-09-10T10:03:51Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "44d00e177b0f9b6b2b07741b3fc42a59fe8d1787", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/44d00e177b0f9b6b2b07741b3fc42a59fe8d1787", "committedDate": "2020-09-10T10:29:04Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44d00e177b0f9b6b2b07741b3fc42a59fe8d1787", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/44d00e177b0f9b6b2b07741b3fc42a59fe8d1787", "committedDate": "2020-09-10T10:29:04Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/c1e36444570d5ca9522d424798fcf5bd911ea1cf", "committedDate": "2020-09-10T13:44:07Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/c1e36444570d5ca9522d424798fcf5bd911ea1cf", "committedDate": "2020-09-10T13:44:07Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "committedDate": "2020-09-10T14:07:49Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1OTY4OTU1", "url": "https://github.com/zaproxy/zaproxy/pull/6146#pullrequestreview-485968955", "createdAt": "2020-09-10T14:02:34Z", "commit": {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDowMjozNFrOHP1m7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNDoyNjo0N1rOHP2wqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM2OTAwNg==", "bodyText": "If done with a ternary then no intermediate declare/storage is necessary. Not a huge difference, but simpler and shorter...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String result = \"\";\n          \n          \n            \n                    if (sb.length() > 0) {\n          \n          \n            \n                        result = sb.insert(0, '(').append(')').toString();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return result;\n          \n          \n            \n                    return sb.length() > 0 ? sb.insert(0, '(').append(')').toString() : \"\";", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486369006", "createdAt": "2020-09-10T14:02:34Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    public String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     * @return the name of the node to be used in the Site Map\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = variantFactory.getLeafName(nodeName, msg);\n+        if (name != null) {\n+            return name;\n+        }\n+\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                convertNVP(\n+                        model.getSession().getParameters(msg, Type.url),\n+                        org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING);\n+        if (msg.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            params.addAll(\n+                    convertNVP(\n+                            model.getSession().getParameters(msg, Type.form),\n+                            org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+        }\n+\n+        return getLeafName(\n+                nodeName,\n+                msg.getRequestHeader().getMethod(),\n+                msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE),\n+                params);\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given parameters in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param uri\n+     * @param method\n+     * @param postData\n+     * @return the name of the node to be used in the Site Map\n+     * @throws HttpMalformedHeaderException\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, URI uri, String method, String postData)\n+            throws HttpMalformedHeaderException {\n+        HttpMessage msg = new HttpMessage(uri);\n+        msg.getRequestHeader().setMethod(method);\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            msg.getRequestBody().setBody(postData);\n+            msg.getRequestHeader().setContentLength(msg.getRequestBody().length());\n+        }\n+        return getLeafName(nodeName, msg);\n+    }\n+\n+    private List<org.parosproxy.paros.core.scanner.NameValuePair> convertNVP(\n+            List<NameValuePair> nvpList, int type) {\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                new ArrayList<org.parosproxy.paros.core.scanner.NameValuePair>();\n+        for (NameValuePair nvp : nvpList) {\n+            params.add(\n+                    new org.parosproxy.paros.core.scanner.NameValuePair(\n+                            type, nvp.getName(), nvp.getValue(), -1));\n+        }\n+        return params;\n+    }\n+\n+    /**\n+     * Returns the names of the parameters in a form suitable to display in the Site Map\n+     *\n+     * @param list the full set of parameters\n+     * @param type the type of parameters to be included\n+     * @return the names of the given parameters\n+     * @since TODO add version\n+     */\n+    private static String getParamDisplayString(\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> list, int type) {\n+        StringBuilder sb = new StringBuilder();\n+        list.stream()\n+                .sorted()\n+                .filter(entry -> entry.getType() == type)\n+                .forEach(\n+                        entry -> {\n+                            String name = entry.getName();\n+                            if (name != null) {\n+                                if (sb.length() > 0) {\n+                                    sb.append(',');\n+                                }\n+                                if (name.length() > 40) {\n+                                    // Truncate\n+                                    name = name.substring(0, 40);\n+                                }\n+                                sb.append(name);\n+                            }\n+                        });\n+        String result = \"\";\n+        if (sb.length() > 0) {\n+            result = sb.insert(0, '(').append(')').toString();\n+        }\n+\n+        return result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM2OTc0Ng==", "bodyText": "I think we have a utility function for doing this that also inserts an ellipsis ... so that it's more obvious that it was intentionally truncated?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486369746", "createdAt": "2020-09-10T14:03:37Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    public String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     * @return the name of the node to be used in the Site Map\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = variantFactory.getLeafName(nodeName, msg);\n+        if (name != null) {\n+            return name;\n+        }\n+\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                convertNVP(\n+                        model.getSession().getParameters(msg, Type.url),\n+                        org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING);\n+        if (msg.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            params.addAll(\n+                    convertNVP(\n+                            model.getSession().getParameters(msg, Type.form),\n+                            org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+        }\n+\n+        return getLeafName(\n+                nodeName,\n+                msg.getRequestHeader().getMethod(),\n+                msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE),\n+                params);\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given parameters in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param uri\n+     * @param method\n+     * @param postData\n+     * @return the name of the node to be used in the Site Map\n+     * @throws HttpMalformedHeaderException\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, URI uri, String method, String postData)\n+            throws HttpMalformedHeaderException {\n+        HttpMessage msg = new HttpMessage(uri);\n+        msg.getRequestHeader().setMethod(method);\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            msg.getRequestBody().setBody(postData);\n+            msg.getRequestHeader().setContentLength(msg.getRequestBody().length());\n+        }\n+        return getLeafName(nodeName, msg);\n+    }\n+\n+    private List<org.parosproxy.paros.core.scanner.NameValuePair> convertNVP(\n+            List<NameValuePair> nvpList, int type) {\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                new ArrayList<org.parosproxy.paros.core.scanner.NameValuePair>();\n+        for (NameValuePair nvp : nvpList) {\n+            params.add(\n+                    new org.parosproxy.paros.core.scanner.NameValuePair(\n+                            type, nvp.getName(), nvp.getValue(), -1));\n+        }\n+        return params;\n+    }\n+\n+    /**\n+     * Returns the names of the parameters in a form suitable to display in the Site Map\n+     *\n+     * @param list the full set of parameters\n+     * @param type the type of parameters to be included\n+     * @return the names of the given parameters\n+     * @since TODO add version\n+     */\n+    private static String getParamDisplayString(\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> list, int type) {\n+        StringBuilder sb = new StringBuilder();\n+        list.stream()\n+                .sorted()\n+                .filter(entry -> entry.getType() == type)\n+                .forEach(\n+                        entry -> {\n+                            String name = entry.getName();\n+                            if (name != null) {\n+                                if (sb.length() > 0) {\n+                                    sb.append(',');\n+                                }\n+                                if (name.length() > 40) {\n+                                    // Truncate\n+                                    name = name.substring(0, 40);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3MTAwOQ==", "bodyText": "Should this be at the bottom of the block? (Just for consistency I guess)", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486371009", "createdAt": "2020-09-10T14:05:09Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/zaproxy/zap/model/SessionStructure.java", "diffHunk": "@@ -82,6 +82,36 @@ public static StructuralNode addPath(\n         }\n     }\n \n+    /**\n+     * @since TODO add version", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4Nzg4Mg==", "bodyText": "?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486387882", "createdAt": "2020-09-10T14:26:47Z", "author": {"login": "kingthorin"}, "path": "zap/src/test/java/org/parosproxy/paros/core/scanner/NameValuePairUnitTest.java", "diffHunk": "@@ -133,7 +133,6 @@ public void shouldBeEqualToDifferentNameValuePairWithSameContents() {\n \n     @Test\n     public void shouldBeEqualToDifferentNameValuePairWithNullNames() {\n-        // Given", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e20bcda39ff5adc1bddb6ca7445f18c43ef618"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "committedDate": "2020-09-10T14:07:49Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "cbaf8783e0802c821e45635fb8af1ca3bac385d6", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/cbaf8783e0802c821e45635fb8af1ca3bac385d6", "committedDate": "2020-09-10T15:27:51Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbaf8783e0802c821e45635fb8af1ca3bac385d6", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/cbaf8783e0802c821e45635fb8af1ca3bac385d6", "committedDate": "2020-09-10T15:27:51Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "ffe589f1a63948a0507267bdff995d7a2ba61fea", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/ffe589f1a63948a0507267bdff995d7a2ba61fea", "committedDate": "2020-09-10T16:12:17Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffe589f1a63948a0507267bdff995d7a2ba61fea", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/ffe589f1a63948a0507267bdff995d7a2ba61fea", "committedDate": "2020-09-10T16:12:17Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "committedDate": "2020-09-10T16:15:25Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MTM2ODA0", "url": "https://github.com/zaproxy/zaproxy/pull/6146#pullrequestreview-486136804", "createdAt": "2020-09-10T17:01:42Z", "commit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NzQwOTgw", "url": "https://github.com/zaproxy/zaproxy/pull/6146#pullrequestreview-487740980", "createdAt": "2020-09-14T13:15:40Z", "commit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoxNTo0MFrOHRTOhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzozNjoxN1rOHRUQ2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg1NQ==", "bodyText": "Return could be documented (for consistency with the following function).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487902855", "createdAt": "2020-09-14T13:15:40Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Input Vector default template.js", "diffHunk": "@@ -72,3 +71,42 @@ function setParameter(helper, msg, param, value, escaped) {\n     //Set the parameters\n     msg.getRequestHeader().getURI().setEscapedQuery(query);\n }\n+\n+/**\n+ * Gets the name of the node to be used for the given {@code msg} in the Site Map. Returning null is\n+ * taken to mean use the default name. This is currently the last element of the path (given in\n+ * {@code nodeName}) followed by the url parameter names in brackets (if any) followed by the\n+ * form parameter names in brackets (if any).\n+ *\n+ * @param helper a helper class as per parseParameters\n+ * @param nodeName the last element of the path\n+ * @param msg the message\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjk2MQ==", "bodyText": "Add that before the first are and change to URLs?", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487902961", "createdAt": "2020-09-14T13:15:51Z", "author": {"login": "thc202"}, "path": "zap/src/main/dist/scripts/templates/variant/Input Vector default template.js", "diffHunk": "@@ -72,3 +71,42 @@ function setParameter(helper, msg, param, value, escaped) {\n     //Set the parameters\n     msg.getRequestHeader().getURI().setEscapedQuery(query);\n }\n+\n+/**\n+ * Gets the name of the node to be used for the given {@code msg} in the Site Map. Returning null is\n+ * taken to mean use the default name. This is currently the last element of the path (given in\n+ * {@code nodeName}) followed by the url parameter names in brackets (if any) followed by the\n+ * form parameter names in brackets (if any).\n+ *\n+ * @param helper a helper class as per parseParameters\n+ * @param nodeName the last element of the path\n+ * @param msg the message\n+ */\n+function getLeafName(helper, nodeName, msg) {\n+\treturn null;\n+}\n+\n+/**\n+ * Returns the tree path elements for the given {@code message}. Returning null is taken to mean\n+ * use the default methods for obtaining tree path elements.\n+ * This will determine the position of this message in the sites tree.\n+ *\n+ * <p>By default the elements are returned for the following URL are:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzc4NA==", "bodyText": "This change should no longer be needed.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487903784", "createdAt": "2020-09-14T13:17:03Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/AbstractPlugin.java", "diffHunk": "@@ -181,7 +182,7 @@ protected HttpMessage getNewMsg() {\n      *\n      * @return The base HttpMessage with request/response.\n      */\n-    protected HttpMessage getBaseMsg() {\n+    public HttpMessage getBaseMsg() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTcyNQ==", "bodyText": "The doc needs update per move to Model.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487905725", "createdAt": "2020-09-14T13:19:58Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/extension/ExtensionHook.java", "diffHunk": "@@ -506,4 +518,40 @@ public void addHttpSenderListener(HttpSenderListener httpSenderListener) {\n         }\n         return Collections.unmodifiableList(httpSenderListeners);\n     }\n+\n+    /**\n+     * Adds the given {@code variant} to the extension hook, to be later added to the {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjQ5NA==", "bodyText": "Needs ZAP comment.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487906494", "createdAt": "2020-09-14T13:21:02Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Model.java", "diffHunk": "@@ -88,6 +89,7 @@\n     // ZAP: Added logger\n     private Logger logger = Logger.getLogger(Model.class);\n     private List<ContextDataFactory> contextDataFactories = new ArrayList<>();\n+    private VariantFactory variantFactory = new VariantFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzc2Mw==", "bodyText": "Could be final.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487907763", "createdAt": "2020-09-14T13:22:51Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwODU4Mw==", "bodyText": "Could be static.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487908583", "createdAt": "2020-09-14T13:24:03Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwODY0Mw==", "bodyText": "Could be final.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487908643", "createdAt": "2020-09-14T13:24:08Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMDY0Ng==", "bodyText": "Could use a mocked Model to avoid the need to tidy up.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487910646", "createdAt": "2020-09-14T13:26:48Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/parosproxy/paros/model/SessionUnitTest.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.model;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.NameValuePair;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.network.HttpHeader;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.I18N;\n+\n+public class SessionUnitTest {\n+\n+    private Session session;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;\n+        Control.initSingletonForTesting(Model.getSingleton());\n+\n+        session = new Session(Model.getSingleton());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzQzNw==", "bodyText": "Remove.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487913437", "createdAt": "2020-09-14T13:30:21Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        for (Class<? extends Variant> variant : customVariants) {\n+            try {\n+                listVariant.add(variant.getDeclaredConstructor().newInstance());\n+            } catch (Exception e) {\n+                e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNjUwMg==", "bodyText": "Could be extracted, same as in createSiteModifyingVariants.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487916502", "createdAt": "2020-09-14T13:33:09Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNjczNw==", "bodyText": "Could be extracted, same as in createSiteModifyingVariants.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487916737", "createdAt": "2020-09-14T13:33:23Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        for (Class<? extends Variant> variant : customVariants) {\n+            try {\n+                listVariant.add(variant.getDeclaredConstructor().newInstance());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                LOG.error(e.getMessage(), e);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzIwNg==", "bodyText": "This shouldn't happen(?), VariantCustom already doing that.", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487917206", "createdAt": "2020-09-14T13:33:51Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        for (Class<? extends Variant> variant : customVariants) {\n+            try {\n+                listVariant.add(variant.getDeclaredConstructor().newInstance());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                LOG.error(e.getMessage(), e);\n+            }\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public List<Variant> createSiteModifyingVariants() {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        if (getExtension() != null) {\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxOTgzNQ==", "bodyText": "This is being done in the setUp (similar comment in following methods).", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487919835", "createdAt": "2020-09-14T13:36:17Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/extension/ascan/VariantFactoryUnitTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.NameValuePair;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.extension.ExtensionLoader;\n+import org.parosproxy.paros.model.Model;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.ZapXmlConfiguration;\n+\n+public class VariantFactoryUnitTest {\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultVariants() {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = new ScannerParam();\n+        HttpMessage message = new HttpMessage();\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc"}, "originalPosition": 74}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "committedDate": "2020-09-10T16:15:25Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "caa14843188d521d7a136170cbf5a1aec1c8030b", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/caa14843188d521d7a136170cbf5a1aec1c8030b", "committedDate": "2020-09-15T08:13:18Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "caa14843188d521d7a136170cbf5a1aec1c8030b", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/caa14843188d521d7a136170cbf5a1aec1c8030b", "committedDate": "2020-09-15T08:13:18Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "2966832f768988a454529f21812dfb81cd25d104", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/2966832f768988a454529f21812dfb81cd25d104", "committedDate": "2020-09-15T10:06:02Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2966832f768988a454529f21812dfb81cd25d104", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/2966832f768988a454529f21812dfb81cd25d104", "committedDate": "2020-09-15T10:06:02Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "5974d5668d4f315eb7829243c3a6284c84915107", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/5974d5668d4f315eb7829243c3a6284c84915107", "committedDate": "2020-09-15T10:26:12Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5974d5668d4f315eb7829243c3a6284c84915107", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/5974d5668d4f315eb7829243c3a6284c84915107", "committedDate": "2020-09-15T10:26:12Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "fa8d2bf8b82eaf18ada865b59ff9ae16936e5ac1", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/fa8d2bf8b82eaf18ada865b59ff9ae16936e5ac1", "committedDate": "2020-09-15T10:36:42Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa8d2bf8b82eaf18ada865b59ff9ae16936e5ac1", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/fa8d2bf8b82eaf18ada865b59ff9ae16936e5ac1", "committedDate": "2020-09-15T10:36:42Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "548c33cb75fea6f5a59cc7983a53061df84db029", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/548c33cb75fea6f5a59cc7983a53061df84db029", "committedDate": "2020-09-15T13:13:16Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "committedDate": "2020-09-15T13:14:09Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "548c33cb75fea6f5a59cc7983a53061df84db029", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/548c33cb75fea6f5a59cc7983a53061df84db029", "committedDate": "2020-09-15T13:13:16Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}, "afterCommit": {"oid": "0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "author": {"user": {"login": "psiinon", "name": "Simon Bennetts"}}, "url": "https://github.com/zaproxy/zaproxy/commit/0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "committedDate": "2020-09-15T13:14:09Z", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NjcwNzIw", "url": "https://github.com/zaproxy/zaproxy/pull/6146#pullrequestreview-488670720", "createdAt": "2020-09-15T13:17:00Z", "commit": {"oid": "0fee8055a850a1c5ec3d7d93f4002e410fbb76e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NjcxNzU5", "url": "https://github.com/zaproxy/zaproxy/pull/6146#pullrequestreview-488671759", "createdAt": "2020-09-15T13:18:05Z", "commit": {"oid": "0fee8055a850a1c5ec3d7d93f4002e410fbb76e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 205, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}