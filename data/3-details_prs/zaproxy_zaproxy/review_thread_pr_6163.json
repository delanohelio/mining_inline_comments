{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxOTU5MDk2", "number": 6163, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzo0ODowNVrOEhQYOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0OTowNVrOE3JQ0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzA2ODA4OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzo0ODowNVrOHOeDAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzo0ODowNVrOHOeDAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzNDQwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns a context data string of the given type and using the given default value is the\n          \n          \n            \n                 * Returns a context data string of the given type and using the given default value if the", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r484934403", "createdAt": "2020-09-08T13:48:05Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1174,6 +1175,52 @@ public void setSessionUrl(int type, String url) throws DatabaseException {\n         return list;\n     }\n \n+    /**\n+     * Returns a context data string of the given type and using the given default value is the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80d28826e15ff48d000c401870329669949566eb"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzA2OTg5OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzo0ODoyNlrOHOeEBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzo0ODoyNlrOHOeEBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzNDY2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns a context data integer of the given type and using the given default value is the\n          \n          \n            \n                 * Returns a context data integer of the given type and using the given default value if the", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r484934660", "createdAt": "2020-09-08T13:48:26Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1174,6 +1175,52 @@ public void setSessionUrl(int type, String url) throws DatabaseException {\n         return list;\n     }\n \n+    /**\n+     * Returns a context data string of the given type and using the given default value is the\n+     * value is not present\n+     *\n+     * @param contextId the context Id\n+     * @param type the data type required\n+     * @param defaultValue the default value to use if the type is not present\n+     * @return the context data string\n+     * @throws DatabaseException\n+     * @since TODO add version\n+     */\n+    public String getContextDataString(int contextId, int type, String defaultValue)\n+            throws DatabaseException {\n+        List<RecordContext> dataList =\n+                model.getDb().getTableContext().getDataForContextAndType(contextId, type);\n+        if (dataList.size() > 0) {\n+            return dataList.get(0).getData();\n+        }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Returns a context data integer of the given type and using the given default value is the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80d28826e15ff48d000c401870329669949566eb"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzM0NzI3OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0NTo1NFrOHOgt2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0NTo1NFrOHOgt2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3ODEzOQ==", "bodyText": "Is there more?", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r484978139", "createdAt": "2020-09-08T14:45:54Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java", "diffHunk": "@@ -243,31 +245,75 @@ public URI getLoginRequestURIForContext(Context ctx) {\n     @Override\n     public void loadContextData(Session session, Context context) {\n         try {\n-            List<String> typeL =\n-                    session.getContextDataStrings(\n-                            context.getId(), RecordContext.TYPE_AUTH_METHOD_TYPE);\n-            if (typeL != null && typeL.size() > 0) {\n+            String type =\n+                    session.getContextDataString(\n+                            context.getId(), RecordContext.TYPE_AUTH_METHOD_TYPE, null);\n+            if (type != null) {\n                 AuthenticationMethodType t =\n-                        getAuthenticationMethodTypeForIdentifier(Integer.parseInt(typeL.get(0)));\n+                        getAuthenticationMethodTypeForIdentifier(Integer.parseInt(type));\n                 if (t != null) {\n                     context.setAuthenticationMethod(\n                             t.loadMethodFromSession(session, context.getId()));\n \n-                    List<String> loginIndicatorL =\n-                            session.getContextDataStrings(\n-                                    context.getId(),\n-                                    RecordContext.TYPE_AUTH_METHOD_LOGGEDIN_INDICATOR);\n-                    if (loginIndicatorL != null && loginIndicatorL.size() > 0)\n-                        context.getAuthenticationMethod()\n-                                .setLoggedInIndicatorPattern(loginIndicatorL.get(0));\n-\n-                    List<String> logoutIndicatorL =\n-                            session.getContextDataStrings(\n-                                    context.getId(),\n-                                    RecordContext.TYPE_AUTH_METHOD_LOGGEDOUT_INDICATOR);\n-                    if (logoutIndicatorL != null && logoutIndicatorL.size() > 0)\n-                        context.getAuthenticationMethod()\n-                                .setLoggedOutIndicatorPattern(logoutIndicatorL.get(0));\n+                    String strategy =\n+                            session.getContextDataString(\n+                                    context.getId(), RecordContext.TYPE_AUTH_VERIF_STRATEGY, null);\n+                    if (strategy != null) {\n+                        try {\n+                            context.getAuthenticationMethod()\n+                                    .setAuthCheckingStrategy(\n+                                            AuthCheckingStrategy.valueOf(strategy));\n+                        } catch (Exception e) {\n+                            log.error(\"Failed to parse auth checking strategy \" + strategy, e);\n+                        }\n+                    }\n+\n+                    context.getAuthenticationMethod()\n+                            .setPollUrl(\n+                                    session.getContextDataString(\n+                                            context.getId(),\n+                                            RecordContext.TYPE_AUTH_POLL_URL,\n+                                            null));\n+\n+                    context.getAuthenticationMethod()\n+                            .setPollData(\n+                                    session.getContextDataString(\n+                                            context.getId(),\n+                                            RecordContext.TYPE_AUTH_POLL_DATA,\n+                                            null));\n+\n+                    context.getAuthenticationMethod()\n+                            .setPollFrequency(\n+                                    session.getContextDataInteger(\n+                                            context.getId(), RecordContext.TYPE_AUTH_POLL_FREQ, 0));\n+\n+                    String freqUnits =\n+                            session.getContextDataString(\n+                                    context.getId(), RecordContext.TYPE_AUTH_POLL_FREQ_UNITS, null);\n+                    if (freqUnits != null) {\n+                        try {\n+                            context.getAuthenticationMethod()\n+                                    .setPollFrequencyUnits(\n+                                            AuthPollFrequencyUnits.valueOf(freqUnits));\n+                        } catch (Exception e) {\n+                            log.error(\"Failed to parse auth frequency units \" + freqUnits, e);\n+                        }\n+                    }\n+                    // TODO add more here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80d28826e15ff48d000c401870329669949566eb"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzM0OTg0OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0NjoyOVrOHOgvhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo0NjoyOVrOHOgvhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3ODU2Ng==", "bodyText": "?", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r484978566", "createdAt": "2020-09-08T14:46:29Z", "author": {"login": "kingthorin"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ExtensionAuthentication.java", "diffHunk": "@@ -286,6 +332,46 @@ public void persistContextData(Session session, Context context) {\n                     RecordContext.TYPE_AUTH_METHOD_TYPE,\n                     Integer.toString(t.getUniqueIdentifier()));\n \n+            if (context.getAuthenticationMethod().getAuthCheckingStrategy() != null) {\n+                session.setContextData(\n+                        contextIdx,\n+                        RecordContext.TYPE_AUTH_VERIF_STRATEGY,\n+                        context.getAuthenticationMethod().getAuthCheckingStrategy().name());\n+            } else {\n+                session.clearContextDataForType(contextIdx, RecordContext.TYPE_AUTH_VERIF_STRATEGY);\n+            }\n+\n+            if (context.getAuthenticationMethod().getPollUrl() != null) {\n+                session.setContextData(\n+                        contextIdx,\n+                        RecordContext.TYPE_AUTH_POLL_URL,\n+                        context.getAuthenticationMethod().getPollUrl());\n+            } else {\n+                session.clearContextDataForType(contextIdx, RecordContext.TYPE_AUTH_POLL_URL);\n+            }\n+            if (context.getAuthenticationMethod().getPollData() != null) {\n+                session.setContextData(\n+                        contextIdx,\n+                        RecordContext.TYPE_AUTH_POLL_DATA,\n+                        context.getAuthenticationMethod().getPollData());\n+            } else {\n+                session.clearContextDataForType(contextIdx, RecordContext.TYPE_AUTH_POLL_DATA);\n+            }\n+            session.setContextData(\n+                    contextIdx,\n+                    RecordContext.TYPE_AUTH_POLL_FREQ,\n+                    Integer.toString(context.getAuthenticationMethod().getPollFrequency()));\n+\n+            if (context.getAuthenticationMethod().getPollFrequencyUnits() != null) {\n+                session.setContextData(\n+                        contextIdx,\n+                        RecordContext.TYPE_AUTH_POLL_FREQ_UNITS,\n+                        context.getAuthenticationMethod().getPollFrequencyUnits().name());\n+            } else {\n+                session.clearContextDataForType(contextIdx, RecordContext.TYPE_AUTH_VERIF_STRATEGY);\n+            }\n+            // TODO add more", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80d28826e15ff48d000c401870329669949566eb"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwNjMwOnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzowMFrOHwSnpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzowMFrOHwSnpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5ODc1OA==", "bodyText": "Worth adding a message saying what failed to be done.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520398758", "createdAt": "2020-11-10T09:07:00Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationHelper.java", "diffHunk": "@@ -151,6 +158,40 @@ public static HttpMessage prepareMessage(\n         return msg;\n     }\n \n+    public static String replaceUserData(\n+            String data, Map<String, String> keyValuePairs, UnaryOperator<String> encoder) {\n+        for (Entry<String, String> kvp : keyValuePairs.entrySet()) {\n+            data = data.replace(kvp.getKey(), encoder.apply(kvp.getValue()));\n+        }\n+        return data;\n+    }\n+\n+    public static void replaceUserDataInRequest(\n+            HttpMessage msg, Map<String, String> userDataMap, UnaryOperator<String> bodyEncoder) {\n+        try {\n+            Map<String, String> kvMap = new HashMap<>(userDataMap.size());\n+            for (Entry<String, String> userdata : userDataMap.entrySet()) {\n+                kvMap.put(\n+                        URLEncoder.encode(userdata.getKey(), StandardCharsets.UTF_8.name()),\n+                        userdata.getValue());\n+            }\n+            String uri =\n+                    AuthenticationHelper.replaceUserData(\n+                            msg.getRequestHeader().getURI().toString(),\n+                            kvMap,\n+                            PostBasedAuthenticationMethodType::encodeParameter);\n+            msg.getRequestHeader().setURI(new URI(uri, true));\n+        } catch (Exception e) {\n+            log.error(e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwNjc5OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzowOVrOHwSn-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzowOVrOHwSn-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5ODg0Mg==", "bodyText": "Could be a long and use System.currentTimeMillis(), the Date is not actually being used just its time.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520398842", "createdAt": "2020-11-10T09:07:09Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -42,16 +51,61 @@\n  */\n public abstract class AuthenticationMethod {\n \n+    private static final Logger LOGGER = Logger.getLogger(AuthenticationMethod.class);\n+\n     public static final String CONTEXT_CONFIG_AUTH = Context.CONTEXT_CONFIG + \".authentication\";\n     public static final String CONTEXT_CONFIG_AUTH_TYPE = CONTEXT_CONFIG_AUTH + \".type\";\n+    public static final String CONTEXT_CONFIG_AUTH_STRATEGY = CONTEXT_CONFIG_AUTH + \".strategy\";\n+    public static final String CONTEXT_CONFIG_AUTH_POLL_URL = CONTEXT_CONFIG_AUTH + \".pollurl\";\n+    public static final String CONTEXT_CONFIG_AUTH_POLL_DATA = CONTEXT_CONFIG_AUTH + \".polldata\";\n+    public static final String CONTEXT_CONFIG_AUTH_POLL_HEADERS =\n+            CONTEXT_CONFIG_AUTH + \".pollheaders\";\n+    public static final String CONTEXT_CONFIG_AUTH_POLL_FREQ = CONTEXT_CONFIG_AUTH + \".pollfreq\";\n+    public static final String CONTEXT_CONFIG_AUTH_POLL_UNITS = CONTEXT_CONFIG_AUTH + \".pollunits\";\n     public static final String CONTEXT_CONFIG_AUTH_LOGGEDIN = CONTEXT_CONFIG_AUTH + \".loggedin\";\n     public static final String CONTEXT_CONFIG_AUTH_LOGGEDOUT = CONTEXT_CONFIG_AUTH + \".loggedout\";\n \n+    public static final String AUTH_STATE_ASSUMED_IN_STATS = \"stats.auth.state.assumedin\";\n     public static final String AUTH_STATE_LOGGED_IN_STATS = \"stats.auth.state.loggedin\";\n     public static final String AUTH_STATE_LOGGED_OUT_STATS = \"stats.auth.state.loggedout\";\n     public static final String AUTH_STATE_NO_INDICATOR_STATS = \"stats.auth.state.noindicator\";\n     public static final String AUTH_STATE_UNKNOWN_STATS = \"stats.auth.state.unknown\";\n \n+    public static final String TOKEN_PREFIX = \"{%\";\n+    public static final String TOKEN_POSTFIX = \"%}\";\n+\n+    public static final int DEFAULT_POLL_FREQUENCY = 60;\n+\n+    public static enum AuthCheckingStrategy {\n+        EACH_RESP,\n+        EACH_REQ,\n+        EACH_REQ_RESP,\n+        POLL_URL\n+    };\n+\n+    public static enum AuthPollFrequencyUnits {\n+        REQUESTS,\n+        SECONDS\n+    };\n+\n+    private AuthCheckingStrategy authCheckingStrategy = AuthCheckingStrategy.EACH_RESP;\n+\n+    private String pollUrl;\n+\n+    private String pollData;\n+\n+    private String pollHeaders;\n+\n+    private int pollFrequency = DEFAULT_POLL_FREQUENCY;\n+\n+    private AuthPollFrequencyUnits pollFrequencyUnits = AuthPollFrequencyUnits.REQUESTS;\n+\n+    private Date lastPollTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwNzI3OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzoxN1rOHwSoRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzoxN1rOHwSoRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5ODkxNw==", "bodyText": "getType() might return a new type each time it's called.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520398917", "createdAt": "2020-11-10T09:07:17Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -193,31 +289,126 @@ public boolean isAuthenticated(HttpMessage msg) {\n             return true;\n         }\n \n-        String body = msg.getResponseBody().toString();\n-        String header = msg.getResponseHeader().toString();\n+        List<String> contentToTest = new ArrayList<>();\n+\n+        switch (this.authCheckingStrategy) {\n+            case EACH_REQ:\n+                contentToTest.add(msg.getRequestHeader().toString());\n+                contentToTest.add(msg.getRequestBody().toString());\n+                break;\n+            case EACH_REQ_RESP:\n+                contentToTest.add(msg.getRequestHeader().toString());\n+                contentToTest.add(msg.getRequestBody().toString());\n+                contentToTest.add(msg.getResponseHeader().toString());\n+                contentToTest.add(msg.getResponseBody().toString());\n+                break;\n+            case EACH_RESP:\n+                contentToTest.add(msg.getResponseHeader().toString());\n+                contentToTest.add(msg.getResponseBody().toString());\n+                break;\n+            case POLL_URL:\n+                if (!force && lastPollResult != null && lastPollResult) {\n+                    // Check if we really need to poll the relevant URL again\n+                    switch (pollFrequencyUnits) {\n+                        case SECONDS:\n+                            if ((new Date().getTime() - lastPollTime.getTime()) / 1000\n+                                    < pollFrequency) {\n+                                try {\n+                                    Stats.incCounter(\n+                                            SessionStructure.getHostName(msg),\n+                                            AUTH_STATE_ASSUMED_IN_STATS);\n+                                } catch (URIException e) {\n+                                    // Ignore\n+                                }\n+                                return true;\n+                            }\n+                            break;\n+                        case REQUESTS:\n+                        default:\n+                            if (requestsSincePoll < pollFrequency) {\n+                                requestsSincePoll++;\n+                                try {\n+                                    Stats.incCounter(\n+                                            SessionStructure.getHostName(msg),\n+                                            AUTH_STATE_ASSUMED_IN_STATS);\n+                                } catch (URIException e) {\n+                                    // Ignore\n+                                }\n+                                return true;\n+                            }\n+                            break;\n+                    }\n+                }\n+                // Make the poll request\n+                try {\n+                    HttpMessage pollMsg = new HttpMessage(new URI(this.getPollUrl(), true));\n+                    if (this.getPollData() != null && this.getPollData().length() > 0) {\n+                        pollMsg.getRequestHeader().setMethod(HttpRequestHeader.POST);\n+                        pollMsg.getRequestBody().setBody(this.getPollData());\n+                        pollMsg.getRequestHeader()\n+                                .setContentLength(pollMsg.getRequestBody().length());\n+                    }\n+                    if (this.getPollHeaders() != null && this.getPollHeaders().length() > 0) {\n+                        for (String header : this.getPollHeaders().split(\"\\n\")) {\n+                            String[] headerValue = header.split(\":\");\n+                            if (headerValue.length == 2) {\n+                                pollMsg.getRequestHeader()\n+                                        .addHeader(headerValue[0].trim(), headerValue[1].trim());\n+                            } else {\n+                                LOGGER.error(\n+                                        \"Invalid header '\"\n+                                                + header\n+                                                + \"' for poll request to \"\n+                                                + this.getPollUrl());\n+                            }\n+                        }\n+                    }\n+                    pollMsg.setRequestingUser(user);\n+                    if (this.getType() != null && user != null) {\n+                        this.getType().replaceUserDataInPollRequest(pollMsg, user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwNzU3OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzoyM1rOHwSodw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzoyM1rOHwSodw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5ODk2Nw==", "bodyText": "Warn, this is expected to happen in case of connection problems, also, worth adding a message saying that it failed to send the auth poll request.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520398967", "createdAt": "2020-11-10T09:07:23Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -193,31 +289,126 @@ public boolean isAuthenticated(HttpMessage msg) {\n             return true;\n         }\n \n-        String body = msg.getResponseBody().toString();\n-        String header = msg.getResponseHeader().toString();\n+        List<String> contentToTest = new ArrayList<>();\n+\n+        switch (this.authCheckingStrategy) {\n+            case EACH_REQ:\n+                contentToTest.add(msg.getRequestHeader().toString());\n+                contentToTest.add(msg.getRequestBody().toString());\n+                break;\n+            case EACH_REQ_RESP:\n+                contentToTest.add(msg.getRequestHeader().toString());\n+                contentToTest.add(msg.getRequestBody().toString());\n+                contentToTest.add(msg.getResponseHeader().toString());\n+                contentToTest.add(msg.getResponseBody().toString());\n+                break;\n+            case EACH_RESP:\n+                contentToTest.add(msg.getResponseHeader().toString());\n+                contentToTest.add(msg.getResponseBody().toString());\n+                break;\n+            case POLL_URL:\n+                if (!force && lastPollResult != null && lastPollResult) {\n+                    // Check if we really need to poll the relevant URL again\n+                    switch (pollFrequencyUnits) {\n+                        case SECONDS:\n+                            if ((new Date().getTime() - lastPollTime.getTime()) / 1000\n+                                    < pollFrequency) {\n+                                try {\n+                                    Stats.incCounter(\n+                                            SessionStructure.getHostName(msg),\n+                                            AUTH_STATE_ASSUMED_IN_STATS);\n+                                } catch (URIException e) {\n+                                    // Ignore\n+                                }\n+                                return true;\n+                            }\n+                            break;\n+                        case REQUESTS:\n+                        default:\n+                            if (requestsSincePoll < pollFrequency) {\n+                                requestsSincePoll++;\n+                                try {\n+                                    Stats.incCounter(\n+                                            SessionStructure.getHostName(msg),\n+                                            AUTH_STATE_ASSUMED_IN_STATS);\n+                                } catch (URIException e) {\n+                                    // Ignore\n+                                }\n+                                return true;\n+                            }\n+                            break;\n+                    }\n+                }\n+                // Make the poll request\n+                try {\n+                    HttpMessage pollMsg = new HttpMessage(new URI(this.getPollUrl(), true));\n+                    if (this.getPollData() != null && this.getPollData().length() > 0) {\n+                        pollMsg.getRequestHeader().setMethod(HttpRequestHeader.POST);\n+                        pollMsg.getRequestBody().setBody(this.getPollData());\n+                        pollMsg.getRequestHeader()\n+                                .setContentLength(pollMsg.getRequestBody().length());\n+                    }\n+                    if (this.getPollHeaders() != null && this.getPollHeaders().length() > 0) {\n+                        for (String header : this.getPollHeaders().split(\"\\n\")) {\n+                            String[] headerValue = header.split(\":\");\n+                            if (headerValue.length == 2) {\n+                                pollMsg.getRequestHeader()\n+                                        .addHeader(headerValue[0].trim(), headerValue[1].trim());\n+                            } else {\n+                                LOGGER.error(\n+                                        \"Invalid header '\"\n+                                                + header\n+                                                + \"' for poll request to \"\n+                                                + this.getPollUrl());\n+                            }\n+                        }\n+                    }\n+                    pollMsg.setRequestingUser(user);\n+                    if (this.getType() != null && user != null) {\n+                        this.getType().replaceUserDataInPollRequest(pollMsg, user);\n+                    }\n+\n+                    getHttpSender().sendAndReceive(pollMsg);\n+                    AuthenticationHelper.addAuthMessageToHistory(pollMsg);\n+                    contentToTest.add(pollMsg.getResponseHeader().toString());\n+                    contentToTest.add(pollMsg.getResponseBody().toString());\n+                    lastPollTime = new Date();\n+                    requestsSincePoll = 0;\n+\n+                } catch (Exception e1) {\n+                    LOGGER.error(e1.getMessage(), e1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwNzg2OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzoyN1rOHwSooA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzoyN1rOHwSooA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5OTAwOA==", "bodyText": "static", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520399008", "createdAt": "2020-11-10T09:07:27Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -226,6 +417,20 @@ public boolean isAuthenticated(HttpMessage msg) {\n         } catch (URIException e) {\n             // Ignore\n         }\n+        if (this.authCheckingStrategy.equals(AuthCheckingStrategy.POLL_URL)) {\n+            this.lastPollResult = false;\n+        }\n+        return false;\n+    }\n+\n+    private boolean patternMatchesAny(Pattern pattern, List<String> content) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwODExOnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzozMlrOHwSoyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzozMlrOHwSoyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5OTA1MA==", "bodyText": "Typo in authenticated.\nDoes it worth saying what null means?", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520399050", "createdAt": "2020-11-10T09:07:32Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -273,6 +478,81 @@ public void setLoggedOutIndicatorPattern(String loggedOutIndicatorPattern) {\n         }\n     }\n \n+    public AuthCheckingStrategy getAuthCheckingStrategy() {\n+        return authCheckingStrategy;\n+    }\n+\n+    public void setAuthCheckingStrategy(AuthCheckingStrategy authCheckingStrategy) {\n+        this.authCheckingStrategy = authCheckingStrategy;\n+    }\n+\n+    public String getPollUrl() {\n+        return pollUrl;\n+    }\n+\n+    public void setPollUrl(String pollUrl) {\n+        this.pollUrl = pollUrl;\n+    }\n+\n+    public String getPollData() {\n+        return pollData;\n+    }\n+\n+    public void setPollData(String pollData) {\n+        this.pollData = pollData;\n+    }\n+\n+    public String getPollHeaders() {\n+        return pollHeaders;\n+    }\n+\n+    public void setPollHeaders(String pollHeaders) {\n+        this.pollHeaders = pollHeaders;\n+    }\n+\n+    public int getPollFrequency() {\n+        return pollFrequency;\n+    }\n+\n+    public void setPollFrequency(int pollFrequency) {\n+        this.pollFrequency = pollFrequency;\n+    }\n+\n+    public AuthPollFrequencyUnits getPollFrequencyUnits() {\n+        return pollFrequencyUnits;\n+    }\n+\n+    public void setPollFrequencyUnits(AuthPollFrequencyUnits pollFrequencyUnits) {\n+        this.pollFrequencyUnits = pollFrequencyUnits;\n+    }\n+\n+    /**\n+     * Gets the last poll result - true means that the user is authnaticated, otherwise false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 358}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwODM1OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzozNVrOHwSo6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMzoxNjo0OVrOHwcDbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5OTA4Mw==", "bodyText": "Does not seem to be used, really needed?", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520399083", "createdAt": "2020-11-10T09:07:35Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -273,6 +478,81 @@ public void setLoggedOutIndicatorPattern(String loggedOutIndicatorPattern) {\n         }\n     }\n \n+    public AuthCheckingStrategy getAuthCheckingStrategy() {\n+        return authCheckingStrategy;\n+    }\n+\n+    public void setAuthCheckingStrategy(AuthCheckingStrategy authCheckingStrategy) {\n+        this.authCheckingStrategy = authCheckingStrategy;\n+    }\n+\n+    public String getPollUrl() {\n+        return pollUrl;\n+    }\n+\n+    public void setPollUrl(String pollUrl) {\n+        this.pollUrl = pollUrl;\n+    }\n+\n+    public String getPollData() {\n+        return pollData;\n+    }\n+\n+    public void setPollData(String pollData) {\n+        this.pollData = pollData;\n+    }\n+\n+    public String getPollHeaders() {\n+        return pollHeaders;\n+    }\n+\n+    public void setPollHeaders(String pollHeaders) {\n+        this.pollHeaders = pollHeaders;\n+    }\n+\n+    public int getPollFrequency() {\n+        return pollFrequency;\n+    }\n+\n+    public void setPollFrequency(int pollFrequency) {\n+        this.pollFrequency = pollFrequency;\n+    }\n+\n+    public AuthPollFrequencyUnits getPollFrequencyUnits() {\n+        return pollFrequencyUnits;\n+    }\n+\n+    public void setPollFrequencyUnits(AuthPollFrequencyUnits pollFrequencyUnits) {\n+        this.pollFrequencyUnits = pollFrequencyUnits;\n+    }\n+\n+    /**\n+     * Gets the last poll result - true means that the user is authnaticated, otherwise false\n+     *\n+     * @return the last poll result\n+     */\n+    public Boolean getLastPollResult() {\n+        return lastPollResult;\n+    }\n+\n+    /**\n+     * Sets the last poll result - this can be used by script or add-ons to change the known logged\n+     * in state eg if they have more accurate information\n+     *\n+     * @param lastPollResult\n+     */\n+    public void setLastPollResult(Boolean lastPollResult) {\n+        this.lastPollResult = lastPollResult;\n+    }\n+\n+    public Date getLastPollTime() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU1MzMyNg==", "bodyText": "Deliberately exposed in case scripts (or other add-ons) want to know what it is.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520553326", "createdAt": "2020-11-10T13:16:49Z", "author": {"login": "psiinon"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -273,6 +478,81 @@ public void setLoggedOutIndicatorPattern(String loggedOutIndicatorPattern) {\n         }\n     }\n \n+    public AuthCheckingStrategy getAuthCheckingStrategy() {\n+        return authCheckingStrategy;\n+    }\n+\n+    public void setAuthCheckingStrategy(AuthCheckingStrategy authCheckingStrategy) {\n+        this.authCheckingStrategy = authCheckingStrategy;\n+    }\n+\n+    public String getPollUrl() {\n+        return pollUrl;\n+    }\n+\n+    public void setPollUrl(String pollUrl) {\n+        this.pollUrl = pollUrl;\n+    }\n+\n+    public String getPollData() {\n+        return pollData;\n+    }\n+\n+    public void setPollData(String pollData) {\n+        this.pollData = pollData;\n+    }\n+\n+    public String getPollHeaders() {\n+        return pollHeaders;\n+    }\n+\n+    public void setPollHeaders(String pollHeaders) {\n+        this.pollHeaders = pollHeaders;\n+    }\n+\n+    public int getPollFrequency() {\n+        return pollFrequency;\n+    }\n+\n+    public void setPollFrequency(int pollFrequency) {\n+        this.pollFrequency = pollFrequency;\n+    }\n+\n+    public AuthPollFrequencyUnits getPollFrequencyUnits() {\n+        return pollFrequencyUnits;\n+    }\n+\n+    public void setPollFrequencyUnits(AuthPollFrequencyUnits pollFrequencyUnits) {\n+        this.pollFrequencyUnits = pollFrequencyUnits;\n+    }\n+\n+    /**\n+     * Gets the last poll result - true means that the user is authnaticated, otherwise false\n+     *\n+     * @return the last poll result\n+     */\n+    public Boolean getLastPollResult() {\n+        return lastPollResult;\n+    }\n+\n+    /**\n+     * Sets the last poll result - this can be used by script or add-ons to change the known logged\n+     * in state eg if they have more accurate information\n+     *\n+     * @param lastPollResult\n+     */\n+    public void setLastPollResult(Boolean lastPollResult) {\n+        this.lastPollResult = lastPollResult;\n+    }\n+\n+    public Date getLastPollTime() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5OTA4Mw=="}, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQxMDQxOnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowODowN1rOHwSqQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowODowN1rOHwSqQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5OTQyNg==", "bodyText": "e.g.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520399426", "createdAt": "2020-11-10T09:08:07Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethod.java", "diffHunk": "@@ -273,6 +478,81 @@ public void setLoggedOutIndicatorPattern(String loggedOutIndicatorPattern) {\n         }\n     }\n \n+    public AuthCheckingStrategy getAuthCheckingStrategy() {\n+        return authCheckingStrategy;\n+    }\n+\n+    public void setAuthCheckingStrategy(AuthCheckingStrategy authCheckingStrategy) {\n+        this.authCheckingStrategy = authCheckingStrategy;\n+    }\n+\n+    public String getPollUrl() {\n+        return pollUrl;\n+    }\n+\n+    public void setPollUrl(String pollUrl) {\n+        this.pollUrl = pollUrl;\n+    }\n+\n+    public String getPollData() {\n+        return pollData;\n+    }\n+\n+    public void setPollData(String pollData) {\n+        this.pollData = pollData;\n+    }\n+\n+    public String getPollHeaders() {\n+        return pollHeaders;\n+    }\n+\n+    public void setPollHeaders(String pollHeaders) {\n+        this.pollHeaders = pollHeaders;\n+    }\n+\n+    public int getPollFrequency() {\n+        return pollFrequency;\n+    }\n+\n+    public void setPollFrequency(int pollFrequency) {\n+        this.pollFrequency = pollFrequency;\n+    }\n+\n+    public AuthPollFrequencyUnits getPollFrequencyUnits() {\n+        return pollFrequencyUnits;\n+    }\n+\n+    public void setPollFrequencyUnits(AuthPollFrequencyUnits pollFrequencyUnits) {\n+        this.pollFrequencyUnits = pollFrequencyUnits;\n+    }\n+\n+    /**\n+     * Gets the last poll result - true means that the user is authnaticated, otherwise false\n+     *\n+     * @return the last poll result\n+     */\n+    public Boolean getLastPollResult() {\n+        return lastPollResult;\n+    }\n+\n+    /**\n+     * Sets the last poll result - this can be used by script or add-ons to change the known logged\n+     * in state eg if they have more accurate information", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQyMzg1OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethodType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxMTowOFrOHwSyVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxMTowOFrOHwSyVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQwMTQ5NQ==", "bodyText": "Should this be in the method not the type? It would avoid creating a new type each time the data needs to be replaced.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520401495", "createdAt": "2020-11-10T09:11:08Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/AuthenticationMethodType.java", "diffHunk": "@@ -214,6 +218,8 @@ public String toString() {\n      */\n     public abstract ApiDynamicActionImplementor getSetCredentialsForUserApiAction();\n \n+    public abstract void replaceUserDataInPollRequest(HttpMessage msg, User user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQzMzg3OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/authentication/PostBasedAuthenticationMethodType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxMzo0N1rOHwS4kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxMzo0N1rOHwS4kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQwMzA5MQ==", "bodyText": "static", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520403091", "createdAt": "2020-11-10T09:13:47Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/authentication/PostBasedAuthenticationMethodType.java", "diffHunk": "@@ -1417,4 +1414,19 @@ public void importData(Configuration config, AuthenticationMethod authMethod)\n             throw new ConfigurationException(e);\n         }\n     }\n+\n+    public void replaceUserCredentialsDataInPollRequest(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQzNzc2OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/extension/api/ContextAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxNDo0NVrOHwS65Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxNDo0NVrOHwS65Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQwMzY4NQ==", "bodyText": "isEmpty()", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520403685", "createdAt": "2020-11-10T09:14:45Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/api/ContextAPI.java", "diffHunk": "@@ -172,6 +193,58 @@ public ApiResponse handleApiAction(String name, JSONObject params) throws ApiExc\n                 }\n                 Model.getSingleton().getSession().saveContext(context);\n                 break;\n+            case ACTION_SET_CONTEXT_CHECKING_STRATEGY:\n+                context = getContext(params);\n+                AuthCheckingStrategy checkingStrategy;\n+                try {\n+                    checkingStrategy =\n+                            AuthCheckingStrategy.valueOf(\n+                                    params.getString(PARAM_CHECKING_STRATEGRY));\n+                } catch (Exception e1) {\n+                    throw new ApiException(\n+                            ApiException.Type.ILLEGAL_PARAMETER, PARAM_CHECKING_STRATEGRY);\n+                }\n+                if (AuthCheckingStrategy.POLL_URL.equals(checkingStrategy)) {\n+                    AuthPollFrequencyUnits units;\n+                    try {\n+                        units =\n+                                AuthPollFrequencyUnits.valueOf(\n+                                        params.getString(PARAM_POLL_FREQ_UNITS));\n+                    } catch (Exception e) {\n+                        throw new ApiException(\n+                                ApiException.Type.ILLEGAL_PARAMETER, PARAM_POLL_FREQ_UNITS);\n+                    }\n+                    int freq;\n+                    String pollUrl = params.getString(PARAM_POLL_URL);\n+                    String pollData = params.getString(PARAM_POLL_DATA);\n+                    String pollHeaders = params.getString(PARAM_POLL_HEADERS);\n+                    if (pollUrl == null || pollUrl.length() <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQ0NjMzOnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ContextAuthenticationPanel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxNjo0MVrOHwS_9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxNjo0MVrOHwS_9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQwNDk4Mg==", "bodyText": "Remove?", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520404982", "createdAt": "2020-11-10T09:16:41Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ContextAuthenticationPanel.java", "diffHunk": "@@ -314,6 +473,116 @@ private JPanel getConfigContainerPanel() {\n         return configContainerPanel;\n     }\n \n+    private JPanel getVerifContainerPanel() {\n+        if (verifContainerPanel == null) {\n+            verifContainerPanel = new JPanel(new GridBagLayout());\n+            verifContainerPanel.setBorder(\n+                    javax.swing.BorderFactory.createTitledBorder(\n+                            null,\n+                            PANEL_TITLE_VERIF,\n+                            javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,\n+                            javax.swing.border.TitledBorder.DEFAULT_POSITION,\n+                            FontUtils.getFont(FontUtils.Size.standard)));\n+        }\n+        return verifContainerPanel;\n+    }\n+\n+    private JButton getPollUrlSelectButton() {\n+        if (pollUrlSelectButton == null) {\n+            pollUrlSelectButton = new JButton(Constant.messages.getString(\"all.button.select\"));\n+            pollUrlSelectButton.setIcon(\n+                    new ImageIcon(\n+                            View.class.getResource(\"/resource/icon/16/094.png\"))); // Globe Icon\n+            // Add behaviour for Node Select dialog\n+            pollUrlSelectButton.addActionListener(\n+                    new java.awt.event.ActionListener() {\n+                        @Override\n+                        public void actionPerformed(java.awt.event.ActionEvent e) {\n+                            NodeSelectDialog nsd =\n+                                    new NodeSelectDialog(View.getSingleton().getMainFrame());\n+                            // Try to pre-select the node according to what has been inserted in the\n+                            // fields\n+                            SiteNode node = null;\n+                            if (getPollUrlField().getText().trim().length() > 0)\n+                                try {\n+                                    // If it's a POST query\n+                                    if (getPollDataField().getText().trim().length() > 0)\n+                                        node =\n+                                                Model.getSingleton()\n+                                                        .getSession()\n+                                                        .getSiteTree()\n+                                                        .findNode(\n+                                                                new URI(\n+                                                                        getPollUrlField().getText(),\n+                                                                        false),\n+                                                                HttpRequestHeader.POST,\n+                                                                getPollDataField().getText());\n+                                    else\n+                                        node =\n+                                                Model.getSingleton()\n+                                                        .getSession()\n+                                                        .getSiteTree()\n+                                                        .findNode(\n+                                                                new URI(\n+                                                                        getPollUrlField().getText(),\n+                                                                        false));\n+                                } catch (Exception e2) {\n+                                    // Ignore. It means we could not properly get a node for the\n+                                    // existing\n+                                    // value and does not have any harmful effects\n+                                }\n+\n+                            // Show the dialog and wait for input\n+                            node = nsd.showDialog(node);\n+                            if (node != null && node.getHistoryReference() != null) {\n+                                try {\n+\n+                                    getPollUrlField()\n+                                            .setText(\n+                                                    node.getHistoryReference().getURI().toString());\n+                                    getPollDataField()\n+                                            .setText(\n+                                                    node.getHistoryReference()\n+                                                            .getHttpMessage()\n+                                                            .getRequestBody()\n+                                                            .toString());\n+                                    /*\n+                                    updateParameters();\n+                                    if (StringUtils.isBlank(loginPageUrlField.getText())) {\n+                                        loginPageUrlField.setText(loginUrlField.getText());\n+                                    }\n+                                    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQ0OTk2OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ContextAuthenticationPanel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxNzoyNVrOHwTCDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToxNzoyNVrOHwTCDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQwNTUxOQ==", "bodyText": "Add braces?", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520405519", "createdAt": "2020-11-10T09:17:25Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/extension/authentication/ContextAuthenticationPanel.java", "diffHunk": "@@ -343,7 +612,25 @@ public void initContextData(Session session, Context uiSharedContext) {\n \n         // If something was already configured, find the type and set the UI accordingly\n         if (selectedAuthenticationMethod != null) {\n-            // Set logged in/out indicators\n+            // Set verification\n+            if (selectedAuthenticationMethod.getAuthCheckingStrategy() != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 382}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQ3MDI2OnYy", "diffSide": "RIGHT", "path": "zap/src/main/java/org/zaproxy/zap/users/User.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToyMTo0OFrOHwTOOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToyMTo0OFrOHwTOOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQwODYzNQ==", "bodyText": "It would be better to add a new method, e.g. processMessageToMatchUserWithoutAuthenticate(HttpMessage), instead of deprecate this one, it would be more clear what the purpose of the new method is, also, others can call it if needed without passing an initiator.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520408635", "createdAt": "2020-11-10T09:21:48Z", "author": {"login": "thc202"}, "path": "zap/src/main/java/org/zaproxy/zap/users/User.java", "diffHunk": "@@ -166,16 +167,31 @@ public int getId() {\n      * user.\n      *\n      * @param message the message\n+     * @deprecated since 2.10.0\n      */\n+    @Deprecated\n     public void processMessageToMatchUser(HttpMessage message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQ5NjQ1OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/AuthenticationMethodIndicatorsUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToyNzo0NFrOHwTeRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOToyNzo0NFrOHwTeRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQxMjc0Mg==", "bodyText": "Technically the AuthenticationMethod should properly handle a null strategy as it allows to set it to null.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520412742", "createdAt": "2020-11-10T09:27:44Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/AuthenticationMethodIndicatorsUnitTest.java", "diffHunk": "@@ -64,6 +65,7 @@ public void setUp() throws Exception {\n         header.setURI(new URI(\"http://www.example.com\", true));\n         loginMessage.setRequestHeader(header);\n         method = Mockito.mock(AuthenticationMethod.class, Mockito.CALLS_REAL_METHODS);\n+        method.setAuthCheckingStrategy(AuthCheckingStrategy.EACH_RESP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjUyNDAwOnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/AuthenticationMethodPollUrlUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozNDowMlrOHwTvMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozNDowMlrOHwTvMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQxNzA3Mg==", "bodyText": "EveryFive \u2192 OnSpecifiedNumberOf (or something), that's using five for the tests is not the important.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520417072", "createdAt": "2020-11-10T09:34:02Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/AuthenticationMethodPollUrlUnitTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2013 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.authentication;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpRequestHeader;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+import org.zaproxy.zap.testutils.TestUtils;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class AuthenticationMethodPollUrlUnitTest extends TestUtils {\n+\n+    private static final String LOGGED_IN_INDICATOR = \"logged in\";\n+    private static final String LOGGED_IN_BODY =\n+            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \"\n+                    + \"Pellentesque auctor nulla id turpis placerat vulputate.\"\n+                    + LOGGED_IN_INDICATOR\n+                    + \" Proin tempor bibendum eros rutrum. \";\n+\n+    private HttpMessage loginMessage;\n+    private AuthenticationMethod method;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        loginMessage = new HttpMessage();\n+        HttpRequestHeader header = new HttpRequestHeader();\n+        header.setURI(new URI(\"http://www.example.com\", true));\n+        loginMessage.setRequestHeader(header);\n+        method = Mockito.mock(AuthenticationMethod.class, Mockito.CALLS_REAL_METHODS);\n+        method.setAuthCheckingStrategy(AuthCheckingStrategy.EACH_RESP);\n+\n+        this.startServer();\n+    }\n+\n+    @AfterEach\n+    public void shutDownServer() throws Exception {\n+        stopServer();\n+    }\n+\n+    @Test\n+    public void shouldPollOnFirstRequest() throws NullPointerException, IOException {\n+        // Given\n+        String test = \"/shouldPollOnFirstRequest/test\";\n+        String pollUrl = \"/shouldPollOnFirstRequest/pollUrl\";\n+        final List<String> orderedReqs = new ArrayList<>();\n+\n+        this.nano.addHandler(\n+                new NanoServerHandler(pollUrl) {\n+                    @Override\n+                    protected Response serve(IHTTPSession session) {\n+                        orderedReqs.add(session.getUri());\n+                        return newFixedLengthResponse(LOGGED_IN_BODY);\n+                    }\n+                });\n+        HttpMessage testMsg = this.getHttpMessage(test);\n+        HttpMessage pollMsg = this.getHttpMessage(pollUrl);\n+\n+        method.setAuthCheckingStrategy(AuthCheckingStrategy.POLL_URL);\n+        method.setPollUrl(pollMsg.getRequestHeader().getURI().toString());\n+        method.setPollFrequencyUnits(AuthPollFrequencyUnits.REQUESTS);\n+        method.setPollFrequency(5);\n+        method.setLoggedInIndicatorPattern(LOGGED_IN_INDICATOR);\n+\n+        // When/Then\n+        assertThat(method.isAuthenticated(testMsg, null), is(true));\n+        assertThat(orderedReqs.size(), is(1));\n+        assertThat(orderedReqs.get(0), is(pollUrl));\n+    }\n+\n+    @Test\n+    public void shouldPollEveryFiveRequests() throws NullPointerException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU0MzY3OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/AuthenticationMethodPollUrlUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozODo1MFrOHwT7tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozODo1MFrOHwT7tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMDI3OA==", "bodyText": "Should not be needed.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520420278", "createdAt": "2020-11-10T09:38:50Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/AuthenticationMethodPollUrlUnitTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2013 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.authentication;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.parosproxy.paros.network.HttpRequestHeader;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+import org.zaproxy.zap.testutils.TestUtils;\n+\n+@ExtendWith(MockitoExtension.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU0NTQ0OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozOToxMFrOHwT8rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozOToxMFrOHwT8rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMDUyNA==", "bodyText": "Should not be needed.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520420524", "createdAt": "2020-11-10T09:39:10Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.authentication;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import java.io.IOException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.authentication.PostBasedAuthenticationMethodType.PostBasedAuthenticationMethod;\n+import org.zaproxy.zap.model.Context;\n+import org.zaproxy.zap.session.SessionManagementMethod;\n+import org.zaproxy.zap.session.WebSession;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+import org.zaproxy.zap.testutils.TestUtils;\n+import org.zaproxy.zap.users.User;\n+import org.zaproxy.zap.utils.I18N;\n+\n+@ExtendWith(MockitoExtension.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU0NTU1OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozOToxMlrOHwT8vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozOToxMlrOHwT8vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMDU0Mw==", "bodyText": "Better as instance variables.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520420543", "createdAt": "2020-11-10T09:39:12Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.authentication;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import java.io.IOException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.authentication.PostBasedAuthenticationMethodType.PostBasedAuthenticationMethod;\n+import org.zaproxy.zap.model.Context;\n+import org.zaproxy.zap.session.SessionManagementMethod;\n+import org.zaproxy.zap.session.WebSession;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+import org.zaproxy.zap.testutils.TestUtils;\n+import org.zaproxy.zap.users.User;\n+import org.zaproxy.zap.utils.I18N;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class FormBasedAuthenticationMethodTypeUnitTest extends TestUtils {\n+\n+    private static final String LOGGED_IN_INDICATOR = \"logged in\";\n+    private static final String LOGGED_IN_BODY =\n+            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \"\n+                    + \"Pellentesque auctor nulla id turpis placerat vulputate.\"\n+                    + LOGGED_IN_INDICATOR\n+                    + \" Proin tempor bibendum eros rutrum. \";\n+\n+    private AuthenticationMethod method;\n+    private FormBasedAuthenticationMethodType type;\n+    private static Context mockedContext;\n+    private static SessionManagementMethod mockedSessionManagementMethod;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU1MDM2OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0MDoxNFrOHwT_pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0MDoxNFrOHwT_pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMTI4Ng==", "bodyText": "Worth exposing a method, e.g. WithConfigsTest#setupConstant() instead of duplicating here.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520421286", "createdAt": "2020-11-10T09:40:14Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.authentication;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import java.io.IOException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.authentication.PostBasedAuthenticationMethodType.PostBasedAuthenticationMethod;\n+import org.zaproxy.zap.model.Context;\n+import org.zaproxy.zap.session.SessionManagementMethod;\n+import org.zaproxy.zap.session.WebSession;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+import org.zaproxy.zap.testutils.TestUtils;\n+import org.zaproxy.zap.users.User;\n+import org.zaproxy.zap.utils.I18N;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class FormBasedAuthenticationMethodTypeUnitTest extends TestUtils {\n+\n+    private static final String LOGGED_IN_INDICATOR = \"logged in\";\n+    private static final String LOGGED_IN_BODY =\n+            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \"\n+                    + \"Pellentesque auctor nulla id turpis placerat vulputate.\"\n+                    + LOGGED_IN_INDICATOR\n+                    + \" Proin tempor bibendum eros rutrum. \";\n+\n+    private AuthenticationMethod method;\n+    private FormBasedAuthenticationMethodType type;\n+    private static Context mockedContext;\n+    private static SessionManagementMethod mockedSessionManagementMethod;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU3NjAxOnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0NTo1N1rOHwUPIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0NTo1N1rOHwUPIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNTI1MQ==", "bodyText": "It could just mock it (instead of instantiate and spy), e.g.:\n    User user = mock(User.class);\n    given(user.getAuthenticationCredentials()).willReturn(new UsernamePasswordAuthenticationCredentials(...));\n    given(user.getContext()).willReturn(mockedContext);", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520425251", "createdAt": "2020-11-10T09:45:57Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/authentication/FormBasedAuthenticationMethodTypeUnitTest.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.authentication;\n+\n+import static fi.iki.elonen.NanoHTTPD.newFixedLengthResponse;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+import fi.iki.elonen.NanoHTTPD.IHTTPSession;\n+import fi.iki.elonen.NanoHTTPD.Response;\n+import java.io.IOException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.authentication.PostBasedAuthenticationMethodType.PostBasedAuthenticationMethod;\n+import org.zaproxy.zap.model.Context;\n+import org.zaproxy.zap.session.SessionManagementMethod;\n+import org.zaproxy.zap.session.WebSession;\n+import org.zaproxy.zap.testutils.NanoServerHandler;\n+import org.zaproxy.zap.testutils.TestUtils;\n+import org.zaproxy.zap.users.User;\n+import org.zaproxy.zap.utils.I18N;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class FormBasedAuthenticationMethodTypeUnitTest extends TestUtils {\n+\n+    private static final String LOGGED_IN_INDICATOR = \"logged in\";\n+    private static final String LOGGED_IN_BODY =\n+            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. \"\n+                    + \"Pellentesque auctor nulla id turpis placerat vulputate.\"\n+                    + LOGGED_IN_INDICATOR\n+                    + \" Proin tempor bibendum eros rutrum. \";\n+\n+    private AuthenticationMethod method;\n+    private FormBasedAuthenticationMethodType type;\n+    private static Context mockedContext;\n+    private static SessionManagementMethod mockedSessionManagementMethod;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;\n+\n+        type = new FormBasedAuthenticationMethodType();\n+        method = Mockito.mock(AuthenticationMethod.class, Mockito.CALLS_REAL_METHODS);\n+        method.setAuthCheckingStrategy(AuthCheckingStrategy.POLL_URL);\n+        method.setPollFrequencyUnits(AuthPollFrequencyUnits.REQUESTS);\n+        method.setPollFrequency(5);\n+        method.setLoggedInIndicatorPattern(LOGGED_IN_INDICATOR);\n+\n+        type = new FormBasedAuthenticationMethodType();\n+        Mockito.when(method.getType()).thenReturn(type);\n+\n+        // Make sure no actual message processing is done\n+        mockedSessionManagementMethod = Mockito.mock(SessionManagementMethod.class);\n+        doNothing()\n+                .when(mockedSessionManagementMethod)\n+                .processMessageToMatchSession((HttpMessage) any(), (WebSession) any());\n+\n+        mockedContext = Mockito.mock(Context.class);\n+        when(mockedContext.getSessionManagementMethod()).thenReturn(mockedSessionManagementMethod);\n+\n+        this.startServer();\n+    }\n+\n+    @AfterEach\n+    public void shutDownServer() throws Exception {\n+        stopServer();\n+    }\n+\n+    @Test\n+    public void shouldReplaceUsernameInPollRequest() throws NullPointerException, IOException {\n+        // Given\n+        String test = \"/shouldReplaceUsernameInPollRequest/test\";\n+        String encodedPattern =\n+                URLEncoder.encode(\n+                        PostBasedAuthenticationMethod.MSG_USER_PATTERN,\n+                        StandardCharsets.UTF_8.name());\n+        String pollUrl = \"/shouldReplaceUsernameInPollRequest/pollUrl\";\n+        String pollData = \"user=\" + PostBasedAuthenticationMethod.MSG_USER_PATTERN;\n+        String username = \"user\";\n+        final List<String> orderedReqUrls = new ArrayList<>();\n+        final List<String> orderedReqData = new ArrayList<>();\n+\n+        this.nano.addHandler(\n+                new NanoServerHandler(pollUrl.replace(encodedPattern, username)) {\n+                    @Override\n+                    protected Response serve(IHTTPSession session) {\n+                        orderedReqUrls.add(\n+                                session.getUri() + \"?\" + session.getQueryParameterString());\n+\n+                        HashMap<String, String> map = new HashMap<String, String>();\n+                        try {\n+                            session.parseBody(map);\n+                            orderedReqData.add(map.get(\"postData\"));\n+                        } catch (Exception e) {\n+                        }\n+                        return newFixedLengthResponse(LOGGED_IN_BODY);\n+                    }\n+                });\n+        HttpMessage testMsg = this.getHttpMessage(test);\n+        HttpMessage pollMsg = this.getHttpMessage(pollUrl + \"?\" + encodedPattern);\n+\n+        method.setPollUrl(pollMsg.getRequestHeader().getURI().toString());\n+        method.setPollData(pollData);\n+\n+        User user = spy(new User(0, \"user\"));\n+        user.setAuthenticationCredentials(\n+                new UsernamePasswordAuthenticationCredentials(username, \"\"));\n+        doReturn(mockedContext).when(user).getContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU4MTM4OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/extension/authentication/ExtensionAuthenticationUnitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0NzoxM1rOHwUSZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0NzoxM1rOHwUSZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjA4NQ==", "bodyText": "Should not be needed.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520426085", "createdAt": "2020-11-10T09:47:13Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/extension/authentication/ExtensionAuthenticationUnitTest.java", "diffHunk": "@@ -19,25 +19,49 @@\n  */\n package org.zaproxy.zap.extension.authentication;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.withSettings;\n \n+import java.util.Locale;\n import org.apache.commons.configuration.Configuration;\n import org.apache.commons.configuration.ConfigurationException;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.extension.ExtensionHook;\n+import org.parosproxy.paros.model.Model;\n+import org.zaproxy.zap.WithConfigsTest;\n+import org.zaproxy.zap.authentication.AuthenticationMethod;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthCheckingStrategy;\n+import org.zaproxy.zap.authentication.AuthenticationMethod.AuthPollFrequencyUnits;\n+import org.zaproxy.zap.authentication.FormBasedAuthenticationMethodType;\n+import org.zaproxy.zap.authentication.FormBasedAuthenticationMethodType.FormBasedAuthenticationMethod;\n import org.zaproxy.zap.model.Context;\n+import org.zaproxy.zap.utils.I18N;\n import org.zaproxy.zap.utils.ZapXmlConfiguration;\n \n /** Unit test for {@link ExtensionAuthentication}. */\n-class ExtensionAuthenticationUnitTest {\n+class ExtensionAuthenticationUnitTest extends WithConfigsTest {\n \n     private ExtensionAuthentication extensionAuthentication;\n \n     @BeforeEach\n     void setup() {\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU4ODk2OnYy", "diffSide": "RIGHT", "path": "zap/src/test/java/org/zaproxy/zap/testutils/TestUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0OTowNVrOHwUXFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0OTowNVrOHwUXFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNzI4NA==", "bodyText": "Worth renaming these to getContent, not just for HTML.", "url": "https://github.com/zaproxy/zaproxy/pull/6163#discussion_r520427284", "createdAt": "2020-11-10T09:49:05Z", "author": {"login": "thc202"}, "path": "zap/src/test/java/org/zaproxy/zap/testutils/TestUtils.java", "diffHunk": "@@ -61,4 +81,196 @@ protected Path getResourcePath(String resourcePath) {\n             throw new RuntimeException(e);\n         }\n     }\n+    /**\n+     * Starts the HTTP test server with a random port.\n+     *\n+     * <p>The port can be obtained with the method {@link HTTPDTestServer#getListeningPort()} from\n+     * the {@link #nano test server}.\n+     *\n+     * @throws IOException if an error occurred while starting the server.\n+     * @see #stopServer()\n+     */\n+    protected void startServer() throws IOException {\n+        startServer(getRandomPort());\n+    }\n+\n+    /**\n+     * Starts the HTTP test server with the specified port.\n+     *\n+     * <p>It's recommended to use {@link #startServer()} instead, using a fixed port might lead to\n+     * random failures when the port is already in use.\n+     *\n+     * @param port the port to listen to.\n+     * @throws IOException if an error occurred while starting the server.\n+     * @see #stopServer()\n+     */\n+    protected void startServer(int port) throws IOException {\n+        stopServer();\n+\n+        nano = new HTTPDTestServer(port);\n+        nano.start();\n+    }\n+\n+    private static int getRandomPort() throws IOException {\n+        try (ServerSocket server = new ServerSocket(0)) {\n+            return server.getLocalPort();\n+        }\n+    }\n+\n+    /**\n+     * Stops the HTTP test server.\n+     *\n+     * @see #startServer()\n+     */\n+    protected void stopServer() {\n+        if (nano == null) {\n+            return;\n+        }\n+        nano.stop();\n+    }\n+\n+    /**\n+     * Creates a (GET) HTTP message with the given path, for the {@link #nano test server}.\n+     *\n+     * <p>The response contains empty HTML tags, {@code <html></html>}.\n+     *\n+     * @param path the path component of the request-target, for example, {@code /dir/file.txt}.\n+     * @return the HTTP message, never {@code null}.\n+     * @throws IllegalStateException if the server was not {@link #startServer() started} prior\n+     *     calling this method.\n+     * @throws HttpMalformedHeaderException if an error occurred while creating the HTTP message.\n+     */\n+    protected HttpMessage getHttpMessage(String path) throws HttpMalformedHeaderException {\n+        return this.getHttpMessage(\"GET\", DEFAULT_CONTENT_TYPE, path, \"<html></html>\");\n+    }\n+\n+    /**\n+     * Creates a (GET) HTTP message with the given path, for the {@link #nano test server}.\n+     *\n+     * <p>The response contains empty HTML tags, {@code <html></html>}.\n+     *\n+     * @param path the path component of the request-target, for example, {@code /dir/file.txt}.\n+     * @return the HTTP message, never {@code null}.\n+     * @throws IllegalStateException if the server was not {@link #startServer() started} prior\n+     *     calling this method.\n+     * @throws HttpMalformedHeaderException if an error occurred while creating the HTTP message.\n+     */\n+    protected HttpMessage getHttpMessage(String path, String contentType)\n+            throws HttpMalformedHeaderException {\n+        return this.getHttpMessage(\"GET\", contentType, path, \"<html></html>\");\n+    }\n+\n+    /**\n+     * Creates a HTTP message with the given data, for the {@link #nano test server}.\n+     *\n+     * @param method the HTTP method.\n+     * @param path the path component of the request-target, for example, {@code /dir/file.txt}.\n+     * @param responseBody the body of the response.\n+     * @return the HTTP message, never {@code null}.\n+     * @throws IllegalStateException if the server was not {@link #startServer() started} prior\n+     *     calling this method.\n+     * @throws HttpMalformedHeaderException if an error occurred while creating the HTTP message.\n+     */\n+    protected HttpMessage getHttpMessage(String method, String path, String responseBody)\n+            throws HttpMalformedHeaderException {\n+        return getHttpMessage(method, DEFAULT_CONTENT_TYPE, path, responseBody);\n+    }\n+    /**\n+     * Creates a HTTP message with the given data, for the {@link #nano test server}.\n+     *\n+     * @param method the HTTP method.\n+     * @param contentType the Content-Type header\n+     * @param path the path component of the request-target, for example, {@code /dir/file.txt}.\n+     * @param responseBody the body of the response.\n+     * @return the HTTP message, never {@code null}.\n+     * @throws IllegalStateException if the server was not {@link #startServer() started} prior\n+     *     calling this method.\n+     * @throws HttpMalformedHeaderException if an error occurred while creating the HTTP message.\n+     */\n+    protected HttpMessage getHttpMessage(\n+            String method, String contentType, String path, String responseBody)\n+            throws HttpMalformedHeaderException {\n+        if (nano == null) {\n+            throw new IllegalStateException(\"The HTTP test server was not started.\");\n+        }\n+\n+        HttpMessage msg = new HttpMessage();\n+        StringBuilder reqHeaderSB = new StringBuilder();\n+        reqHeaderSB.append(method);\n+        reqHeaderSB.append(\" http://localhost:\");\n+        reqHeaderSB.append(nano.getListeningPort());\n+        reqHeaderSB.append(path);\n+        reqHeaderSB.append(\" HTTP/1.1\\r\\n\");\n+        reqHeaderSB.append(\"Host: localhost:\").append(nano.getListeningPort()).append(\"\\r\\n\");\n+        reqHeaderSB.append(\"User-Agent: ZAP\\r\\n\");\n+        reqHeaderSB.append(\"Pragma: no-cache\\r\\n\");\n+        msg.setRequestHeader(reqHeaderSB.toString());\n+\n+        msg.setResponseBody(responseBody);\n+\n+        StringBuilder respHeaderSB = new StringBuilder();\n+        respHeaderSB.append(\"HTTP/1.1 200 OK\\r\\n\");\n+        respHeaderSB.append(\"Server: Apache-Coyote/1.1\\r\\n\");\n+        respHeaderSB.append(\"Content-Type: \");\n+        respHeaderSB.append(contentType);\n+        respHeaderSB.append(\"\\r\\n\");\n+        respHeaderSB.append(\"Content-Length: \");\n+        respHeaderSB.append(msg.getResponseBody().length());\n+        respHeaderSB.append(\"\\r\\n\");\n+        msg.setResponseHeader(respHeaderSB.toString());\n+\n+        return msg;\n+    }\n+\n+    /**\n+     * Gets the contents of the file with the given path.\n+     *\n+     * @param resourcePath the path to the resource.\n+     * @return the contents of the file.\n+     * @see #getResourcePath(String)\n+     */\n+    public String getHtml(String resourcePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce12eba9c0385ba616a2143930f221e4e6b95652"}, "originalPosition": 187}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 635, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}