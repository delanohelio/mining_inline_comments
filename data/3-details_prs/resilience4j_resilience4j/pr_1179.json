{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyOTY4Mjk1", "number": 1179, "title": "Micronaut support final", "bodyText": "the merged final PR from the following 2 PRs :\n#1152 and #1140\n@RobWin  @pollend for ur final review\nI am going to push the missing package shortly", "createdAt": "2020-09-25T10:02:38Z", "url": "https://github.com/resilience4j/resilience4j/pull/1179", "merged": true, "mergeCommit": {"oid": "86f7868c0f523e7764ed121976d24483c19934a1"}, "closed": true, "closedAt": "2020-11-16T07:55:26Z", "author": {"login": "Romeh"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcttDuKAH2gAyNDkyOTY4Mjk1OmRiNzE4ZGZiOGYwNGZhMzA2NmZiOTg0ZmQ3MjAyMWYxZDNlMjEyYzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSvzjNgH2gAyNDkyOTY4Mjk1OjAyN2U1MzcwZGY3ZGRjNTQwYTRlYjVmYWNlOTg4OWM5ZGI0MDgzNTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "db718dfb8f04fa3066fb984fd72021f1d3e212c3", "author": {"user": {"login": "RobWin", "name": "Robert Winkler"}}, "url": "https://github.com/resilience4j/resilience4j/commit/db718dfb8f04fa3066fb984fd72021f1d3e212c3", "committedDate": "2020-06-22T09:02:28Z", "message": "Micronaut support (#1036)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c17948c5e2860dda68192b146546f43c3d43e1a", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/7c17948c5e2860dda68192b146546f43c3d43e1a", "committedDate": "2020-06-29T07:34:47Z", "message": "Added qualifier to resilience4j-micronaut to correct multiple resolved types (#1051)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6623abc15ea4c685edc1b6454d4191843200a12c", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/6623abc15ea4c685edc1b6454d4191843200a12c", "committedDate": "2020-08-12T06:52:23Z", "message": "Removed annotation mapper (#1104)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ab4e5d73df97788622c5ff1e64d92e6eeb81573", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/5ab4e5d73df97788622c5ff1e64d92e6eeb81573", "committedDate": "2020-09-02T03:50:45Z", "message": "cleanup and remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbe2a7ef11e6b1bc44b34db088bd9f55520316cc", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/bbe2a7ef11e6b1bc44b34db088bd9f55520316cc", "committedDate": "2020-09-03T22:09:28Z", "message": "clean up code and rename test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "419c6143c7342718917725b05b26254f3b3e75d1", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/419c6143c7342718917725b05b26254f3b3e75d1", "committedDate": "2020-09-14T19:53:51Z", "message": "remove http server for test and clean up imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c82679d6220153693cc533c8c994fd28496af44c", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/c82679d6220153693cc533c8c994fd28496af44c", "committedDate": "2020-09-14T23:24:06Z", "message": "simplify test and added coverage for timelimiter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62568873c933d9663ba4d8a317269a9d45859a1b", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/62568873c933d9663ba4d8a317269a9d45859a1b", "committedDate": "2020-09-24T12:06:57Z", "message": "Merge remote-tracking branch 'upstream/master' into micronaut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "031c90268a7ef2a67a32341dd34ecd3c37576cd5", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/031c90268a7ef2a67a32341dd34ecd3c37576cd5", "committedDate": "2020-09-25T09:49:41Z", "message": "Merge remote-tracking branch 'upstream/micronaut' into rework_cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/e00af2462a8f45c1ad1983e17249824c82a30dd3", "committedDate": "2020-09-25T12:40:42Z", "message": "update the package to include micronaut plus cleaning java doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MzEyMjQ2", "url": "https://github.com/resilience4j/resilience4j/pull/1179#pullrequestreview-497312246", "createdAt": "2020-09-28T08:55:14Z", "commit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1NToxNFrOHY0a_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDo1NVrOHY0ouw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ==", "bodyText": "@RobWin @pollend  is that right ?  i guess we need to wrap the call in bulkhead.executeCompletionStage not the result of the proceed ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786749", "createdAt": "2020-09-28T08:55:14Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw==", "bodyText": "Same comment as above ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786947", "createdAt": "2020-09-28T08:55:35Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng==", "bodyText": "why we are doing the process call here ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495788546", "createdAt": "2020-09-28T08:58:13Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = ThreadPoolBulkheadRegistry.class)\n+public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n+\n+    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n+                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+            return context.proceed();\n+        }\n+        final String name = opt.get().stringValue().orElse(\"default\");\n+        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw==", "bodyText": "why not wrapping the proceed call with circuitBreaker.executeCompletionStage()  ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789037", "createdAt": "2020-09-28T08:59:00Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTE1Mg==", "bodyText": "Same comment ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789152", "createdAt": "2020-09-28T08:59:11Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTQ1Mg==", "bodyText": "Same comment ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789452", "createdAt": "2020-09-28T08:59:41Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.ratelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterRegistry;\n+import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = RateLimiterRegistry.class)\n+public class RateLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n+    private final RateLimiterRegistry rateLimiterRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public RateLimiterInterceptor(BeanContext beanContext, RateLimiterRegistry rateLimiterRegistry) {\n+        this.rateLimiterRegistry = rateLimiterRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RATE_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.RateLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.RateLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"name\").orElse(\"default\");\n+        RateLimiter rateLimiter = this.rateLimiterRegistry.rateLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTU0Nw==", "bodyText": "Same ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789547", "createdAt": "2020-09-28T08:59:49Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.ratelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterRegistry;\n+import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = RateLimiterRegistry.class)\n+public class RateLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n+    private final RateLimiterRegistry rateLimiterRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public RateLimiterInterceptor(BeanContext beanContext, RateLimiterRegistry rateLimiterRegistry) {\n+        this.rateLimiterRegistry = rateLimiterRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RATE_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.RateLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.RateLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"name\").orElse(\"default\");\n+        RateLimiter rateLimiter = this.rateLimiterRegistry.rateLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(rateLimiter.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTc5Mg==", "bodyText": "Same ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789792", "createdAt": "2020-09-28T09:00:13Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+\n+    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n+        this.retryRegistry = retryRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RETRY.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n+        Retry retry = retryRegistry.retry(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTkwMQ==", "bodyText": "Same !?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789901", "createdAt": "2020-09-28T09:00:23Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+\n+    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n+        this.retryRegistry = retryRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RETRY.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n+        Retry retry = retryRegistry.retry(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(retry.executeCompletionStage(retryExecutorService, () -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDExNw==", "bodyText": "Same ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495790117", "createdAt": "2020-09-28T09:00:41Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.timelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.timelimiter.TimeLimiter;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = TimeLimiterRegistry.class)\n+public class TimeLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+\n+    private final TimeLimiterRegistry timeLimiterRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+    public TimeLimiterInterceptor(BeanContext beanContext, TimeLimiterRegistry timeLimiterRegistry) {\n+        this.beanContext = beanContext;\n+        this.timeLimiterRegistry = timeLimiterRegistry;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.TIME_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.TimeLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class).orElse(\"default\");\n+        TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDI2Nw==", "bodyText": "Same comment i guess", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495790267", "createdAt": "2020-09-28T09:00:55Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.timelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.timelimiter.TimeLimiter;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = TimeLimiterRegistry.class)\n+public class TimeLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+\n+    private final TimeLimiterRegistry timeLimiterRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+    public TimeLimiterInterceptor(BeanContext beanContext, TimeLimiterRegistry timeLimiterRegistry) {\n+        this.beanContext = beanContext;\n+        this.timeLimiterRegistry = timeLimiterRegistry;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.TIME_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.TimeLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class).orElse(\"default\");\n+        TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(timeLimiter.executeCompletionStage(timeLimiterExecutorService, () -> ((CompletableFuture<?>) result)), context);\n+\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MjQxODA1", "url": "https://github.com/resilience4j/resilience4j/pull/1179#pullrequestreview-498241805", "createdAt": "2020-09-29T08:42:06Z", "commit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwODo0MjowNlrOHZifXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwODo0NToyMlrOHZisAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MTUzNQ==", "bodyText": "Yes, correct.\nPlease see https://github.com/resilience4j/resilience4j/blob/master/resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java#L221-L230", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496541535", "createdAt": "2020-09-29T08:42:06Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MzU3Nw==", "bodyText": "No, here it's fine.\nA Publisher is emitting events, when someone subscribes.", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496543577", "createdAt": "2020-09-29T08:43:57Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDU4Mw==", "bodyText": "Method must be decorated, before it is executed.", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544583", "createdAt": "2020-09-29T08:45:04Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = ThreadPoolBulkheadRegistry.class)\n+public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n+\n+    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n+                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+            return context.proceed();\n+        }\n+        final String name = opt.get().stringValue().orElse(\"default\");\n+        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDc3MA==", "bodyText": "Same as above", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544770", "createdAt": "2020-09-29T08:45:22Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676da2d940165295c5e20a81e3076628c3e64961", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/676da2d940165295c5e20a81e3076628c3e64961", "committedDate": "2020-09-29T17:05:31Z", "message": "move proceed into excuteCompletionStage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "committedDate": "2020-09-29T18:01:49Z", "message": "enable event listening"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1f27f6b8e855b01a0e425d2265789223972eec0", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/c1f27f6b8e855b01a0e425d2265789223972eec0", "committedDate": "2020-09-29T19:41:19Z", "message": "tweak for flowable test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a774192bfd0b024b2b621237da37b7e936865d7", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/4a774192bfd0b024b2b621237da37b7e936865d7", "committedDate": "2020-09-29T19:42:10Z", "message": "Merge branch 'feature/flowable-test' into feature/tweak-completion-stage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "committedDate": "2020-09-29T21:30:52Z", "message": "correct flowable and exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd485881cad4f2d7d27f45ed4568fd2910fab95e", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/bd485881cad4f2d7d27f45ed4568fd2910fab95e", "committedDate": "2020-09-29T21:57:36Z", "message": "tweak intercept for fallback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1954c7335d322093e67bf5627178053dcf068edd", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/1954c7335d322093e67bf5627178053dcf068edd", "committedDate": "2020-09-29T22:04:29Z", "message": "correct recovery for threadpool bulkhead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e938994915810ec176d1091c682b90a05861082e", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/e938994915810ec176d1091c682b90a05861082e", "committedDate": "2020-10-01T19:12:34Z", "message": "bump"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58b991464c47c5584304f1c11517ff2e6c8bdc73", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/58b991464c47c5584304f1c11517ff2e6c8bdc73", "committedDate": "2020-10-02T08:04:51Z", "message": "Merge pull request #1183 from pollend/feature/tweak-completion-stage\n\nfeat(micronaut): update intercept and test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "386aa68ef63a85e682b28458e976e85258b4392d", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/386aa68ef63a85e682b28458e976e85258b4392d", "committedDate": "2020-10-06T19:24:44Z", "message": "remove duplicate code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a76a6800287e5b14de84b6cb6914f77925911a1b", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/a76a6800287e5b14de84b6cb6914f77925911a1b", "committedDate": "2020-10-06T19:28:06Z", "message": "clean up imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bc66e039d40f11730c3bc7640f268b4ac3fdc3a", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/6bc66e039d40f11730c3bc7640f268b4ac3fdc3a", "committedDate": "2020-10-06T19:37:38Z", "message": "correct javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "committedDate": "2020-10-06T19:56:57Z", "message": "correct bulkhead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "committedDate": "2020-10-06T20:11:58Z", "message": "add back null check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/be03fecd0850883f170896b9a0315e84fc308141", "committedDate": "2020-10-06T20:32:16Z", "message": "Merge pull request #1190 from pollend/feature/micronaut-fix-duplication\n\nlower code duplication for micronaut"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NDUyNTcw", "url": "https://github.com/resilience4j/resilience4j/pull/1179#pullrequestreview-504452570", "createdAt": "2020-10-08T06:06:47Z", "commit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNjo0OFrOHePNDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxODoxMlrOHePcdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2ODQyOQ==", "bodyText": "Increase to Micronaut 2.1.0 which is the current stable release", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501468429", "createdAt": "2020-10-08T06:06:48Z", "author": {"login": "graemerocher"}, "path": "libraries.gradle", "diffHunk": "@@ -32,6 +32,9 @@ ext {\n     kotlinCoroutinesVersion = '1.3.2'\n     springBootOpenFeignVersion = '2.2.2.RELEASE'\n     blockhoundVersion = '1.0.1.RELEASE'\n+    micronautVersion = '2.0.0.M3'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2ODYyNg==", "bodyText": "Should be testImplementation as testCompile is deprecated", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501468626", "createdAt": "2020-10-08T06:07:28Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/build.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+apply plugin: 'groovy'\n+repositories {\n+    maven { url \"https://repo.grails.org/grails/core\" }\n+    maven { url \"https://oss.jfrog.org/oss-snapshot-local\" }\n+}\n+dependencies {\n+    annotationProcessor(platform(libraries.micronaut))\n+    testAnnotationProcessor(platform(libraries.micronaut))\n+    implementation(platform(libraries.micronaut))\n+    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n+\n+    compileOnly \"io.micronaut:micronaut-http\"\n+    compileOnly \"io.micronaut:micronaut-http-server\"\n+    compileOnly \"io.micronaut:micronaut-aop\"\n+\n+    implementation \"io.micronaut:micronaut-validation\"\n+    implementation \"io.micronaut:micronaut-router\"\n+\n+    compileOnly project(':resilience4j-circuitbreaker')\n+    compileOnly project(':resilience4j-ratelimiter')\n+    compileOnly project(':resilience4j-timelimiter')\n+    compileOnly project(':resilience4j-retry')\n+    compileOnly project(':resilience4j-rxjava2')\n+    compileOnly project(':resilience4j-bulkhead')\n+    compileOnly project(':resilience4j-consumer')\n+    compile project(':resilience4j-framework-common')\n+\n+    testCompile project(':resilience4j-circuitbreaker')\n+    testCompile project(':resilience4j-ratelimiter')\n+    testCompile project(':resilience4j-timelimiter')\n+    testCompile project(':resilience4j-bulkhead')\n+    testCompile project(':resilience4j-retry')\n+    testCompile project(':resilience4j-rxjava2')\n+    testCompile project(':resilience4j-consumer')\n+    testCompile \"io.micronaut:micronaut-aop\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2ODcwMA==", "bodyText": "Should be testImplementation", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501468700", "createdAt": "2020-10-08T06:07:41Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/build.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+apply plugin: 'groovy'\n+repositories {\n+    maven { url \"https://repo.grails.org/grails/core\" }\n+    maven { url \"https://oss.jfrog.org/oss-snapshot-local\" }\n+}\n+dependencies {\n+    annotationProcessor(platform(libraries.micronaut))\n+    testAnnotationProcessor(platform(libraries.micronaut))\n+    implementation(platform(libraries.micronaut))\n+    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n+\n+    compileOnly \"io.micronaut:micronaut-http\"\n+    compileOnly \"io.micronaut:micronaut-http-server\"\n+    compileOnly \"io.micronaut:micronaut-aop\"\n+\n+    implementation \"io.micronaut:micronaut-validation\"\n+    implementation \"io.micronaut:micronaut-router\"\n+\n+    compileOnly project(':resilience4j-circuitbreaker')\n+    compileOnly project(':resilience4j-ratelimiter')\n+    compileOnly project(':resilience4j-timelimiter')\n+    compileOnly project(':resilience4j-retry')\n+    compileOnly project(':resilience4j-rxjava2')\n+    compileOnly project(':resilience4j-bulkhead')\n+    compileOnly project(':resilience4j-consumer')\n+    compile project(':resilience4j-framework-common')\n+\n+    testCompile project(':resilience4j-circuitbreaker')\n+    testCompile project(':resilience4j-ratelimiter')\n+    testCompile project(':resilience4j-timelimiter')\n+    testCompile project(':resilience4j-bulkhead')\n+    testCompile project(':resilience4j-retry')\n+    testCompile project(':resilience4j-rxjava2')\n+    testCompile project(':resilience4j-consumer')\n+    testCompile \"io.micronaut:micronaut-aop\"\n+\n+    testImplementation \"io.micronaut:micronaut-http-client\"\n+    testImplementation \"io.micronaut:micronaut-http-server-netty\"\n+\n+    testImplementation(libraries.micronaut_inject)\n+    testImplementation(libraries.micronaut_spock)\n+\n+    testImplementation \"cglib:cglib-nodep:3.3.0\"\n+    testImplementation \"org.objenesis:objenesis:3.1\"\n+\n+    testCompile(libraries.spock){\n+        exclude module:'groovy-all'\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MDYwNQ==", "bodyText": "For this, you may want to consider in Micronaut 2.1 using the new InterceptedMethod API which simplifies handling future/reactive/synchronous cases. See https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501470605", "createdAt": "2020-10-08T06:13:20Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.discovery.exceptions.NoAvailableServiceException;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+import io.reactivex.FlowableTransformer;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+public abstract class BaseInterceptor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTIxMQ==", "bodyText": "You may want to make these values relative to the built in values in Micronaut https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471211", "createdAt": "2020-10-08T06:14:53Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.mirconaut.retry.RetryInterceptor;\n+import io.micronaut.aop.Interceptor;\n+\n+/**\n+ * <p>{@link Interceptor} classes implement the {@link io.micronaut.core.order.Ordered} interface\n+ * in order to control the order of execution when multiple interceptors are present.</p>\n+ *\n+ * <p> This class provides a set of phases used for resilience4j</p>\n+ * <p>\n+ * The default order of phases are: <code>Retry ( CircuitBreaker ( RateLimiter ( TimeLimiter ( Bulkhead ( Function ) ) ) ) )</code>\n+ * The order places this at {@link RetryInterceptor} and before {@link io.micronaut.retry.intercept.RecoveryInterceptor}\n+ */\n+public enum ResilienceInterceptPhase {\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RETRY(-60),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    CIRCUIT_BREAKER(-55),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RATE_LIMITER(-50),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    TIME_LIMITER(-45),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    BULKHEAD(-40);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTU5MQ==", "bodyText": "For Micronaut 2.0 and above you will need to add @Executable meta annotation to these annotations", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471591", "createdAt": "2020-10-08T06:15:59Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.github.resilience4j.mirconaut.annotation;\n+\n+import io.github.resilience4j.mirconaut.bulkhead.BulkheadInterceptor;\n+import io.github.resilience4j.mirconaut.bulkhead.ThreadPoolBulkheadInterceptor;\n+import io.micronaut.aop.Around;\n+import io.micronaut.context.annotation.Type;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * This annotation can be applied to a class or a specific method. Applying it on a class is\n+ * equivalent to applying it on all its public methods.\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Target(value = {ElementType.METHOD, ElementType.TYPE})\n+@Around\n+@Type({BulkheadInterceptor.class, ThreadPoolBulkheadInterceptor.class})\n+@Documented\n+public @interface Bulkhead {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjM3NQ==", "bodyText": "This thread pool should be shutdown in a @PreDestroy method. Alternatively if you can use one of Micronaut's built in thread pools by injecting for example @Named(TasksExecutors.IO) ScheduledExecutorService executorService", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501472375", "createdAt": "2020-10-08T06:18:12Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18f44fd27466086da055aa6b931fece30838b614", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/18f44fd27466086da055aa6b931fece30838b614", "committedDate": "2020-10-08T06:22:52Z", "message": "Correct resilience4j-micronaut package name (#1195)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bad74de92dc11dfa15e502ece51804928844371b", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/bad74de92dc11dfa15e502ece51804928844371b", "committedDate": "2020-10-08T13:24:02Z", "message": "review comments for micronaut integration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73bb54660f3dde616d46a62904897316316b773a", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/73bb54660f3dde616d46a62904897316316b773a", "committedDate": "2020-10-08T13:33:26Z", "message": "review comments for micronaut integration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/2312e448c39790e37bc9c7493a4fde3ee68cc537", "committedDate": "2020-10-08T17:28:57Z", "message": "update intercept"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8df034e63c1060c89b38076d496b3605fd134f5f", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/8df034e63c1060c89b38076d496b3605fd134f5f", "committedDate": "2020-10-08T17:45:27Z", "message": "tweak to assignment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8670290e4bb5c3c8981b200adad0462b540a7481", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/8670290e4bb5c3c8981b200adad0462b540a7481", "committedDate": "2020-10-08T18:44:47Z", "message": "fix problem with test not running"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7943edc8eefdce244c09cc44a09ccb92111e65b8", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/7943edc8eefdce244c09cc44a09ccb92111e65b8", "committedDate": "2020-10-08T18:55:17Z", "message": "Merge pull request #1197 from pollend/feature/rework-intercept\n\nUpdate Micronaut intercept"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d87effab2edfdb3562814b63ee3cd373818ce879", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/d87effab2edfdb3562814b63ee3cd373818ce879", "committedDate": "2020-10-08T18:57:24Z", "message": "pump the versions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f643d71fe6eb6f51065303184e3e7f648be6129", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/1f643d71fe6eb6f51065303184e3e7f648be6129", "committedDate": "2020-10-08T19:21:36Z", "message": "Adding more test and reverting groovy version plus code imports optimziation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02b44886ca7309327d17ac828d135bdc8df911c7", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/02b44886ca7309327d17ac828d135bdc8df911c7", "committedDate": "2020-10-08T19:30:19Z", "message": "Adding more test and reverting groovy version plus code imports optimziation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acf680cfb9afa7dbb309caaabb577a872d30bcf5", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/acf680cfb9afa7dbb309caaabb577a872d30bcf5", "committedDate": "2020-10-08T19:37:25Z", "message": "Adding NULL test case for one of reactive types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51498b4046b0eab4d2a0f251463ccfa272adc939", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/51498b4046b0eab4d2a0f251463ccfa272adc939", "committedDate": "2020-10-08T19:40:00Z", "message": "rolling back wrong commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9544bd2a33074aa039d01e4ddfccc804a5bba578", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/9544bd2a33074aa039d01e4ddfccc804a5bba578", "committedDate": "2020-10-08T19:51:37Z", "message": "Logging formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MTE3OTQ5", "url": "https://github.com/resilience4j/resilience4j/pull/1179#pullrequestreview-505117949", "createdAt": "2020-10-08T19:54:31Z", "commit": {"oid": "9544bd2a33074aa039d01e4ddfccc804a5bba578"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxOTo1NDozMlrOHeuKig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxOTo1NDozMlrOHeuKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3NTY5MA==", "bodyText": "Should be implementation (or possibly 'api' with the java-library plugin applied)", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501975690", "createdAt": "2020-10-08T19:54:32Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/build.gradle", "diffHunk": "@@ -0,0 +1,57 @@\n+apply plugin: 'groovy'\n+repositories {\n+    maven { url \"https://repo.grails.org/grails/core\" }\n+    maven { url \"https://oss.jfrog.org/oss-snapshot-local\" }\n+}\n+dependencies {\n+    annotationProcessor(platform(libraries.micronaut))\n+    testAnnotationProcessor(platform(libraries.micronaut))\n+    implementation(platform(libraries.micronaut))\n+    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n+\n+    compileOnly \"io.micronaut:micronaut-http\"\n+    compileOnly \"io.micronaut:micronaut-http-server\"\n+    compileOnly \"io.micronaut:micronaut-aop\"\n+\n+    implementation \"io.micronaut:micronaut-validation\"\n+    implementation \"io.micronaut:micronaut-router\"\n+\n+    compileOnly project(':resilience4j-circuitbreaker')\n+    compileOnly project(':resilience4j-ratelimiter')\n+    compileOnly project(':resilience4j-timelimiter')\n+    compileOnly project(':resilience4j-retry')\n+    compileOnly project(':resilience4j-rxjava2')\n+    compileOnly project(':resilience4j-bulkhead')\n+    compileOnly project(':resilience4j-consumer')\n+    compile project(':resilience4j-framework-common')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9544bd2a33074aa039d01e4ddfccc804a5bba578"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "committedDate": "2020-10-08T23:17:27Z", "message": "feat(micronaut): add non recoverable test cases and replaced UnhandledFallbackException with micronaut Fallback Exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2ede431833cc8398edab494b9abb2cd4df51e1c", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/b2ede431833cc8398edab494b9abb2cd4df51e1c", "committedDate": "2020-10-08T23:57:11Z", "message": "add fallback spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2144e19cc341ba318423f01c7cdcad5f69765797", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/2144e19cc341ba318423f01c7cdcad5f69765797", "committedDate": "2020-10-09T00:37:20Z", "message": "correct stuck executor service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "544e72cebbf794061e684f45c062dce0c5a0a6bb", "author": {"user": {"login": "pollend", "name": "Michael Pollind"}}, "url": "https://github.com/resilience4j/resilience4j/commit/544e72cebbf794061e684f45c062dce0c5a0a6bb", "committedDate": "2020-10-09T00:46:24Z", "message": "update executor service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b4d95fc0c6676e897c6d6c8c0c6b6bc2e1263e0", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/3b4d95fc0c6676e897c6d6c8c0c6b6bc2e1263e0", "committedDate": "2020-10-09T08:35:36Z", "message": "Merge pull request #1198 from pollend/fix/add-more-test-cases\n\nfeat(micronaut): add non recoverable test cases and replaced UnhandledFallbackException with micronaut Fallback Exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36a8ef1d942206b472ef4e7fbbdff8d7f557a1c2", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/36a8ef1d942206b472ef4e7fbbdff8d7f557a1c2", "committedDate": "2020-10-09T09:04:31Z", "message": "merging thread pool and Bulkhead interceptors plus more exception handling."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14b6256c55329001f02868f570f22c8b4d5a3397", "author": {"user": {"login": "graemerocher", "name": "Graeme Rocher"}}, "url": "https://github.com/resilience4j/resilience4j/commit/14b6256c55329001f02868f570f22c8b4d5a3397", "committedDate": "2020-10-15T10:14:33Z", "message": "Use more idiomatic configuration / cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "027e5370df7ddc540a4eb5face9889c9db408352", "author": {"user": {"login": "Romeh", "name": "MRomeh"}}, "url": "https://github.com/resilience4j/resilience4j/commit/027e5370df7ddc540a4eb5face9889c9db408352", "committedDate": "2020-10-15T11:09:43Z", "message": "Merge pull request #1207 from graemerocher/micronaut_final\n\nMicronaut: Use more idiomatic configuration / cleanup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1793, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}