{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNDMzNzAy", "number": 1133, "title": "Fix ConcurrentModificationException in EventProcessor.", "bodyText": "Should address issue #1115 .", "createdAt": "2020-08-19T20:20:42Z", "url": "https://github.com/resilience4j/resilience4j/pull/1133", "merged": true, "mergeCommit": {"oid": "e431fe064467457e449536a8628fdc5211ba02f1"}, "closed": true, "closedAt": "2020-08-20T12:47:46Z", "author": {"login": "rulle-io"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAhgAsAH2gAyNDcwNDMzNzAyOmMzZTRkMWZiNzhhZDEwYzI3ZmY1ZDcyYTZlYzBiYmE1YjhhM2IwZDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAvo7ugFqTQ3MTU1ODA4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6", "committedDate": "2020-08-19T20:19:04Z", "message": "Changes to fix ConcurrentModificationException."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNDI3MzQy", "url": "https://github.com/resilience4j/resilience4j/pull/1133#pullrequestreview-471427342", "createdAt": "2020-08-20T09:39:38Z", "commit": {"oid": "c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozOTozOFrOHD3s1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozOTozOFrOHD3s1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMDM3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testOnEventParallel() throws ExecutionException {\n          \n          \n            \n                    EventProcessor<Number> eventProcessor = new EventProcessor<>();\n          \n          \n            \n                    EventConsumer<Integer> eventConsumer1 = event -> {\n          \n          \n            \n                        // Artificial delay in a listener's code\n          \n          \n            \n                        System.out.println(\"1\" + \"start\" + event.toString());\n          \n          \n            \n                        try {\n          \n          \n            \n                            Thread.sleep(10 * 1000L);\n          \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                            e.printStackTrace();\n          \n          \n            \n                        }\n          \n          \n            \n                        System.out.println(\"1\" + \"end\" + event.toString());\n          \n          \n            \n                    };\n          \n          \n            \n            \n          \n          \n            \n                    EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n          \n          \n            \n            \n          \n          \n            \n                    // 1st consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n          \n          \n            \n            \n          \n          \n            \n                    // process first event in a separate thread to create a race condition\n          \n          \n            \n                    CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n          \n          \n            \n                        eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        Thread.sleep(1 * 1000L);\n          \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    // 2nd consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        future.get();\n          \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                    } catch (ExecutionException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        throw e;\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                public void testOnEventParallel() throws ExecutionException, InterruptedException {\n          \n          \n            \n                    CountDownLatch eventConsumed = new CountDownLatch(1);\n          \n          \n            \n                    CountDownLatch waitForConsumerRegistration = new CountDownLatch(1);\n          \n          \n            \n            \n          \n          \n            \n                    EventProcessor<Number> eventProcessor = new EventProcessor<>();\n          \n          \n            \n                    EventConsumer<Integer> eventConsumer1 = event -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            eventConsumed.countDown();\n          \n          \n            \n                            waitForConsumerRegistration.await(5, TimeUnit.SECONDS);\n          \n          \n            \n                            logger.info(event.toString());\n          \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                            fail(\"Must not happen\");\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n            \n          \n          \n            \n                    EventConsumer<Integer> eventConsumer2 = event -> logger.info(event.toString());\n          \n          \n            \n            \n          \n          \n            \n                    // 1st consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n          \n          \n            \n            \n          \n          \n            \n                    // process first event in a separate thread to create a race condition\n          \n          \n            \n                    CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n          \n          \n            \n                        eventProcessor.processEvent(1); // blocks because of the count down latch\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    eventConsumed.await(1, TimeUnit.SECONDS);\n          \n          \n            \n            \n          \n          \n            \n                    // 2nd consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n          \n          \n            \n            \n          \n          \n            \n                    future.get();\n          \n          \n            \n            \n          \n          \n            \n                    waitForConsumerRegistration.countDown();\n          \n          \n            \n            \n          \n          \n            \n                    then(logger).should(times(1)).info(\"1\");\n          \n          \n            \n                }", "url": "https://github.com/resilience4j/resilience4j/pull/1133#discussion_r473820375", "createdAt": "2020-08-20T09:39:38Z", "author": {"login": "RobWin"}, "path": "resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java", "diffHunk": "@@ -107,4 +110,48 @@ public void testNoConsumers() {\n         assertThat(consumed).isEqualTo(false);\n     }\n \n+\n+    @Test\n+    public void testOnEventParallel() throws ExecutionException {\n+        EventProcessor<Number> eventProcessor = new EventProcessor<>();\n+        EventConsumer<Integer> eventConsumer1 = event -> {\n+            // Artificial delay in a listener's code\n+            System.out.println(\"1\" + \"start\" + event.toString());\n+            try {\n+                Thread.sleep(10 * 1000L);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            System.out.println(\"1\" + \"end\" + event.toString());\n+        };\n+\n+        EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n+\n+        // 1st consumer is added\n+        eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n+\n+        // process first event in a separate thread to create a race condition\n+        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+            eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n+        });\n+\n+        try {\n+            Thread.sleep(1 * 1000L);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+\n+        // 2nd consumer is added\n+        eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n+\n+        try {\n+            future.get();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        } catch (ExecutionException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70527a65d2e2419fdba55cbae4fc7d2fe3f8b5a5", "author": {"user": {"login": "rulle-io", "name": "Ruslan Altynnikov"}}, "url": "https://github.com/resilience4j/resilience4j/commit/70527a65d2e2419fdba55cbae4fc7d2fe3f8b5a5", "committedDate": "2020-08-20T11:30:58Z", "message": "Update resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java\n\nCo-authored-by: Robert Winkler <robwin@t-online.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "235081d0c32fd5c828d3a5b9c4e0ed8b83c8157b", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/235081d0c32fd5c828d3a5b9c4e0ed8b83c8157b", "committedDate": "2020-08-20T11:59:56Z", "message": "Add missing imports."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTU4MDg4", "url": "https://github.com/resilience4j/resilience4j/pull/1133#pullrequestreview-471558088", "createdAt": "2020-08-20T12:47:30Z", "commit": {"oid": "235081d0c32fd5c828d3a5b9c4e0ed8b83c8157b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1773, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}