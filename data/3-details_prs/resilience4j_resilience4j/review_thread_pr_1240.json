{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3MzgwNjk5", "number": 1240, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODowMjowOVrOE2pQzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQxOTo0ODo0MFrOE4_WSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzM0NjA1OnYy", "diffSide": "RIGHT", "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/RateLimiterOnDrainEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODowMjowOVrOHviy_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjowMDoyM1rOHxTbBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYxNTIyOA==", "bodyText": "DRAINED", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r519615228", "createdAt": "2020-11-09T08:02:09Z", "author": {"login": "RobWin"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/RateLimiterOnDrainEvent.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ *\n+ *  Copyright 2016 Robert Winkler and Bohdan Storozhuk\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter.event;\n+\n+public class RateLimiterOnDrainEvent extends AbstractRateLimiterEvent {\n+\n+    public RateLimiterOnDrainEvent(String rateLimiterName, int numberOfPermits) {\n+        super(rateLimiterName, numberOfPermits);\n+    }\n+\n+    @Override\n+    public Type getEventType() {\n+        return Type.SUCCESSFUL_ACQUIRE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcbd9308888200cd142c02c2d1967fed3648fb7a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2MDQ4NA==", "bodyText": "fixed", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r521460484", "createdAt": "2020-11-11T16:00:23Z", "author": {"login": "walec51"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/RateLimiterOnDrainEvent.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ *\n+ *  Copyright 2016 Robert Winkler and Bohdan Storozhuk\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter.event;\n+\n+public class RateLimiterOnDrainEvent extends AbstractRateLimiterEvent {\n+\n+    public RateLimiterOnDrainEvent(String rateLimiterName, int numberOfPermits) {\n+        super(rateLimiterName, numberOfPermits);\n+    }\n+\n+    @Override\n+    public Type getEventType() {\n+        return Type.SUCCESSFUL_ACQUIRE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYxNTIyOA=="}, "originalCommit": {"oid": "bcbd9308888200cd142c02c2d1967fed3648fb7a"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzM0NzA5OnYy", "diffSide": "RIGHT", "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/RateLimiterOnDrainEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODowMjozMlrOHvizmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwODowMjozMlrOHvizmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYxNTM4NA==", "bodyText": "RateLimiterOnDrainedEvent\nwdyt?", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r519615384", "createdAt": "2020-11-09T08:02:32Z", "author": {"login": "RobWin"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/event/RateLimiterOnDrainEvent.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ *\n+ *  Copyright 2016 Robert Winkler and Bohdan Storozhuk\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *\n+ */\n+package io.github.resilience4j.ratelimiter.event;\n+\n+public class RateLimiterOnDrainEvent extends AbstractRateLimiterEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcbd9308888200cd142c02c2d1967fed3648fb7a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MTkzNjExOnYy", "diffSide": "RIGHT", "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQxOTo0ODo0MFrOHzNOMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQwMTo0NDoxNVrOHzVnkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1NjA1MQ==", "bodyText": "Please don't change state directly, but use the same approach as in updateStateWithBackOff \n  \n    \n      resilience4j/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java\n    \n    \n         Line 157\n      in\n      a2534c5\n    \n    \n    \n    \n\n        \n          \n           private State updateStateWithBackOff(final int permits, final long timeoutInNanos) {", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r523456051", "createdAt": "2020-11-14T19:48:40Z", "author": {"login": "storozhukBM"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java", "diffHunk": "@@ -128,20 +129,34 @@ public long reservePermission(final int permits) {\n \n         boolean canAcquireImmediately = modifiedState.nanosToWait <= 0;\n         if (canAcquireImmediately) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return 0;\n         }\n \n         boolean canAcquireInTime = timeoutInNanos >= modifiedState.nanosToWait;\n         if (canAcquireInTime) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return modifiedState.nanosToWait;\n         }\n \n-        publishRateLimiterEvent(false, permits);\n+        publishRateLimiterAcquisitionEvent(false, permits);\n         return -1;\n     }\n \n+    @Override\n+    public void drainPermissions() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008426f1326eeb8b83f8297eae75e0ad35c58d98"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ2NzA3Mg==", "bodyText": "I don't think that is a good idea\nto drain the number of permits to zero precisely in a thread safe manner I have to read the number of permits left and subtract that amount in one atomic operation\nupdateStateWithBackOff doesn't do that - explain why using it would be better?", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r523467072", "createdAt": "2020-11-14T21:46:13Z", "author": {"login": "walec51"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java", "diffHunk": "@@ -128,20 +129,34 @@ public long reservePermission(final int permits) {\n \n         boolean canAcquireImmediately = modifiedState.nanosToWait <= 0;\n         if (canAcquireImmediately) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return 0;\n         }\n \n         boolean canAcquireInTime = timeoutInNanos >= modifiedState.nanosToWait;\n         if (canAcquireInTime) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return modifiedState.nanosToWait;\n         }\n \n-        publishRateLimiterEvent(false, permits);\n+        publishRateLimiterAcquisitionEvent(false, permits);\n         return -1;\n     }\n \n+    @Override\n+    public void drainPermissions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1NjA1MQ=="}, "originalCommit": {"oid": "008426f1326eeb8b83f8297eae75e0ad35c58d98"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ2ODgwMg==", "bodyText": "updateStateWithBackOff uses compareAndSwap operation, so it is atomic, consistent and will do completely fine.\ngetAndUpdate is also fine with one exception that it will reduce throughput of contended operations on state for Java 8 (starting from Java 9 it is fine), for additional details, please read the doc comment on updateStateWithBackOff method.", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r523468802", "createdAt": "2020-11-14T22:06:47Z", "author": {"login": "storozhukBM"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java", "diffHunk": "@@ -128,20 +129,34 @@ public long reservePermission(final int permits) {\n \n         boolean canAcquireImmediately = modifiedState.nanosToWait <= 0;\n         if (canAcquireImmediately) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return 0;\n         }\n \n         boolean canAcquireInTime = timeoutInNanos >= modifiedState.nanosToWait;\n         if (canAcquireInTime) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return modifiedState.nanosToWait;\n         }\n \n-        publishRateLimiterEvent(false, permits);\n+        publishRateLimiterAcquisitionEvent(false, permits);\n         return -1;\n     }\n \n+    @Override\n+    public void drainPermissions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1NjA1MQ=="}, "originalCommit": {"oid": "008426f1326eeb8b83f8297eae75e0ad35c58d98"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzU5MzYxOQ==", "bodyText": "reimplemented drain using compareAndSet\nplease check if this impl is ok for you\nI also added a unit test for an drain edge case", "url": "https://github.com/resilience4j/resilience4j/pull/1240#discussion_r523593619", "createdAt": "2020-11-15T01:44:15Z", "author": {"login": "walec51"}, "path": "resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java", "diffHunk": "@@ -128,20 +129,34 @@ public long reservePermission(final int permits) {\n \n         boolean canAcquireImmediately = modifiedState.nanosToWait <= 0;\n         if (canAcquireImmediately) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return 0;\n         }\n \n         boolean canAcquireInTime = timeoutInNanos >= modifiedState.nanosToWait;\n         if (canAcquireInTime) {\n-            publishRateLimiterEvent(true, permits);\n+            publishRateLimiterAcquisitionEvent(true, permits);\n             return modifiedState.nanosToWait;\n         }\n \n-        publishRateLimiterEvent(false, permits);\n+        publishRateLimiterAcquisitionEvent(false, permits);\n         return -1;\n     }\n \n+    @Override\n+    public void drainPermissions() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1NjA1MQ=="}, "originalCommit": {"oid": "008426f1326eeb8b83f8297eae75e0ad35c58d98"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4964, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}