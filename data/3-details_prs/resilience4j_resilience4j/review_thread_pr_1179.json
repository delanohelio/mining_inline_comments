{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyOTY4Mjk1", "number": 1179, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1NToxNFrOEn_A6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxOTo1NDozMlrOErxKHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzYyMzQ2OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1NToxNFrOHY0a_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0MToxOFrOHZ3fBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ==", "bodyText": "@RobWin @pollend  is that right ?  i guess we need to wrap the call in bulkhead.executeCompletionStage not the result of the proceed ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786749", "createdAt": "2020-09-28T08:55:14Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MTUzNQ==", "bodyText": "Yes, correct.\nPlease see https://github.com/resilience4j/resilience4j/blob/master/resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java#L221-L230", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496541535", "createdAt": "2020-09-29T08:42:06Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NTUwOQ==", "bodyText": "The result it is used in an executeCompletionStage on line 104. I write it to an object first to do a null check. so would it just execute the proceeded within the executeCompletionStage? if its null then it will error out right? I guess it shouldn't matter because it will still throw it back to the fallbackCompletable.\nreturn this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496885509", "createdAt": "2020-09-29T16:41:18Z", "author": {"login": "pollend"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzYyNDcxOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1NTozNVrOHY0bww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwODo0Mzo1N1rOHZinWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw==", "bodyText": "Same comment as above ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786947", "createdAt": "2020-09-28T08:55:35Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MzU3Nw==", "bodyText": "No, here it's fine.\nA Publisher is emitting events, when someone subscribes.", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496543577", "createdAt": "2020-09-29T08:43:57Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzYzNDgzOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1ODoxM1rOHY0iAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwODo0NTowNFrOHZirRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng==", "bodyText": "why we are doing the process call here ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495788546", "createdAt": "2020-09-28T08:58:13Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = ThreadPoolBulkheadRegistry.class)\n+public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n+\n+    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n+                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+            return context.proceed();\n+        }\n+        final String name = opt.get().stringValue().orElse(\"default\");\n+        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDU4Mw==", "bodyText": "Method must be decorated, before it is executed.", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544583", "createdAt": "2020-09-29T08:45:04Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = ThreadPoolBulkheadRegistry.class)\n+public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n+\n+    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n+                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+            return context.proceed();\n+        }\n+        final String name = opt.get().stringValue().orElse(\"default\");\n+        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzYzNzkxOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OTowMFrOHY0j7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwODo0NToyMlrOHZisAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw==", "bodyText": "why not wrapping the proceed call with circuitBreaker.executeCompletionStage()  ?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789037", "createdAt": "2020-09-28T08:59:00Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDc3MA==", "bodyText": "Same as above", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544770", "createdAt": "2020-09-29T08:45:22Z", "author": {"login": "RobWin"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw=="}, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzYzODYxOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OToxMVrOHY0kYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OToxMVrOHY0kYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTE1Mg==", "bodyText": "Same comment ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789152", "createdAt": "2020-09-28T08:59:11Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzY0MDUyOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OTo0MVrOHY0ljA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OTo0MVrOHY0ljA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTQ1Mg==", "bodyText": "Same comment ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789452", "createdAt": "2020-09-28T08:59:41Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.ratelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterRegistry;\n+import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = RateLimiterRegistry.class)\n+public class RateLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n+    private final RateLimiterRegistry rateLimiterRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public RateLimiterInterceptor(BeanContext beanContext, RateLimiterRegistry rateLimiterRegistry) {\n+        this.rateLimiterRegistry = rateLimiterRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RATE_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.RateLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.RateLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"name\").orElse(\"default\");\n+        RateLimiter rateLimiter = this.rateLimiterRegistry.rateLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzY0MTA2OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OTo0OVrOHY0l6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwODo1OTo0OVrOHY0l6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTU0Nw==", "bodyText": "Same ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789547", "createdAt": "2020-09-28T08:59:49Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ratelimiter/RateLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.ratelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.ratelimiter.RateLimiter;\n+import io.github.resilience4j.ratelimiter.RateLimiterRegistry;\n+import io.github.resilience4j.ratelimiter.operator.RateLimiterOperator;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = RateLimiterRegistry.class)\n+public class RateLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n+    private final RateLimiterRegistry rateLimiterRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public RateLimiterInterceptor(BeanContext beanContext, RateLimiterRegistry rateLimiterRegistry) {\n+        this.rateLimiterRegistry = rateLimiterRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RATE_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.RateLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.RateLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.RateLimiter.class, \"name\").orElse(\"default\");\n+        RateLimiter rateLimiter = this.rateLimiterRegistry.rateLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(rateLimiter.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzY0MjczOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDoxM1rOHY0m4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDoxM1rOHY0m4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTc5Mg==", "bodyText": "Same ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789792", "createdAt": "2020-09-28T09:00:13Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+\n+    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n+        this.retryRegistry = retryRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RETRY.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n+        Retry retry = retryRegistry.retry(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzY0MzQ0OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDoyM1rOHY0nTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDoyM1rOHY0nTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTkwMQ==", "bodyText": "Same !?", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789901", "createdAt": "2020-09-28T09:00:23Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+\n+    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n+        this.retryRegistry = retryRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.RETRY.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n+        Retry retry = retryRegistry.retry(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(retry.executeCompletionStage(retryExecutorService, () -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzY0NDgxOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDo0MVrOHY0oJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDo0MVrOHY0oJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDExNw==", "bodyText": "Same ?!", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495790117", "createdAt": "2020-09-28T09:00:41Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.timelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.timelimiter.TimeLimiter;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = TimeLimiterRegistry.class)\n+public class TimeLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+\n+    private final TimeLimiterRegistry timeLimiterRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+    public TimeLimiterInterceptor(BeanContext beanContext, TimeLimiterRegistry timeLimiterRegistry) {\n+        this.beanContext = beanContext;\n+        this.timeLimiterRegistry = timeLimiterRegistry;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.TIME_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.TimeLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class).orElse(\"default\");\n+        TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMzY0NTczOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDo1NVrOHY0ouw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwOTowMDo1NVrOHY0ouw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5MDI2Nw==", "bodyText": "Same comment i guess", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495790267", "createdAt": "2020-09-28T09:00:55Z", "author": {"login": "Romeh"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/timelimiter/TimeLimiterInterceptor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.timelimiter;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.timelimiter.TimeLimiter;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.transformer.TimeLimiterTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = TimeLimiterRegistry.class)\n+public class TimeLimiterInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+\n+    private final TimeLimiterRegistry timeLimiterRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService timeLimiterExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n+\n+    public TimeLimiterInterceptor(BeanContext beanContext, TimeLimiterRegistry timeLimiterRegistry) {\n+        this.beanContext = beanContext;\n+        this.timeLimiterRegistry = timeLimiterRegistry;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.TIME_LIMITER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.TimeLimiter>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.TimeLimiter.class).orElse(\"default\");\n+        TimeLimiter timeLimiter = this.timeLimiterRegistry.timeLimiter(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(timeLimiter.executeCompletionStage(timeLimiterExecutorService, () -> ((CompletableFuture<?>) result)), context);\n+\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA2Mjk4OnYy", "diffSide": "RIGHT", "path": "libraries.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNjo0OFrOHePNDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNjo0OFrOHePNDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2ODQyOQ==", "bodyText": "Increase to Micronaut 2.1.0 which is the current stable release", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501468429", "createdAt": "2020-10-08T06:06:48Z", "author": {"login": "graemerocher"}, "path": "libraries.gradle", "diffHunk": "@@ -32,6 +32,9 @@ ext {\n     kotlinCoroutinesVersion = '1.3.2'\n     springBootOpenFeignVersion = '2.2.2.RELEASE'\n     blockhoundVersion = '1.0.1.RELEASE'\n+    micronautVersion = '2.0.0.M3'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA2NDM1OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNzoyOFrOHePN0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNzoyOFrOHePN0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2ODYyNg==", "bodyText": "Should be testImplementation as testCompile is deprecated", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501468626", "createdAt": "2020-10-08T06:07:28Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/build.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+apply plugin: 'groovy'\n+repositories {\n+    maven { url \"https://repo.grails.org/grails/core\" }\n+    maven { url \"https://oss.jfrog.org/oss-snapshot-local\" }\n+}\n+dependencies {\n+    annotationProcessor(platform(libraries.micronaut))\n+    testAnnotationProcessor(platform(libraries.micronaut))\n+    implementation(platform(libraries.micronaut))\n+    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n+\n+    compileOnly \"io.micronaut:micronaut-http\"\n+    compileOnly \"io.micronaut:micronaut-http-server\"\n+    compileOnly \"io.micronaut:micronaut-aop\"\n+\n+    implementation \"io.micronaut:micronaut-validation\"\n+    implementation \"io.micronaut:micronaut-router\"\n+\n+    compileOnly project(':resilience4j-circuitbreaker')\n+    compileOnly project(':resilience4j-ratelimiter')\n+    compileOnly project(':resilience4j-timelimiter')\n+    compileOnly project(':resilience4j-retry')\n+    compileOnly project(':resilience4j-rxjava2')\n+    compileOnly project(':resilience4j-bulkhead')\n+    compileOnly project(':resilience4j-consumer')\n+    compile project(':resilience4j-framework-common')\n+\n+    testCompile project(':resilience4j-circuitbreaker')\n+    testCompile project(':resilience4j-ratelimiter')\n+    testCompile project(':resilience4j-timelimiter')\n+    testCompile project(':resilience4j-bulkhead')\n+    testCompile project(':resilience4j-retry')\n+    testCompile project(':resilience4j-rxjava2')\n+    testCompile project(':resilience4j-consumer')\n+    testCompile \"io.micronaut:micronaut-aop\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA2NDg4OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNzo0MVrOHePOHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjowNzo0MVrOHePOHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2ODcwMA==", "bodyText": "Should be testImplementation", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501468700", "createdAt": "2020-10-08T06:07:41Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/build.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+apply plugin: 'groovy'\n+repositories {\n+    maven { url \"https://repo.grails.org/grails/core\" }\n+    maven { url \"https://oss.jfrog.org/oss-snapshot-local\" }\n+}\n+dependencies {\n+    annotationProcessor(platform(libraries.micronaut))\n+    testAnnotationProcessor(platform(libraries.micronaut))\n+    implementation(platform(libraries.micronaut))\n+    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n+\n+    compileOnly \"io.micronaut:micronaut-http\"\n+    compileOnly \"io.micronaut:micronaut-http-server\"\n+    compileOnly \"io.micronaut:micronaut-aop\"\n+\n+    implementation \"io.micronaut:micronaut-validation\"\n+    implementation \"io.micronaut:micronaut-router\"\n+\n+    compileOnly project(':resilience4j-circuitbreaker')\n+    compileOnly project(':resilience4j-ratelimiter')\n+    compileOnly project(':resilience4j-timelimiter')\n+    compileOnly project(':resilience4j-retry')\n+    compileOnly project(':resilience4j-rxjava2')\n+    compileOnly project(':resilience4j-bulkhead')\n+    compileOnly project(':resilience4j-consumer')\n+    compile project(':resilience4j-framework-common')\n+\n+    testCompile project(':resilience4j-circuitbreaker')\n+    testCompile project(':resilience4j-ratelimiter')\n+    testCompile project(':resilience4j-timelimiter')\n+    testCompile project(':resilience4j-bulkhead')\n+    testCompile project(':resilience4j-retry')\n+    testCompile project(':resilience4j-rxjava2')\n+    testCompile project(':resilience4j-consumer')\n+    testCompile \"io.micronaut:micronaut-aop\"\n+\n+    testImplementation \"io.micronaut:micronaut-http-client\"\n+    testImplementation \"io.micronaut:micronaut-http-server-netty\"\n+\n+    testImplementation(libraries.micronaut_inject)\n+    testImplementation(libraries.micronaut_spock)\n+\n+    testImplementation \"cglib:cglib-nodep:3.3.0\"\n+    testImplementation \"org.objenesis:objenesis:3.1\"\n+\n+    testCompile(libraries.spock){\n+        exclude module:'groovy-all'\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA3NzE4OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxMzoyMFrOHePVjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxMzoyMFrOHePVjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MDYwNQ==", "bodyText": "For this, you may want to consider in Micronaut 2.1 using the new InterceptedMethod API which simplifies handling future/reactive/synchronous cases. See https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501470605", "createdAt": "2020-10-08T06:13:20Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.discovery.exceptions.NoAvailableServiceException;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+import io.reactivex.FlowableTransformer;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+public abstract class BaseInterceptor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA4MTUwOnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxNDo1M1rOHePX6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxNDo1M1rOHePX6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTIxMQ==", "bodyText": "You may want to make these values relative to the built in values in Micronaut https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471211", "createdAt": "2020-10-08T06:14:53Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.mirconaut.retry.RetryInterceptor;\n+import io.micronaut.aop.Interceptor;\n+\n+/**\n+ * <p>{@link Interceptor} classes implement the {@link io.micronaut.core.order.Ordered} interface\n+ * in order to control the order of execution when multiple interceptors are present.</p>\n+ *\n+ * <p> This class provides a set of phases used for resilience4j</p>\n+ * <p>\n+ * The default order of phases are: <code>Retry ( CircuitBreaker ( RateLimiter ( TimeLimiter ( Bulkhead ( Function ) ) ) ) )</code>\n+ * The order places this at {@link RetryInterceptor} and before {@link io.micronaut.retry.intercept.RecoveryInterceptor}\n+ */\n+public enum ResilienceInterceptPhase {\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RETRY(-60),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    CIRCUIT_BREAKER(-55),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RATE_LIMITER(-50),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    TIME_LIMITER(-45),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    BULKHEAD(-40);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA4NDE3OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxNTo1OVrOHePZZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxNTo1OVrOHePZZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTU5MQ==", "bodyText": "For Micronaut 2.0 and above you will need to add @Executable meta annotation to these annotations", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471591", "createdAt": "2020-10-08T06:15:59Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.github.resilience4j.mirconaut.annotation;\n+\n+import io.github.resilience4j.mirconaut.bulkhead.BulkheadInterceptor;\n+import io.github.resilience4j.mirconaut.bulkhead.ThreadPoolBulkheadInterceptor;\n+import io.micronaut.aop.Around;\n+import io.micronaut.context.annotation.Type;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * This annotation can be applied to a class or a specific method. Applying it on a class is\n+ * equivalent to applying it on all its public methods.\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Target(value = {ElementType.METHOD, ElementType.TYPE})\n+@Around\n+@Type({BulkheadInterceptor.class, ThreadPoolBulkheadInterceptor.class})\n+@Documented\n+public @interface Bulkhead {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDA4OTU1OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxODoxMlrOHePcdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxODoxMlrOHePcdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjM3NQ==", "bodyText": "This thread pool should be shutdown in a @PreDestroy method. Alternatively if you can use one of Micronaut's built in thread pools by injecting for example @Named(TasksExecutors.IO) ScheduledExecutorService executorService", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501472375", "createdAt": "2020-10-08T06:18:12Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be03fecd0850883f170896b9a0315e84fc308141"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzI5NjI4OnYy", "diffSide": "RIGHT", "path": "resilience4j-micronaut/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxOTo1NDozMlrOHeuKig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxOTo1NDozMlrOHeuKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3NTY5MA==", "bodyText": "Should be implementation (or possibly 'api' with the java-library plugin applied)", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501975690", "createdAt": "2020-10-08T19:54:32Z", "author": {"login": "graemerocher"}, "path": "resilience4j-micronaut/build.gradle", "diffHunk": "@@ -0,0 +1,57 @@\n+apply plugin: 'groovy'\n+repositories {\n+    maven { url \"https://repo.grails.org/grails/core\" }\n+    maven { url \"https://oss.jfrog.org/oss-snapshot-local\" }\n+}\n+dependencies {\n+    annotationProcessor(platform(libraries.micronaut))\n+    testAnnotationProcessor(platform(libraries.micronaut))\n+    implementation(platform(libraries.micronaut))\n+    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n+\n+    compileOnly \"io.micronaut:micronaut-http\"\n+    compileOnly \"io.micronaut:micronaut-http-server\"\n+    compileOnly \"io.micronaut:micronaut-aop\"\n+\n+    implementation \"io.micronaut:micronaut-validation\"\n+    implementation \"io.micronaut:micronaut-router\"\n+\n+    compileOnly project(':resilience4j-circuitbreaker')\n+    compileOnly project(':resilience4j-ratelimiter')\n+    compileOnly project(':resilience4j-timelimiter')\n+    compileOnly project(':resilience4j-retry')\n+    compileOnly project(':resilience4j-rxjava2')\n+    compileOnly project(':resilience4j-bulkhead')\n+    compileOnly project(':resilience4j-consumer')\n+    compile project(':resilience4j-framework-common')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9544bd2a33074aa039d01e4ddfccc804a5bba578"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 11, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}