{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5NDU1MzYy", "number": 1225, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwODozMDozOFrOEyO8cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwODozMDozOFrOEyO8cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMTA5MTA1OnYy", "diffSide": "RIGHT", "path": "resilience4j-cache/src/main/java/io/github/resilience4j/cache/CacheRegistryStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwODozMDozOFrOHowYzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMTozMjozM1rOHo3kAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ5Nzg3MQ==", "bodyText": "I think we should throw a custom exception:\nInstead of wrapping it in a RuntimeException or CacheException, we could define a CacheRegistryStoreException.", "url": "https://github.com/resilience4j/resilience4j/pull/1225#discussion_r512497871", "createdAt": "2020-10-27T08:30:38Z", "author": {"login": "RobWin"}, "path": "resilience4j-cache/src/main/java/io/github/resilience4j/cache/CacheRegistryStore.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package io.github.resilience4j.cache;\n+\n+import io.github.resilience4j.core.RegistryStore;\n+\n+import javax.cache.Cache;\n+import javax.cache.processor.EntryProcessor;\n+import javax.cache.processor.EntryProcessorException;\n+import javax.cache.processor.MutableEntry;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class CacheRegistryStore<E> implements RegistryStore<E> {\n+\n+    private final Cache<String, E> cacheStore;\n+\n+    public CacheRegistryStore(Cache<String, E> cacheStore) {\n+        this.cacheStore = cacheStore;\n+    }\n+\n+    @Override\n+    public E computeIfAbsent(String key, Function<? super String, ? extends E> mappingFunction) {\n+        try {\n+            return cacheStore.invoke(key, new AtomicComputeProcessor<>(), mappingFunction);\n+        } catch (EntryProcessorException e) {\n+            throw new RuntimeException(e.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "215af1f86683b5000cf0115da5102df4f618a90c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxMjY4Mw==", "bodyText": "Thanks for the review!\nI didn't create a new type to keep the behavior in sync with the in-memory store that throws underlying ConcurrentHashMap exception type: \n  \n    \n      resilience4j/resilience4j-core/src/main/java/io/github/resilience4j/core/registry/InMemoryRegistryStore.java\n    \n    \n         Line 35\n      in\n      3dc2ead\n    \n    \n    \n    \n\n        \n          \n           this.entryMap = new ConcurrentHashMap<>(); \n        \n    \n  \n\n\nDo you think it makes sense to create a RegistryStoreException that can be used by all store implementations?", "url": "https://github.com/resilience4j/resilience4j/pull/1225#discussion_r512612683", "createdAt": "2020-10-27T11:27:37Z", "author": {"login": "laksnv"}, "path": "resilience4j-cache/src/main/java/io/github/resilience4j/cache/CacheRegistryStore.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package io.github.resilience4j.cache;\n+\n+import io.github.resilience4j.core.RegistryStore;\n+\n+import javax.cache.Cache;\n+import javax.cache.processor.EntryProcessor;\n+import javax.cache.processor.EntryProcessorException;\n+import javax.cache.processor.MutableEntry;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class CacheRegistryStore<E> implements RegistryStore<E> {\n+\n+    private final Cache<String, E> cacheStore;\n+\n+    public CacheRegistryStore(Cache<String, E> cacheStore) {\n+        this.cacheStore = cacheStore;\n+    }\n+\n+    @Override\n+    public E computeIfAbsent(String key, Function<? super String, ? extends E> mappingFunction) {\n+        try {\n+            return cacheStore.invoke(key, new AtomicComputeProcessor<>(), mappingFunction);\n+        } catch (EntryProcessorException e) {\n+            throw new RuntimeException(e.getCause());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ5Nzg3MQ=="}, "originalCommit": {"oid": "215af1f86683b5000cf0115da5102df4f618a90c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYxNTQyNA==", "bodyText": "@throws RuntimeException or Error if the remappingFunction does so, in which case the mapping is unchanged\n\n\nYes, you are right. Then let's keep it as it is.", "url": "https://github.com/resilience4j/resilience4j/pull/1225#discussion_r512615424", "createdAt": "2020-10-27T11:32:33Z", "author": {"login": "RobWin"}, "path": "resilience4j-cache/src/main/java/io/github/resilience4j/cache/CacheRegistryStore.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package io.github.resilience4j.cache;\n+\n+import io.github.resilience4j.core.RegistryStore;\n+\n+import javax.cache.Cache;\n+import javax.cache.processor.EntryProcessor;\n+import javax.cache.processor.EntryProcessorException;\n+import javax.cache.processor.MutableEntry;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class CacheRegistryStore<E> implements RegistryStore<E> {\n+\n+    private final Cache<String, E> cacheStore;\n+\n+    public CacheRegistryStore(Cache<String, E> cacheStore) {\n+        this.cacheStore = cacheStore;\n+    }\n+\n+    @Override\n+    public E computeIfAbsent(String key, Function<? super String, ? extends E> mappingFunction) {\n+        try {\n+            return cacheStore.invoke(key, new AtomicComputeProcessor<>(), mappingFunction);\n+        } catch (EntryProcessorException e) {\n+            throw new RuntimeException(e.getCause());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ5Nzg3MQ=="}, "originalCommit": {"oid": "215af1f86683b5000cf0115da5102df4f618a90c"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 33, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}