{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzA5NDc2", "number": 1093, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozODo1OVrOERrcng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjoxMTo1OFrOEZztAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTczMDg2OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/build.gradle", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozODo1OVrOG2hlmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNToyMzo1MlrOG49v6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw==", "bodyText": "I think these should be compileOnly.\nThere are users who doesn't use reactor or webflux.\nWhat do you think?", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r459826587", "createdAt": "2020-07-24T02:38:59Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1MTA0NQ==", "bodyText": "I see your point.. rxjava is already part of testCompile.  I could use Flowable instead of FLUX (thus webflux).\nrxjava is anyway part of the manifest of springboot2.  Would that be OK ?", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r460351045", "createdAt": "2020-07-25T02:04:58Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3ODI1OQ==", "bodyText": "resilience4j should not have any optional dependencies like RxJava or Reactor.\nFlowable also cannot be used because rxjava is only used in test.\nI think SSE endpoint should be only enabled when Flux exists by ConditionalOnClass(Flux.class).", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r460378259", "createdAt": "2020-07-25T07:46:22Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMzQ1Nw==", "bodyText": "makes sense to me. will let you know once the changes are done.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r460413457", "createdAt": "2020-07-25T15:05:27Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxMDk5Ng==", "bodyText": "Updated it with conditiononclass", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r460610996", "createdAt": "2020-07-27T02:06:10Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MjAzOQ==", "bodyText": "Need to be compileOnly. Please change these :)", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462372039", "createdAt": "2020-07-29T15:06:10Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM4NTEzMA==", "bodyText": "done.  @dlsrb6342 . Thank you", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462385130", "createdAt": "2020-07-29T15:23:52Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTczMTY4OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOToyM1rOG2hmDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMzowMToyM1rOG2udOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjcwMg==", "bodyText": "Is this needed?", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r459826702", "createdAt": "2020-07-24T02:39:23Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)\n+    compileOnly(libraries.rxjava2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAzNzQzMg==", "bodyText": "you are right. I forgot to remove this at the end. Will remove", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r460037432", "createdAt": "2020-07-24T13:01:23Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)\n+    compileOnly(libraries.rxjava2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjcwMg=="}, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Njg4MzExOnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/build.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NDo0NlrOG4-qOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjoyOTo1M1rOG5AiYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDA1OA==", "bodyText": "This also need to be compileOnly.\nThe users who doesn't use reactor don't want to have this dependency.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462400058", "createdAt": "2020-07-29T15:44:46Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,7 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzMDI3Nw==", "bodyText": "i see. made changes. thanks for correcting.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462430277", "createdAt": "2020-07-29T16:29:07Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,7 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDA1OA=="}, "originalCommit": {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzMDgxNw==", "bodyText": "@dlsrb6342", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462430817", "createdAt": "2020-07-29T16:29:53Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,7 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDA1OA=="}, "originalCommit": {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODY4ODI5OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODoyN1rOG5P-vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODoyN1rOG5P-vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MzgzNw==", "bodyText": "I think this doesn't need to be checked.\nCircuitBreakerRegistry create or get when you request a circuitbreaker.\nTherefore, it cannot be null, and it must be the same as the requested name.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462683837", "createdAt": "2020-07-30T01:38:27Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (circuitBreaker == null && !circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODY4ODg4OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODo1MFrOG5P_Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODo1MFrOG5P_Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MzkzNA==", "bodyText": "I think this doesn't need to be checked.\nCircuitBreakerRegistry create or get when you request a circuitbreaker.\nTherefore, it cannot be null, and it must be the same as the requested name.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462683934", "createdAt": "2020-07-30T01:38:50Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventDTOFactory;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.Function;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams.\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ */\n+\n+@Endpoint(id = \"stream-circuitbreaker-events\")\n+public class CircuitBreakerServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerServerSideEvent() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return Flux.merge(eventStreams).map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent))\n+            .build()\n+        );\n+    }\n+\n+    private Function<CircuitBreakerEvent, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();\n+        return cbEvent -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    CircuitBreakerEventDTOFactory.createCircuitBreakerEventDTO(cbEvent)\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (circuitBreaker == null && !circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODcxNDE5OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1Mjo1MlrOG5QOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1Mjo1MlrOG5QOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4NzgyOQ==", "bodyText": "Can be moved to class member variable.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462687829", "createdAt": "2020-07-30T01:52:52Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventDTOFactory;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.Function;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams.\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ */\n+\n+@Endpoint(id = \"stream-circuitbreaker-events\")\n+public class CircuitBreakerServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerServerSideEvent() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return Flux.merge(eventStreams).map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent))\n+            .build()\n+        );\n+    }\n+\n+    private Function<CircuitBreakerEvent, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODcyNTM2OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1ODo1M1rOG5QU2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1ODo1M1rOG5QU2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4OTQ5Ng==", "bodyText": "Can be moved to class member variable.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462689496", "createdAt": "2020-07-30T01:58:53Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTIyNzkwOnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTo0Njo1NVrOG8gV3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDo1MTowMlrOG9ndeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NzYyOQ==", "bodyText": "I think this property isn't needed because SSE can be controlled with management.endpoints.stream-circuitbreaker-events.exposure.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r466097629", "createdAt": "2020-08-06T01:46:55Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.circuitbreaker.autoconfigure;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixServerSideEvent;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerServerSideEvent;\n+import io.github.resilience4j.reactor.adapter.ReactorAdapter;\n+import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnAvailableEndpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import reactor.core.publisher.Flux;\n+\n+@Configuration\n+@ConditionalOnClass({CircuitBreaker.class, Endpoint.class})\n+@AutoConfigureAfter(CircuitBreakerAutoConfiguration.class)\n+@ConditionalOnProperty(value = \"resilience4j.circuitBreaker.stream.event.enabled\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2Mjg0Mg==", "bodyText": "Agreed. Removed the property\nTested locally with \"management.endpoints.web.exposure.exclude: stream-circuitbreaker-events\"", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r467262842", "createdAt": "2020-08-07T20:51:02Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.circuitbreaker.autoconfigure;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixServerSideEvent;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerServerSideEvent;\n+import io.github.resilience4j.reactor.adapter.ReactorAdapter;\n+import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnAvailableEndpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import reactor.core.publisher.Flux;\n+\n+@Configuration\n+@ConditionalOnClass({CircuitBreaker.class, Endpoint.class})\n+@AutoConfigureAfter(CircuitBreakerAutoConfiguration.class)\n+@ConditionalOnProperty(value = \"resilience4j.circuitBreaker.stream.event.enabled\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NzYyOQ=="}, "originalCommit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTIzNDI2OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTo1MDozNFrOG8gZfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDo0OTo0NFrOG9nbMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5ODU1OQ==", "bodyText": "If you make CircuitBreaker from CircuitBreakerRegistry with name, it always have the name that you requested.\nYou don't need to check. I think you can get CircuitBreaker from registry directly not with this function.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r466098559", "createdAt": "2020-08-06T01:50:34Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.stereotype.Component;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final ObjectMapper jsonMapper = new ObjectMapper();\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (!circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MjI1OQ==", "bodyText": "yeap. makes sense. pushed my changes", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r467262259", "createdAt": "2020-08-07T20:49:44Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.stereotype.Component;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final ObjectMapper jsonMapper = new ObjectMapper();\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (!circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5ODU1OQ=="}, "originalCommit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTMxOTY5OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToxMFrOG__uww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToxMFrOG__uww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzYzNQ==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757635", "createdAt": "2020-08-13T07:41:10Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTMyMDA1OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToxNVrOG__u9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToxNVrOG__u9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzY4Nw==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757687", "createdAt": "2020-08-13T07:41:15Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assert (events.size() == 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTMyMDI4OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToyMFrOG__vFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToyMFrOG__vFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzcxOA==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757718", "createdAt": "2020-08-13T07:41:20Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assert (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTMyMTg1OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MTo0M1rOG__wAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MTo0M1rOG__wAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1Nzk1Mw==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757953", "createdAt": "2020-08-13T07:41:43Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjcyMTkwOnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDowMjoyNlrOHAM-ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToxNzowMFrOHAQU8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA==", "bodyText": "Assertj has a fluent API. You have to do\nassertThat(events.size()).isEqulTo(1);", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469974634", "createdAt": "2020-08-13T14:02:26Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyOTQwMg==", "bodyText": "Oh.. yeah. I see.. I updated it and pushed it", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r470029402", "createdAt": "2020-08-13T15:16:46Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA=="}, "originalCommit": {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyOTU1Mw==", "bodyText": "@RobWin", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r470029553", "createdAt": "2020-08-13T15:17:00Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA=="}, "originalCommit": {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDg0OTE4OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MjoyOFrOHC0wAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MjoyOFrOHC0wAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzQ1Nw==", "bodyText": "Waiting between calls should not be necessary", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723457", "createdAt": "2020-08-19T05:42:28Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDg0OTU0OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MjozNFrOHC0wRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxNTo1NjozMlrOHFOECw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzUyNA==", "bodyText": "Waiting between calls should not be necessary", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723524", "createdAt": "2020-08-19T05:42:34Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzNTMzOQ==", "bodyText": "Removed it", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475235339", "createdAt": "2020-08-23T15:56:32Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzUyNA=="}, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDg0OTc0OnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MjozN1rOHC0wZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxNTo0MToxMFrOHFN9_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzU1OA==", "bodyText": "Waiting between calls should not be necessary", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723558", "createdAt": "2020-08-19T05:42:37Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzMzc4OQ==", "bodyText": "resolved it", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475233789", "createdAt": "2020-08-23T15:41:10Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzU1OA=="}, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDk2OTIxOnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjoxMTo0OVrOHC1-oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOTozOTo1OVrOHGQIrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA==", "bodyText": "Is it possible to use the WebTestClient  here?\nHere is a guide how to use the WebTestClient for streaming responses:\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/testing-webtestclient.pdf\nThen please use the StepVerifier to subscribe to the stream and verify that the streams emits one event.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472743584", "createdAt": "2020-08-19T06:11:49Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzODUxNg==", "bodyText": "WebTestClient on streaming events throws  Timeout on blocking read for 3600 MILLISECOND on exchage()\nmethod. Tried increasing the timeout and everything ..   Googling reveals that this might be a bug for integration tests\n(where  the test written pointing to localhost) thought pointing against Controller class works well.\n\n\n https://github.com/spring-projects/spring-boot/issues/9992. \n\n\n\nThe Thread.Sleep thats needed for subscription  is due to the  difficult to simultaneously publish  the events and  subscribe. Thread.sleep is the hack to make subscribe wait without blocking the pub sub model.  I tried making asyc way of publishing but co ordination b/w  pub and sub is not working consistently. Thread.sleep works all the time so  committed my changes again with some refactoring. Please take a look. I am documenting the observation here so that if anyone has better idea can come up with the solution.\n@RobWin", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475238516", "createdAt": "2020-08-23T16:28:25Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA=="}, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzg2OA==", "bodyText": "Yes, I think the problem is that .exchange() is blocking :(\nInternally it's doing\nClientResponse clientResponse = this.bodySpec.exchange().block(getTimeout());\n\nBecause of some reason there is no clientResponse within that timeout period.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r476317868", "createdAt": "2020-08-25T09:39:59Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA=="}, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDk2OTYyOnYy", "diffSide": "RIGHT", "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjoxMTo1OFrOHC1-7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxNjoyODo0MFrOHFOQnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzY2Mg==", "bodyText": "Is it possible to use the WebTestClient here?\nHere is a guide how to use the WebTestClient for streaming responses:\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/testing-webtestclient.pdf\nThen please use the StepVerifier to subscribe to the stream and verify that the streams emits one event.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472743662", "createdAt": "2020-08-19T06:11:58Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (circuitBreakerEventsAfter.getCircuitBreakerEvents().size()).isGreaterThan(0);\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // pause 1 sec to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIzODU1Ng==", "bodyText": "same a above comment", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r475238556", "createdAt": "2020-08-23T16:28:40Z", "author": {"login": "vijaycse"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (circuitBreakerEventsAfter.getCircuitBreakerEvents().size()).isGreaterThan(0);\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // pause 1 sec to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzY2Mg=="}, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4986, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}