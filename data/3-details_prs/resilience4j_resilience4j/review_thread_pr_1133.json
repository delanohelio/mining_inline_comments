{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNDMzNzAy", "number": 1133, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozOTozOFrOEacDDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozOTozOFrOEacDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MTU3OTY0OnYy", "diffSide": "RIGHT", "path": "resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozOTozOFrOHD3s1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwOTozOTozOFrOHD3s1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMDM3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testOnEventParallel() throws ExecutionException {\n          \n          \n            \n                    EventProcessor<Number> eventProcessor = new EventProcessor<>();\n          \n          \n            \n                    EventConsumer<Integer> eventConsumer1 = event -> {\n          \n          \n            \n                        // Artificial delay in a listener's code\n          \n          \n            \n                        System.out.println(\"1\" + \"start\" + event.toString());\n          \n          \n            \n                        try {\n          \n          \n            \n                            Thread.sleep(10 * 1000L);\n          \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                            e.printStackTrace();\n          \n          \n            \n                        }\n          \n          \n            \n                        System.out.println(\"1\" + \"end\" + event.toString());\n          \n          \n            \n                    };\n          \n          \n            \n            \n          \n          \n            \n                    EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n          \n          \n            \n            \n          \n          \n            \n                    // 1st consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n          \n          \n            \n            \n          \n          \n            \n                    // process first event in a separate thread to create a race condition\n          \n          \n            \n                    CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n          \n          \n            \n                        eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        Thread.sleep(1 * 1000L);\n          \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    // 2nd consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        future.get();\n          \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                    } catch (ExecutionException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        throw e;\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                public void testOnEventParallel() throws ExecutionException, InterruptedException {\n          \n          \n            \n                    CountDownLatch eventConsumed = new CountDownLatch(1);\n          \n          \n            \n                    CountDownLatch waitForConsumerRegistration = new CountDownLatch(1);\n          \n          \n            \n            \n          \n          \n            \n                    EventProcessor<Number> eventProcessor = new EventProcessor<>();\n          \n          \n            \n                    EventConsumer<Integer> eventConsumer1 = event -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            eventConsumed.countDown();\n          \n          \n            \n                            waitForConsumerRegistration.await(5, TimeUnit.SECONDS);\n          \n          \n            \n                            logger.info(event.toString());\n          \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                            fail(\"Must not happen\");\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n            \n          \n          \n            \n                    EventConsumer<Integer> eventConsumer2 = event -> logger.info(event.toString());\n          \n          \n            \n            \n          \n          \n            \n                    // 1st consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n          \n          \n            \n            \n          \n          \n            \n                    // process first event in a separate thread to create a race condition\n          \n          \n            \n                    CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n          \n          \n            \n                        eventProcessor.processEvent(1); // blocks because of the count down latch\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    eventConsumed.await(1, TimeUnit.SECONDS);\n          \n          \n            \n            \n          \n          \n            \n                    // 2nd consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n          \n          \n            \n            \n          \n          \n            \n                    future.get();\n          \n          \n            \n            \n          \n          \n            \n                    waitForConsumerRegistration.countDown();\n          \n          \n            \n            \n          \n          \n            \n                    then(logger).should(times(1)).info(\"1\");\n          \n          \n            \n                }", "url": "https://github.com/resilience4j/resilience4j/pull/1133#discussion_r473820375", "createdAt": "2020-08-20T09:39:38Z", "author": {"login": "RobWin"}, "path": "resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java", "diffHunk": "@@ -107,4 +110,48 @@ public void testNoConsumers() {\n         assertThat(consumed).isEqualTo(false);\n     }\n \n+\n+    @Test\n+    public void testOnEventParallel() throws ExecutionException {\n+        EventProcessor<Number> eventProcessor = new EventProcessor<>();\n+        EventConsumer<Integer> eventConsumer1 = event -> {\n+            // Artificial delay in a listener's code\n+            System.out.println(\"1\" + \"start\" + event.toString());\n+            try {\n+                Thread.sleep(10 * 1000L);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            System.out.println(\"1\" + \"end\" + event.toString());\n+        };\n+\n+        EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n+\n+        // 1st consumer is added\n+        eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n+\n+        // process first event in a separate thread to create a race condition\n+        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+            eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n+        });\n+\n+        try {\n+            Thread.sleep(1 * 1000L);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+\n+        // 2nd consumer is added\n+        eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n+\n+        try {\n+            future.get();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        } catch (ExecutionException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4996, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}