{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NTA3Nzc2", "number": 865, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoyMToyNFrODfdAOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoyMToyNFrODfdAOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzA3NjQxOnYy", "diffSide": "RIGHT", "path": "resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/timelimiter/TimeLimiterMethodInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODoyMToyNFrOFpKh7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMjo1ODowMFrOFpqU8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwODQ2Mw==", "bodyText": "In our Spring Boot TimeLimiterAspect we throw an exception if the return type is not supported.\nWe currently do not support a usage of the @TimeLimiter annotation and a basic return types.\nIt could be somehow confusing to a developer that the method is \"implicitly\" executed in a thread pool, but the thread is blocking. I think it would be better if the developer decides it explicitly and uses a  @Bulkhead(type = Type.THREADPOOL) or Promise.\nWhat do you think?", "url": "https://github.com/resilience4j/resilience4j/pull/865#discussion_r378708463", "createdAt": "2020-02-13T08:21:24Z", "author": {"login": "RobWin"}, "path": "resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/timelimiter/TimeLimiterMethodInterceptor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2017 Dan Maas\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.ratpack.timelimiter;\n+\n+import com.google.inject.Inject;\n+import io.github.resilience4j.core.lang.Nullable;\n+import io.github.resilience4j.ratpack.internal.AbstractMethodInterceptor;\n+import io.github.resilience4j.ratpack.recovery.DefaultRecoveryFunction;\n+import io.github.resilience4j.ratpack.recovery.RecoveryFunction;\n+import io.github.resilience4j.reactor.timelimiter.TimeLimiterOperator;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.annotation.TimeLimiter;\n+import org.aopalliance.intercept.MethodInterceptor;\n+import org.aopalliance.intercept.MethodInvocation;\n+import ratpack.exec.Execution;\n+import ratpack.exec.Promise;\n+import ratpack.util.Exceptions;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A {@link MethodInterceptor} to handle all methods annotated with {@link TimeLimiter}. It will\n+ * handle methods that return a {@link Promise}, {@link Flux}, {@link\n+ * Mono}, {@link CompletionStage}, or value.\n+ * <p>\n+ * Given a method like this:\n+ * <pre><code>\n+ *     {@literal @}TimeLimiter(name = \"myService\")\n+ *     public String fancyName(String name) {\n+ *         return \"Sir Captain \" + name;\n+ *     }\n+ * </code></pre>\n+ * each time the {@code #fancyName(String)} method is invoked, the method's execution will pass\n+ * through a a {@link TimeLimiter} according to the given\n+ * config.\n+ * <p>\n+ * The fallbackMethod signature must match either:\n+ * <p>\n+ * 1) The method parameter signature on the annotated method or 2) The method parameter signature\n+ * with a matching exception type as the last parameter on the annotated method\n+ * <p>\n+ * The return value can be a {@link Promise}, {@link CompletionStage}, {@link\n+ * Flux}, {@link Mono}, or an object value. Other\n+ * reactive types are not supported.\n+ * <p>\n+ * If the return value is one of the reactive types listed above, it must match the return value\n+ * type of the annotated method.\n+ */\n+public class TimeLimiterMethodInterceptor extends AbstractMethodInterceptor {\n+\n+    @Inject(optional = true)\n+    @Nullable\n+    private TimeLimiterRegistry registry;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Nullable\n+    @Override\n+    public Object invoke(MethodInvocation invocation) throws Throwable {\n+        TimeLimiter annotation = invocation.getMethod().getAnnotation(TimeLimiter.class);\n+        if (annotation == null) {\n+            annotation = invocation.getMethod().getDeclaringClass()\n+                .getAnnotation(TimeLimiter.class);\n+        }\n+        final RecoveryFunction<?> fallbackMethod = Optional\n+            .ofNullable(createRecoveryFunction(invocation, annotation.fallbackMethod()))\n+            .orElse(new DefaultRecoveryFunction<>());\n+        if (registry == null) {\n+            registry = TimeLimiterRegistry.ofDefaults();\n+        }\n+        io.github.resilience4j.timelimiter.TimeLimiter timeLimiter = registry\n+            .timeLimiter(annotation.name());\n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        if (Promise.class.isAssignableFrom(returnType)) {\n+            Promise<?> result = (Promise<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterTransformer transformer = TimeLimiterTransformer.of(timeLimiter)\n+                    .recover(fallbackMethod);\n+                result = result.transform(transformer);\n+            }\n+            return result;\n+        } else if (Flux.class.isAssignableFrom(returnType)) {\n+            Flux<?> result = (Flux<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterOperator operator = TimeLimiterOperator.of(timeLimiter);\n+                result = fallbackMethod.onErrorResume(result.transform(operator));\n+            }\n+            return result;\n+        } else if (Mono.class.isAssignableFrom(returnType)) {\n+            Mono<?> result = (Mono<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterOperator operator = TimeLimiterOperator.of(timeLimiter);\n+                result = fallbackMethod.onErrorResume(result.transform(operator));\n+            }\n+            return result;\n+        } else if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            ScheduledExecutorService scheduler = Execution.current().getController().getExecutor();\n+            CompletableFuture<?> future = timeLimiter.executeCompletionStage(scheduler, () -> {\n+                try {\n+                    return (CompletionStage)proceed(invocation);\n+                } catch (Throwable t) {\n+                    final CompletableFuture<?> promise = new CompletableFuture<>();\n+                    promise.completeExceptionally(t);\n+                    return (CompletionStage)promise;\n+                }\n+            }).toCompletableFuture();\n+            completeFailedFuture(new TimeoutException(), fallbackMethod, future);\n+            return future;\n+        } else {\n+            return handleProceedWithException(invocation, timeLimiter, fallbackMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6e671915718e1ffbbb75347b868fcd489621d45"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyOTQyNg==", "bodyText": "@RobWin that make sense - I can fix that up", "url": "https://github.com/resilience4j/resilience4j/pull/865#discussion_r379229426", "createdAt": "2020-02-14T02:58:00Z", "author": {"login": "drmaas"}, "path": "resilience4j-ratpack/src/main/java/io/github/resilience4j/ratpack/timelimiter/TimeLimiterMethodInterceptor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2017 Dan Maas\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.ratpack.timelimiter;\n+\n+import com.google.inject.Inject;\n+import io.github.resilience4j.core.lang.Nullable;\n+import io.github.resilience4j.ratpack.internal.AbstractMethodInterceptor;\n+import io.github.resilience4j.ratpack.recovery.DefaultRecoveryFunction;\n+import io.github.resilience4j.ratpack.recovery.RecoveryFunction;\n+import io.github.resilience4j.reactor.timelimiter.TimeLimiterOperator;\n+import io.github.resilience4j.timelimiter.TimeLimiterRegistry;\n+import io.github.resilience4j.timelimiter.annotation.TimeLimiter;\n+import org.aopalliance.intercept.MethodInterceptor;\n+import org.aopalliance.intercept.MethodInvocation;\n+import ratpack.exec.Execution;\n+import ratpack.exec.Promise;\n+import ratpack.util.Exceptions;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A {@link MethodInterceptor} to handle all methods annotated with {@link TimeLimiter}. It will\n+ * handle methods that return a {@link Promise}, {@link Flux}, {@link\n+ * Mono}, {@link CompletionStage}, or value.\n+ * <p>\n+ * Given a method like this:\n+ * <pre><code>\n+ *     {@literal @}TimeLimiter(name = \"myService\")\n+ *     public String fancyName(String name) {\n+ *         return \"Sir Captain \" + name;\n+ *     }\n+ * </code></pre>\n+ * each time the {@code #fancyName(String)} method is invoked, the method's execution will pass\n+ * through a a {@link TimeLimiter} according to the given\n+ * config.\n+ * <p>\n+ * The fallbackMethod signature must match either:\n+ * <p>\n+ * 1) The method parameter signature on the annotated method or 2) The method parameter signature\n+ * with a matching exception type as the last parameter on the annotated method\n+ * <p>\n+ * The return value can be a {@link Promise}, {@link CompletionStage}, {@link\n+ * Flux}, {@link Mono}, or an object value. Other\n+ * reactive types are not supported.\n+ * <p>\n+ * If the return value is one of the reactive types listed above, it must match the return value\n+ * type of the annotated method.\n+ */\n+public class TimeLimiterMethodInterceptor extends AbstractMethodInterceptor {\n+\n+    @Inject(optional = true)\n+    @Nullable\n+    private TimeLimiterRegistry registry;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Nullable\n+    @Override\n+    public Object invoke(MethodInvocation invocation) throws Throwable {\n+        TimeLimiter annotation = invocation.getMethod().getAnnotation(TimeLimiter.class);\n+        if (annotation == null) {\n+            annotation = invocation.getMethod().getDeclaringClass()\n+                .getAnnotation(TimeLimiter.class);\n+        }\n+        final RecoveryFunction<?> fallbackMethod = Optional\n+            .ofNullable(createRecoveryFunction(invocation, annotation.fallbackMethod()))\n+            .orElse(new DefaultRecoveryFunction<>());\n+        if (registry == null) {\n+            registry = TimeLimiterRegistry.ofDefaults();\n+        }\n+        io.github.resilience4j.timelimiter.TimeLimiter timeLimiter = registry\n+            .timeLimiter(annotation.name());\n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        if (Promise.class.isAssignableFrom(returnType)) {\n+            Promise<?> result = (Promise<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterTransformer transformer = TimeLimiterTransformer.of(timeLimiter)\n+                    .recover(fallbackMethod);\n+                result = result.transform(transformer);\n+            }\n+            return result;\n+        } else if (Flux.class.isAssignableFrom(returnType)) {\n+            Flux<?> result = (Flux<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterOperator operator = TimeLimiterOperator.of(timeLimiter);\n+                result = fallbackMethod.onErrorResume(result.transform(operator));\n+            }\n+            return result;\n+        } else if (Mono.class.isAssignableFrom(returnType)) {\n+            Mono<?> result = (Mono<?>) proceed(invocation);\n+            if (result != null) {\n+                TimeLimiterOperator operator = TimeLimiterOperator.of(timeLimiter);\n+                result = fallbackMethod.onErrorResume(result.transform(operator));\n+            }\n+            return result;\n+        } else if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            ScheduledExecutorService scheduler = Execution.current().getController().getExecutor();\n+            CompletableFuture<?> future = timeLimiter.executeCompletionStage(scheduler, () -> {\n+                try {\n+                    return (CompletionStage)proceed(invocation);\n+                } catch (Throwable t) {\n+                    final CompletableFuture<?> promise = new CompletableFuture<>();\n+                    promise.completeExceptionally(t);\n+                    return (CompletionStage)promise;\n+                }\n+            }).toCompletableFuture();\n+            completeFailedFuture(new TimeoutException(), fallbackMethod, future);\n+            return future;\n+        } else {\n+            return handleProceedWithException(invocation, timeLimiter, fallbackMethod);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcwODQ2Mw=="}, "originalCommit": {"oid": "b6e671915718e1ffbbb75347b868fcd489621d45"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 61, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}