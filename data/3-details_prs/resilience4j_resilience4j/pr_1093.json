{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzA5NDc2", "number": 1093, "title": " Adding Springboot2 SSE ", "bodyText": "This closes the issue #1076", "createdAt": "2020-07-23T13:31:34Z", "url": "https://github.com/resilience4j/resilience4j/pull/1093", "merged": true, "mergeCommit": {"oid": "8e53afb5607a7f29b04606167a3f238f8ebaf1ba"}, "closed": true, "closedAt": "2020-08-25T06:29:35Z", "author": {"login": "vijaycse"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3vXcsAH2gAyNDU1NzA5NDc2OmZlM2I2NjVhNWE4Y2JiMWVjODRhNTY5NWQ4ODJhNjhjYTMzOTgyNjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCRMR8gFqTQ3NDE2OTA4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fe3b665a5a8cbb1ec84a5695d882a68ca3398264", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/fe3b665a5a8cbb1ec84a5695d882a68ca3398264", "committedDate": "2020-07-23T13:23:04Z", "message": " Adding springboot SSE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5921fd255960a5c57cfb3fea78f9cd76b7e7b784", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/5921fd255960a5c57cfb3fea78f9cd76b7e7b784", "committedDate": "2020-07-23T13:51:40Z", "message": " Adding thread sleep to buy time to record an event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/33133391f0cc254674c12c6c4146ee6c4bb7b512", "committedDate": "2020-07-23T15:08:47Z", "message": " Trying to fix CI failure. works locally"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjA3NTg2", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-454607586", "createdAt": "2020-07-24T02:38:59Z", "commit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozODo1OVrOG2hlmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMjozOToyM1rOG2hmDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjU4Nw==", "bodyText": "I think these should be compileOnly.\nThere are users who doesn't use reactor or webflux.\nWhat do you think?", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r459826587", "createdAt": "2020-07-24T02:38:59Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjcwMg==", "bodyText": "Is this needed?", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r459826702", "createdAt": "2020-07-24T02:39:23Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,6 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')\n+    compile(libraries.spring_boot2_webflux)\n+    compileOnly(libraries.rxjava2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33133391f0cc254674c12c6c4146ee6c4bb7b512"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0304227efa8946df790b90ee0c90728a07c1aa8", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/f0304227efa8946df790b90ee0c90728a07c1aa8", "committedDate": "2020-07-27T02:02:04Z", "message": "code review comments to include SSE only on the presence of Flux"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaea558e1bea679f76a10182290ae7f527d63fd9", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/eaea558e1bea679f76a10182290ae7f527d63fd9", "committedDate": "2020-07-27T02:05:14Z", "message": " rxjava not needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64b5831cdcb8054f47b60a422e7e92293216d60d", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/64b5831cdcb8054f47b60a422e7e92293216d60d", "committedDate": "2020-07-29T15:22:53Z", "message": " Changing it to compileonly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4", "committedDate": "2020-07-29T15:24:26Z", "message": " Changing it to compileonly"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjUyNzM1", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-457652735", "createdAt": "2020-07-29T15:44:45Z", "commit": {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NDo0NlrOG4-qOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0NDo0NlrOG4-qOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMDA1OA==", "bodyText": "This also need to be compileOnly.\nThe users who doesn't use reactor don't want to have this dependency.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462400058", "createdAt": "2020-07-29T15:44:46Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/build.gradle", "diffHunk": "@@ -1,7 +1,9 @@\n dependencies {\n     compile project(':resilience4j-spring')\n     compile project(':resilience4j-micrometer')\n+    compile project(':resilience4j-reactor')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "284ab71dd6b36f6aaf5dc62d6ed715bbd3763ac4"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3b51bb60ecbd71837948cdae461b9acc73a48a4", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/f3b51bb60ecbd71837948cdae461b9acc73a48a4", "committedDate": "2020-07-29T16:28:36Z", "message": " Changing it to compileonly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/8d9255aff02fbd85b911bd2c8004fd8578b2d57b", "committedDate": "2020-07-29T22:32:28Z", "message": " adding dummy commit to trigger CI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDE0MTg3", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-458014187", "createdAt": "2020-07-30T01:38:27Z", "commit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODoyN1rOG5P-vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODo1MFrOG5P_Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MzgzNw==", "bodyText": "I think this doesn't need to be checked.\nCircuitBreakerRegistry create or get when you request a circuitbreaker.\nTherefore, it cannot be null, and it must be the same as the requested name.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462683837", "createdAt": "2020-07-30T01:38:27Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (circuitBreaker == null && !circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MzkzNA==", "bodyText": "I think this doesn't need to be checked.\nCircuitBreakerRegistry create or get when you request a circuitbreaker.\nTherefore, it cannot be null, and it must be the same as the requested name.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462683934", "createdAt": "2020-07-30T01:38:50Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventDTOFactory;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.Function;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams.\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ */\n+\n+@Endpoint(id = \"stream-circuitbreaker-events\")\n+public class CircuitBreakerServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerServerSideEvent() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return Flux.merge(eventStreams).map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent))\n+            .build()\n+        );\n+    }\n+\n+    private Function<CircuitBreakerEvent, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();\n+        return cbEvent -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    CircuitBreakerEventDTOFactory.createCircuitBreakerEventDTO(cbEvent)\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (circuitBreaker == null && !circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDE4NzMy", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-458018732", "createdAt": "2020-07-30T01:52:52Z", "commit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1Mjo1MlrOG5QOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTo1ODo1M1rOG5QU2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4NzgyOQ==", "bodyText": "Can be moved to class member variable.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462687829", "createdAt": "2020-07-30T01:52:52Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerServerSideEvent.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventDTOFactory;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.Function;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams.\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ */\n+\n+@Endpoint(id = \"stream-circuitbreaker-events\")\n+public class CircuitBreakerServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerServerSideEvent() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return Flux.merge(eventStreams).map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        Function<CircuitBreakerEvent, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent))\n+            .build()\n+        );\n+    }\n+\n+    private Function<CircuitBreakerEvent, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4OTQ5Ng==", "bodyText": "Can be moved to class member variable.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r462689496", "createdAt": "2020-07-30T01:58:53Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+\n+/**\n+ * @author vijayram\n+ */\n+\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        ObjectMapper jsonMapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d9255aff02fbd85b911bd2c8004fd8578b2d57b"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2936269b83e0babdab35b7091c352a4d8fc1de70", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/2936269b83e0babdab35b7091c352a4d8fc1de70", "committedDate": "2020-08-01T04:31:07Z", "message": " Testing CI for failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b286f3e8c8b4c489dc0c5f1aed8efcfd5fd54601", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/b286f3e8c8b4c489dc0c5f1aed8efcfd5fd54601", "committedDate": "2020-08-01T21:10:20Z", "message": " Fixing CI failures and refactored to have own auto config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05e0fd6e624dd786596e0a2d607e55bdeebcd371", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/05e0fd6e624dd786596e0a2d607e55bdeebcd371", "committedDate": "2020-08-01T21:10:42Z", "message": " Fixing CI failures and refactored to have own auto config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1c3b712a90427f08d08efc8ff0bcf3a32a77a54", "author": {"user": null}, "url": "https://github.com/resilience4j/resilience4j/commit/e1c3b712a90427f08d08efc8ff0bcf3a32a77a54", "committedDate": "2020-08-02T19:14:32Z", "message": "Adding copywrite to all the new classes and refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6397c56df541cdff423573c7124bef1ba10c57ff", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/6397c56df541cdff423573c7124bef1ba10c57ff", "committedDate": "2020-08-03T13:20:58Z", "message": " Refactoring to enable with property"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/4a956551a7e3989acdf8ed052e8bc8411391c890", "committedDate": "2020-08-03T13:25:03Z", "message": " remvoing unnecessary formatting and spaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMTMyNzMy", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-462132732", "createdAt": "2020-08-06T01:46:55Z", "commit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTo0Njo1NVrOG8gV3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTo1MDozNFrOG8gZfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NzYyOQ==", "bodyText": "I think this property isn't needed because SSE can be controlled with management.endpoints.stream-circuitbreaker-events.exposure.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r466097629", "createdAt": "2020-08-06T01:46:55Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/autoconfigure/CircuitBreakerStreamEventsAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.circuitbreaker.autoconfigure;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixServerSideEvent;\n+import io.github.resilience4j.circuitbreaker.monitoring.endpoint.CircuitBreakerServerSideEvent;\n+import io.github.resilience4j.reactor.adapter.ReactorAdapter;\n+import org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnAvailableEndpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import reactor.core.publisher.Flux;\n+\n+@Configuration\n+@ConditionalOnClass({CircuitBreaker.class, Endpoint.class})\n+@AutoConfigureAfter(CircuitBreakerAutoConfiguration.class)\n+@ConditionalOnProperty(value = \"resilience4j.circuitBreaker.stream.event.enabled\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5ODU1OQ==", "bodyText": "If you make CircuitBreaker from CircuitBreakerRegistry with name, it always have the name that you requested.\nYou don't need to check. I think you can get CircuitBreaker from registry directly not with this function.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r466098559", "createdAt": "2020-08-06T01:50:34Z", "author": {"login": "dlsrb6342"}, "path": "resilience4j-spring-boot2/src/main/java/io/github/resilience4j/circuitbreaker/monitoring/endpoint/CircuitBreakerHystrixServerSideEvent.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.endpoint;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.github.resilience4j.circuitbreaker.CircuitBreaker;\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.event.CircuitBreakerEvent;\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerHystrixStreamEventsDTO;\n+import io.vavr.collection.Seq;\n+import org.springframework.boot.actuate.endpoint.annotation.Endpoint;\n+import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;\n+import org.springframework.boot.actuate.endpoint.annotation.Selector;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.stereotype.Component;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.function.BiFunction;\n+\n+import static io.github.resilience4j.reactor.adapter.ReactorAdapter.toFlux;\n+/**\n+ * This class is used to produce Circuit breaker events as streams in hystrix like fashion\n+ * <p>\n+ * The following endpoints are automatically generated and events are produced as Server Sent Event(SSE)\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}\n+ * curl -vv http://localhost:8090/actuator/hystrix-stream-circuitbreaker-events/{circuitbreakername}/{errorType}\n+ * <p>\n+ * <p>\n+ * Note: This SSE data can be easily mapped to hystrix compatible data format (specific K V pairs)\n+ * and be used in Turbine or hystrix dashboard or vizceral.\n+ * <p>\n+ * This is created as a bridge to support the legacy hystrix eco system of monitoring tools especially for\n+ * those that are migrating from hystrix to resilence4j to continue to use hystrix eco tools.\n+ */\n+\n+@Endpoint(id = \"hystrix-stream-circuitbreaker-events\")\n+public class CircuitBreakerHystrixServerSideEvent {\n+\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final ObjectMapper jsonMapper = new ObjectMapper();\n+\n+    public CircuitBreakerHystrixServerSideEvent(\n+        CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getAllCircuitBreakerHystrixStreamEvents() {\n+        Seq<Flux<CircuitBreakerEvent>> eventStreams = circuitBreakerRegistry.getAllCircuitBreakers()\n+            .map(\n+                circuitBreaker -> toFlux(circuitBreaker.getEventPublisher())\n+            );\n+        Flux<CircuitBreakerEvent> eventStream = Flux.merge(eventStreams);\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, getCircuitBreaker(cbEvent.getCircuitBreakerName())))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerName(\n+        @Selector String name) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher());\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(\n+            cbEvent -> ServerSentEvent.<String>builder()\n+                .id(cbEvent.getCircuitBreakerName())\n+                .event(cbEvent.getEventType().name())\n+                .data(data.apply(cbEvent, circuitBreaker))\n+                .build()\n+        );\n+    }\n+\n+    @ReadOperation(produces = \"text/event-stream\")\n+    public Flux<ServerSentEvent<String>> getHystrixStreamEventsFilteredByCircuitBreakerNameAndEventType(\n+        @Selector String name, @Selector String eventType) {\n+\n+        CircuitBreaker circuitBreaker = getCircuitBreaker(name);\n+        Flux<CircuitBreakerEvent> eventStream = toFlux(circuitBreaker.getEventPublisher())\n+            .filter(\n+                event -> event.getEventType() == CircuitBreakerEvent.Type.valueOf(eventType.toUpperCase())\n+            );\n+        BiFunction<CircuitBreakerEvent, CircuitBreaker, String> data = getCircuitBreakerEventStringFunction();\n+        return eventStream.map(cbEvent -> ServerSentEvent.<String>builder()\n+            .id(cbEvent.getCircuitBreakerName())\n+            .event(cbEvent.getEventType().name())\n+            .data(data.apply(cbEvent, circuitBreaker))\n+            .build()\n+        );\n+    }\n+\n+    private BiFunction<CircuitBreakerEvent, CircuitBreaker, String> getCircuitBreakerEventStringFunction() {\n+        return (cbEvent, cb) -> {\n+            try {\n+                return jsonMapper.writeValueAsString(\n+                    new CircuitBreakerHystrixStreamEventsDTO(cbEvent,\n+                        cb.getState(),\n+                        cb.getMetrics(),\n+                        cb.getCircuitBreakerConfig()\n+                    )\n+                );\n+            } catch (JsonProcessingException e) {\n+                /* ignore silently */\n+            }\n+            return \"\";\n+        };\n+    }\n+\n+    private CircuitBreaker getCircuitBreaker(String circuitBreakerName) {\n+        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(circuitBreakerName);\n+        if (!circuitBreaker.getName().equalsIgnoreCase(circuitBreakerName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a956551a7e3989acdf8ed052e8bc8411391c890"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/634a46875da51e75a3c78e60e2e13ffc13412fbe", "committedDate": "2020-08-07T20:49:17Z", "message": " Removed property and removed additional check for CB name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NDAxNjA0", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-466401604", "createdAt": "2020-08-13T02:22:04Z", "commit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NTE2Nzkx", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-466516791", "createdAt": "2020-08-13T07:41:10Z", "commit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MToxMFrOG__uww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0MTo0M1rOG__wAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzYzNQ==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757635", "createdAt": "2020-08-13T07:41:10Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzY4Nw==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757687", "createdAt": "2020-08-13T07:41:15Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assert (events.size() == 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NzcxOA==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757718", "createdAt": "2020-08-13T07:41:20Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assert (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1Nzk1Mw==", "bodyText": "Please use AssertJ", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469757953", "createdAt": "2020-08-13T07:41:43Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assert (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "634a46875da51e75a3c78e60e2e13ffc13412fbe"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdb5aee61111c6a6797b99d2927b74b03d9ca517", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/cdb5aee61111c6a6797b99d2927b74b03d9ca517", "committedDate": "2020-08-13T13:15:58Z", "message": "Added code review comments to use assertJ"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/cab178cc71eb5519566de7fcb9f43dec78274152", "committedDate": "2020-08-13T13:21:10Z", "message": "Merge branch 'master' into springboot2-sse-vrbranch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzkxNTI1", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-466791525", "createdAt": "2020-08-13T14:02:26Z", "commit": {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDowMjoyNlrOHAM-ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDowMjoyNlrOHAM-ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NDYzNA==", "bodyText": "Assertj has a fluent API. You have to do\nassertThat(events.size()).isEqulTo(1);", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r469974634", "createdAt": "2020-08-13T14:02:26Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size() < circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab178cc71eb5519566de7fcb9f43dec78274152"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d3a9ae0041aefb5832a2fbf36b8ba1f43359528", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/3d3a9ae0041aefb5832a2fbf36b8ba1f43359528", "committedDate": "2020-08-13T15:11:01Z", "message": "Review Comments to use AssertJ fluent APIs for assertion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9", "committedDate": "2020-08-13T15:15:36Z", "message": "Merge branch 'springboot2-sse-vrbranch' of https://github.com/vijaycse/resilience4j into springboot2-sse-vrbranch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMTM5NDQ0", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-470139444", "createdAt": "2020-08-19T05:42:28Z", "commit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNTo0MjoyOFrOHC0wAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNjoxMTo1OFrOHC1-7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzQ1Nw==", "bodyText": "Waiting between calls should not be necessary", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723457", "createdAt": "2020-08-19T05:42:28Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzUyNA==", "bodyText": "Waiting between calls should not be necessary", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723524", "createdAt": "2020-08-19T05:42:34Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzU1OA==", "bodyText": "Waiting between calls should not be necessary", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472723558", "createdAt": "2020-08-19T05:42:37Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzU4NA==", "bodyText": "Is it possible to use the WebTestClient  here?\nHere is a guide how to use the WebTestClient for streaming responses:\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/testing-webtestclient.pdf\nThen please use the StepVerifier to subscribe to the stream and verify that the streams emits one event.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472743584", "createdAt": "2020-08-19T06:11:49Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerHystrixStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = TestApplication.class)\n+public class CircuitBreakerHystrixStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/hystrix-stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // sleep is needed to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); //  webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzY2Mg==", "bodyText": "Is it possible to use the WebTestClient here?\nHere is a guide how to use the WebTestClient for streaming responses:\nhttps://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/testing-webtestclient.pdf\nThen please use the StepVerifier to subscribe to the stream and verify that the streams emits one event.", "url": "https://github.com/resilience4j/resilience4j/pull/1093#discussion_r472743662", "createdAt": "2020-08-19T06:11:58Z", "author": {"login": "RobWin"}, "path": "resilience4j-spring-boot2/src/test/java/io/github/resilience4j/circuitbreaker/monitoring/events/CircuitBreakerStreamEventsTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Vijay Ram\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.circuitbreaker.monitoring.events;\n+\n+\n+import io.github.resilience4j.common.circuitbreaker.monitoring.endpoint.CircuitBreakerEventsEndpointResponse;\n+import io.github.resilience4j.service.test.DummyService;\n+import io.github.resilience4j.service.test.TestApplication;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.boot.web.server.LocalServerPort;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.codec.ServerSentEvent;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+import org.springframework.test.web.reactive.server.WebTestClient;\n+import org.springframework.web.reactive.function.client.WebClient;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * @author vijayram\n+ */\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,classes = TestApplication.class)\n+public class CircuitBreakerStreamEventsTest {\n+\n+    public static final String ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS = \"/actuator/stream-circuitbreaker-events\";\n+    public static final String ACTUATOR_CIRCUITBREAKEREVENTS = \"/actuator/circuitbreakerevents\";\n+\n+    @Autowired\n+    private WebTestClient webTestClient;\n+\n+    @LocalServerPort\n+    int randomServerPort;\n+\n+    @Autowired\n+    DummyService dummyService;\n+\n+    @Test\n+    public void streamAllEvents() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS);\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        Thread.sleep(1000); // to record the event\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS);\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (circuitBreakerEventsAfter.getCircuitBreakerEvents().size()).isGreaterThan(0);\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyName() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS + \"/backendA\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // pause 1 sec to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size() ).isEqualTo(2);\n+    }\n+\n+    @Test\n+    public void streamEventsbyNameAndType() throws IOException, InterruptedException {\n+        List<ServerSentEvent<String>> events = getServerSentEvents(ACTUATOR_STREAM_CIRCUITBREAKER_EVENTS+ \"/backendA/ERROR\");\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsBefore = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        // The invocation is recorded by the CircuitBreaker as a success.\n+        dummyService.doSomething(false);\n+        Thread.sleep(1000); // to record the event\n+        try {\n+            dummyService.doSomething(true);\n+        } catch (IOException ex) {\n+            // Do nothing. The IOException is recorded by the CircuitBreaker as part of the recordFailurePredicate as a failure.\n+        }\n+        CircuitBreakerEventsEndpointResponse circuitBreakerEventsAfter = circuitBreakerEvents(ACTUATOR_CIRCUITBREAKEREVENTS + \"/backendA\");\n+        Thread.sleep(1000); // for webClient to complete the subscribe operation\n+        assertThat (circuitBreakerEventsBefore.getCircuitBreakerEvents().size()).isLessThan(circuitBreakerEventsAfter.getCircuitBreakerEvents().size());\n+        assertThat (events.size()).isEqualTo(1);\n+    }\n+\n+    private List<ServerSentEvent<String>> getServerSentEvents(String s) {\n+        Flux<ServerSentEvent<String>> circuitBreakerStreamEventsForAfter = circuitBreakerStreamEvents(s);\n+        List<ServerSentEvent<String>> events = new ArrayList<>();\n+\n+        circuitBreakerStreamEventsForAfter.subscribe(\n+            content -> events.add(content),\n+            error -> System.out.println(\"Error receiving SSE: {}\" + error),\n+            () -> System.out.println(\"Completed!!!\"));\n+        return events;\n+    }\n+\n+    private CircuitBreakerEventsEndpointResponse circuitBreakerEvents(String s) {\n+        return this.webTestClient.get().uri(s).exchange()\n+            .expectStatus().isOk()\n+            .expectBody(CircuitBreakerEventsEndpointResponse.class)\n+            .returnResult()\n+            .getResponseBody();\n+    }\n+\n+    private Flux<ServerSentEvent<String>> circuitBreakerStreamEvents(String s) {\n+        WebClient client = WebClient.create(\"http://localhost:\" + randomServerPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e75d7d1333dd7b47d8b3e101c0fe118b89f4d9"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33265f41446c1365d1de80d308ef7d74b8766573", "author": {"user": {"login": "vijaycse", "name": "Vijay Ram"}}, "url": "https://github.com/resilience4j/resilience4j/commit/33265f41446c1365d1de80d308ef7d74b8766573", "committedDate": "2020-08-23T15:40:17Z", "message": " Removed thread.sleep inbetween methods  code review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTY5MDg4", "url": "https://github.com/resilience4j/resilience4j/pull/1093#pullrequestreview-474169088", "createdAt": "2020-08-25T06:26:53Z", "commit": {"oid": "33265f41446c1365d1de80d308ef7d74b8766573"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1761, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}