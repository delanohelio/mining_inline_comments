{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMjY0MTMy", "number": 2169, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowOTozOVrOEPXrTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwOToyMjoyNFrOEYZnmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUyMDEyOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowOTozOVrOGzC71A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoxNzo0MVrOG2KDmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODY0NA==", "bodyText": "Would it be better if we cache the commonly used Strategy Object on the broker side? I think it's better than creating it for every request.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r456178644", "createdAt": "2020-07-17T02:09:39Z", "author": {"login": "xiangwangcheng"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.List;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.protocol.RequestCode;\n+import org.apache.rocketmq.common.protocol.ResponseCode;\n+import org.apache.rocketmq.common.protocol.body.AllocateMessageQueueRequestBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueRequestHeader;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseHeader;\n+import org.apache.rocketmq.common.rebalance.AllocateMachineRoomNearby;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragely;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragelyByCircle;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByConfig;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByMachineRoom;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueConsistentHash;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+\n+public class AllocateMessageQueueProcessor implements NettyRequestProcessor {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n+\n+    private final BrokerController brokerController;\n+\n+    public AllocateMessageQueueProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        switch (request.getCode()) {\n+            case RequestCode.ALLOCATE_MESSAGE_QUEUE:\n+                return this.allocateMessageQueue(ctx, request);\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String strategyName = requestHeader.getStrategyName();\n+        if (strategyName.startsWith(\"MACHINE_ROOM_NEARBY\")) {\n+            strategy = new AllocateMachineRoomNearby(new AllocateMessageQueueAveragely(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0MTA0OA==", "bodyText": "Hi, good point. I had created a ConcurrentHashMap to cache Strategy Object.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r459441048", "createdAt": "2020-07-23T13:17:41Z", "author": {"login": "jack870131"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.List;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.protocol.RequestCode;\n+import org.apache.rocketmq.common.protocol.ResponseCode;\n+import org.apache.rocketmq.common.protocol.body.AllocateMessageQueueRequestBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueRequestHeader;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseHeader;\n+import org.apache.rocketmq.common.rebalance.AllocateMachineRoomNearby;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragely;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragelyByCircle;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByConfig;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByMachineRoom;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueConsistentHash;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+\n+public class AllocateMessageQueueProcessor implements NettyRequestProcessor {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n+\n+    private final BrokerController brokerController;\n+\n+    public AllocateMessageQueueProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        switch (request.getCode()) {\n+            case RequestCode.ALLOCATE_MESSAGE_QUEUE:\n+                return this.allocateMessageQueue(ctx, request);\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String strategyName = requestHeader.getStrategyName();\n+        if (strategyName.startsWith(\"MACHINE_ROOM_NEARBY\")) {\n+            strategy = new AllocateMachineRoomNearby(new AllocateMessageQueueAveragely(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODY0NA=="}, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTc4NzU0OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDo1NTozOFrOGzFVhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyNjozMlrOG2KbYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNzk5MA==", "bodyText": "Enum or constant would be better\uff0cmagic numbers not a good choice.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r456217990", "createdAt": "2020-07-17T04:55:38Z", "author": {"login": "duhenglucky"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.List;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.protocol.RequestCode;\n+import org.apache.rocketmq.common.protocol.ResponseCode;\n+import org.apache.rocketmq.common.protocol.body.AllocateMessageQueueRequestBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueRequestHeader;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseHeader;\n+import org.apache.rocketmq.common.rebalance.AllocateMachineRoomNearby;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragely;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragelyByCircle;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByConfig;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByMachineRoom;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueConsistentHash;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+\n+public class AllocateMessageQueueProcessor implements NettyRequestProcessor {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n+\n+    private final BrokerController brokerController;\n+\n+    public AllocateMessageQueueProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        switch (request.getCode()) {\n+            case RequestCode.ALLOCATE_MESSAGE_QUEUE:\n+                return this.allocateMessageQueue(ctx, request);\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String strategyName = requestHeader.getStrategyName();\n+        if (strategyName.startsWith(\"MACHINE_ROOM_NEARBY\")) {\n+            strategy = new AllocateMachineRoomNearby(new AllocateMessageQueueAveragely(),\n+                new AllocateMachineRoomNearby.MachineRoomResolver() {\n+                    @Override\n+                    public String brokerDeployIn(MessageQueue messageQueue) {\n+                        return messageQueue.getBrokerName().split(\"-\")[0];\n+                    }\n+\n+                    @Override\n+                    public String consumerDeployIn(String clientID) {\n+                        return clientID.split(\"-\")[0];\n+                    }\n+                });\n+        } else {\n+            switch (strategyName) {\n+                case \"AVG\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0NzEzOA==", "bodyText": "Updated. The strings have been changed to constants.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r459447138", "createdAt": "2020-07-23T13:26:32Z", "author": {"login": "jack870131"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.List;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.protocol.RequestCode;\n+import org.apache.rocketmq.common.protocol.ResponseCode;\n+import org.apache.rocketmq.common.protocol.body.AllocateMessageQueueRequestBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueRequestHeader;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseHeader;\n+import org.apache.rocketmq.common.rebalance.AllocateMachineRoomNearby;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragely;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragelyByCircle;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByConfig;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByMachineRoom;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueConsistentHash;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+\n+public class AllocateMessageQueueProcessor implements NettyRequestProcessor {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n+\n+    private final BrokerController brokerController;\n+\n+    public AllocateMessageQueueProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        switch (request.getCode()) {\n+            case RequestCode.ALLOCATE_MESSAGE_QUEUE:\n+                return this.allocateMessageQueue(ctx, request);\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String strategyName = requestHeader.getStrategyName();\n+        if (strategyName.startsWith(\"MACHINE_ROOM_NEARBY\")) {\n+            strategy = new AllocateMachineRoomNearby(new AllocateMessageQueueAveragely(),\n+                new AllocateMachineRoomNearby.MachineRoomResolver() {\n+                    @Override\n+                    public String brokerDeployIn(MessageQueue messageQueue) {\n+                        return messageQueue.getBrokerName().split(\"-\")[0];\n+                    }\n+\n+                    @Override\n+                    public String consumerDeployIn(String clientID) {\n+                        return clientID.split(\"-\")[0];\n+                    }\n+                });\n+        } else {\n+            switch (strategyName) {\n+                case \"AVG\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNzk5MA=="}, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTc5MjgwOnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwNDo1OTowOVrOGzFYkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyMzoyN1rOG2KTDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxODc3MA==", "bodyText": "Recommend to add strategy consistency check logic", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r456218770", "createdAt": "2020-07-17T04:59:09Z", "author": {"login": "duhenglucky"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.List;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.protocol.RequestCode;\n+import org.apache.rocketmq.common.protocol.ResponseCode;\n+import org.apache.rocketmq.common.protocol.body.AllocateMessageQueueRequestBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueRequestHeader;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseHeader;\n+import org.apache.rocketmq.common.rebalance.AllocateMachineRoomNearby;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragely;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragelyByCircle;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByConfig;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByMachineRoom;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueConsistentHash;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+\n+public class AllocateMessageQueueProcessor implements NettyRequestProcessor {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n+\n+    private final BrokerController brokerController;\n+\n+    public AllocateMessageQueueProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        switch (request.getCode()) {\n+            case RequestCode.ALLOCATE_MESSAGE_QUEUE:\n+                return this.allocateMessageQueue(ctx, request);\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String strategyName = requestHeader.getStrategyName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0NTAwNQ==", "bodyText": "Updated. I had added the try/catch statement for the strategy.allocate() method, which could enhance the consistency here.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r459445005", "createdAt": "2020-07-23T13:23:27Z", "author": {"login": "jack870131"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/AllocateMessageQueueProcessor.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.broker.processor;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.List;\n+import org.apache.rocketmq.broker.BrokerController;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.common.protocol.RequestCode;\n+import org.apache.rocketmq.common.protocol.ResponseCode;\n+import org.apache.rocketmq.common.protocol.body.AllocateMessageQueueRequestBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueRequestHeader;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseBody;\n+import org.apache.rocketmq.common.protocol.header.AllocateMessageQueueResponseHeader;\n+import org.apache.rocketmq.common.rebalance.AllocateMachineRoomNearby;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragely;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueAveragelyByCircle;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByConfig;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueByMachineRoom;\n+import org.apache.rocketmq.common.rebalance.AllocateMessageQueueConsistentHash;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+import org.apache.rocketmq.remoting.exception.RemotingCommandException;\n+import org.apache.rocketmq.remoting.netty.NettyRequestProcessor;\n+import org.apache.rocketmq.remoting.protocol.RemotingCommand;\n+\n+public class AllocateMessageQueueProcessor implements NettyRequestProcessor {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n+\n+    private final BrokerController brokerController;\n+\n+    public AllocateMessageQueueProcessor(final BrokerController brokerController) {\n+        this.brokerController = brokerController;\n+    }\n+\n+    @Override\n+    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        switch (request.getCode()) {\n+            case RequestCode.ALLOCATE_MESSAGE_QUEUE:\n+                return this.allocateMessageQueue(ctx, request);\n+            default:\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String strategyName = requestHeader.getStrategyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxODc3MA=="}, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI1NTcyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/org/apache/rocketmq/client/impl/consumer/RebalanceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoxMTo0MFrOGzJrAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyMDo1OFrOG2KMYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4OTAyNA==", "bodyText": "IMO, It would be better that the client only needs to bring the current cid to get the result.\nBoth mqAll and cidAll are obtained on the broker side.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r456289024", "createdAt": "2020-07-17T08:11:40Z", "author": {"login": "RongtongJin"}, "path": "client/src/main/java/org/apache/rocketmq/client/impl/consumer/RebalanceImpl.java", "diffHunk": "@@ -278,11 +278,20 @@ private void rebalanceByTopic(final String topic, final boolean isOrder) {\n \n                     List<MessageQueue> allocateResult = null;\n                     try {\n-                        allocateResult = strategy.allocate(\n-                            this.consumerGroup,\n-                            this.mQClientFactory.getClientId(),\n-                            mqAll,\n-                            cidAll);\n+                        if (!isRebalanceByBroker()) {\n+                            allocateResult = strategy.allocate(\n+                                this.consumerGroup,\n+                                this.mQClientFactory.getClientId(),\n+                                mqAll,\n+                                cidAll);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0MzI5OQ==", "bodyText": "Updated. According to our previous discussion, the performance of obtaining mqAll from broker side still need further discussions.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r459443299", "createdAt": "2020-07-23T13:20:58Z", "author": {"login": "jack870131"}, "path": "client/src/main/java/org/apache/rocketmq/client/impl/consumer/RebalanceImpl.java", "diffHunk": "@@ -278,11 +278,20 @@ private void rebalanceByTopic(final String topic, final boolean isOrder) {\n \n                     List<MessageQueue> allocateResult = null;\n                     try {\n-                        allocateResult = strategy.allocate(\n-                            this.consumerGroup,\n-                            this.mQClientFactory.getClientId(),\n-                            mqAll,\n-                            cidAll);\n+                        if (!isRebalanceByBroker()) {\n+                            allocateResult = strategy.allocate(\n+                                this.consumerGroup,\n+                                this.mQClientFactory.getClientId(),\n+                                mqAll,\n+                                cidAll);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4OTAyNA=="}, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjI5MjIwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/org/apache/rocketmq/client/impl/factory/MQClientInstance.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMjozMFrOGzKBBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoxNzo1OFrOG2KEag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDY2Mg==", "bodyText": "It would be better to use placeholders, such as log.warn(\"getAllocationResultByStrategy exception, {} {}\", brokerAddr, group, e);", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r456294662", "createdAt": "2020-07-17T08:22:30Z", "author": {"login": "RongtongJin"}, "path": "client/src/main/java/org/apache/rocketmq/client/impl/factory/MQClientInstance.java", "diffHunk": "@@ -1161,6 +1161,26 @@ public void resetOffset(String topic, String group, Map<MessageQueue, Long> offs\n         }\n     }\n \n+    public List<MessageQueue> getAllocationResult(final String topic, final String group, final String strategyName,\n+        final List<MessageQueue> mqAll, final List<String> cidAll) {\n+        String brokerAddr = this.findBrokerAddrByTopic(topic);\n+        if (null == brokerAddr) {\n+            this.updateTopicRouteInfoFromNameServer(topic);\n+            brokerAddr = this.findBrokerAddrByTopic(topic);\n+        }\n+\n+        if (null != brokerAddr) {\n+            try {\n+                return this.mQClientAPIImpl.getAllocationResultByStrategy(brokerAddr, group, clientId, strategyName,\n+                    mqAll, cidAll, 3000);\n+            } catch (Exception e) {\n+                log.warn(\"getAllocationResultByStrategy exception, \" + brokerAddr, \" \" + group, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0MTI1OA==", "bodyText": "Updated.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r459441258", "createdAt": "2020-07-23T13:17:58Z", "author": {"login": "jack870131"}, "path": "client/src/main/java/org/apache/rocketmq/client/impl/factory/MQClientInstance.java", "diffHunk": "@@ -1161,6 +1161,26 @@ public void resetOffset(String topic, String group, Map<MessageQueue, Long> offs\n         }\n     }\n \n+    public List<MessageQueue> getAllocationResult(final String topic, final String group, final String strategyName,\n+        final List<MessageQueue> mqAll, final List<String> cidAll) {\n+        String brokerAddr = this.findBrokerAddrByTopic(topic);\n+        if (null == brokerAddr) {\n+            this.updateTopicRouteInfoFromNameServer(topic);\n+            brokerAddr = this.findBrokerAddrByTopic(topic);\n+        }\n+\n+        if (null != brokerAddr) {\n+            try {\n+                return this.mQClientAPIImpl.getAllocationResultByStrategy(brokerAddr, group, clientId, strategyName,\n+                    mqAll, cidAll, 3000);\n+            } catch (Exception e) {\n+                log.warn(\"getAllocationResultByStrategy exception, \" + brokerAddr, \" \" + group, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDY2Mg=="}, "originalCommit": {"oid": "3059642788f063fd41a5ee445483ee668b2b63b4"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTQ1NjM2OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNTowMTozNVrOG1Sxhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyODo1MVrOG2Kh3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNTMwMw==", "bodyText": "IMO, we don\u2019t need to open a thread pool separately, could we reuse consumerManageExecutor?", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r458535303", "createdAt": "2020-07-22T05:01:35Z", "author": {"login": "RongtongJin"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java", "diffHunk": "@@ -329,6 +331,10 @@ public boolean initialize() throws CloneNotSupportedException {\n                 Executors.newFixedThreadPool(this.brokerConfig.getConsumerManageThreadPoolNums(), new ThreadFactoryImpl(\n                     \"ConsumerManageThread_\"));\n \n+            this.allocateMessageQueueExecutor =\n+                Executors.newFixedThreadPool(this.brokerConfig.getConsumerManageThreadPoolNums(), new ThreadFactoryImpl(\n+                    \"AllocateMessageQueueThread_\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7d2a99a5c341637bb524fa12279dc47abb832ec"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0ODc5Nw==", "bodyText": "Updated. The processor thread had been deleted and the code had migrated to ConsumerManageProcessor.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r459448797", "createdAt": "2020-07-23T13:28:51Z", "author": {"login": "jack870131"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/BrokerController.java", "diffHunk": "@@ -329,6 +331,10 @@ public boolean initialize() throws CloneNotSupportedException {\n                 Executors.newFixedThreadPool(this.brokerConfig.getConsumerManageThreadPoolNums(), new ThreadFactoryImpl(\n                     \"ConsumerManageThread_\"));\n \n+            this.allocateMessageQueueExecutor =\n+                Executors.newFixedThreadPool(this.brokerConfig.getConsumerManageThreadPoolNums(), new ThreadFactoryImpl(\n+                    \"AllocateMessageQueueThread_\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzNTMwMw=="}, "originalCommit": {"oid": "e7d2a99a5c341637bb524fa12279dc47abb832ec"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjMxODg3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/org/apache/rocketmq/common/rebalance/AllocateMessageQueueSticky.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNjo0NDo0M1rOG-qc0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjoyMDoxMlrOHAS2kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MDQwMw==", "bodyText": "Throwing NPE is very strange, because even if you don\u2019t write related code, it will still throw NPE.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r468360403", "createdAt": "2020-08-11T06:44:43Z", "author": {"login": "RongtongJin"}, "path": "common/src/main/java/org/apache/rocketmq/common/rebalance/AllocateMessageQueueSticky.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.common.rebalance;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeSet;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+\n+public class AllocateMessageQueueSticky implements AllocateMessageQueueStrategy {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);\n+\n+    private final Map<String, List<MessageQueue>> messageQueueAllocation;\n+\n+    private final List<MessageQueue> unassignedQueues = new ArrayList<MessageQueue>();\n+\n+    public AllocateMessageQueueSticky(Map<String, List<MessageQueue>> messageQueueAllocation)\n+        throws NullPointerException {\n+        if (messageQueueAllocation == null) {\n+            throw new NullPointerException(\"currentMessageQueueAllocation is null\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96b7a0055f22ac6ff36aef7bf4c3d1037e10cc17"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3MDkzMQ==", "bodyText": "Updated. Thx for pointing out.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r470070931", "createdAt": "2020-08-13T16:20:12Z", "author": {"login": "jack870131"}, "path": "common/src/main/java/org/apache/rocketmq/common/rebalance/AllocateMessageQueueSticky.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.common.rebalance;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeSet;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+\n+public class AllocateMessageQueueSticky implements AllocateMessageQueueStrategy {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);\n+\n+    private final Map<String, List<MessageQueue>> messageQueueAllocation;\n+\n+    private final List<MessageQueue> unassignedQueues = new ArrayList<MessageQueue>();\n+\n+    public AllocateMessageQueueSticky(Map<String, List<MessageQueue>> messageQueueAllocation)\n+        throws NullPointerException {\n+        if (messageQueueAllocation == null) {\n+            throw new NullPointerException(\"currentMessageQueueAllocation is null\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MDQwMw=="}, "originalCommit": {"oid": "96b7a0055f22ac6ff36aef7bf4c3d1037e10cc17"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjMzMzExOnYy", "diffSide": "RIGHT", "path": "common/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNjo0OTo1N1rOG-qlPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjoyNToxMVrOHATCiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjU1Nw==", "bodyText": "Is it necessary to force the compilation version to 8, which may cause some compatibility issues", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r468362557", "createdAt": "2020-08-11T06:49:57Z", "author": {"login": "RongtongJin"}, "path": "common/pom.xml", "diffHunk": "@@ -24,6 +24,18 @@\n \n     <modelVersion>4.0.0</modelVersion>\n     <packaging>jar</packaging>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>8</source>\n+                    <target>8</target>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96b7a0055f22ac6ff36aef7bf4c3d1037e10cc17"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3Mzk5Mw==", "bodyText": "Updated. It seems like an automatic update from IDE and I forgot to change it back.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r470073993", "createdAt": "2020-08-13T16:25:11Z", "author": {"login": "jack870131"}, "path": "common/pom.xml", "diffHunk": "@@ -24,6 +24,18 @@\n \n     <modelVersion>4.0.0</modelVersion>\n     <packaging>jar</packaging>\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>8</source>\n+                    <target>8</target>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjU1Nw=="}, "originalCommit": {"oid": "96b7a0055f22ac6ff36aef7bf4c3d1037e10cc17"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNjM1MDM1OnYy", "diffSide": "RIGHT", "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/ConsumerManageProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNjo1NjowNVrOG-qvOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjoyNjoyMFrOHATFPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2NTExNQ==", "bodyText": "There may be a thread-safe issue, because multiple threads may call allocateMessageQueue at the same time", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r468365115", "createdAt": "2020-08-11T06:56:05Z", "author": {"login": "RongtongJin"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/ConsumerManageProcessor.java", "diffHunk": "@@ -152,4 +168,75 @@ private RemotingCommand queryConsumerOffset(ChannelHandlerContext ctx, RemotingC\n \n         return response;\n     }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String consumerGroup = requestHeader.getConsumerGroup();\n+        String strategyName = requestHeader.getStrategyName();\n+\n+        if (this.brokerController.getAllocateMessageQueueStrategyTable().containsKey(consumerGroup)) {\n+            strategy = this.brokerController.getAllocateMessageQueueStrategyTable().get(consumerGroup);\n+        } else {\n+            if (strategyName.startsWith(AllocateMessageQueueStrategyConstants.ALLOCATE_MACHINE_ROOM_NEARBY)) {\n+                response.setCode(ResponseCode.ALLOCATE_MESSAGE_QUEUE_STRATEGY_NOT_SUPPORTED);\n+                response.setRemark(\"The broker does not support message queue strategy \" + strategyName);\n+                return response;\n+            } else {\n+                switch (strategyName) {\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_AVERAGELY:\n+                        strategy = new AllocateMessageQueueAveragely();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_AVERAGELY_BY_CIRCLE:\n+                        strategy = new AllocateMessageQueueAveragelyByCircle();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_BY_CONFIG:\n+                        strategy = new AllocateMessageQueueByConfig();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_BY_MACHINE_ROOM:\n+                        strategy = new AllocateMessageQueueByMachineRoom();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_CONSISTENT_HASH:\n+                        strategy = new AllocateMessageQueueConsistentHash();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_STICKY:\n+                        strategy = new AllocateMessageQueueSticky(new HashMap<String, List<MessageQueue>>());\n+                    default:\n+                        break;\n+                }\n+            }\n+            this.brokerController.getAllocateMessageQueueStrategyTable().put(consumerGroup, strategy);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96b7a0055f22ac6ff36aef7bf4c3d1037e10cc17"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3NDY4NA==", "bodyText": "Updated. A synchronized keyword had been applied to avoid race conditions.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r470074684", "createdAt": "2020-08-13T16:26:20Z", "author": {"login": "jack870131"}, "path": "broker/src/main/java/org/apache/rocketmq/broker/processor/ConsumerManageProcessor.java", "diffHunk": "@@ -152,4 +168,75 @@ private RemotingCommand queryConsumerOffset(ChannelHandlerContext ctx, RemotingC\n \n         return response;\n     }\n+\n+    private RemotingCommand allocateMessageQueue(ChannelHandlerContext ctx, RemotingCommand request)\n+        throws RemotingCommandException {\n+        final RemotingCommand response =\n+            RemotingCommand.createResponseCommand(AllocateMessageQueueResponseHeader.class);\n+        final AllocateMessageQueueRequestHeader requestHeader =\n+            (AllocateMessageQueueRequestHeader) request.decodeCommandCustomHeader(AllocateMessageQueueRequestHeader.class);\n+        final AllocateMessageQueueRequestBody requestBody = AllocateMessageQueueRequestBody.decode(request.getBody(),\n+            AllocateMessageQueueRequestBody.class);\n+\n+        AllocateMessageQueueStrategy strategy = null;\n+        String consumerGroup = requestHeader.getConsumerGroup();\n+        String strategyName = requestHeader.getStrategyName();\n+\n+        if (this.brokerController.getAllocateMessageQueueStrategyTable().containsKey(consumerGroup)) {\n+            strategy = this.brokerController.getAllocateMessageQueueStrategyTable().get(consumerGroup);\n+        } else {\n+            if (strategyName.startsWith(AllocateMessageQueueStrategyConstants.ALLOCATE_MACHINE_ROOM_NEARBY)) {\n+                response.setCode(ResponseCode.ALLOCATE_MESSAGE_QUEUE_STRATEGY_NOT_SUPPORTED);\n+                response.setRemark(\"The broker does not support message queue strategy \" + strategyName);\n+                return response;\n+            } else {\n+                switch (strategyName) {\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_AVERAGELY:\n+                        strategy = new AllocateMessageQueueAveragely();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_AVERAGELY_BY_CIRCLE:\n+                        strategy = new AllocateMessageQueueAveragelyByCircle();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_BY_CONFIG:\n+                        strategy = new AllocateMessageQueueByConfig();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_BY_MACHINE_ROOM:\n+                        strategy = new AllocateMessageQueueByMachineRoom();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_CONSISTENT_HASH:\n+                        strategy = new AllocateMessageQueueConsistentHash();\n+                        break;\n+                    case AllocateMessageQueueStrategyConstants.ALLOCATE_MESSAGE_QUEUE_STICKY:\n+                        strategy = new AllocateMessageQueueSticky(new HashMap<String, List<MessageQueue>>());\n+                    default:\n+                        break;\n+                }\n+            }\n+            this.brokerController.getAllocateMessageQueueStrategyTable().put(consumerGroup, strategy);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2NTExNQ=="}, "originalCommit": {"oid": "96b7a0055f22ac6ff36aef7bf4c3d1037e10cc17"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MDIxMDE5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/org/apache/rocketmq/common/rebalance/AllocateMessageQueueSticky.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwOToyMjoyNFrOHAtzBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwMzo1NjoyNlrOHBY8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUxMjM4OQ==", "bodyText": "Why not just new a hashmap in the constructor instead of passing one \uff1f", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r470512389", "createdAt": "2020-08-14T09:22:24Z", "author": {"login": "RongtongJin"}, "path": "common/src/main/java/org/apache/rocketmq/common/rebalance/AllocateMessageQueueSticky.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.common.rebalance;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeSet;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+\n+public class AllocateMessageQueueSticky implements AllocateMessageQueueStrategy {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);\n+\n+    private final Map<String, List<MessageQueue>> messageQueueAllocation;\n+\n+    private final List<MessageQueue> unassignedQueues = new ArrayList<MessageQueue>();\n+\n+    public AllocateMessageQueueSticky(Map<String, List<MessageQueue>> messageQueueAllocation) {\n+        this.messageQueueAllocation = messageQueueAllocation;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3549cac6f4b00ca6d4ae3f23e7609011ae582cd9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIxOTI4Ng==", "bodyText": "IMO, It's would be better not to upload LitePullConsumerRebalanceByBrokerReliabilityTest.java and PushConsumerRebalanceByBrokerReliabilityTest.java, because they are not examples and will mislead users.\n\nYou're right. Those two tests had been taken off from the commit.\n\nWhy not just new a hashmap in the constructor instead of passing one \uff1f\n\nFixed. It's just a careless mistake. Thx for pointing out.", "url": "https://github.com/apache/rocketmq/pull/2169#discussion_r471219286", "createdAt": "2020-08-17T03:56:26Z", "author": {"login": "jack870131"}, "path": "common/src/main/java/org/apache/rocketmq/common/rebalance/AllocateMessageQueueSticky.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.rocketmq.common.rebalance;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeSet;\n+import org.apache.rocketmq.common.AllocateMessageQueueStrategy;\n+import org.apache.rocketmq.common.constant.LoggerName;\n+import org.apache.rocketmq.common.message.MessageQueue;\n+import org.apache.rocketmq.logging.InternalLogger;\n+import org.apache.rocketmq.logging.InternalLoggerFactory;\n+\n+public class AllocateMessageQueueSticky implements AllocateMessageQueueStrategy {\n+    private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);\n+\n+    private final Map<String, List<MessageQueue>> messageQueueAllocation;\n+\n+    private final List<MessageQueue> unassignedQueues = new ArrayList<MessageQueue>();\n+\n+    public AllocateMessageQueueSticky(Map<String, List<MessageQueue>> messageQueueAllocation) {\n+        this.messageQueueAllocation = messageQueueAllocation;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUxMjM4OQ=="}, "originalCommit": {"oid": "3549cac6f4b00ca6d4ae3f23e7609011ae582cd9"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1630, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}