{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3Mjg1MTg3", "number": 2406, "title": "[ISSUE #690] Support batch msgs in dledger mode", "bodyText": "What is the purpose of the change\n#690\nBrief changelog\nXX\nVerifying this change\nXXXX\nFollow this checklist to help us incorporate your contribution quickly and easily. Notice, it would be helpful if you could finish the following 5 checklist(the last one is not necessary)before request the community to review your PR.\n\n Make sure there is a Github issue filed for the change (usually before you start working on it). Trivial changes like typos do not require a Github issue. Your pull request should address just this issue, without pulling in other changes - one PR resolves one issue.\n Format the pull request title like [ISSUE #123] Fix UnknownException when host config not exist. Each commit in the pull request should have a meaningful subject line and body.\n Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\n Write necessary unit-test(over 80% coverage) to verify your logic correction, more mock a little better when cross module dependency exist. If the new feature or significant change is committed, please remember to add integration-test in test module.\n Run mvn -B clean apache-rat:check findbugs:findbugs checkstyle:checkstyle to make sure basic checks pass. Run mvn clean install -DskipITs to make sure unit-test pass. Run mvn clean test-compile failsafe:integration-test  to make sure integration-test pass.\n If this contribution is large, please file an Apache Individual Contributor License Agreement.", "createdAt": "2020-11-08T10:39:03Z", "url": "https://github.com/apache/rocketmq/pull/2406", "merged": true, "mergeCommit": {"oid": "4730987c9cc046c6db980a48aaed9eacc13c630d"}, "closed": true, "closedAt": "2020-12-08T08:58:59Z", "author": {"login": "TerrellChen"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdaHVorAH2gAyNTE3Mjg1MTg3OmQxNjg3ODY2M2VmNTZkMDVlZmMxMzhjMmQ0MWQxODZlOTExOGYwMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddY02MgFqTUzMjMxNzc1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d16878663ef56d05efc138c2d41d186e9118f033", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/d16878663ef56d05efc138c2d41d186e9118f033", "committedDate": "2020-11-07T08:32:14Z", "message": "implement issue-690"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6d4affa0ff54997dfb6d0561320cd9c18490a17", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/a6d4affa0ff54997dfb6d0561320cd9c18490a17", "committedDate": "2020-11-08T05:20:32Z", "message": "implement issue 690"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a7893bdb95761cb51ba02f9e8fffaefedbc2c4d", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/9a7893bdb95761cb51ba02f9e8fffaefedbc2c4d", "committedDate": "2020-11-08T09:52:09Z", "message": "add unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d638e5ffdb94f0957da36253eb971990ded68ea6", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/d638e5ffdb94f0957da36253eb971990ded68ea6", "committedDate": "2020-11-08T10:38:08Z", "message": "fix version"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1ODg1MTE4", "url": "https://github.com/apache/rocketmq/pull/2406#pullrequestreview-525885118", "createdAt": "2020-11-09T02:19:18Z", "commit": {"oid": "d638e5ffdb94f0957da36253eb971990ded68ea6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjoxOToxOFrOHvc9fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMjoyODoyNVrOHvdFPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxOTYxMg==", "bodyText": "When sending batch messages, worteOffset is the offset of the first message, but this is the offset of the last message, so the unit test fails.", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r519519612", "createdAt": "2020-11-09T02:19:18Z", "author": {"login": "RongtongJin"}, "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,122 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"[DEBUG_CTR] handleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            for (long pos : dledgerFuture.getPositions()) {\n+                wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }\n+            elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginTimeInDledgerLock;\n+            appendResult = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, encodeResult.totalMsgLen,\n+                    msgIdBuilder.toString(), System.currentTimeMillis(), queueOffset, elapsedTimeInLock);\n+            DLedgerCommitLog.this.topicQueueTable.put(encodeResult.queueOffsetKey, queueOffset + msgNum);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d638e5ffdb94f0957da36253eb971990ded68ea6"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyMDM3Mw==", "bodyText": "Write code as this:\nboolean isFirstOffset = true;\n            for (long pos : dledgerFuture.getPositions()) {\n                if(isFirstOffset) {\n                    wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n                    isFirstOffset = false;\n                }\n                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n                if (msgIdBuilder.length() > 0) {\n                    msgIdBuilder.append(',').append(msgId);\n                } else {\n                    msgIdBuilder.append(msgId);\n                }\n                msgNum++;\n            }\nOr do you have a better solution\uff1f", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r519520373", "createdAt": "2020-11-09T02:22:42Z", "author": {"login": "RongtongJin"}, "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,122 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"[DEBUG_CTR] handleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            for (long pos : dledgerFuture.getPositions()) {\n+                wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d638e5ffdb94f0957da36253eb971990ded68ea6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyMTU5OA==", "bodyText": "Removing [DEBUG_CTR] will be better.", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r519521598", "createdAt": "2020-11-09T02:28:25Z", "author": {"login": "RongtongJin"}, "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,122 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"[DEBUG_CTR] handleAppend return false due to error code {}\", dledgerFuture.get().getCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d638e5ffdb94f0957da36253eb971990ded68ea6"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08c9b0110d0b6e32a3c7ce741d3296f337700430", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/08c9b0110d0b6e32a3c7ce741d3296f337700430", "committedDate": "2020-11-10T15:15:02Z", "message": "fix wroteOffset;update version;polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/6e7488353dc2c35b6fba097da1b5c28ced7d2a61", "committedDate": "2020-11-10T15:43:33Z", "message": "polish"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3Njk3Mjk5", "url": "https://github.com/apache/rocketmq/pull/2406#pullrequestreview-527697299", "createdAt": "2020-11-10T23:45:09Z", "commit": {"oid": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo0NTowOVrOHw0ASA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMzo0NTo1MVrOHw0BRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTczNg==", "bodyText": "This is my fault. The code will cause the writeOffset of the following message not to be updated, so as to get the wrong msgId. We need to fix it and ensure that the writeOffset of the first message is returned to the user.", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520945736", "createdAt": "2020-11-10T23:45:09Z", "author": {"login": "RongtongJin"}, "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -609,7 +735,122 @@ public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n \n     @Override\n     public CompletableFuture<PutMessageResult> asyncPutMessages(MessageExtBatch messageExtBatch) {\n-        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status)));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"HandleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR)));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            boolean isFirstOffset = true;\n+            for (long pos : dledgerFuture.getPositions()) {\n+                if (isFirstOffset) {\n+                    wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                    isFirstOffset = false;\n+                }\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTk5MQ==", "bodyText": "Same as below", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520945991", "createdAt": "2020-11-10T23:45:51Z", "author": {"login": "RongtongJin"}, "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,127 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"HandleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            boolean isFirstOffset = true;\n+            for (long pos : dledgerFuture.getPositions()) {\n+                if (isFirstOffset) {\n+                    wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                    isFirstOffset = false;\n+                }\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1adcb5c00e9c759ce029438ac183f19e5b241854", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/1adcb5c00e9c759ce029438ac183f19e5b241854", "committedDate": "2020-11-12T14:35:14Z", "message": "Merge branch 'develop' of github.com:apache/rocketmq into issue_690"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37798914b2ca712844e49f3986626dcffbfb89b5", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/37798914b2ca712844e49f3986626dcffbfb89b5", "committedDate": "2020-11-12T15:26:47Z", "message": "fix wrong wroteOffset of AppendMessageResult"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dbf7d6c9f8a05763d5202f8151b5ffa5bb32661", "author": {"user": {"login": "TerrellChen", "name": null}}, "url": "https://github.com/apache/rocketmq/commit/4dbf7d6c9f8a05763d5202f8151b5ffa5bb32661", "committedDate": "2020-11-12T15:29:36Z", "message": "move serialization out of lock in async method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NjUxOTk0", "url": "https://github.com/apache/rocketmq/pull/2406#pullrequestreview-529651994", "createdAt": "2020-11-13T02:06:39Z", "commit": {"oid": "4dbf7d6c9f8a05763d5202f8151b5ffa5bb32661"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMzE3NzU2", "url": "https://github.com/apache/rocketmq/pull/2406#pullrequestreview-532317756", "createdAt": "2020-11-17T12:36:29Z", "commit": {"oid": "4dbf7d6c9f8a05763d5202f8151b5ffa5bb32661"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4899, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}