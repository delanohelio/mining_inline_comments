{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NzU5MDgy", "number": 5627, "title": "5966-open-source-GPX-module-and-update-how-it-makes-artifacts", "bodyText": "GPX internal python module update for open source and geoartifacthelper", "createdAt": "2020-01-31T20:30:51Z", "url": "https://github.com/sleuthkit/autopsy/pull/5627", "merged": true, "mergeCommit": {"oid": "29da2bf9cacb60802801443b4c0d3f406728b7e6"}, "closed": true, "closedAt": "2020-02-11T23:04:50Z", "author": {"login": "markmckinnon"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_1Lc1AH2gAyMzY5NzU5MDgyOmVkZDIwZTUwNmQ1ZGY3MDlkM2JiMmQzNTVhMThmNmM5ZmE0MjZjY2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcB_9eDAH2gAyMzY5NzU5MDgyOjQ4YjA3NDM1MjU4N2ViMGQ1YmM5Mjg1MDUwYmFhODVlNDdmMWZiNmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "edd20e506d5df709d3bb2d355a18f6c9fa426ccd", "author": {"user": {"login": "markmckinnon", "name": "Mark McKinnon"}}, "url": "https://github.com/sleuthkit/autopsy/commit/edd20e506d5df709d3bb2d355a18f6c9fa426ccd", "committedDate": "2020-01-31T20:29:38Z", "message": "GPX internal python module update\n\nGPX internal pythong module update for open source and geoartifacthelper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc63b3134c9cca3b50a1f7016cd95f1b878c50b8", "author": {"user": {"login": "markmckinnon", "name": "Mark McKinnon"}}, "url": "https://github.com/sleuthkit/autopsy/commit/dc63b3134c9cca3b50a1f7016cd95f1b878c50b8", "committedDate": "2020-02-04T20:26:46Z", "message": "Upgrade gpxpy to newer version\n\nUpgrade gpxpy to version 1.3.5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48acd461a7bfc698c026005b1e23f41d1ce1162d", "author": {"user": {"login": "markmckinnon", "name": "Mark McKinnon"}}, "url": "https://github.com/sleuthkit/autopsy/commit/48acd461a7bfc698c026005b1e23f41d1ce1162d", "committedDate": "2020-02-04T20:28:33Z", "message": "Update GPX_Parser_Module.py\n\nAdd tracks and route artifacts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTg0NjEz", "url": "https://github.com/sleuthkit/autopsy/pull/5627#pullrequestreview-353984613", "createdAt": "2020-02-05T19:33:22Z", "commit": {"oid": "48acd461a7bfc698c026005b1e23f41d1ce1162d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTozMzoyM1rOFmEgLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTozMzoyM1rOFmEgLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2Mzk4Mw==", "bodyText": "What is the purpose of this logic? It seems like the logic will break if we have a route that has only 1 point in it, because the end point will not be set and the artifact will not be created?", "url": "https://github.com/sleuthkit/autopsy/pull/5627#discussion_r375463983", "createdAt": "2020-02-05T19:33:23Z", "author": {"login": "eugene7646"}, "path": "InternalPythonModules/GPX_Module/GPX_Parser_Module.py", "diffHunk": "@@ -0,0 +1,265 @@\n+\"\"\"\n+Autopsy Forensic Browser\n+\n+Copyright 2019-2020 Basis Technology Corp.\n+Contact: carrier <at> sleuthkit <dot> org\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\"\"\"\n+\n+import os\n+import jarray\n+import inspect\n+import time\n+import calendar\n+from datetime import datetime\n+\n+from java.lang import System\n+from java.util.logging import Level\n+from java.io import File\n+from java.util import ArrayList\n+\n+from org.sleuthkit.datamodel import SleuthkitCase\n+from org.sleuthkit.datamodel import AbstractFile\n+from org.sleuthkit.datamodel import ReadContentInputStream\n+from org.sleuthkit.datamodel import Blackboard\n+from org.sleuthkit.datamodel import BlackboardArtifact\n+from org.sleuthkit.datamodel import BlackboardAttribute\n+from org.sleuthkit.datamodel import TskCoreException\n+from org.sleuthkit.datamodel.blackboardutils import GeoArtifactsHelper\n+from org.sleuthkit.datamodel.blackboardutils.attributes import GeoWaypoint\n+from org.sleuthkit.datamodel.blackboardutils.attributes import GeoTrackPoints\n+from org.sleuthkit.autopsy.datamodel import ContentUtils\n+from org.sleuthkit.autopsy.ingest import IngestModule\n+from org.sleuthkit.autopsy.ingest.IngestModule import IngestModuleException\n+from org.sleuthkit.autopsy.ingest import DataSourceIngestModule\n+from org.sleuthkit.autopsy.ingest import FileIngestModule\n+from org.sleuthkit.autopsy.ingest import IngestModuleFactoryAdapter\n+from org.sleuthkit.autopsy.ingest import IngestMessage\n+from org.sleuthkit.autopsy.ingest import IngestServices\n+from org.sleuthkit.autopsy.coreutils import Logger\n+from org.sleuthkit.autopsy.casemodule import Case\n+from org.sleuthkit.autopsy.casemodule.services import Services\n+from org.sleuthkit.autopsy.casemodule.services import FileManager\n+from org.sleuthkit.autopsy.ingest import ModuleDataEvent\n+\n+# Based on gpxpy module: https://github.com/tkrajina/gpxpy\n+import gpxpy\n+import gpxpy.gpx\n+import gpxpy.parser\n+\n+# Factory that defines the name and details of the module and allows Autopsy\n+# to create instances of the modules that will do the analysis.\n+class GPXParserDataSourceIngestModuleFactory(IngestModuleFactoryAdapter):\n+\n+    moduleName = \"GPX Parser Module\"\n+\n+    # True - Verbose debugging messages sent to log file.\n+    # False - Verbose debugging turned off.\n+    debuglevel = False\n+    \n+    def getModuleDisplayName(self):\n+        return self.moduleName\n+\n+    # TODO: Give it a description\n+    def getModuleDescription(self):\n+        return \"Module that extracts GEO data from GPX files.\"\n+\n+    def getModuleVersionNumber(self):\n+        return \"1.1\"\n+\n+    def isDataSourceIngestModuleFactory(self):\n+        return True\n+\n+    def createDataSourceIngestModule(self, ingestOptions):\n+        return GPXParserDataSourceIngestModule()\n+\n+    \n+# Data Source-level ingest module. One gets created per data source.\n+class GPXParserDataSourceIngestModule(DataSourceIngestModule):\n+\n+    _logger = Logger.getLogger(GPXParserDataSourceIngestModuleFactory.moduleName)\n+\n+    def log(self, level, msg):\n+        self._logger.logp(level, self.__class__.__name__, inspect.stack()[1][3], msg)\n+\n+    def __init__(self):\n+        self.context = None\n+\n+    # Where any setup and configuration is done.\n+    def startUp(self, context):\n+        self.context = context\n+\n+    # Where the analysis is done.\n+    def process(self, dataSource, progressBar):\n+\n+        # We don't know how much work there is yet.\n+        progressBar.switchToIndeterminate()\n+\n+        # This will work in 4.0.1 and beyond.\n+        # Use blackboard class to index blackboard artifacts for keyword search.\n+        blackboard = Case.getCurrentCase().getServices().getBlackboard()\n+        \n+        # Get the sleuthkitcase\n+        skCase = Case.getCurrentCase().getSleuthkitCase()\n+\n+        # In the name and then count and read them.\n+        fileManager = Case.getCurrentCase().getServices().getFileManager()\n+        \n+        files = fileManager.findFiles(dataSource, \"%.gpx\")\n+        # TODO: Would like to change this to find files based on mimetype rather than extension.\n+        #files = findFiles(dataSource, \"text/xml\")\n+        #if (file.isMimeType('text/xml') == False):\n+\n+        numFiles = len(files)\n+        if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"found \" + str(numFiles) + \" files\") \n+        progressBar.switchToDeterminate(numFiles)\n+        fileCount = 0;\n+\n+        # Get module name for adding attributes\n+        moduleName = GPXParserDataSourceIngestModuleFactory.moduleName\n+        \n+        for file in files:\n+\n+            # Get the GeoArtifactsHelper\n+            geoArtifactHelper = GeoArtifactsHelper(skCase, moduleName, file) \n+            \n+            # Check if the user pressed cancel while we were busy.\n+            if self.context.isJobCancelled():\n+                return IngestModule.ProcessResult.OK\n+\n+            #self.log(Level.INFO, \"GPX: Processing file: \" + file.getName())\n+            fileCount += 1\n+\n+            # Check if module folder is present. If not, create it.\n+            dirName = os.path.join(Case.getCurrentCase().getTempDirectory(), \"GPX_Parser_Module\")\n+            try:\n+                os.stat(dirName)\n+            except:\n+                os.mkdir(dirName)\n+            fileName = os.path.join(dirName, \"tmp.gpx\")\n+\n+            # Check to see if temporary file exists. If it does, remove it.\n+            if os.path.exists(fileName):\n+                try:\n+                    os.remove(fileName)\n+                    if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"GPX:\\t\" + \"FILE DELETED \" + fileName )\n+                except:\n+                    if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"GPX:\\t\" + \"FILE NOT DELETED \" + fileName)\n+\n+            # This writes the file to the local file system.\n+            localFile = File(fileName)\n+            ContentUtils.writeToFile(file, localFile)\n+\n+            # Send to gpxpy for parsing.\n+            gpxfile = open(fileName)\n+            try:\n+                gpx = gpxpy.parse(gpxfile)\n+                if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"GPX:\\t\" + \"FILE PARSED\")\n+            except:\n+                if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.SEVERE, \"GPX:\\t\" + file.getName() + \" - FILE NOT PARSED\")\n+                continue\n+            \n+            if gpx:\n+                if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"GPX: TRACKS\")\n+                for track in gpx.tracks:                \n+                    for segment in track.segments:\n+                        geoPointList = ArrayList()\n+                        for point in segment.points:\n+                            \n+                            elevation = 0\n+                            if point.elevation != None:\n+                                elevation = point.elevation\n+                                \n+                            dateTime = 0                               \n+                            try: \n+                                if (point.time != None):\n+                                    datetime = long(time.mktime(point.time.timetuple()))                                    \n+                            except:                            \n+                                pass\n+\n+                            geoPointList.add(GeoWaypoint.GeoTrackPoint(point.latitude, point.longitude, elevation, 0, 0, 0, dateTime))\n+                                                                                                             \n+                        try:\n+                        # Add the trackpoint using the helper class\n+                            geoartifact = geoArtifactHelper.addTrack(\"Trackpoint\", geoPointList)\n+                        except Blackboard.BlackboardException as e:\n+                            if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.SEVERE, \"GPX: Error using geo artifact helper with blackboard \" )\n+                        except TskCoreException as e:\n+                            if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.SEVERE, \"GPX: Error using geo artifact helper tskcoreexception\" )\n+                            \n+                if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"GPX: WAYPOINTS\") \n+                for waypoint in gpx.waypoints:\n+                    attributes = ArrayList()\n+                    art = file.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_BOOKMARK)\n+\n+                    attributes.add(BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, waypoint.latitude))\n+                    attributes.add(BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, waypoint.longitude))                    \n+                    attributes.add(BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FLAG.getTypeID(), moduleName, \"Waypoint\"))\n+                    attributes.add(BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, waypoint.name))\n+                    attributes.add(BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, \"GPXParser\"))\n+\n+                    art.addAttributes(attributes)\n+                    \n+                    try:\n+                    # Post the artifact to blackboard\n+                       skCase.getBlackboard().postArtifact(art, moduleName)\n+                    except Blackboard.BlackboardException as e:\n+                        if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.SEVERE, \"GPX: Error using geo artifact helper with blackboard  for waypoints\" )\n+\n+                if GPXParserDataSourceIngestModuleFactory.debuglevel: self.log(Level.INFO, \"GPX: ROUTES\")\n+                for route in gpx.routes:    \n+                    firstTimeThru = 0\n+                    startingPoint = list()\n+                    endingPoint = list()\n+                    for point in route.points:\n+                        # If first time in loop only populate starting point", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48acd461a7bfc698c026005b1e23f41d1ce1162d"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODU5NDE0", "url": "https://github.com/sleuthkit/autopsy/pull/5627#pullrequestreview-354859414", "createdAt": "2020-02-07T00:09:57Z", "commit": {"oid": "48acd461a7bfc698c026005b1e23f41d1ce1162d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48b074352587eb0d5bc9285050baa85e47f1fb6b", "author": {"user": {"login": "markmckinnon", "name": "Mark McKinnon"}}, "url": "https://github.com/sleuthkit/autopsy/commit/48b074352587eb0d5bc9285050baa85e47f1fb6b", "committedDate": "2020-02-07T14:11:10Z", "message": "Update GPX_Parser_Module.py\n\nAdded logic that if there is only a starting point and no ending point it will use the starting point as the ending point.  This can happen in a GPX route file for whatever reason."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2763, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}