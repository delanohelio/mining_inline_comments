{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3MzM2ODE5", "number": 6140, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNDozMjoxMVrOEUFGFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0Mjo1MFrOEUojeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NDkwNDUzOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNDozMjoxMVrOG6KuqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNDozMjoxMVrOG6KuqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY0NjM3Ng==", "bodyText": "Unused import", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r463646376", "createdAt": "2020-07-31T14:32:11Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -18,6 +18,8 @@\n  */\n package org.sleuthkit.autopsy.casemodule.datasourcesummary;\n \n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n import java.util.ArrayList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bb530923df9cc4f9003556bc96216b6c7309795"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NDkyOTg4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNDozOTowM1rOG6K-Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNTozNTo0M1rOG6-ZFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1MDM3NA==", "bodyText": "ResultSet should be closed.", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r463650374", "createdAt": "2020-07-31T14:39:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -43,6 +45,297 @@\n \n     private static final Logger logger = Logger.getLogger(DataSourceInfoUtilities.class.getName());\n \n+    /**\n+     * Gets a count of files for a particular datasource where it is not a\n+     * virtual directory and has a name.\n+     *\n+     * @param currentDataSource The datasource.\n+     * @param additionalWhere   Additional sql where clauses.\n+     * @param onError           The message to log on error.\n+     *\n+     * @return The count of files or null on error.\n+     */\n+    private static Long getCountOfFiles(DataSource currentDataSource, String additionalWhere, String onError) {\n+        if (currentDataSource != null) {\n+            try {\n+                SleuthkitCase skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+                return skCase.countFilesWhere(\n+                        \"dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                        + \" AND name<>''\"\n+                        + \" AND data_source_obj_id=\" + currentDataSource.getId()\n+                        + \" AND \" + additionalWhere);\n+            } catch (TskCoreException | NoCurrentCaseException ex) {\n+                logger.log(Level.WARNING, onError, ex);\n+                //unable to get count of files for the specified types cell will be displayed as empty\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get count of files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType(),\n+                \"Unable to get count of files, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of unallocated files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfUnallocatedFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue(),\n+                \"Unable to get counts of unallocated files for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of directories in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfDirectories(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND meta_type=\" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR.getValue(),\n+                \"Unable to get count of directories for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of slack files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfSlackFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type=\" + TskData.TSK_DB_FILES_TYPE_ENUM.SLACK.getFileType(),\n+                \"Unable to get count of slack files for datasources, providing empty results\");\n+    }\n+\n+    /**\n+     * An interface for handling a result set and returning a value.\n+     */\n+    private interface ResultSetHandler<T> {\n+\n+        T process(ResultSet resultset) throws SQLException;\n+    }\n+\n+    /**\n+     * Retrieves a result based on the provided query.\n+     *\n+     * @param query        The query.\n+     * @param processor    The result set handler.\n+     * @param errorMessage The error message to display if there is an error\n+     *                     retrieving the resultset.\n+     *\n+     * @return The ResultSetHandler value or null if no ResultSet could be\n+     *         obtained.\n+     */\n+    private static <T> T getBaseQueryResult(String query, ResultSetHandler<T> processor, String errorMessage) {\n+        try (SleuthkitCase.CaseDbQuery dbQuery = Case.getCurrentCaseThrows().getSleuthkitCase().executeQuery(query)) {\n+            ResultSet resultSet = dbQuery.getResultSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bb530923df9cc4f9003556bc96216b6c7309795"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MjgyMw==", "bodyText": "As greg has pointed out to me CaseDbQuery closes the resultSet, so this is not an issue.", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r464492823", "createdAt": "2020-08-03T15:35:43Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -43,6 +45,297 @@\n \n     private static final Logger logger = Logger.getLogger(DataSourceInfoUtilities.class.getName());\n \n+    /**\n+     * Gets a count of files for a particular datasource where it is not a\n+     * virtual directory and has a name.\n+     *\n+     * @param currentDataSource The datasource.\n+     * @param additionalWhere   Additional sql where clauses.\n+     * @param onError           The message to log on error.\n+     *\n+     * @return The count of files or null on error.\n+     */\n+    private static Long getCountOfFiles(DataSource currentDataSource, String additionalWhere, String onError) {\n+        if (currentDataSource != null) {\n+            try {\n+                SleuthkitCase skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+                return skCase.countFilesWhere(\n+                        \"dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                        + \" AND name<>''\"\n+                        + \" AND data_source_obj_id=\" + currentDataSource.getId()\n+                        + \" AND \" + additionalWhere);\n+            } catch (TskCoreException | NoCurrentCaseException ex) {\n+                logger.log(Level.WARNING, onError, ex);\n+                //unable to get count of files for the specified types cell will be displayed as empty\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get count of files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType(),\n+                \"Unable to get count of files, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of unallocated files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfUnallocatedFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue(),\n+                \"Unable to get counts of unallocated files for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of directories in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfDirectories(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND meta_type=\" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR.getValue(),\n+                \"Unable to get count of directories for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of slack files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfSlackFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type=\" + TskData.TSK_DB_FILES_TYPE_ENUM.SLACK.getFileType(),\n+                \"Unable to get count of slack files for datasources, providing empty results\");\n+    }\n+\n+    /**\n+     * An interface for handling a result set and returning a value.\n+     */\n+    private interface ResultSetHandler<T> {\n+\n+        T process(ResultSet resultset) throws SQLException;\n+    }\n+\n+    /**\n+     * Retrieves a result based on the provided query.\n+     *\n+     * @param query        The query.\n+     * @param processor    The result set handler.\n+     * @param errorMessage The error message to display if there is an error\n+     *                     retrieving the resultset.\n+     *\n+     * @return The ResultSetHandler value or null if no ResultSet could be\n+     *         obtained.\n+     */\n+    private static <T> T getBaseQueryResult(String query, ResultSetHandler<T> processor, String errorMessage) {\n+        try (SleuthkitCase.CaseDbQuery dbQuery = Case.getCurrentCaseThrows().getSleuthkitCase().executeQuery(query)) {\n+            ResultSet resultSet = dbQuery.getResultSet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1MDM3NA=="}, "originalCommit": {"oid": "1bb530923df9cc4f9003556bc96216b6c7309795"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NDk4NTY1OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNDo1Mzo1N1rOG6LgwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNDo1Mzo1N1rOG6LgwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1OTIwMA==", "bodyText": "Method name does not really make sense to me since it is getting a string based on results not getting a query itself.", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r463659200", "createdAt": "2020-07-31T14:53:57Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/DataSourceInfoUtilities.java", "diffHunk": "@@ -43,6 +45,297 @@\n \n     private static final Logger logger = Logger.getLogger(DataSourceInfoUtilities.class.getName());\n \n+    /**\n+     * Gets a count of files for a particular datasource where it is not a\n+     * virtual directory and has a name.\n+     *\n+     * @param currentDataSource The datasource.\n+     * @param additionalWhere   Additional sql where clauses.\n+     * @param onError           The message to log on error.\n+     *\n+     * @return The count of files or null on error.\n+     */\n+    private static Long getCountOfFiles(DataSource currentDataSource, String additionalWhere, String onError) {\n+        if (currentDataSource != null) {\n+            try {\n+                SleuthkitCase skCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+                return skCase.countFilesWhere(\n+                        \"dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                        + \" AND name<>''\"\n+                        + \" AND data_source_obj_id=\" + currentDataSource.getId()\n+                        + \" AND \" + additionalWhere);\n+            } catch (TskCoreException | NoCurrentCaseException ex) {\n+                logger.log(Level.WARNING, onError, ex);\n+                //unable to get count of files for the specified types cell will be displayed as empty\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get count of files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType(),\n+                \"Unable to get count of files, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of unallocated files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfUnallocatedFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue(),\n+                \"Unable to get counts of unallocated files for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of directories in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfDirectories(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND meta_type=\" + TskData.TSK_FS_META_TYPE_ENUM.TSK_FS_META_TYPE_DIR.getValue(),\n+                \"Unable to get count of directories for datasource, providing empty results\");\n+    }\n+\n+    /**\n+     * Get count of slack files in a data source.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The count.\n+     */\n+    static Long getCountOfSlackFiles(DataSource currentDataSource) {\n+        return getCountOfFiles(currentDataSource,\n+                \"type=\" + TskData.TSK_DB_FILES_TYPE_ENUM.SLACK.getFileType(),\n+                \"Unable to get count of slack files for datasources, providing empty results\");\n+    }\n+\n+    /**\n+     * An interface for handling a result set and returning a value.\n+     */\n+    private interface ResultSetHandler<T> {\n+\n+        T process(ResultSet resultset) throws SQLException;\n+    }\n+\n+    /**\n+     * Retrieves a result based on the provided query.\n+     *\n+     * @param query        The query.\n+     * @param processor    The result set handler.\n+     * @param errorMessage The error message to display if there is an error\n+     *                     retrieving the resultset.\n+     *\n+     * @return The ResultSetHandler value or null if no ResultSet could be\n+     *         obtained.\n+     */\n+    private static <T> T getBaseQueryResult(String query, ResultSetHandler<T> processor, String errorMessage) {\n+        try (SleuthkitCase.CaseDbQuery dbQuery = Case.getCurrentCaseThrows().getSleuthkitCase().executeQuery(query)) {\n+            ResultSet resultSet = dbQuery.getResultSet();\n+            try {\n+                return processor.process(resultSet);\n+            } catch (SQLException ex) {\n+                logger.log(Level.WARNING, errorMessage, ex);\n+            }\n+        } catch (TskCoreException | NoCurrentCaseException ex) {\n+            logger.log(Level.WARNING, errorMessage, ex);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of unallocated files in a particular datasource.\n+     *\n+     * @param currentDataSource The data source.\n+     *\n+     * @return The size or null if the query could not be executed.\n+     */\n+    static Long getSizeOfUnallocatedFiles(DataSource currentDataSource) {\n+        if (currentDataSource == null) {\n+            return null;\n+        }\n+\n+        final String valueParam = \"value\";\n+        final String countParam = \"count\";\n+        String query = \"SELECT SUM(size) AS \" + valueParam + \", COUNT(*) AS \" + countParam\n+                + \" FROM tsk_files WHERE type<>\" + TskData.TSK_DB_FILES_TYPE_ENUM.VIRTUAL_DIR.getFileType()\n+                + \" AND dir_type<>\" + TskData.TSK_FS_NAME_TYPE_ENUM.VIRT_DIR.getValue()\n+                + \" AND dir_flags=\" + TskData.TSK_FS_NAME_FLAG_ENUM.UNALLOC.getValue()\n+                + \" AND name<>''\"\n+                + \" AND data_source_obj_id=\" + currentDataSource.getId();\n+\n+        ResultSetHandler<Long> handler = (resultSet) -> {\n+            if (resultSet.next()) {\n+                // ensure that there is an unallocated count result that is attached to this data source\n+                long resultCount = resultSet.getLong(valueParam);\n+                return (resultCount > 0) ? resultSet.getLong(valueParam) : null;\n+            } else {\n+                return null;\n+            }\n+        };\n+        String errorMessage = \"Unable to get size of unallocated files; returning null.\";\n+\n+        return getBaseQueryResult(query, handler, errorMessage);\n+    }\n+\n+    /**\n+     * Retrieves counts for each artifact type in a data source.\n+     *\n+     * @param selectedDataSource The data source.\n+     *\n+     * @return A mapping of artifact type name to the counts or null if there\n+     *         was an error executing the query.\n+     */\n+    static Map<String, Long> getCountsOfArtifactsByType(DataSource selectedDataSource) {\n+        if (selectedDataSource == null) {\n+            return Collections.emptyMap();\n+        }\n+\n+        final String nameParam = \"name\";\n+        final String valueParam = \"value\";\n+        String query\n+                = \"SELECT bbt.display_name AS \" + nameParam + \", COUNT(*) AS \" + valueParam\n+                + \" FROM blackboard_artifacts bba \"\n+                + \" INNER JOIN blackboard_artifact_types bbt ON bba.artifact_type_id = bbt.artifact_type_id\"\n+                + \" WHERE bba.data_source_obj_id =\" + selectedDataSource.getId()\n+                + \" GROUP BY bbt.display_name\";\n+\n+        ResultSetHandler<Map<String, Long>> handler = (resultSet) -> {\n+            Map<String, Long> toRet = new HashMap<>();\n+            while (resultSet.next()) {\n+                try {\n+                    toRet.put(resultSet.getString(nameParam), resultSet.getLong(valueParam));\n+                } catch (SQLException ex) {\n+                    logger.log(Level.WARNING, \"Failed to get a result pair from the result set.\", ex);\n+                }\n+            }\n+\n+            return toRet;\n+        };\n+\n+        String errorMessage = \"Unable to get artifact type counts; returning null.\";\n+\n+        return getBaseQueryResult(query, handler, errorMessage);\n+    }\n+\n+    /**\n+     * Generates a string which is a concatenation of the value received from\n+     * the result set.\n+     *\n+     * @param query              The query.\n+     * @param valueParam         The parameter for the value in the result set.\n+     * @param separator          The string separator used in concatenation.\n+     * @param errorMessage       The error message if the result set could not\n+     *                           be received.\n+     * @param singleErrorMessage The error message if a single result could not\n+     *                           be obtained.\n+     *\n+     * @return The concatenated string or null if the query could not be\n+     *         executed.\n+     */\n+    private static String getConcattedStringQuery(String query, String valueParam, String separator, String errorMessage, String singleErrorMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bb530923df9cc4f9003556bc96216b6c7309795"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDcxNDE4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/NonEditableTableModel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0Mjo1MFrOG68WCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDo0Mjo1MFrOG68WCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1OTI3Mw==", "bodyText": "add serial id to make codacy and netbeans happy", "url": "https://github.com/sleuthkit/autopsy/pull/6140#discussion_r464459273", "createdAt": "2020-08-03T14:42:50Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/casemodule/datasourcesummary/NonEditableTableModel.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.casemodule.datasourcesummary;\n+\n+import javax.swing.table.DefaultTableModel;\n+\n+/**\n+ * A Table model where cells are not editable.\n+ */\n+class NonEditableTableModel extends DefaultTableModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8d2e48e2553ec3032af58d10649a111cf5d6c8f"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 921, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}