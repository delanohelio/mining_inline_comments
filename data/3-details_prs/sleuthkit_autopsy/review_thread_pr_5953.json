{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxMzk4OTAw", "number": 5953, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMTowNToyOFrOEHusog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMTowNToyOFrOEHusog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTQwNTc4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/datamodel/RefreshThrottler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMTowNToyOFrOGnQ-ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjoyNTo1MlrOGoP2mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNTg1MA==", "bodyText": "There is a typo on this line.", "url": "https://github.com/sleuthkit/autopsy/pull/5953#discussion_r443825850", "createdAt": "2020-06-22T21:05:28Z", "author": {"login": "rcordovano"}, "path": "Core/src/org/sleuthkit/autopsy/datamodel/RefreshThrottler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2011-2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datamodel;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+\n+/**\n+ * Utility class that can be used by UI nodes to reduce the number of\n+ * potentially expensive UI refresh events when DATA_ADDED and CONTENT_CHANGED\n+ * ingest manager events are received.\n+ */\n+class RefreshThrottler {\n+\n+    /**\n+     * The Refresher interface needs to be implemented by ChildFactory instances\n+     * that wish to take advantage of throttled refresh functionality.\n+     */\n+    interface Refresher {\n+\n+        /**\n+         * The RefreshThrottler calls this method when the RefreshTask runs.\n+         *\n+         */\n+        void refresh();\n+\n+        /**\n+         * Determine whether the given event should result in a refresh.\n+         *\n+         * @param evt\n+         *\n+         * @return true if event should trigger a refresh, otherwise false.\n+         */\n+        boolean isRefreshRequired(PropertyChangeEvent evt);\n+    }\n+\n+    static ScheduledThreadPoolExecutor refreshExecutor = new ScheduledThreadPoolExecutor(1, new ThreadFactoryBuilder().setNameFormat(\"Node Refresh Thread\").build());\n+    // Keep a thread safe reference to the current refresh task (if any)\n+    private final AtomicReference<RefreshTask> refreshTaskRef;\n+\n+    // The factory instance that will be called when a refresh is due.\n+    private final Refresher refresher;\n+\n+    private static final long MIN_SECONDS_BETWEEN_RERFESH = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e4b6d28156d1fa3c2227330dd84127a2dcc1dba"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1NTk2Mw==", "bodyText": "Fixed. Thanks.", "url": "https://github.com/sleuthkit/autopsy/pull/5953#discussion_r444855963", "createdAt": "2020-06-24T12:25:52Z", "author": {"login": "esaunders"}, "path": "Core/src/org/sleuthkit/autopsy/datamodel/RefreshThrottler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2011-2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datamodel;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+\n+/**\n+ * Utility class that can be used by UI nodes to reduce the number of\n+ * potentially expensive UI refresh events when DATA_ADDED and CONTENT_CHANGED\n+ * ingest manager events are received.\n+ */\n+class RefreshThrottler {\n+\n+    /**\n+     * The Refresher interface needs to be implemented by ChildFactory instances\n+     * that wish to take advantage of throttled refresh functionality.\n+     */\n+    interface Refresher {\n+\n+        /**\n+         * The RefreshThrottler calls this method when the RefreshTask runs.\n+         *\n+         */\n+        void refresh();\n+\n+        /**\n+         * Determine whether the given event should result in a refresh.\n+         *\n+         * @param evt\n+         *\n+         * @return true if event should trigger a refresh, otherwise false.\n+         */\n+        boolean isRefreshRequired(PropertyChangeEvent evt);\n+    }\n+\n+    static ScheduledThreadPoolExecutor refreshExecutor = new ScheduledThreadPoolExecutor(1, new ThreadFactoryBuilder().setNameFormat(\"Node Refresh Thread\").build());\n+    // Keep a thread safe reference to the current refresh task (if any)\n+    private final AtomicReference<RefreshTask> refreshTaskRef;\n+\n+    // The factory instance that will be called when a refresh is due.\n+    private final Refresher refresher;\n+\n+    private static final long MIN_SECONDS_BETWEEN_RERFESH = 5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNTg1MA=="}, "originalCommit": {"oid": "1e4b6d28156d1fa3c2227330dd84127a2dcc1dba"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 511, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}