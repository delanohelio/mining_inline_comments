{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NjE4ODQw", "number": 6149, "title": "1498 make method to map account to contact book", "bodyText": "", "createdAt": "2020-07-29T18:49:05Z", "url": "https://github.com/sleuthkit/autopsy/pull/6149", "merged": true, "mergeCommit": {"oid": "f0efc5bee0fad92f48c3ab870152751dedd90e4c"}, "closed": true, "closedAt": "2020-08-12T15:26:08Z", "author": {"login": "kellykelly3"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc31j02gH2gAyNDU4NjE4ODQwOmYxNzFkZTI1YzZkNDc4NWNhNTYzNGNmZDE4YzllMjg0YzA5M2E2ZmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-MkNiAFqTQ2NTk5MDk3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f171de25c6d4785ca5634cfd18c9e284c093a6fe", "author": {"user": {"login": "kellykelly3", "name": null}}, "url": "https://github.com/sleuthkit/autopsy/commit/f171de25c6d4785ca5634cfd18c9e284c093a6fe", "committedDate": "2020-07-23T20:36:01Z", "message": "Added ContactCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "692b4604fa511fc3ea376a615d48fdd01e69940d", "author": {"user": {"login": "kellykelly3", "name": null}}, "url": "https://github.com/sleuthkit/autopsy/commit/692b4604fa511fc3ea376a615d48fdd01e69940d", "committedDate": "2020-07-23T20:47:23Z", "message": "Address codacy issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d028db66dd1e687590e20d56acf05932e3e82fcc", "author": {"user": {"login": "kellykelly3", "name": null}}, "url": "https://github.com/sleuthkit/autopsy/commit/d028db66dd1e687590e20d56acf05932e3e82fcc", "committedDate": "2020-07-29T18:46:52Z", "message": "Modified cvt account cache to be more efficent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd", "author": {"user": {"login": "kellykelly3", "name": null}}, "url": "https://github.com/sleuthkit/autopsy/commit/1d168f32f4c34399490bda0661c686da9b0975dd", "committedDate": "2020-08-03T15:04:33Z", "message": "Simplified algorithum"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTA1Njc5", "url": "https://github.com/sleuthkit/autopsy/pull/6149#pullrequestreview-461905679", "createdAt": "2020-08-05T18:09:34Z", "commit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowOTozNFrOG8U9Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxMjozN1rOG8VDcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTA1NA==", "bodyText": "You may find acctMap.getOrDefault(accountID, new ArrayList<>()) useful here.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465911054", "createdAt": "2020-08-05T18:09:34Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {\n+            String eventType = pce.getPropertyName();\n+            if (eventType.equals(DATA_ADDED.toString())) {\n+                ModuleDataEvent eventData = (ModuleDataEvent) pce.getOldValue();\n+                if (eventData.getBlackboardArtifactType().getTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT.getTypeID()) {\n+                    invalidateCache();\n+                }\n+            }\n+        };\n+\n+        IngestManager.getInstance().addIngestModuleEventListener(EnumSet.of(DATA_ADDED), ingestListener);\n+    }\n+\n+    /**\n+     * Returns the singleton instance of the cache object.\n+     *\n+     * @return AccountCache instance.\n+     */\n+    private static synchronized ContactCache getInstance() {\n+        if (instance == null) {\n+            instance = new ContactCache();\n+        }\n+\n+        return instance;\n+    }\n+    \n+    /**\n+     * Builds the map of account IDs to contacts that reference them.\n+     * \n+     * @return A map of account IDs to contact artifacts.\n+     * \n+     * @throws TskCoreException\n+     * @throws SQLException \n+     */\n+    private Map<String, List<BlackboardArtifact>> buildMap() throws TskCoreException, SQLException {\n+        Map<String, List<BlackboardArtifact>> acctMap = new HashMap<>();\n+        List<BlackboardArtifact> contactList = Case.getCurrentCase().getSleuthkitCase().getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n+\n+        for(BlackboardArtifact contactArtifact: contactList) {\n+            List<BlackboardAttribute> contactAttributes = contactArtifact.getAttributes();\n+            for(BlackboardAttribute attribute: contactAttributes) {\n+                String typeName = attribute.getAttributeType().getTypeName();\n+                \n+                if(typeName.startsWith(\"TSK_EMAIL\")\n+                || typeName.startsWith(\"TSK_PHONE\")\n+                || typeName.startsWith(\"TSK_NAME\")\n+                || typeName.startsWith(\"TSK_ID\")) {\n+                    String accountID = attribute.getValueString();\n+                    List<BlackboardArtifact> artifactList = acctMap.get(accountID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMjY4OQ==", "bodyText": "In its current state, switching between cases may return old artifacts. Could you invalidate the cache when a case is closed?", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465912689", "createdAt": "2020-08-05T18:12:37Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTExNjc5", "url": "https://github.com/sleuthkit/autopsy/pull/6149#pullrequestreview-461911679", "createdAt": "2020-08-05T18:18:16Z", "commit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxODoxN1rOG8VPBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxODoxN1rOG8VPBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA==", "bodyText": "I was originally going to post this on the story but I can't find it. But, this class seems to be filling a void in SleuthkitCase, @rcordovano would it make sense to add queries to be able to select artifacts by type and attribute value? I'd imagine this functionality will be needed elsewhere.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465915654", "createdAt": "2020-08-05T18:18:17Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ca4dc6022e5d7ca8c9a8263a7b6c251f2c92b13", "author": {"user": {"login": "kellykelly3", "name": null}}, "url": "https://github.com/sleuthkit/autopsy/commit/5ca4dc6022e5d7ca8c9a8263a7b6c251f2c92b13", "committedDate": "2020-08-05T19:12:22Z", "message": "Updated based on review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1OTkwOTc3", "url": "https://github.com/sleuthkit/autopsy/pull/6149#pullrequestreview-465990977", "createdAt": "2020-08-12T14:47:49Z", "commit": {"oid": "5ca4dc6022e5d7ca8c9a8263a7b6c251f2c92b13"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2904, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}