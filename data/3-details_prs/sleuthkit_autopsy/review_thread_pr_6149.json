{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NjE4ODQw", "number": 6149, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowOTozNFrOEVhazw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxODoxN1rOEVhltQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDAzMDg3OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowOTozNFrOG8U9Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowOTozNFrOG8U9Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTA1NA==", "bodyText": "You may find acctMap.getOrDefault(accountID, new ArrayList<>()) useful here.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465911054", "createdAt": "2020-08-05T18:09:34Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {\n+            String eventType = pce.getPropertyName();\n+            if (eventType.equals(DATA_ADDED.toString())) {\n+                ModuleDataEvent eventData = (ModuleDataEvent) pce.getOldValue();\n+                if (eventData.getBlackboardArtifactType().getTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT.getTypeID()) {\n+                    invalidateCache();\n+                }\n+            }\n+        };\n+\n+        IngestManager.getInstance().addIngestModuleEventListener(EnumSet.of(DATA_ADDED), ingestListener);\n+    }\n+\n+    /**\n+     * Returns the singleton instance of the cache object.\n+     *\n+     * @return AccountCache instance.\n+     */\n+    private static synchronized ContactCache getInstance() {\n+        if (instance == null) {\n+            instance = new ContactCache();\n+        }\n+\n+        return instance;\n+    }\n+    \n+    /**\n+     * Builds the map of account IDs to contacts that reference them.\n+     * \n+     * @return A map of account IDs to contact artifacts.\n+     * \n+     * @throws TskCoreException\n+     * @throws SQLException \n+     */\n+    private Map<String, List<BlackboardArtifact>> buildMap() throws TskCoreException, SQLException {\n+        Map<String, List<BlackboardArtifact>> acctMap = new HashMap<>();\n+        List<BlackboardArtifact> contactList = Case.getCurrentCase().getSleuthkitCase().getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n+\n+        for(BlackboardArtifact contactArtifact: contactList) {\n+            List<BlackboardAttribute> contactAttributes = contactArtifact.getAttributes();\n+            for(BlackboardAttribute attribute: contactAttributes) {\n+                String typeName = attribute.getAttributeType().getTypeName();\n+                \n+                if(typeName.startsWith(\"TSK_EMAIL\")\n+                || typeName.startsWith(\"TSK_PHONE\")\n+                || typeName.startsWith(\"TSK_NAME\")\n+                || typeName.startsWith(\"TSK_ID\")) {\n+                    String accountID = attribute.getValueString();\n+                    List<BlackboardArtifact> artifactList = acctMap.get(accountID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDA0MTAxOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxMjozN1rOG8VDcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo0MzoyN1rOG8WFFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMjY4OQ==", "bodyText": "In its current state, switching between cases may return old artifacts. Could you invalidate the cache when a case is closed?", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465912689", "createdAt": "2020-08-05T18:12:37Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyOTQ5Mg==", "bodyText": "Good idea.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465929492", "createdAt": "2020-08-05T18:43:27Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {\n+\n+    private static final Logger logger = Logger.getLogger(ContactCache.class.getName());\n+\n+    private static ContactCache instance;\n+    \n+    private final LoadingCache<String, Map<String, List<BlackboardArtifact>>> accountMap;\n+\n+    /**\n+     * Returns the list of Contacts for the given Account.\n+     *\n+     * @param account Account instance.\n+     *\n+     * @return List of TSK_CONTACT artifacts that references the given Account.\n+     *         An empty list is returned if no contacts are found.\n+     *\n+     * @throws ExecutionException\n+     */\n+    static synchronized List<BlackboardArtifact> getContacts(Account account) throws ExecutionException {\n+        return getInstance().accountMap.get(\"realMap\").get(account.getTypeSpecificID());\n+    }\n+\n+    /**\n+     * Force the cache to invalidate all entries.\n+     */\n+    static synchronized void invalidateCache() {\n+        getInstance().accountMap.invalidateAll();\n+    }\n+\n+    /**\n+     * Construct a new instance.\n+     */\n+    private ContactCache() {\n+        \n+        accountMap = CacheBuilder.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES).build(\n+                new CacheLoader<String, Map<String, List<BlackboardArtifact>>>() {\n+            @Override\n+            public Map<String, List<BlackboardArtifact>> load(String key) {\n+                try {\n+                    return  buildMap();\n+                } catch (SQLException | TskCoreException ex) {\n+                    logger.log(Level.WARNING, \"Failed to build account to contact map\", ex);\n+                } \n+                return new HashMap<>();  // Return an empty map if there is an exception to avoid NPE and continual trying.\n+            }\n+        });\n+\n+        PropertyChangeListener ingestListener = pce -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMjY4OQ=="}, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDA1ODc3OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoxODoxN1rOG8VPBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo1Mjo0OFrOG8WY6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA==", "bodyText": "I was originally going to post this on the story but I can't find it. But, this class seems to be filling a void in SleuthkitCase, @rcordovano would it make sense to add queries to be able to select artifacts by type and attribute value? I'd imagine this functionality will be needed elsewhere.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465915654", "createdAt": "2020-08-05T18:18:17Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyNzc3Nw==", "bodyText": "@dannysmyda & @rcordovano For this story Brian told me to put this class in communications.  It moves to guiutils in a later story.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465927777", "createdAt": "2020-08-05T18:40:17Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA=="}, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDU3MA==", "bodyText": "Richard sent me a link to the story. Since the requirement is to keep these queries out of public API, we can just ignore this comment.", "url": "https://github.com/sleuthkit/autopsy/pull/6149#discussion_r465934570", "createdAt": "2020-08-05T18:52:48Z", "author": {"login": "dannysmyda"}, "path": "Core/src/org/sleuthkit/autopsy/communications/ContactCache.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.communications;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import java.beans.PropertyChangeListener;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import org.sleuthkit.autopsy.casemodule.Case;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.ingest.IngestManager;\n+import static org.sleuthkit.autopsy.ingest.IngestManager.IngestModuleEvent.DATA_ADDED;\n+import org.sleuthkit.autopsy.ingest.ModuleDataEvent;\n+import org.sleuthkit.datamodel.Account;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * A singleton cache of the Contact artifacts for accounts. The map of account\n+ * unique ids to list of contact artifacts is stored in a LoadingCache which\n+ * expires after 10 of non-use. \n+ *\n+ */\n+final class ContactCache {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY1NA=="}, "originalCommit": {"oid": "1d168f32f4c34399490bda0661c686da9b0975dd"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 927, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}