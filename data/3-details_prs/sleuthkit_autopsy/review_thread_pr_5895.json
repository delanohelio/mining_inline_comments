{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3OTU3NTc4", "number": 5895, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMzozNDowOVrOD837Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMzozNDowOVrOD837Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTU3NDM4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/contentviewers/AnnotationsContentViewer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMzozNDowOVrOGWFF1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMzozNDowOVrOGWFF1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNTI3MQ==", "bodyText": "This type of comment produces doxygen warnings. Please remove all instances.", "url": "https://github.com/sleuthkit/autopsy/pull/5895#discussion_r425805271", "createdAt": "2020-05-15T13:34:09Z", "author": {"login": "APriestman"}, "path": "Core/src/org/sleuthkit/autopsy/contentviewers/AnnotationsContentViewer.java", "diffHunk": "@@ -101,279 +272,441 @@ public void setNode(Node node) {\n                     artifact.getDisplayName(), artifact.getArtifactID()), ex);\n         }\n \n+        boolean somethingWasRendered = false;\n         if (artifact != null) {\n-            populateTagData(html, artifact, sourceFile);\n+            somethingWasRendered = renderArtifact(body, artifact, sourceFile);\n         } else {\n-            populateTagData(html, sourceFile);\n+            somethingWasRendered = renderContent(body, sourceFile, false);\n         }\n \n-        if (sourceFile instanceof AbstractFile) {\n-            populateCentralRepositoryData(html, artifact, (AbstractFile) sourceFile);\n+        if (!somethingWasRendered) {\n+            appendMessage(body, Bundle.AnnotationsContentViewer_onEmpty());\n         }\n \n-        setText(html.toString());\n+        jTextPane1.setText(html.html());\n         jTextPane1.setCaretPosition(0);\n     }\n \n     /**\n-     * Populate the \"Selected Item\" sections with tag data for the supplied\n-     * content.\n+     * Renders annotations for an artifact.\n+     *\n+     * @param parent        The html element to render content int.\n+     * @param bba           The blackboard artifact to render.\n+     * @param sourceContent The content from which the blackboard artifact\n+     *                      comes.\n      *\n-     * @param html    The HTML text to update.\n-     * @param content Selected content.\n+     * @return If any content was actually rendered.\n      */\n-    private void populateTagData(StringBuilder html, Content content) {\n-        try {\n-            SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+    private static boolean renderArtifact(Element parent, BlackboardArtifact bba, Content sourceContent) {\n+        boolean contentRendered = appendEntries(parent, TAG_CONFIG, getTags(bba), false);\n \n-            startSection(html, \"Selected Item\");\n-            List<ContentTag> fileTagsList = tskCase.getContentTagsByContent(content);\n-            if (fileTagsList.isEmpty()) {\n-                addMessage(html, \"There are no tags for the selected content.\");\n-            } else {\n-                for (ContentTag tag : fileTagsList) {\n-                    addTagEntry(html, tag);\n-                }\n+        if (CentralRepository.isEnabled()) {\n+            List<CorrelationAttributeInstance> centralRepoComments = getCentralRepositoryData(bba);\n+            boolean crRendered = appendEntries(parent, CR_COMMENTS_CONFIG, centralRepoComments, false);\n+            contentRendered = contentRendered || crRendered;\n+        }\n+\n+        // if artifact is a hashset hit or interesting file and has a non-blank comment\n+        if ((ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID() == bba.getArtifactTypeID()\n+                || ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT.getTypeID() == bba.getArtifactTypeID())\n+                && (hasTskComment(bba))) {\n+\n+            boolean filesetRendered = appendEntries(parent, ARTIFACT_COMMENT_CONFIG, Arrays.asList(bba), false);\n+            contentRendered = contentRendered || filesetRendered;\n+        }\n+\n+        Element sourceFileSection = appendSection(parent, Bundle.AnnotationsContentViewer_sourceFile_title());\n+        boolean sourceFileRendered = renderContent(sourceFileSection, sourceContent, true);\n+\n+        if (!sourceFileRendered) {\n+            sourceFileSection.remove();\n+        }\n+\n+        return contentRendered || sourceFileRendered;\n+    }\n+\n+    /**\n+     * Renders annotations for a content item.\n+     *\n+     * @param parent        The parent within which to render.\n+     * @param sourceContent The content for which annotations will be gathered.\n+     * @param isSubheader   True if this section should be rendered as a\n+     *                      subheader as opposed to a top-level header.\n+     *\n+     * @return If any content was actually rendered.\n+     */\n+    private static boolean renderContent(Element parent, Content sourceContent, boolean isSubheader) {\n+        boolean contentRendered = appendEntries(parent, TAG_CONFIG, getTags(sourceContent), isSubheader);\n+\n+        if (sourceContent instanceof AbstractFile) {\n+            AbstractFile sourceFile = (AbstractFile) sourceContent;\n+\n+            if (CentralRepository.isEnabled()) {\n+                List<CorrelationAttributeInstance> centralRepoComments = getCentralRepositoryData(sourceFile);\n+                boolean crRendered = appendEntries(parent, CR_COMMENTS_CONFIG, centralRepoComments, isSubheader);\n+                contentRendered = contentRendered || crRendered;\n             }\n-            endSection(html);\n+\n+            boolean hashsetRendered = appendEntries(parent, HASHSET_CONFIG,\n+                    getFileSetHits(sourceFile, ARTIFACT_TYPE.TSK_HASHSET_HIT),\n+                    isSubheader);\n+\n+            boolean interestingFileRendered = appendEntries(parent, INTERESTING_FILE_CONFIG,\n+                    getFileSetHits(sourceFile, ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT),\n+                    isSubheader);\n+\n+            contentRendered = contentRendered || hashsetRendered || interestingFileRendered;\n+        }\n+        return contentRendered;\n+    }\n+\n+    /**\n+     * Retrieves tags associated with a content item.\n+     *\n+     * @param sourceContent The content for which to gather content.\n+     *\n+     * @return The Tags associated with this item.\n+     */\n+    private static List<ContentTag> getTags(Content sourceContent) {\n+        try {\n+            SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+            return tskCase.getContentTagsByContent(sourceContent);\n         } catch (NoCurrentCaseException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting open case.\", ex); // NON-NLS\n         } catch (TskCoreException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting tags from the case database.\", ex); //NON-NLS\n         }\n+        return new ArrayList<>();\n     }\n \n     /**\n-     * Populate the \"Selected Item\" and \"Source File\" sections with tag data for\n-     * a supplied artifact.\n+     * Retrieves tags for blackboard artifact tags.\n+     *\n+     * @param bba The blackboard artifact for which to retrieve tags.\n      *\n-     * @param html       The HTML text to update.\n-     * @param artifact   A selected artifact.\n-     * @param sourceFile The source content of the selected artifact.\n+     * @return The found tags.\n      */\n-    private void populateTagData(StringBuilder html, BlackboardArtifact artifact, Content sourceFile) {\n+    private static List<BlackboardArtifactTag> getTags(BlackboardArtifact bba) {\n         try {\n             SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n-\n-            startSection(html, \"Selected Item\");\n-            List<BlackboardArtifactTag> artifactTagsList = tskCase.getBlackboardArtifactTagsByArtifact(artifact);\n-            if (artifactTagsList.isEmpty()) {\n-                addMessage(html, \"There are no tags for the selected artifact.\");\n-            } else {\n-                for (BlackboardArtifactTag tag : artifactTagsList) {\n-                    addTagEntry(html, tag);\n-                }\n-            }\n-            endSection(html);\n-\n-            if (sourceFile != null) {\n-                startSection(html, \"Source File\");\n-                List<ContentTag> fileTagsList = tskCase.getContentTagsByContent(sourceFile);\n-                if (fileTagsList.isEmpty()) {\n-                    addMessage(html, \"There are no tags for the source content.\");\n-                } else {\n-                    for (ContentTag tag : fileTagsList) {\n-                        addTagEntry(html, tag);\n-                    }\n-                }\n-                endSection(html);\n-            }\n+            return tskCase.getBlackboardArtifactTagsByArtifact(bba);\n         } catch (NoCurrentCaseException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting open case.\", ex); // NON-NLS\n         } catch (TskCoreException ex) {\n             logger.log(Level.SEVERE, \"Exception while getting tags from the case database.\", ex); //NON-NLS\n         }\n+        return new ArrayList<>();\n     }\n \n     /**\n-     * Populate the \"Central Repository Comments\" section with data.\n+     * Retrieves the blackboard artifacts for a source file matching a certain\n+     * type that have a non-blank TSK_COMMENT.\n      *\n-     * @param html       The HTML text to update.\n-     * @param artifact   A selected artifact (can be null).\n-     * @param sourceFile A selected file, or a source file of the selected\n-     *                   artifact.\n+     * @param sourceFile The source file for which to fetch artifacts.\n+     * @param type       The type of blackboard artifact to fetch.\n+     *\n+     * @return The artifacts found matching this type.\n      */\n-    private void populateCentralRepositoryData(StringBuilder html, BlackboardArtifact artifact, AbstractFile sourceFile) {\n-        if (CentralRepository.isEnabled()) {\n-            startSection(html, \"Central Repository Comments\");\n-            List<CorrelationAttributeInstance> instancesList = new ArrayList<>();\n-            if (artifact != null) {\n-                instancesList.addAll(CorrelationAttributeUtil.makeCorrAttrsForCorrelation(artifact));\n-            }\n-            try {\n-                List<CorrelationAttributeInstance.Type> artifactTypes = CentralRepository.getInstance().getDefinedCorrelationTypes();\n-                String md5 = sourceFile.getMd5Hash();\n-                if (md5 != null && !md5.isEmpty() && null != artifactTypes && !artifactTypes.isEmpty()) {\n-                    for (CorrelationAttributeInstance.Type attributeType : artifactTypes) {\n-                        if (attributeType.getId() == CorrelationAttributeInstance.FILES_TYPE_ID) {\n-                            CorrelationCase correlationCase = CentralRepository.getInstance().getCase(Case.getCurrentCase());\n-                            instancesList.add(new CorrelationAttributeInstance(\n-                                    attributeType,\n-                                    md5,\n-                                    correlationCase,\n-                                    CorrelationDataSource.fromTSKDataSource(correlationCase, sourceFile.getDataSource()),\n-                                    sourceFile.getParentPath() + sourceFile.getName(),\n-                                    \"\",\n-                                    sourceFile.getKnown(),\n-                                    sourceFile.getId()));\n-                            break;\n-                        }\n-                    }\n-                }\n+    private static List<BlackboardArtifact> getFileSetHits(AbstractFile sourceFile, ARTIFACT_TYPE type) {\n+        try {\n+            SleuthkitCase tskCase = Case.getCurrentCaseThrows().getSleuthkitCase();\n+            return tskCase.getBlackboardArtifacts(type, sourceFile.getId()).stream()\n+                    .filter((bba) -> hasTskComment(bba))\n+                    .collect(Collectors.toList());\n+        } catch (NoCurrentCaseException ex) {\n+            logger.log(Level.SEVERE, \"Exception while getting open case.\", ex); // NON-NLS\n+        } catch (TskCoreException ex) {\n+            logger.log(Level.SEVERE, \"Exception while getting file set hits from the case database.\", ex); //NON-NLS\n+        }\n+        return new ArrayList<>();\n+    }\n \n-                boolean commentDataFound = false;\n-\n-                for (CorrelationAttributeInstance instance : instancesList) {\n-                    List<CorrelationAttributeInstance> correlatedInstancesList\n-                            = CentralRepository.getInstance().getArtifactInstancesByTypeValue(instance.getCorrelationType(), instance.getCorrelationValue());\n-                    for (CorrelationAttributeInstance correlatedInstance : correlatedInstancesList) {\n-                        if (correlatedInstance.getComment() != null && correlatedInstance.getComment().isEmpty() == false) {\n-                            commentDataFound = true;\n-                            addCentralRepositoryEntry(html, correlatedInstance);\n-                        }\n-                    }\n-                }\n+    /**\n+     * Returns true if the artifact contains a non-blank TSK_COMMENT attribute.\n+     *\n+     * @param artifact The artifact to check.\n+     *\n+     * @return True if it has a non-blank TSK_COMMENT.\n+     */\n+    private static boolean hasTskComment(BlackboardArtifact artifact) {\n+        return StringUtils.isNotBlank(tryGetAttribute(artifact, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT));\n+    }\n \n-                if (commentDataFound == false) {\n-                    addMessage(html, \"There is no comment data for the selected content in the Central Repository.\");\n-                }\n-            } catch (CentralRepoException | TskCoreException ex) {\n-                logger.log(Level.SEVERE, \"Error connecting to the Central Repository database.\", ex); // NON-NLS\n-            } catch (CorrelationAttributeNormalizationException ex) {\n-                logger.log(Level.SEVERE, \"Error normalizing instance from Central Repository database.\", ex); // NON-NLS\n-            }\n-            endSection(html);\n+    /**\n+     * Attempts to retrieve the attribute of a particular type from a blackboard\n+     * artifact.\n+     *\n+     * @param artifact      The artifact from which to retrieve the information.\n+     * @param attributeType The attribute type to retrieve from the artifact.\n+     *\n+     * @return The string value of the attribute or null if not found.\n+     */\n+    private static String tryGetAttribute(BlackboardArtifact artifact, BlackboardAttribute.ATTRIBUTE_TYPE attributeType) {\n+        if (artifact == null) {\n+            return null;\n+        }\n+\n+        BlackboardAttribute attr = null;\n+        try {\n+            attr = artifact.getAttribute(new BlackboardAttribute.Type(attributeType));\n+        } catch (TskCoreException ex) {\n+            logger.log(Level.WARNING, String.format(\"Unable to fetch attribute of type %s for artifact %s\", attributeType, artifact), ex);\n+        }\n+\n+        if (attr == null) {\n+            return null;\n         }\n+\n+        return attr.getValueString();\n     }\n \n     /**\n-     * Set the text of the text panel.\n+     * Gets the \"Central Repository Comments\" section with data for the\n+     * blackboard artifact.\n+     *\n+     * @param artifact The selected artifact.\n      *\n-     * @param text The text to set to the text panel.\n+     * @return The Correlation Attribute Instances associated with the artifact\n+     *         that have comments.\n      */\n-    private void setText(String text) {\n-        jTextPane1.setText(\"<html><body>\" + text + \"</body></html>\"); //NON-NLS\n+    private static List<CorrelationAttributeInstance> getCentralRepositoryData(BlackboardArtifact artifact) {\n+        if (artifact == null) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<Pair<CorrelationAttributeInstance.Type, String>> lookupKeys = CorrelationAttributeUtil.makeCorrAttrsForCorrelation(artifact)\n+                .stream()\n+                .map(cai -> Pair.of(cai.getCorrelationType(), cai.getCorrelationValue()))\n+                .collect(Collectors.toList());\n+\n+        return getCorrelationAttributeComments(lookupKeys);\n     }\n \n     /**\n-     * Start a new data section.\n+     * Gets the \"Central Repository Comments\" section with data.\n+     *\n+     * @param sourceFile A selected file, or a source file of the selected\n+     *                   artifact.\n      *\n-     * @param html        The HTML text to add the section to.\n-     * @param sectionName The name of the section.\n+     * @return The Correlation Attribute Instances associated with the\n+     *         sourcefile that have comments.\n      */\n-    private void startSection(StringBuilder html, String sectionName) {\n-        html.append(\"<p style=\\\"font-size:14px;font-weight:bold;\\\">\")\n-                .append(sectionName)\n-                .append(\"</p><br>\"); //NON-NLS\n+    private static List<CorrelationAttributeInstance> getCentralRepositoryData(AbstractFile sourceFile) {\n+        if (sourceFile == null || StringUtils.isEmpty(sourceFile.getMd5Hash())) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<CorrelationAttributeInstance.Type> artifactTypes = null;\n+        try {\n+            artifactTypes = CentralRepository.getInstance().getDefinedCorrelationTypes();\n+        } catch (CentralRepoException ex) {\n+            logger.log(Level.SEVERE, \"Error connecting to the Central Repository database.\", ex); // NON-NLS\n+        }\n+\n+        if (artifactTypes == null || artifactTypes.isEmpty()) {\n+            return new ArrayList<>();\n+        }\n+\n+        String md5 = sourceFile.getMd5Hash();\n+\n+        // get key lookups for a file attribute types and the md5 hash\n+        List<Pair<CorrelationAttributeInstance.Type, String>> lookupKeys = artifactTypes.stream()\n+                .filter((attributeType) -> attributeType.getId() == CorrelationAttributeInstance.FILES_TYPE_ID)\n+                .map((attributeType) -> Pair.of(attributeType, md5))\n+                .collect(Collectors.toList());\n+\n+        return getCorrelationAttributeComments(lookupKeys);\n     }\n \n     /**\n-     * Add a message.\n+     * Given a type and a value for that type, does a lookup in the Central\n+     * Repository for matching values that have comments.\n      *\n-     * @param html    The HTML text to add the message to.\n-     * @param message The message text.\n+     * @param lookupKeys The type and value to lookup.\n+     *\n+     * @return The found correlation attribute instances.\n      */\n-    private void addMessage(StringBuilder html, String message) {\n-        html.append(\"<p style=\\\"font-size:11px;font-style:italic;\\\">\")\n-                .append(message)\n-                .append(\"</p><br>\"); //NON-NLS\n+    private static List<CorrelationAttributeInstance> getCorrelationAttributeComments(List<Pair<CorrelationAttributeInstance.Type, String>> lookupKeys) {\n+        List<CorrelationAttributeInstance> instancesToRet = new ArrayList<>();\n+\n+        try {\n+            // use lookup instances to find the actual correlation attributes for the items selected\n+            for (Pair<CorrelationAttributeInstance.Type, String> typeVal : lookupKeys) {\n+                instancesToRet.addAll(CentralRepository.getInstance()\n+                        .getArtifactInstancesByTypeValue(typeVal.getKey(), typeVal.getValue())\n+                        .stream()\n+                        // for each one found, if it has a comment, return\n+                        .filter((cai) -> StringUtils.isNotBlank(cai.getComment()))\n+                        .collect(Collectors.toList()));\n+            }\n+\n+        } catch (CentralRepoException ex) {\n+            logger.log(Level.SEVERE, \"Error connecting to the Central Repository database.\", ex); // NON-NLS\n+        } catch (CorrelationAttributeNormalizationException ex) {\n+            logger.log(Level.SEVERE, \"Error normalizing instance from Central Repository database.\", ex); // NON-NLS\n+        }\n+\n+        return instancesToRet;\n     }\n \n     /**\n-     * Add a data table containing information about a tag.\n+     * Append entries to the parent element in the annotations viewer. Entries\n+     * will be formatted as a table in the format specified in the\n+     * SectionConfig.\n      *\n-     * @param html The HTML text to add the table to.\n-     * @param tag  The tag whose information will be used to populate the table.\n+     * @param <T>          The item type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c517371a0be3d575627426d4ad988c76932b432"}, "originalPosition": 646}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 614, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}