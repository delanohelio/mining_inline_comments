{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNDA5NzAw", "number": 5783, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTowNzoyMFrODwIHyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTowNzoyMFrODwIHyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzkxMzA0OnYy", "diffSide": "RIGHT", "path": "Experimental/src/org/sleuthkit/autopsy/experimental/autoingest/DeleteOrphanCaseNodesTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTowNzoyMFrOGC9DVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTowNzoyMFrOGC9DVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDYxMw==", "bodyText": "Spelling error in the comment - confirmingg", "url": "https://github.com/sleuthkit/autopsy/pull/5783#discussion_r405750613", "createdAt": "2020-04-08T19:07:20Z", "author": {"login": "eugene7646"}, "path": "Experimental/src/org/sleuthkit/autopsy/experimental/autoingest/DeleteOrphanCaseNodesTask.java", "diffHunk": "@@ -53,6 +60,130 @@\n         this.progress = progress;\n     }\n \n+    /**\n+     * Retrieves an instance of the coordination service in order to fetch\n+     * znodes and potentially delete.\n+     *\n+     * @return The coordination service or null on error.\n+     */\n+    private CoordinationService getCoordinationService() {\n+        progress.progress(Bundle.DeleteOrphanCaseNodesTask_progress_connectingToCoordSvc());\n+        logger.log(Level.INFO, Bundle.DeleteOrphanCaseNodesTask_progress_connectingToCoordSvc());\n+        CoordinationService coordinationService = null;\n+        try {\n+            coordinationService = CoordinationService.getInstance();\n+        } catch (CoordinationService.CoordinationServiceException ex) {\n+            logger.log(Level.SEVERE, \"Error connecting to the coordination service\", ex); //NON-NLS\n+        }\n+        return coordinationService;\n+    }\n+\n+    /**\n+     * Retrieves node paths for cases.\n+     *\n+     * @param coordinationService The coordination service to use in order to\n+     *                            fetch the node paths.\n+     *\n+     * @return The list of node paths for cases.\n+     */\n+    private List<String> getNodePaths(CoordinationService coordinationService) {\n+        progress.progress(Bundle.DeleteOrphanCaseNodesTask_progress_gettingCaseZnodes());\n+        logger.log(Level.INFO, Bundle.DeleteOrphanCaseNodesTask_progress_gettingCaseZnodes());\n+        List<String> nodePaths = null;\n+        try {\n+            nodePaths = coordinationService.getNodeList(CoordinationService.CategoryNode.CASES);\n+            // in the event that getNodeList returns null (but still successful) return empty list\n+            if (nodePaths == null) {\n+                return new ArrayList<String>();\n+            }\n+        } catch (CoordinationService.CoordinationServiceException ex) {\n+            logger.log(Level.SEVERE, \"Error getting case znode list\", ex); //NON-NLS\n+        } catch (InterruptedException unused) {\n+            logger.log(Level.WARNING, \"Task cancelled while getting case znode list\"); //NON-NLS\n+        }\n+\n+        return nodePaths;\n+    }\n+\n+    private void addIfExists(List<String> paths, String path) {\n+        if (path != null && !path.isEmpty()) {\n+            paths.add(path);\n+        }\n+    }\n+\n+    /**\n+     * Determines orphaned znode paths.\n+     *\n+     * @param nodePaths The list of case node paths.\n+     *\n+     * @return The list of orphaned node paths.\n+     */\n+    private Map<String, List<String>> getOrphanedNodes(List<String> nodePaths) {\n+        progress.progress(Bundle.DeleteOrphanCaseNodesTask_progress_lookingForOrphanedCaseZnodes());\n+        logger.log(Level.INFO, Bundle.DeleteOrphanCaseNodesTask_progress_lookingForOrphanedCaseZnodes());\n+        Map<String, List<String>> nodePathsToDelete = new HashMap<>();\n+        for (String caseNodePath : nodePaths) {\n+            if (isCaseNameNodePath(caseNodePath) || isCaseResourcesNodePath(caseNodePath) || isCaseAutoIngestLogNodePath(caseNodePath)) {\n+                continue;\n+            }\n+\n+            final Path caseDirectoryPath = Paths.get(caseNodePath);\n+            final File caseDirectory = caseDirectoryPath.toFile();\n+            if (!caseDirectory.exists()) {\n+                String caseName = CoordinationServiceUtils.getCaseNameNodePath(caseDirectoryPath);\n+                List<String> paths = new ArrayList<>();\n+\n+                addIfExists(paths, CoordinationServiceUtils.getCaseNameNodePath(caseDirectoryPath));\n+                addIfExists(paths, CoordinationServiceUtils.getCaseResourcesNodePath(caseDirectoryPath));\n+                addIfExists(paths, CoordinationServiceUtils.getCaseAutoIngestLogNodePath(caseDirectoryPath));\n+                addIfExists(paths, CoordinationServiceUtils.getCaseDirectoryNodePath(caseDirectoryPath));\n+                nodePathsToDelete.put(caseName, paths);\n+            }\n+        }\n+        return nodePathsToDelete;\n+    }\n+\n+    /**\n+     * Boxed boolean so that promptUser method can set a value on a final object\n+     * from custom jdialog message.\n+     */\n+    private class PromptResult {\n+\n+        private boolean value = false;\n+\n+        boolean isValue() {\n+            return value;\n+        }\n+\n+        void setValue(boolean value) {\n+            this.value = value;\n+        }\n+\n+    }\n+\n+    /**\n+     * prompts the user with a list of orphaned znodes.\n+     *\n+     * @param orphanedNodes The orphaned znode cases.\n+     *\n+     * @return True if the user would like to proceed deleting the znodes.\n+     */\n+    private boolean promptUser(Collection<String> orphanedNodes) {\n+        final PromptResult dialogResult = new PromptResult();\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                DeleteOrphanCaseNodesDialog dialog = new DeleteOrphanCaseNodesDialog(orphanedNodes);\n+                dialog.display();\n+                dialogResult.setValue(dialog.isOkSelected());\n+            });\n+\n+            return dialogResult.isValue();\n+        } catch (InterruptedException | InvocationTargetException e) {\n+            logger.log(Level.WARNING, \"Task cancelled while confirmingg case znodes to delete\"); //NON-NLS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd06d740140a2ef3119321c319a3933b1e542536"}, "originalPosition": 161}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 695, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}