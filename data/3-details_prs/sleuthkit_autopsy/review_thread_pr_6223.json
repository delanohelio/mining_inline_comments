{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MDM0MzQ1", "number": 6223, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODo1OToyMlrOEfmP6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTowNDo0OVrOEfmcIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTY3OTc4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODo1OToyMlrOHL97fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo0Mjo0MlrOHMAyHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMTAzNg==", "bodyText": "Why are you passing in the logger?  I don't think I have seen that before.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482311036", "createdAt": "2020-09-02T18:59:22Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.datamodel;\n+\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.autopsy.texttranslation.NoServiceProviderException;\n+import org.sleuthkit.autopsy.texttranslation.TextTranslationService;\n+import org.sleuthkit.autopsy.texttranslation.TranslationException;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;\n+\n+/**\n+ * Provides summary information about user activity in a datasource. At this\n+ * time, the data being provided for domains is fictitious and is done as a\n+ * placeholder.\n+ */\n+public class DataSourceUserActivitySummary {\n+\n+    private static final BlackboardArtifact.Type TYPE_DEVICE_ATTACHED = new BlackboardArtifact.Type(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n+\n+    private static final BlackboardAttribute.Type TYPE_DATETIME = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME);\n+    private static final BlackboardAttribute.Type TYPE_DATETIME_ACCESSED = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_ID = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_ID);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MAKE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MODEL = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL);\n+    private static final BlackboardAttribute.Type TYPE_MESSAGE_TYPE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE);\n+    private static final BlackboardAttribute.Type TYPE_TEXT = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_TEXT);\n+\n+    private static final Comparator<TopAccountResult> TOP_ACCOUNT_RESULT_DATE_COMPARE = (a, b) -> a.getLastAccess().compareTo(b.getLastAccess());\n+    private static final Comparator<TopWebSearchResult> TOP_WEBSEARCH_RESULT_DATE_COMPARE = (a, b) -> a.getDateAccessed().compareTo(b.getDateAccessed());\n+    private static final String ROOT_HUB_IDENTIFIER = \"ROOT_HUB\";\n+\n+    private static final long SLEEP_TIME = 5000;\n+\n+    /**\n+     * A function to calculate a result from 2 parameters.\n+     */\n+    interface Function2<A1, A2, O> {\n+\n+        O apply(A1 a1, A2 a2);\n+    }\n+\n+    /**\n+     * Gets a list of recent domains based on the datasource.\n+     *\n+     * @param dataSource The datasource to query for recent domains.\n+     * @param count      The max count of items to return.\n+     *\n+     * @return The list of items retrieved from the database.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public List<TopDomainsResult> getRecentDomains(DataSource dataSource, int count) throws InterruptedException {\n+        Thread.sleep(SLEEP_TIME);\n+        final String dId = Long.toString(dataSource.getId());\n+        final Function2<String, Integer, String> getId = (s, idx) -> String.format(\"d:%s, f:%s, i:%d\", dId, s, idx);\n+        return IntStream.range(0, count)\n+                .mapToObj(num -> new TopDomainsResult(\n+                getId.apply(\"domain\", num),\n+                getId.apply(\"url\", num),\n+                (long) num,\n+                new Date(((long) num) * 1000 * 60 * 60 * 24)\n+        ))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private final SleuthkitCaseProvider caseProvider;\n+    private final TextTranslationService translationService;\n+    private final java.util.logging.Logger logger;\n+\n+    /**\n+     * Main constructor.\n+     */\n+    public DataSourceUserActivitySummary() {\n+        this(SleuthkitCaseProvider.DEFAULT, TextTranslationService.getInstance(),\n+                org.sleuthkit.autopsy.coreutils.Logger.getLogger(DataSourceUserActivitySummary.class.getName()));\n+    }\n+\n+    /**\n+     * Main constructor with external dependencies specified. This constructor\n+     * is designed with unit testing in mind since mocked dependencies can be\n+     * utilized.\n+     *\n+     * @param provider           The object providing the current SleuthkitCase.\n+     * @param translationService The translation service.\n+     * @param logger             The logger to use.\n+     */\n+    public DataSourceUserActivitySummary(\n+            SleuthkitCaseProvider provider,\n+            TextTranslationService translationService,\n+            java.util.logging.Logger logger) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM1Nzc4OA==", "bodyText": "This was done for testing purposes.  If the java.util.logging.Logger is used, we can create a mock or bare bones logger for unit testing purposes without having to load up the netbeans platform.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482357788", "createdAt": "2020-09-02T19:42:42Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.datamodel;\n+\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.autopsy.texttranslation.NoServiceProviderException;\n+import org.sleuthkit.autopsy.texttranslation.TextTranslationService;\n+import org.sleuthkit.autopsy.texttranslation.TranslationException;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;\n+\n+/**\n+ * Provides summary information about user activity in a datasource. At this\n+ * time, the data being provided for domains is fictitious and is done as a\n+ * placeholder.\n+ */\n+public class DataSourceUserActivitySummary {\n+\n+    private static final BlackboardArtifact.Type TYPE_DEVICE_ATTACHED = new BlackboardArtifact.Type(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n+\n+    private static final BlackboardAttribute.Type TYPE_DATETIME = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME);\n+    private static final BlackboardAttribute.Type TYPE_DATETIME_ACCESSED = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_ID = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_ID);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MAKE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MODEL = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL);\n+    private static final BlackboardAttribute.Type TYPE_MESSAGE_TYPE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE);\n+    private static final BlackboardAttribute.Type TYPE_TEXT = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_TEXT);\n+\n+    private static final Comparator<TopAccountResult> TOP_ACCOUNT_RESULT_DATE_COMPARE = (a, b) -> a.getLastAccess().compareTo(b.getLastAccess());\n+    private static final Comparator<TopWebSearchResult> TOP_WEBSEARCH_RESULT_DATE_COMPARE = (a, b) -> a.getDateAccessed().compareTo(b.getDateAccessed());\n+    private static final String ROOT_HUB_IDENTIFIER = \"ROOT_HUB\";\n+\n+    private static final long SLEEP_TIME = 5000;\n+\n+    /**\n+     * A function to calculate a result from 2 parameters.\n+     */\n+    interface Function2<A1, A2, O> {\n+\n+        O apply(A1 a1, A2 a2);\n+    }\n+\n+    /**\n+     * Gets a list of recent domains based on the datasource.\n+     *\n+     * @param dataSource The datasource to query for recent domains.\n+     * @param count      The max count of items to return.\n+     *\n+     * @return The list of items retrieved from the database.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public List<TopDomainsResult> getRecentDomains(DataSource dataSource, int count) throws InterruptedException {\n+        Thread.sleep(SLEEP_TIME);\n+        final String dId = Long.toString(dataSource.getId());\n+        final Function2<String, Integer, String> getId = (s, idx) -> String.format(\"d:%s, f:%s, i:%d\", dId, s, idx);\n+        return IntStream.range(0, count)\n+                .mapToObj(num -> new TopDomainsResult(\n+                getId.apply(\"domain\", num),\n+                getId.apply(\"url\", num),\n+                (long) num,\n+                new Date(((long) num) * 1000 * 60 * 60 * 24)\n+        ))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private final SleuthkitCaseProvider caseProvider;\n+    private final TextTranslationService translationService;\n+    private final java.util.logging.Logger logger;\n+\n+    /**\n+     * Main constructor.\n+     */\n+    public DataSourceUserActivitySummary() {\n+        this(SleuthkitCaseProvider.DEFAULT, TextTranslationService.getInstance(),\n+                org.sleuthkit.autopsy.coreutils.Logger.getLogger(DataSourceUserActivitySummary.class.getName()));\n+    }\n+\n+    /**\n+     * Main constructor with external dependencies specified. This constructor\n+     * is designed with unit testing in mind since mocked dependencies can be\n+     * utilized.\n+     *\n+     * @param provider           The object providing the current SleuthkitCase.\n+     * @param translationService The translation service.\n+     * @param logger             The logger to use.\n+     */\n+    public DataSourceUserActivitySummary(\n+            SleuthkitCaseProvider provider,\n+            TextTranslationService translationService,\n+            java.util.logging.Logger logger) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMTAzNg=="}, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTY5MTA5OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTowMToxNlrOHL-Ckw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo0NTowNFrOHMA-aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMjg1MQ==", "bodyText": "There is a warning about dereferencing a null pointer.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482312851", "createdAt": "2020-09-02T19:01:16Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.datamodel;\n+\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.autopsy.texttranslation.NoServiceProviderException;\n+import org.sleuthkit.autopsy.texttranslation.TextTranslationService;\n+import org.sleuthkit.autopsy.texttranslation.TranslationException;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;\n+\n+/**\n+ * Provides summary information about user activity in a datasource. At this\n+ * time, the data being provided for domains is fictitious and is done as a\n+ * placeholder.\n+ */\n+public class DataSourceUserActivitySummary {\n+\n+    private static final BlackboardArtifact.Type TYPE_DEVICE_ATTACHED = new BlackboardArtifact.Type(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n+\n+    private static final BlackboardAttribute.Type TYPE_DATETIME = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME);\n+    private static final BlackboardAttribute.Type TYPE_DATETIME_ACCESSED = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_ID = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_ID);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MAKE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MODEL = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL);\n+    private static final BlackboardAttribute.Type TYPE_MESSAGE_TYPE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE);\n+    private static final BlackboardAttribute.Type TYPE_TEXT = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_TEXT);\n+\n+    private static final Comparator<TopAccountResult> TOP_ACCOUNT_RESULT_DATE_COMPARE = (a, b) -> a.getLastAccess().compareTo(b.getLastAccess());\n+    private static final Comparator<TopWebSearchResult> TOP_WEBSEARCH_RESULT_DATE_COMPARE = (a, b) -> a.getDateAccessed().compareTo(b.getDateAccessed());\n+    private static final String ROOT_HUB_IDENTIFIER = \"ROOT_HUB\";\n+\n+    private static final long SLEEP_TIME = 5000;\n+\n+    /**\n+     * A function to calculate a result from 2 parameters.\n+     */\n+    interface Function2<A1, A2, O> {\n+\n+        O apply(A1 a1, A2 a2);\n+    }\n+\n+    /**\n+     * Gets a list of recent domains based on the datasource.\n+     *\n+     * @param dataSource The datasource to query for recent domains.\n+     * @param count      The max count of items to return.\n+     *\n+     * @return The list of items retrieved from the database.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public List<TopDomainsResult> getRecentDomains(DataSource dataSource, int count) throws InterruptedException {\n+        Thread.sleep(SLEEP_TIME);\n+        final String dId = Long.toString(dataSource.getId());\n+        final Function2<String, Integer, String> getId = (s, idx) -> String.format(\"d:%s, f:%s, i:%d\", dId, s, idx);\n+        return IntStream.range(0, count)\n+                .mapToObj(num -> new TopDomainsResult(\n+                getId.apply(\"domain\", num),\n+                getId.apply(\"url\", num),\n+                (long) num,\n+                new Date(((long) num) * 1000 * 60 * 60 * 24)\n+        ))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private final SleuthkitCaseProvider caseProvider;\n+    private final TextTranslationService translationService;\n+    private final java.util.logging.Logger logger;\n+\n+    /**\n+     * Main constructor.\n+     */\n+    public DataSourceUserActivitySummary() {\n+        this(SleuthkitCaseProvider.DEFAULT, TextTranslationService.getInstance(),\n+                org.sleuthkit.autopsy.coreutils.Logger.getLogger(DataSourceUserActivitySummary.class.getName()));\n+    }\n+\n+    /**\n+     * Main constructor with external dependencies specified. This constructor\n+     * is designed with unit testing in mind since mocked dependencies can be\n+     * utilized.\n+     *\n+     * @param provider           The object providing the current SleuthkitCase.\n+     * @param translationService The translation service.\n+     * @param logger             The logger to use.\n+     */\n+    public DataSourceUserActivitySummary(\n+            SleuthkitCaseProvider provider,\n+            TextTranslationService translationService,\n+            java.util.logging.Logger logger) {\n+\n+        this.caseProvider = provider;\n+        this.translationService = translationService;\n+        this.logger = logger;\n+    }\n+\n+    /**\n+     * Throws an IllegalArgumentException if count <= 0.\n+     *\n+     * @param count The count being checked.\n+     */\n+    private void assertValidCount(int count) {\n+        if (count <= 0) {\n+            throw new IllegalArgumentException(\"Count must be greater than 0\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieves most recent web searches by most recent date grouped by search\n+     * term.\n+     *\n+     * @param dataSource The data source.\n+     * @param count      The maximum number of records to be shown (must be >\n+     *                   0).\n+     *\n+     * @return The list of most recent web searches where most recent search\n+     *         appears first.\n+     *\n+     * @throws\n+     * org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException\n+     * @throws TskCoreException\n+     */\n+    public List<TopWebSearchResult> getMostRecentWebSearches(DataSource dataSource, int count) throws SleuthkitCaseProviderException, TskCoreException {\n+        assertValidCount(count);\n+\n+        List<TopWebSearchResult> results = caseProvider.get().getBlackboard().getArtifacts(ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID(), dataSource.getId())\n+                .stream()\n+                // get items where search string and date is not null\n+                .map(artifact -> {\n+                    String searchString = DataSourceInfoUtilities.getStringOrNull(artifact, TYPE_TEXT);\n+                    Date dateAccessed = DataSourceInfoUtilities.getDateOrNull(artifact, TYPE_DATETIME_ACCESSED);\n+                    return (StringUtils.isNotBlank(searchString) && dateAccessed != null)\n+                            ? new TopWebSearchResult(searchString, dateAccessed)\n+                            : null;\n+                })\n+                // remove null records\n+                .filter(result -> result != null)\n+                // get these messages grouped by search to string\n+                .collect(Collectors.groupingBy((result) -> result.getSearchString().toUpperCase()))\n+                .entrySet()\n+                .stream()\n+                // get the most recent access per account type\n+                .map((entry) -> entry.getValue().stream().max(TOP_WEBSEARCH_RESULT_DATE_COMPARE).get())\n+                // get most recent accounts accessed\n+                .sorted(TOP_WEBSEARCH_RESULT_DATE_COMPARE.reversed())\n+                .limit(count)\n+                // get as list\n+                .collect(Collectors.toList());\n+\n+        // get translation if possible\n+        if (translationService.hasProvider()) {\n+            for (TopWebSearchResult result : results) {\n+                result.setTranslatedResult(getTranslationOrNull(result.getSearchString()));\n+            }\n+        }\n+\n+        return results;\n+    }\n+\n+    /**\n+     * Return the translation of the original text if possible and differs from\n+     * the original. Otherwise, return null.\n+     *\n+     * @param original The original text.\n+     *\n+     * @return The translated text or null if no translation can be determined\n+     *         or exists.\n+     */\n+    private String getTranslationOrNull(String original) {\n+        if (!translationService.hasProvider() || StringUtils.isBlank(original)) {\n+            return null;\n+        }\n+\n+        String translated = null;\n+        try {\n+            translated = translationService.translate(original);\n+        } catch (NoServiceProviderException | TranslationException ex) {\n+            logger.log(Level.WARNING, String.format(\"There was an error translating text: '%s'\", original), ex);\n+        }\n+\n+        // if there is no translation or the translation is the same as the original, return null.\n+        if (StringUtils.isBlank(translated)\n+                || translated.toUpperCase().trim().equals(original.toUpperCase().trim())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM2MDkzNg==", "bodyText": "I think the StringUtils.isBlank checks on the original variable and the translated variable prevent either of these from being null.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482360936", "createdAt": "2020-09-02T19:45:04Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.datamodel;\n+\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.autopsy.texttranslation.NoServiceProviderException;\n+import org.sleuthkit.autopsy.texttranslation.TextTranslationService;\n+import org.sleuthkit.autopsy.texttranslation.TranslationException;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;\n+\n+/**\n+ * Provides summary information about user activity in a datasource. At this\n+ * time, the data being provided for domains is fictitious and is done as a\n+ * placeholder.\n+ */\n+public class DataSourceUserActivitySummary {\n+\n+    private static final BlackboardArtifact.Type TYPE_DEVICE_ATTACHED = new BlackboardArtifact.Type(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n+\n+    private static final BlackboardAttribute.Type TYPE_DATETIME = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME);\n+    private static final BlackboardAttribute.Type TYPE_DATETIME_ACCESSED = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_ID = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_ID);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MAKE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MODEL = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL);\n+    private static final BlackboardAttribute.Type TYPE_MESSAGE_TYPE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE);\n+    private static final BlackboardAttribute.Type TYPE_TEXT = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_TEXT);\n+\n+    private static final Comparator<TopAccountResult> TOP_ACCOUNT_RESULT_DATE_COMPARE = (a, b) -> a.getLastAccess().compareTo(b.getLastAccess());\n+    private static final Comparator<TopWebSearchResult> TOP_WEBSEARCH_RESULT_DATE_COMPARE = (a, b) -> a.getDateAccessed().compareTo(b.getDateAccessed());\n+    private static final String ROOT_HUB_IDENTIFIER = \"ROOT_HUB\";\n+\n+    private static final long SLEEP_TIME = 5000;\n+\n+    /**\n+     * A function to calculate a result from 2 parameters.\n+     */\n+    interface Function2<A1, A2, O> {\n+\n+        O apply(A1 a1, A2 a2);\n+    }\n+\n+    /**\n+     * Gets a list of recent domains based on the datasource.\n+     *\n+     * @param dataSource The datasource to query for recent domains.\n+     * @param count      The max count of items to return.\n+     *\n+     * @return The list of items retrieved from the database.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public List<TopDomainsResult> getRecentDomains(DataSource dataSource, int count) throws InterruptedException {\n+        Thread.sleep(SLEEP_TIME);\n+        final String dId = Long.toString(dataSource.getId());\n+        final Function2<String, Integer, String> getId = (s, idx) -> String.format(\"d:%s, f:%s, i:%d\", dId, s, idx);\n+        return IntStream.range(0, count)\n+                .mapToObj(num -> new TopDomainsResult(\n+                getId.apply(\"domain\", num),\n+                getId.apply(\"url\", num),\n+                (long) num,\n+                new Date(((long) num) * 1000 * 60 * 60 * 24)\n+        ))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private final SleuthkitCaseProvider caseProvider;\n+    private final TextTranslationService translationService;\n+    private final java.util.logging.Logger logger;\n+\n+    /**\n+     * Main constructor.\n+     */\n+    public DataSourceUserActivitySummary() {\n+        this(SleuthkitCaseProvider.DEFAULT, TextTranslationService.getInstance(),\n+                org.sleuthkit.autopsy.coreutils.Logger.getLogger(DataSourceUserActivitySummary.class.getName()));\n+    }\n+\n+    /**\n+     * Main constructor with external dependencies specified. This constructor\n+     * is designed with unit testing in mind since mocked dependencies can be\n+     * utilized.\n+     *\n+     * @param provider           The object providing the current SleuthkitCase.\n+     * @param translationService The translation service.\n+     * @param logger             The logger to use.\n+     */\n+    public DataSourceUserActivitySummary(\n+            SleuthkitCaseProvider provider,\n+            TextTranslationService translationService,\n+            java.util.logging.Logger logger) {\n+\n+        this.caseProvider = provider;\n+        this.translationService = translationService;\n+        this.logger = logger;\n+    }\n+\n+    /**\n+     * Throws an IllegalArgumentException if count <= 0.\n+     *\n+     * @param count The count being checked.\n+     */\n+    private void assertValidCount(int count) {\n+        if (count <= 0) {\n+            throw new IllegalArgumentException(\"Count must be greater than 0\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieves most recent web searches by most recent date grouped by search\n+     * term.\n+     *\n+     * @param dataSource The data source.\n+     * @param count      The maximum number of records to be shown (must be >\n+     *                   0).\n+     *\n+     * @return The list of most recent web searches where most recent search\n+     *         appears first.\n+     *\n+     * @throws\n+     * org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException\n+     * @throws TskCoreException\n+     */\n+    public List<TopWebSearchResult> getMostRecentWebSearches(DataSource dataSource, int count) throws SleuthkitCaseProviderException, TskCoreException {\n+        assertValidCount(count);\n+\n+        List<TopWebSearchResult> results = caseProvider.get().getBlackboard().getArtifacts(ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID(), dataSource.getId())\n+                .stream()\n+                // get items where search string and date is not null\n+                .map(artifact -> {\n+                    String searchString = DataSourceInfoUtilities.getStringOrNull(artifact, TYPE_TEXT);\n+                    Date dateAccessed = DataSourceInfoUtilities.getDateOrNull(artifact, TYPE_DATETIME_ACCESSED);\n+                    return (StringUtils.isNotBlank(searchString) && dateAccessed != null)\n+                            ? new TopWebSearchResult(searchString, dateAccessed)\n+                            : null;\n+                })\n+                // remove null records\n+                .filter(result -> result != null)\n+                // get these messages grouped by search to string\n+                .collect(Collectors.groupingBy((result) -> result.getSearchString().toUpperCase()))\n+                .entrySet()\n+                .stream()\n+                // get the most recent access per account type\n+                .map((entry) -> entry.getValue().stream().max(TOP_WEBSEARCH_RESULT_DATE_COMPARE).get())\n+                // get most recent accounts accessed\n+                .sorted(TOP_WEBSEARCH_RESULT_DATE_COMPARE.reversed())\n+                .limit(count)\n+                // get as list\n+                .collect(Collectors.toList());\n+\n+        // get translation if possible\n+        if (translationService.hasProvider()) {\n+            for (TopWebSearchResult result : results) {\n+                result.setTranslatedResult(getTranslationOrNull(result.getSearchString()));\n+            }\n+        }\n+\n+        return results;\n+    }\n+\n+    /**\n+     * Return the translation of the original text if possible and differs from\n+     * the original. Otherwise, return null.\n+     *\n+     * @param original The original text.\n+     *\n+     * @return The translated text or null if no translation can be determined\n+     *         or exists.\n+     */\n+    private String getTranslationOrNull(String original) {\n+        if (!translationService.hasProvider() || StringUtils.isBlank(original)) {\n+            return null;\n+        }\n+\n+        String translated = null;\n+        try {\n+            translated = translationService.translate(original);\n+        } catch (NoServiceProviderException | TranslationException ex) {\n+            logger.log(Level.WARNING, String.format(\"There was an error translating text: '%s'\", original), ex);\n+        }\n+\n+        // if there is no translation or the translation is the same as the original, return null.\n+        if (StringUtils.isBlank(translated)\n+                || translated.toUpperCase().trim().equals(original.toUpperCase().trim())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxMjg1MQ=="}, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTcwMjIxOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTowMzoxOVrOHL-J2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo0NTo1MlrOHMBC5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNDcxNA==", "bodyText": "This would be very difficult to debug if there was an issue.  You might want to consider revising.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482314714", "createdAt": "2020-09-02T19:03:19Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.datamodel;\n+\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.autopsy.texttranslation.NoServiceProviderException;\n+import org.sleuthkit.autopsy.texttranslation.TextTranslationService;\n+import org.sleuthkit.autopsy.texttranslation.TranslationException;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;\n+\n+/**\n+ * Provides summary information about user activity in a datasource. At this\n+ * time, the data being provided for domains is fictitious and is done as a\n+ * placeholder.\n+ */\n+public class DataSourceUserActivitySummary {\n+\n+    private static final BlackboardArtifact.Type TYPE_DEVICE_ATTACHED = new BlackboardArtifact.Type(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n+\n+    private static final BlackboardAttribute.Type TYPE_DATETIME = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME);\n+    private static final BlackboardAttribute.Type TYPE_DATETIME_ACCESSED = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_ID = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_ID);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MAKE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MODEL = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL);\n+    private static final BlackboardAttribute.Type TYPE_MESSAGE_TYPE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE);\n+    private static final BlackboardAttribute.Type TYPE_TEXT = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_TEXT);\n+\n+    private static final Comparator<TopAccountResult> TOP_ACCOUNT_RESULT_DATE_COMPARE = (a, b) -> a.getLastAccess().compareTo(b.getLastAccess());\n+    private static final Comparator<TopWebSearchResult> TOP_WEBSEARCH_RESULT_DATE_COMPARE = (a, b) -> a.getDateAccessed().compareTo(b.getDateAccessed());\n+    private static final String ROOT_HUB_IDENTIFIER = \"ROOT_HUB\";\n+\n+    private static final long SLEEP_TIME = 5000;\n+\n+    /**\n+     * A function to calculate a result from 2 parameters.\n+     */\n+    interface Function2<A1, A2, O> {\n+\n+        O apply(A1 a1, A2 a2);\n+    }\n+\n+    /**\n+     * Gets a list of recent domains based on the datasource.\n+     *\n+     * @param dataSource The datasource to query for recent domains.\n+     * @param count      The max count of items to return.\n+     *\n+     * @return The list of items retrieved from the database.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public List<TopDomainsResult> getRecentDomains(DataSource dataSource, int count) throws InterruptedException {\n+        Thread.sleep(SLEEP_TIME);\n+        final String dId = Long.toString(dataSource.getId());\n+        final Function2<String, Integer, String> getId = (s, idx) -> String.format(\"d:%s, f:%s, i:%d\", dId, s, idx);\n+        return IntStream.range(0, count)\n+                .mapToObj(num -> new TopDomainsResult(\n+                getId.apply(\"domain\", num),\n+                getId.apply(\"url\", num),\n+                (long) num,\n+                new Date(((long) num) * 1000 * 60 * 60 * 24)\n+        ))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private final SleuthkitCaseProvider caseProvider;\n+    private final TextTranslationService translationService;\n+    private final java.util.logging.Logger logger;\n+\n+    /**\n+     * Main constructor.\n+     */\n+    public DataSourceUserActivitySummary() {\n+        this(SleuthkitCaseProvider.DEFAULT, TextTranslationService.getInstance(),\n+                org.sleuthkit.autopsy.coreutils.Logger.getLogger(DataSourceUserActivitySummary.class.getName()));\n+    }\n+\n+    /**\n+     * Main constructor with external dependencies specified. This constructor\n+     * is designed with unit testing in mind since mocked dependencies can be\n+     * utilized.\n+     *\n+     * @param provider           The object providing the current SleuthkitCase.\n+     * @param translationService The translation service.\n+     * @param logger             The logger to use.\n+     */\n+    public DataSourceUserActivitySummary(\n+            SleuthkitCaseProvider provider,\n+            TextTranslationService translationService,\n+            java.util.logging.Logger logger) {\n+\n+        this.caseProvider = provider;\n+        this.translationService = translationService;\n+        this.logger = logger;\n+    }\n+\n+    /**\n+     * Throws an IllegalArgumentException if count <= 0.\n+     *\n+     * @param count The count being checked.\n+     */\n+    private void assertValidCount(int count) {\n+        if (count <= 0) {\n+            throw new IllegalArgumentException(\"Count must be greater than 0\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieves most recent web searches by most recent date grouped by search\n+     * term.\n+     *\n+     * @param dataSource The data source.\n+     * @param count      The maximum number of records to be shown (must be >\n+     *                   0).\n+     *\n+     * @return The list of most recent web searches where most recent search\n+     *         appears first.\n+     *\n+     * @throws\n+     * org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException\n+     * @throws TskCoreException\n+     */\n+    public List<TopWebSearchResult> getMostRecentWebSearches(DataSource dataSource, int count) throws SleuthkitCaseProviderException, TskCoreException {\n+        assertValidCount(count);\n+\n+        List<TopWebSearchResult> results = caseProvider.get().getBlackboard().getArtifacts(ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID(), dataSource.getId())\n+                .stream()\n+                // get items where search string and date is not null\n+                .map(artifact -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM2MjA4Nw==", "bodyText": "Ok.  I'll break it up a little bit.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482362087", "createdAt": "2020-09-02T19:45:52Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/datamodel/DataSourceUserActivitySummary.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.datasourcesummary.datamodel;\n+\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.DataSource;\n+import org.sleuthkit.datamodel.TskCoreException;\n+import org.sleuthkit.autopsy.texttranslation.NoServiceProviderException;\n+import org.sleuthkit.autopsy.texttranslation.TextTranslationService;\n+import org.sleuthkit.autopsy.texttranslation.TranslationException;\n+import static org.sleuthkit.datamodel.BlackboardArtifact.ARTIFACT_TYPE;\n+import static org.sleuthkit.datamodel.BlackboardAttribute.ATTRIBUTE_TYPE;\n+\n+/**\n+ * Provides summary information about user activity in a datasource. At this\n+ * time, the data being provided for domains is fictitious and is done as a\n+ * placeholder.\n+ */\n+public class DataSourceUserActivitySummary {\n+\n+    private static final BlackboardArtifact.Type TYPE_DEVICE_ATTACHED = new BlackboardArtifact.Type(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n+\n+    private static final BlackboardAttribute.Type TYPE_DATETIME = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME);\n+    private static final BlackboardAttribute.Type TYPE_DATETIME_ACCESSED = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_ID = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_ID);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MAKE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MAKE);\n+    private static final BlackboardAttribute.Type TYPE_DEVICE_MODEL = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL);\n+    private static final BlackboardAttribute.Type TYPE_MESSAGE_TYPE = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE);\n+    private static final BlackboardAttribute.Type TYPE_TEXT = new BlackboardAttribute.Type(ATTRIBUTE_TYPE.TSK_TEXT);\n+\n+    private static final Comparator<TopAccountResult> TOP_ACCOUNT_RESULT_DATE_COMPARE = (a, b) -> a.getLastAccess().compareTo(b.getLastAccess());\n+    private static final Comparator<TopWebSearchResult> TOP_WEBSEARCH_RESULT_DATE_COMPARE = (a, b) -> a.getDateAccessed().compareTo(b.getDateAccessed());\n+    private static final String ROOT_HUB_IDENTIFIER = \"ROOT_HUB\";\n+\n+    private static final long SLEEP_TIME = 5000;\n+\n+    /**\n+     * A function to calculate a result from 2 parameters.\n+     */\n+    interface Function2<A1, A2, O> {\n+\n+        O apply(A1 a1, A2 a2);\n+    }\n+\n+    /**\n+     * Gets a list of recent domains based on the datasource.\n+     *\n+     * @param dataSource The datasource to query for recent domains.\n+     * @param count      The max count of items to return.\n+     *\n+     * @return The list of items retrieved from the database.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public List<TopDomainsResult> getRecentDomains(DataSource dataSource, int count) throws InterruptedException {\n+        Thread.sleep(SLEEP_TIME);\n+        final String dId = Long.toString(dataSource.getId());\n+        final Function2<String, Integer, String> getId = (s, idx) -> String.format(\"d:%s, f:%s, i:%d\", dId, s, idx);\n+        return IntStream.range(0, count)\n+                .mapToObj(num -> new TopDomainsResult(\n+                getId.apply(\"domain\", num),\n+                getId.apply(\"url\", num),\n+                (long) num,\n+                new Date(((long) num) * 1000 * 60 * 60 * 24)\n+        ))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private final SleuthkitCaseProvider caseProvider;\n+    private final TextTranslationService translationService;\n+    private final java.util.logging.Logger logger;\n+\n+    /**\n+     * Main constructor.\n+     */\n+    public DataSourceUserActivitySummary() {\n+        this(SleuthkitCaseProvider.DEFAULT, TextTranslationService.getInstance(),\n+                org.sleuthkit.autopsy.coreutils.Logger.getLogger(DataSourceUserActivitySummary.class.getName()));\n+    }\n+\n+    /**\n+     * Main constructor with external dependencies specified. This constructor\n+     * is designed with unit testing in mind since mocked dependencies can be\n+     * utilized.\n+     *\n+     * @param provider           The object providing the current SleuthkitCase.\n+     * @param translationService The translation service.\n+     * @param logger             The logger to use.\n+     */\n+    public DataSourceUserActivitySummary(\n+            SleuthkitCaseProvider provider,\n+            TextTranslationService translationService,\n+            java.util.logging.Logger logger) {\n+\n+        this.caseProvider = provider;\n+        this.translationService = translationService;\n+        this.logger = logger;\n+    }\n+\n+    /**\n+     * Throws an IllegalArgumentException if count <= 0.\n+     *\n+     * @param count The count being checked.\n+     */\n+    private void assertValidCount(int count) {\n+        if (count <= 0) {\n+            throw new IllegalArgumentException(\"Count must be greater than 0\");\n+        }\n+    }\n+\n+    /**\n+     * Retrieves most recent web searches by most recent date grouped by search\n+     * term.\n+     *\n+     * @param dataSource The data source.\n+     * @param count      The maximum number of records to be shown (must be >\n+     *                   0).\n+     *\n+     * @return The list of most recent web searches where most recent search\n+     *         appears first.\n+     *\n+     * @throws\n+     * org.sleuthkit.autopsy.datasourcesummary.datamodel.SleuthkitCaseProvider.SleuthkitCaseProviderException\n+     * @throws TskCoreException\n+     */\n+    public List<TopWebSearchResult> getMostRecentWebSearches(DataSource dataSource, int count) throws SleuthkitCaseProviderException, TskCoreException {\n+        assertValidCount(count);\n+\n+        List<TopWebSearchResult> results = caseProvider.get().getBlackboard().getArtifacts(ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID(), dataSource.getId())\n+                .stream()\n+                // get items where search string and date is not null\n+                .map(artifact -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNDcxNA=="}, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTcxMTA2OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTowNDo0OVrOHL-PQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo1MjozM1rOHMnpDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNjA5OA==", "bodyText": "I have already fixed this in my PR, might want to remove this so there is no conflicts.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482316098", "createdAt": "2020-09-02T19:04:49Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java", "diffHunk": "@@ -45,7 +45,7 @@\n     private final List<Pair<String, BaseDataSourceSummaryPanel>> tabs = Arrays.asList(\n             Pair.of(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new DataSourceSummaryDetailsPanel()),\n             Pair.of(Bundle.DataSourceSummaryTabbedPane_countsTab_title(), new DataSourceSummaryCountsPanel()),\n-            Pair.of(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new DataSourceSummaryUserActivityPanel())\n+            Pair.of(Bundle.DataSourceSummaryTabbedPane_userActivityTab_title(), new DataSourceSummaryUserActivityPanel())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM2NTEzNQ==", "bodyText": "I just checked and I think if nothing else, the comma will cause a conflict.  I don't know if I'm entirely accurate on this, but I think if I revert my code, it will still be a conflict with the revert.  I think it might make sense to deal with the conflict when it happens.  If I go second, I'll pull and handle the merge conflict.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482365135", "createdAt": "2020-09-02T19:48:04Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java", "diffHunk": "@@ -45,7 +45,7 @@\n     private final List<Pair<String, BaseDataSourceSummaryPanel>> tabs = Arrays.asList(\n             Pair.of(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new DataSourceSummaryDetailsPanel()),\n             Pair.of(Bundle.DataSourceSummaryTabbedPane_countsTab_title(), new DataSourceSummaryCountsPanel()),\n-            Pair.of(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new DataSourceSummaryUserActivityPanel())\n+            Pair.of(Bundle.DataSourceSummaryTabbedPane_userActivityTab_title(), new DataSourceSummaryUserActivityPanel())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNjA5OA=="}, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5NDQ0NQ==", "bodyText": "I wasn't suggesting reverting it, just change it back, but what ever you want to do.", "url": "https://github.com/sleuthkit/autopsy/pull/6223#discussion_r482994445", "createdAt": "2020-09-03T13:52:33Z", "author": {"login": "kellykelly3"}, "path": "Core/src/org/sleuthkit/autopsy/datasourcesummary/ui/DataSourceSummaryTabbedPane.java", "diffHunk": "@@ -45,7 +45,7 @@\n     private final List<Pair<String, BaseDataSourceSummaryPanel>> tabs = Arrays.asList(\n             Pair.of(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new DataSourceSummaryDetailsPanel()),\n             Pair.of(Bundle.DataSourceSummaryTabbedPane_countsTab_title(), new DataSourceSummaryCountsPanel()),\n-            Pair.of(Bundle.DataSourceSummaryTabbedPane_detailsTab_title(), new DataSourceSummaryUserActivityPanel())\n+            Pair.of(Bundle.DataSourceSummaryTabbedPane_userActivityTab_title(), new DataSourceSummaryUserActivityPanel())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMxNjA5OA=="}, "originalCommit": {"oid": "e6c41a3f67010f27f2d139cceec779d4dbb56ce1"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 871, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}