{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzkzMjk3", "number": 5771, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1Nzo1OVrODvzfQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoyMlrODvzqHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDUzMjUxOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1Nzo1OVrOGCcUgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjo0ODoxNVrOGCtmZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDMzNw==", "bodyText": "Year is incorrect.\nAlso I am not a fan of having multiple classes with identical names is there anyway we can rename one of our two WrapLayout classes?", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214337", "createdAt": "2020-04-08T01:57:59Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NzQ0NQ==", "bodyText": "I corrected the year and there is a question in Jira for the second concern.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405497445", "createdAt": "2020-04-08T12:48:15Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDMzNw=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDUzMzAzOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODoyOFrOGCcU4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODoyOFrOGCcU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDQzMw==", "bodyText": "separation", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214433", "createdAt": "2020-04-08T01:58:28Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDUzMzUwOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODozOVrOGCcVIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODozOVrOGCcVIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDQ5Ng==", "bodyText": "separation", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214496", "createdAt": "2020-04-08T01:58:39Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDUzOTQ5OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMTo1OFrOGCcYtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTozNTozNlrOGCrHyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQxNA==", "bodyText": "This doesn't feel like something we want to add to the public API a method where it does nothing and just has a note saying it is not used for this layout in the comment.\nAlso codacy doesn't like the empty body being undocumented.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215414", "createdAt": "2020-04-08T02:01:58Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1Njg0MA==", "bodyText": "This is a method of the interface, java.awt.LayoutManager.  I documented that it was not in use in the method body.  Is there a particular way this should be documented?", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405456840", "createdAt": "2020-04-08T11:35:36Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQxNA=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDUzOTY1OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMjowM1rOGCcY0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoyNToyOFrOGCvH-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg==", "bodyText": "This doesn't feel like something we want to add to the public API a method where it does nothing and just has a note saying it is not used for this layout in the comment.\nAlso codacy doesn't like the empty body being undocumented.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215442", "createdAt": "2020-04-08T02:02:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1Njg4Nw==", "bodyText": "This is a method of the interface, java.awt.LayoutManager.  I documented that it was not in use in the method body.  Is there a particular way this should be documented?", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405456887", "createdAt": "2020-04-08T11:35:43Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMjQyNQ==", "bodyText": "Putting a comment in the body generally makes codacy happy about its \"Document Empty Body\" suggestion. I usually go with something like //Empty - This method intentionally left blank.  But there is no like required phrasing that I know of.\nMy bigger concern is that maybe these methods are expected to do things when implementing this class and that a user calling them will not quickly realize they are not doing anything when making use of the public API, I almost feel like them throwing an Unsupported exception would be preferable if they are not used by our code.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405522425", "createdAt": "2020-04-08T13:25:28Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU0MjU0OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMzo1N1rOGCcatw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMzo1N1rOGCcatw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTkyNw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215927", "createdAt": "2020-04-08T02:03:57Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU0Mjc4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNDowM1rOGCca1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNDowM1rOGCca1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTk1OQ==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215959", "createdAt": "2020-04-08T02:04:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 370}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU0NTk1OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNjowNFrOGCcc5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNjowNFrOGCcc5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjQ4Nw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405216487", "createdAt": "2020-04-08T02:06:04Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU0NzgwOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNzoxNlrOGCceCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNzoxNlrOGCceCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjc3OQ==", "bodyText": "Assigned value never used.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405216779", "createdAt": "2020-04-08T02:07:16Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU0OTQxOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODowN1rOGCcfAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODowN1rOGCcfAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzAyNg==", "bodyText": "local variable hides field", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217026", "createdAt": "2020-04-08T02:08:07Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 410}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1MDU5OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODo0MFrOGCcfpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzowNDoxOVrOGCuO8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ==", "bodyText": "return of collection field.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217191", "createdAt": "2020-04-08T02:08:40Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTU2NA==", "bodyText": "Do you have a preference how this is handled (i.e. returning a new list generated from the original or something else)?", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405459564", "createdAt": "2020-04-08T11:40:55Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzgyNg==", "bodyText": "Generally we have been using Collections.unmodifiableCollection(...)", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405507826", "createdAt": "2020-04-08T13:04:19Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1MjUxOnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowOTo0MlrOGCcguA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo1ODozMFrOGC6l1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA==", "bodyText": "synchronizing inside synchronization seems like a recipe for problems to me but I will let @rcordovano  weigh in on this one.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217464", "createdAt": "2020-04-08T02:09:42Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MjMwNw==", "bodyText": "My aim was to synchronize on both items similar to https://stackoverflow.com/a/4604038.  I wanted the tree lock to avoid problems with altering objects in a container during layout: https://docs.oracle.com/javase/7/docs/api/java/awt/Component.html#getTreeLock(), and I wanted a lock to prevent access to the collection created for objects that will be oppositely aligned to prevent changes during layout operations.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405462307", "createdAt": "2020-04-08T11:46:26Z", "author": {"login": "gdicristofaro"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMDI5Mg==", "bodyText": "@gdicristofaro and @wschaeferB, nested locking is really risky and the consequence of a mistake, now or in maintenance, is a deadlock. Given that this code is UI code that will be thread-confined in the EDT, there should be no need for any synchronization at all in this class. Swing components get their thread safety by thread-confinement by design. Please remove all synchronization.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405710292", "createdAt": "2020-04-08T17:58:30Z", "author": {"login": "rcordovano"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1NDU2OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMDo1M1rOGCch8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMDo1M1rOGCch8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzc3Nw==", "bodyText": "synchronizing inside synchronization", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217777", "createdAt": "2020-04-08T02:10:53Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 430}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1NjE3OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMTozOFrOGCci2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMTozOFrOGCci2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODAwOA==", "bodyText": "public constructor in private class should be package level constructor.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218008", "createdAt": "2020-04-08T02:11:38Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;\n+\n+        /**\n+         * The minimum width of the row which is the sum of the preferred widths\n+         * of the subcomponents.\n+         */\n+        final int width;\n+\n+        public WrapLayoutRow(List<Component> components, List<Component> oppositeAligned, int height, int width) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 490}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1OTU4OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowM1rOGCckpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowM1rOGCckpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODQ3MQ==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218471", "createdAt": "2020-04-08T02:13:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 470}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1OTc2OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowOVrOGCckyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowOVrOGCckyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODUwNw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218507", "createdAt": "2020-04-08T02:13:09Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 476}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU1OTk3OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoxNVrOGCck6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoxNVrOGCck6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODUzOA==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218538", "createdAt": "2020-04-08T02:13:15Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 482}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDU2MDI5OnYy", "diffSide": "RIGHT", "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoyMlrOGCclEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoyMlrOGCclEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODU3Nw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218577", "createdAt": "2020-04-08T02:13:22Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;\n+\n+        /**\n+         * The minimum width of the row which is the sum of the preferred widths\n+         * of the subcomponents.\n+         */\n+        final int width;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 488}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 681, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}