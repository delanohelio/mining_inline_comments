{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzkzMjk3", "number": 5771, "title": "6186 horizontal resizing", "bodyText": "", "createdAt": "2020-04-02T20:14:54Z", "url": "https://github.com/sleuthkit/autopsy/pull/5771", "merged": true, "mergeCommit": {"oid": "ef0357fe5e9156037e2d6124acc34526c24aed51"}, "closed": true, "closedAt": "2020-04-16T13:45:38Z", "author": {"login": "gdicristofaro"}, "timelineItems": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTFXQLAH2gAyMzk3NzkzMjk3OjQ5NjNkYWVmODNhOTkwNjkyNTgyZDYyM2YyZjkxZTBjZWQzYjRlYjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYM8xJAFqTM5NDY0NzQxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4963daef83a990692582d623f2f91e0ced3b4eb0", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/4963daef83a990692582d623f2f91e0ced3b4eb0", "committedDate": "2020-03-31T16:05:34Z", "message": "beginnings of horizontal resizing panel in indexed text viewer; needs spacing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78d1bc1fc042a514adfdc2f2a7048617b5ce6ca9", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/78d1bc1fc042a514adfdc2f2a7048617b5ce6ca9", "committedDate": "2020-03-31T16:06:25Z", "message": "adding wrap layout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e070a5dae1a1ad0e2e350dd42c820518e9070066", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/e070a5dae1a1ad0e2e350dd42c820518e9070066", "committedDate": "2020-03-31T16:07:12Z", "message": "reverting bundle properties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dba59edfb724c866f6a72ad7b4df357ead0a011", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/8dba59edfb724c866f6a72ad7b4df357ead0a011", "committedDate": "2020-03-31T17:51:59Z", "message": "updated spacing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6156be0d8293c5d400bcdf21175b3d816a845d9", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/d6156be0d8293c5d400bcdf21175b3d816a845d9", "committedDate": "2020-04-01T02:03:45Z", "message": "new layout manager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93e7f6be929a29642ad807966c3350c71e1465ca", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/93e7f6be929a29642ad807966c3350c71e1465ca", "committedDate": "2020-04-01T20:04:35Z", "message": "package scoping wrap layout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2614255fe26391c0908991b26e8185bfa6c5037f", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/2614255fe26391c0908991b26e8185bfa6c5037f", "committedDate": "2020-04-02T14:23:59Z", "message": "working through public api wrap layout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20281bbf0053930285ec55eff45d6b31977787ba", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/20281bbf0053930285ec55eff45d6b31977787ba", "committedDate": "2020-04-02T18:05:23Z", "message": "fine tuning of resizing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f1c9cc543acb055de9a2ebf29eba7f15ff39fe9", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/5f1c9cc543acb055de9a2ebf29eba7f15ff39fe9", "committedDate": "2020-04-02T18:36:55Z", "message": "merge from develop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f54e9dc9ddb64ed980745c7af74ec552a572560f", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/f54e9dc9ddb64ed980745c7af74ec552a572560f", "committedDate": "2020-04-02T20:08:43Z", "message": "update for fonts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5036610b55c9e280fffd3ddb4fbf8547e9636f22", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/5036610b55c9e280fffd3ddb4fbf8547e9636f22", "committedDate": "2020-04-03T14:20:32Z", "message": "addressing some codacy issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c0c42eb65c6e487cfa0bb2a9168c899a8be289c", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/3c0c42eb65c6e487cfa0bb2a9168c899a8be289c", "committedDate": "2020-04-03T14:35:44Z", "message": "addressing some codacy issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1", "committedDate": "2020-04-03T14:46:54Z", "message": "commenting fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA0MzE0", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389604314", "createdAt": "2020-04-08T01:57:59Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1Nzo1OVrOGCcUgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1Nzo1OVrOGCcUgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDMzNw==", "bodyText": "Year is incorrect.\nAlso I am not a fan of having multiple classes with identical names is there anyway we can rename one of our two WrapLayout classes?", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214337", "createdAt": "2020-04-08T01:57:59Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA0NDQ2", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389604446", "createdAt": "2020-04-08T01:58:27Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODoyOFrOGCcU4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODoyOFrOGCcU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDQzMw==", "bodyText": "separation", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214433", "createdAt": "2020-04-08T01:58:28Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA0NTAy", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389604502", "createdAt": "2020-04-08T01:58:39Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODozOVrOGCcVIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTo1ODozOVrOGCcVIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNDQ5Ng==", "bodyText": "separation", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405214496", "createdAt": "2020-04-08T01:58:39Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA1NDgx", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389605481", "createdAt": "2020-04-08T02:01:58Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMTo1OFrOGCcYtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMTo1OFrOGCcYtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQxNA==", "bodyText": "This doesn't feel like something we want to add to the public API a method where it does nothing and just has a note saying it is not used for this layout in the comment.\nAlso codacy doesn't like the empty body being undocumented.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215414", "createdAt": "2020-04-08T02:01:58Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 206}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA1NTA3", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389605507", "createdAt": "2020-04-08T02:02:03Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMjowM1rOGCcY0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMjowM1rOGCcY0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTQ0Mg==", "bodyText": "This doesn't feel like something we want to add to the public API a method where it does nothing and just has a note saying it is not used for this layout in the comment.\nAlso codacy doesn't like the empty body being undocumented.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215442", "createdAt": "2020-04-08T02:02:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA2MDU4", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389606058", "createdAt": "2020-04-08T02:03:57Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMzo1N1rOGCcatw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowMzo1N1rOGCcatw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTkyNw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215927", "createdAt": "2020-04-08T02:03:57Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 364}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA2MDgy", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389606082", "createdAt": "2020-04-08T02:04:02Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNDowM1rOGCca1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNDowM1rOGCca1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNTk1OQ==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405215959", "createdAt": "2020-04-08T02:04:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 370}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA2NjQ5", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389606649", "createdAt": "2020-04-08T02:06:03Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNjowNFrOGCcc5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNjowNFrOGCcc5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjQ4Nw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405216487", "createdAt": "2020-04-08T02:06:04Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 375}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA2OTY0", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389606964", "createdAt": "2020-04-08T02:07:16Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNzoxNlrOGCceCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNzoxNlrOGCceCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjc3OQ==", "bodyText": "Assigned value never used.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405216779", "createdAt": "2020-04-08T02:07:16Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 397}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA3MjE4", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389607218", "createdAt": "2020-04-08T02:08:07Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODowN1rOGCcfAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODowN1rOGCcfAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzAyNg==", "bodyText": "local variable hides field", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217026", "createdAt": "2020-04-08T02:08:07Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 410}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA3MzY3", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389607367", "createdAt": "2020-04-08T02:08:40Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODo0MFrOGCcfpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowODo0MFrOGCcfpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzE5MQ==", "bodyText": "return of collection field.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217191", "createdAt": "2020-04-08T02:08:40Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA3NjU3", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389607657", "createdAt": "2020-04-08T02:09:42Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowOTo0MlrOGCcguA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowOTo0MlrOGCcguA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA==", "bodyText": "synchronizing inside synchronization seems like a recipe for problems to me but I will let @rcordovano  weigh in on this one.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217464", "createdAt": "2020-04-08T02:09:42Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA4MDA4", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389608008", "createdAt": "2020-04-08T02:10:52Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMDo1M1rOGCch8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMDo1M1rOGCch8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzc3Nw==", "bodyText": "synchronizing inside synchronization", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405217777", "createdAt": "2020-04-08T02:10:53Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 430}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA4Mjcx", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389608271", "createdAt": "2020-04-08T02:11:38Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMTozOFrOGCci2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMTozOFrOGCci2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODAwOA==", "bodyText": "public constructor in private class should be package level constructor.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218008", "createdAt": "2020-04-08T02:11:38Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;\n+\n+        /**\n+         * The minimum width of the row which is the sum of the preferred widths\n+         * of the subcomponents.\n+         */\n+        final int width;\n+\n+        public WrapLayoutRow(List<Component> components, List<Component> oppositeAligned, int height, int width) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 490}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA4NzMw", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389608730", "createdAt": "2020-04-08T02:13:03Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowM1rOGCckpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowM1rOGCckpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODQ3MQ==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218471", "createdAt": "2020-04-08T02:13:03Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 470}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA4NzY3", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389608767", "createdAt": "2020-04-08T02:13:09Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowOVrOGCckyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzowOVrOGCckyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODUwNw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218507", "createdAt": "2020-04-08T02:13:09Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 476}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA4ODAz", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389608803", "createdAt": "2020-04-08T02:13:15Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoxNVrOGCck6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoxNVrOGCck6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODUzOA==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218538", "createdAt": "2020-04-08T02:13:15Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 482}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjA4ODM5", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389608839", "createdAt": "2020-04-08T02:13:22Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoyMlrOGCclEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjoxMzoyMlrOGCclEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxODU3Nw==", "bodyText": "Should be private with package level getters and no setters.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405218577", "createdAt": "2020-04-08T02:13:22Z", "author": {"login": "wschaeferB"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, true, targetDims.innerWidth);\n+\n+                boolean ltr = target.getComponentOrientation().isLeftToRight();\n+                boolean useBaseline = getAlignOnBaseline();\n+\n+                int rowY = targetDims.insets.top + getVgap();\n+                int leftX = targetDims.insets.left + getHgap();\n+                int rightX = targetDims.outerWidth - targetDims.insets.right - getHgap();\n+\n+                for (WrapLayoutRow row : rows) {\n+                    int rowHeight = row.height;\n+\n+                    int curX = 0;\n+                    if (row.components != null) {\n+                        for (Component origComp : row.components) {\n+                            curX += setComponentDims(origComp, useBaseline, ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    if (row.oppositeAligned != null) {\n+                        curX = 0;\n+                        // reverse opposite aligned for layout purposes since flipping ltr\n+                        Collections.reverse(row.oppositeAligned);\n+                        for (Component oppAlignedComp : row.oppositeAligned) {\n+                            curX += setComponentDims(oppAlignedComp, useBaseline, !ltr, rowY, rowHeight, leftX, rightX, curX) + getHgap();\n+                        }\n+                    }\n+\n+                    rowY += rowHeight + getVgap();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the preferred dimensions for this layout given the\n+     * <i>visible</i> components in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The preferred dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension preferredLayoutSize(Container target) {\n+        return layoutSize(target, true);\n+    }\n+\n+    /**\n+     * Returns the minimum dimensions needed to layout the <i>visible</i>\n+     * components contained in the specified target container.\n+     *\n+     * @param target The component which needs to be laid out.\n+     *\n+     * @return The minimum dimensions to lay out the subcomponents of the\n+     *         specified container.\n+     */\n+    @Override\n+    public Dimension minimumLayoutSize(Container target) {\n+        Dimension minimum = layoutSize(target, false);\n+        minimum.width -= (getHgap() + 1);\n+        return minimum;\n+    }\n+\n+    /**\n+     * This class provides metrics on the parent container dimensions.\n+     */\n+    private static class ParentDimensions {\n+\n+        /**\n+         * The full width that the component can consume.\n+         */\n+        final int outerWidth;\n+\n+        /**\n+         * The full width that subcomponent rows can consume. This is the\n+         * outerWidth accounting for left and right insets.\n+         */\n+        final int innerWidth;\n+\n+        /**\n+         * The insets of the parent container.\n+         */\n+        final Insets insets;\n+\n+        ParentDimensions(int outerWidth, int innerWidth, Insets insets) {\n+            this.outerWidth = outerWidth;\n+            this.innerWidth = innerWidth;\n+            this.insets = insets;\n+        }\n+    }\n+\n+    /**\n+     * Derives metrics on the space allowed within the parent container for rows\n+     * of components.\n+     *\n+     * @param target The target container.\n+     *\n+     * @return The dimensions for laying out components.\n+     */\n+    private ParentDimensions getTargetDimensions(Container target) {\n+        //  Each row must fit with the width allocated to the containter.\n+        //  When the container width = 0, the preferred width of the container\n+        //  has not yet been calculated so lets ask for the maximum.\n+\n+        int targetWidth = target.getSize().width;\n+        Container container = target;\n+\n+        while (container.getSize().width == 0 && container.getParent() != null) {\n+            container = container.getParent();\n+        }\n+\n+        targetWidth = container.getSize().width;\n+\n+        if (targetWidth == 0) {\n+            targetWidth = Integer.MAX_VALUE;\n+        }\n+\n+        int hgap = getHgap();\n+\n+        Insets insets = target.getInsets();\n+        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n+        int maxWidth = targetWidth - horizontalInsetsAndGap;\n+\n+        return new ParentDimensions(targetWidth, maxWidth, insets);\n+    }\n+\n+    /**\n+     * Returns the minimum or preferred dimension needed to layout the target\n+     * container.\n+     *\n+     * @param target    Target to get layout size for.\n+     * @param preferred Should preferred size be calculate.d\n+     *\n+     * @return The dimension to layout the target container.\n+     */\n+    private Dimension layoutSize(Container target, boolean preferred) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {\n+                ParentDimensions targetDims = getTargetDimensions(target);\n+                List<Component> components = Arrays.asList(target.getComponents());\n+                List<WrapLayoutRow> rows = getAllRows(components, preferred, targetDims.innerWidth);\n+\n+                Integer containerHeight = rows.stream().map((r) -> r.height).reduce(0, Integer::sum);\n+                // add in vertical gap between rows\n+                if (rows.size() > 1) {\n+                    containerHeight += (rows.size() - 1) * getVgap();\n+                }\n+\n+                containerHeight += targetDims.insets.top + targetDims.insets.bottom;\n+\n+                Integer containerWidth = rows.stream().map((r) -> r.width).reduce(0, Math::max);\n+                containerWidth += targetDims.insets.left + targetDims.insets.right + (getHgap() * 2);\n+\n+                //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n+                //  make sure the preferred size is less than the size of the\n+                //  target containter so shrinking the container size works\n+                //  correctly. Removing the horizontal gap is an easy way to do this.\n+                Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n+\n+                if (scrollPane != null && target.isValid()) {\n+                    containerWidth -= (getHgap() + 1);\n+                }\n+\n+                return new Dimension(containerWidth, containerHeight);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A row of components in the WrapLayout.\n+     */\n+    private class WrapLayoutRow {\n+\n+        /**\n+         * The normally aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> components;\n+\n+        /**\n+         * The opposite aligned components in the order that they will be laid\n+         * out.\n+         */\n+        final List<Component> oppositeAligned;\n+\n+        /**\n+         * The minimum height of the row which is the maximum of the preferred\n+         * heights of the components.\n+         */\n+        final int height;\n+\n+        /**\n+         * The minimum width of the row which is the sum of the preferred widths\n+         * of the subcomponents.\n+         */\n+        final int width;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 488}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE4Nzc5", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-389618779", "createdAt": "2020-04-08T02:47:52Z", "commit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0904d9fa24cfac8739a52d24c5793e50e004a43", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/c0904d9fa24cfac8739a52d24c5793e50e004a43", "committedDate": "2020-04-08T12:21:42Z", "message": "updated formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "876a9870b2d65cf59abc0f4ff9dac1792437ad4d", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/876a9870b2d65cf59abc0f4ff9dac1792437ad4d", "committedDate": "2020-04-08T12:59:53Z", "message": "fix for assigned value never used"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56cd8fcff69f1832d71456a7f1cb9a7a26a6e421", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/56cd8fcff69f1832d71456a7f1cb9a7a26a6e421", "committedDate": "2020-04-08T14:58:24Z", "message": "address codacy items"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjA0NjA5", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-390204609", "createdAt": "2020-04-08T17:58:30Z", "commit": {"oid": "56cd8fcff69f1832d71456a7f1cb9a7a26a6e421"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo1ODozMFrOGC6l1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo1ODozMFrOGC6l1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMDI5Mg==", "bodyText": "@gdicristofaro and @wschaeferB, nested locking is really risky and the consequence of a mistake, now or in maintenance, is a deadlock. Given that this code is UI code that will be thread-confined in the EDT, there should be no need for any synchronization at all in this class. Swing components get their thread safety by thread-confinement by design. Please remove all synchronization.", "url": "https://github.com/sleuthkit/autopsy/pull/5771#discussion_r405710292", "createdAt": "2020-04-08T17:58:30Z", "author": {"login": "rcordovano"}, "path": "Core/src/org/sleuthkit/autopsy/guiutils/WrapLayout.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+ * Autopsy Forensic Browser\n+ *\n+ * Copyright 2019 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.guiutils;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * A layout class similar to FlowLayout in that when a component can't fit in a\n+ * row it is moved to the next row. Inspired by WrapLayout, this layout also\n+ * allows for aligning some components in the opposite side. In instances where\n+ * components are laid out left to right, these opposite aligned components will\n+ * be aligned to the right.\n+ *\n+ * Inspired by WrapLayout\n+ * https://tips4java.wordpress.com/2008/11/06/wrap-layout/ and FlowLayout\n+ * https://raw.githubusercontent.com/mynawang/Java8-Source-Code/master/src/main/jdk8/java/awt/FlowLayout.java.\n+ */\n+public class WrapLayout implements LayoutManager, java.io.Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The horizontal gap will specify the space between components\n+     * and between the components and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getHgap()\n+     * @see #setHgap(int)\n+     */\n+    private int hgap = 0;\n+\n+    /**\n+     * The <code>WrapLayout</code> manager allows a seperation of components\n+     * with gaps. The vertical gap will specify the space between rows and\n+     * between the the rows and the borders of the <code>Container</code>.\n+     *\n+     * @serial\n+     * @see #getVgap()\n+     * @see #setVgap(int)\n+     */\n+    private int vgap = 0;\n+\n+    /**\n+     * If true, components will be aligned on their baseline.\n+     */\n+    private boolean alignOnBaseline = false;\n+\n+    /**\n+     * The set of components that will be aligned on the opposite side (if left\n+     * to right, on the right).\n+     */\n+    private final Set<Component> oppositeAlignedItems = new HashSet<>();\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment and a\n+     * default 5-unit horizontal and vertical gap.\n+     */\n+    public WrapLayout() {\n+        this(5, 5);\n+    }\n+\n+    /**\n+     * Constructs a new <code>WrapLayout</code> with a left alignment.\n+     * \n+     * @param vgap  The vertical gap spacing between rows of components.\n+     * @param hgap  The horizontal gap spacing between components.\n+     */\n+    public WrapLayout(int vgap, int hgap) {\n+        this.vgap = vgap;\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @param oppAlignedComponents The components to display with opposite\n+     *                             alignment.\n+     */\n+    public void setOppositeAligned(Collection<Component> oppAlignedComponents) {\n+        synchronized (this.oppositeAlignedItems) {\n+            this.oppositeAlignedItems.clear();\n+            this.oppositeAlignedItems.addAll(oppAlignedComponents);\n+        }\n+    }\n+\n+    /**\n+     * Items in the collection will be aligned opposite to the rest. For\n+     * instance, if items should be displayed left to right based on locale,\n+     * these components will be on the right.\n+     *\n+     * @return The components to display with opposite alignment.\n+     */\n+    public Collection<Component> getOppositeAlignedItems() {\n+        return oppositeAlignedItems;\n+    }\n+\n+    /**\n+     * Gets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>\n+     *\n+     * @return The horizontal gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getHgap() {\n+        return hgap;\n+    }\n+\n+    /**\n+     * Sets the horizontal gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param hgap The horizontal gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setHgap(int hgap) {\n+        this.hgap = hgap;\n+    }\n+\n+    /**\n+     * Gets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @return The vertical gap between components and between the components\n+     *         and the borders of the <code>Container</code>.\n+     */\n+    public int getVgap() {\n+        return vgap;\n+    }\n+\n+    /**\n+     * Sets the vertical gap between components and between the components and\n+     * the borders of the <code>Container</code>.\n+     *\n+     * @param vgap The vertical gap between components and between the\n+     *             components and the borders of the <code>Container</code>.\n+     */\n+    public void setVgap(int vgap) {\n+        this.vgap = vgap;\n+    }\n+\n+    /**\n+     * Sets whether or not components should be vertically aligned along their\n+     * baseline. Components that do not have a baseline will be centered. The\n+     * default is false.\n+     *\n+     * @param alignOnBaseline Whether or not components should be vertically\n+     *                        aligned on their baseline.\n+     */\n+    public void setAlignOnBaseline(boolean alignOnBaseline) {\n+        this.alignOnBaseline = alignOnBaseline;\n+    }\n+\n+    /**\n+     * Returns true if components are to be vertically aligned along their\n+     * baseline. The default is false.\n+     *\n+     * @return true If components are to be vertically aligned along their\n+     *         baseline.\n+     */\n+    public boolean getAlignOnBaseline() {\n+        return alignOnBaseline;\n+    }\n+\n+    /**\n+     * Adds the specified component to the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param name The name of the component.\n+     * @param comp The component to be added.\n+     */\n+    @Override\n+    public void addLayoutComponent(String name, Component comp) {\n+    }\n+\n+    /**\n+     * Removes the specified component from the layout. Not used by this class.\n+     * NOTE: This is not used for this layout\n+     *\n+     * @param comp The component to remove.\n+     */\n+    @Override\n+    public void removeLayoutComponent(Component comp) {\n+    }\n+\n+    /**\n+     * Determines the subcomponent's y position.\n+     *\n+     * @param rowY          The top y position of the row.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param rowHeight     The height of the row.\n+     * @param itemHeight    The height of the item.\n+     *\n+     * @return The top y position of the component.\n+     */\n+    private int getComponentY(int rowY, boolean alignBaseline, int rowHeight, int itemHeight) {\n+        return alignBaseline\n+                ? rowY + rowHeight - itemHeight\n+                : rowY;\n+    }\n+\n+    /**\n+     * * Determines the subcomponent's x position.\n+     *\n+     * @param leftX          The leftmost position a component can be placed.\n+     * @param rightX         The rightmost position a component can be placed.\n+     * @param ltr            If the components should be laid out left to right.\n+     * @param xPos           The x position of the component (if left to right,\n+     *                       how far from leftX; otherwise how far from rightX).\n+     * @param componentWidth The component's width.\n+     *\n+     * @return The component's left x position.\n+     */\n+    private int getComponentX(int leftX, int rightX, boolean ltr, int xPos, int componentWidth) {\n+        return ltr ? leftX + xPos : rightX - xPos - componentWidth;\n+    }\n+\n+    /**\n+     * Sets a subcomponent's size to preferred size and sets the (x,y) position\n+     * for the component.\n+     *\n+     * @param comp          The component.\n+     * @param alignBaseline Whether this component should be aligned on the\n+     *                      baseline.\n+     * @param ltr           If the components should be laid out left to right.\n+     * @param rowY          The top y position of the row.\n+     * @param rowHeight     The height of the row.\n+     * @param leftX         The leftmost position a component can be placed.\n+     * @param rightX        The rightmost position a component can be placed.\n+     * @param xPos          The x position of the component (if left to right,\n+     *                      how far from leftX; otherwise how far from rightX).\n+     *\n+     * @return The width of the component.\n+     */\n+    private int setComponentDims(Component comp, boolean alignBaseline, boolean ltr, int rowY, int rowHeight, int leftX, int rightX, int xPos) {\n+        Dimension d = comp.getPreferredSize();\n+        comp.setSize(d);\n+\n+        int x = getComponentX(leftX, rightX, ltr, xPos, d.width);\n+        int y = getComponentY(rowY, alignBaseline, rowHeight, d.height);\n+        comp.setLocation(x, y);\n+\n+        return d.width;\n+    }\n+\n+    /**\n+     * Lays out the container. This method lets each\n+     * <i>visible</i> component take its preferred size by reshaping the\n+     * components in the target container and creating new rows.\n+     *\n+     * @param target The specified component being laid out.\n+     */\n+    @Override\n+    public void layoutContainer(Container target) {\n+        synchronized (target.getTreeLock()) {\n+            synchronized (this.oppositeAlignedItems) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzQ2NA=="}, "originalCommit": {"oid": "1c8aadf9ff1346e665d0b44fedd35a4fe20d5bc1"}, "originalPosition": 289}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48d1e08280c13ea276550aed9e1e36f35301b9ec", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/48d1e08280c13ea276550aed9e1e36f35301b9ec", "committedDate": "2020-04-08T19:11:03Z", "message": "remove synchronization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8755ba9302a9b27ad524fe9fe21c3056bf70e2b3", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/8755ba9302a9b27ad524fe9fe21c3056bf70e2b3", "committedDate": "2020-04-08T20:07:53Z", "message": "update for codacy remark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a089bae8cf8c7c5daaa631babf2f411f2083628", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/5a089bae8cf8c7c5daaa631babf2f411f2083628", "committedDate": "2020-04-09T19:21:30Z", "message": "move to new WrapLayout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f15a2ea712f5391dade596dae076438dc4153b8a", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/f15a2ea712f5391dade596dae076438dc4153b8a", "committedDate": "2020-04-10T15:49:39Z", "message": "improved commenting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1e2bd67f0d2ea78b750914c71c168e207befe31", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/f1e2bd67f0d2ea78b750914c71c168e207befe31", "committedDate": "2020-04-10T15:55:18Z", "message": "improved commenting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a423825adf55ca6f70878387b42d2f3ec91bd81", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/9a423825adf55ca6f70878387b42d2f3ec91bd81", "committedDate": "2020-04-16T11:47:32Z", "message": "updated hgap to horizontalGap and vgap to verticalGap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c3465269346999d1bc8eeca6fd4680bd683c05b", "author": {"user": {"login": "gdicristofaro", "name": "Greg DiCristofaro"}}, "url": "https://github.com/sleuthkit/autopsy/commit/2c3465269346999d1bc8eeca6fd4680bd683c05b", "committedDate": "2020-04-16T13:36:15Z", "message": "isAlignOnBaseline method change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjQ3NDE5", "url": "https://github.com/sleuthkit/autopsy/pull/5771#pullrequestreview-394647419", "createdAt": "2020-04-16T13:45:30Z", "commit": {"oid": "2c3465269346999d1bc8eeca6fd4680bd683c05b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2738, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}