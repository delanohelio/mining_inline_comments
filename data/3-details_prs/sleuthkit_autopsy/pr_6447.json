{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4Njc0Njg5", "number": 6447, "title": "6781 6781 general purpose artifact viewer", "bodyText": "", "createdAt": "2020-11-10T18:14:46Z", "url": "https://github.com/sleuthkit/autopsy/pull/6447", "merged": true, "mergeCommit": {"oid": "638c0d8dfb7add86d314e02ac23812771869e6b4"}, "closed": true, "closedAt": "2020-11-20T17:22:18Z", "author": {"login": "wschaeferB"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdY8uSmgH2gAyNTE4Njc0Njg5OmFiNGNiNDg0MWJjNTAyYzQ3Y2MxMmFhOGM0MDU1ZTUwZjU4YmYwM2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeZ-1GgH2gAyNTE4Njc0Njg5OjIyNTcyNDZlYjBkNjY1ODU4ZmZjNzE0YzRhZWU1YjlmODI5ZGE3NjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ab4cb4841bc502c47cc12aa8c4055e50f58bf03a", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/ab4cb4841bc502c47cc12aa8c4055e50f58bf03a", "committedDate": "2020-11-03T17:36:17Z", "message": "Merge branch 'develop' of https://github.com/sleuthkit/autopsy into 6781-GeneralPurposeArtifactViewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3af5d0b05020def51cbf3066bb6f9db39a5cb3f", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/a3af5d0b05020def51cbf3066bb6f9db39a5cb3f", "committedDate": "2020-11-03T18:44:55Z", "message": "6781 general purpose artifact viewer stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e008170d82afb788a8d8eee64eb537bf37e7d2f", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/8e008170d82afb788a8d8eee64eb537bf37e7d2f", "committedDate": "2020-11-04T02:13:03Z", "message": "6781 resolve merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68191e03d0b847430bc7ec4eee7275e936dd6a20", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/68191e03d0b847430bc7ec4eee7275e936dd6a20", "committedDate": "2020-11-04T02:14:57Z", "message": "6781 remove empty lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a327ab07f9b7039993059e3d93ee5499ffb90b91", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/a327ab07f9b7039993059e3d93ee5499ffb90b91", "committedDate": "2020-11-09T15:19:35Z", "message": "6781 resolve merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e1e3ff21beeba75e444956449eb01ee9806146a", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/6e1e3ff21beeba75e444956449eb01ee9806146a", "committedDate": "2020-11-09T17:40:04Z", "message": "6781 general purpose viewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dd28340e5e6435758190d95fc48adb8fb3fd33d", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/3dd28340e5e6435758190d95fc48adb8fb3fd33d", "committedDate": "2020-11-10T17:27:38Z", "message": "6781 refactor viewer code for general purpose viewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64fd4af87f4fb73387174cf8de26bfff6dca6dea", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/64fd4af87f4fb73387174cf8de26bfff6dca6dea", "committedDate": "2020-11-10T17:31:22Z", "message": "6781 fix missing parrens"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7584f5c9751d83c4a1b774897fa46142dfa96c29", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/7584f5c9751d83c4a1b774897fa46142dfa96c29", "committedDate": "2020-11-10T18:14:20Z", "message": "6781 clean up logic and code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84d667473a4e07efdb21182fa6b941023f0a5cff", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/84d667473a4e07efdb21182fa6b941023f0a5cff", "committedDate": "2020-11-10T18:42:39Z", "message": "6781 remove unnecessary public declarations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ffc8c98574ce17400986b29afd4ea84ba675a05", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/8ffc8c98574ce17400986b29afd4ea84ba675a05", "committedDate": "2020-11-13T14:17:55Z", "message": "Merge branch 'develop' of https://github.com/sleuthkit/autopsy into 6781-GeneralPurposeArtifactViewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "017a21fb2d700375f6bae045e46c34445a7cc592", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/017a21fb2d700375f6bae045e46c34445a7cc592", "committedDate": "2020-11-13T18:42:18Z", "message": "Merge branch 'develop' of https://github.com/sleuthkit/autopsy into 6781-GeneralPurposeArtifactViewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e14473fdae4233b5760ce5fb453bbaa2741a1b5", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/1e14473fdae4233b5760ce5fb453bbaa2741a1b5", "committedDate": "2020-11-13T18:44:36Z", "message": "6781 fix comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMzc4MzAy", "url": "https://github.com/sleuthkit/autopsy/pull/6447#pullrequestreview-530378302", "createdAt": "2020-11-13T20:21:06Z", "commit": {"oid": "1e14473fdae4233b5760ce5fb453bbaa2741a1b5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QyMDoyMTowNlrOHy9vFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxODoxMjoxN1rOH0LVuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIwMjMyNw==", "bodyText": "There is a copy-paste error here. TSK_WEB_BOOKMARK is added to orderingMap six times. It accidentally works out because all of the currently supported artifact types are all using  DEFAULT_ORDERING, and that is also the fall back if an artifact type is not found in the orderingMap.", "url": "https://github.com/sleuthkit/autopsy/pull/6447#discussion_r523202327", "createdAt": "2020-11-13T20:21:06Z", "author": {"login": "rcordovano"}, "path": "Core/src/org/sleuthkit/autopsy/contentviewers/artifactviewers/GeneralPurposeArtifactViewer.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Autopsy\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.contentviewers.artifactviewers;\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextPane;\n+import javax.swing.SwingUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.lookup.ServiceProvider;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.ThreadConfined;\n+import org.sleuthkit.autopsy.discovery.ui.AbstractArtifactDetailsPanel;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Panel to display the details for an Artifact.\n+ */\n+@ServiceProvider(service = ArtifactContentViewer.class)\n+public class GeneralPurposeArtifactViewer extends AbstractArtifactDetailsPanel implements ArtifactContentViewer {\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final Logger logger = Logger.getLogger(GeneralPurposeArtifactViewer.class.getName());\n+    // Number of columns in the gridbag layout.\n+    private final static int MAX_COLS = 4;\n+    private final static Insets ROW_INSETS = new java.awt.Insets(0, 12, 0, 0);\n+    private final static Insets HEADER_INSETS = new java.awt.Insets(0, 0, 0, 0);\n+    private final static double GLUE_WEIGHT_X = 1.0;\n+    private final static double TEXT_WEIGHT_X = 0.0;\n+    private final static int LABEL_COLUMN = 0;\n+    private final static int VALUE_COLUMN = 1;\n+    private final static int VALUE_WIDTH = 2;\n+    private final static int LABEL_WIDTH = 1;\n+    private static final Integer[] DEFAULT_ORDERING = new Integer[]{BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TITLE.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH_ID.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_HEADERS.getTypeID()};\n+    private final GridBagLayout gridBagLayout = new GridBagLayout();\n+    private final GridBagConstraints gridBagConstraints = new GridBagConstraints();\n+    private String dataSourceName;\n+    private String sourceFileName;\n+    private Integer artifactTypeId = -1;\n+    private final Map<Integer, List<BlackboardAttribute>> attributeMap = new HashMap<>();\n+    private final Map<Integer, Integer[]> orderingMap = new HashMap<>();\n+\n+    /**\n+     * Creates new form GeneralPurposeArtifactViewer.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    public GeneralPurposeArtifactViewer() {\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e14473fdae4233b5760ce5fb453bbaa2741a1b5"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1MzYwMw==", "bodyText": "The artifact source could actually be a data source rather than a file within a data source, e.g., for forensic tool reports. However, looking at the GUI, I don't think it will be a problem if the values for the \"Data Source\" and \"File\" labels will be the same in such circumstances,", "url": "https://github.com/sleuthkit/autopsy/pull/6447#discussion_r524453603", "createdAt": "2020-11-16T17:40:16Z", "author": {"login": "rcordovano"}, "path": "Core/src/org/sleuthkit/autopsy/contentviewers/artifactviewers/GeneralPurposeArtifactViewer.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Autopsy\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.contentviewers.artifactviewers;\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextPane;\n+import javax.swing.SwingUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.lookup.ServiceProvider;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.ThreadConfined;\n+import org.sleuthkit.autopsy.discovery.ui.AbstractArtifactDetailsPanel;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Panel to display the details for an Artifact.\n+ */\n+@ServiceProvider(service = ArtifactContentViewer.class)\n+public class GeneralPurposeArtifactViewer extends AbstractArtifactDetailsPanel implements ArtifactContentViewer {\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final Logger logger = Logger.getLogger(GeneralPurposeArtifactViewer.class.getName());\n+    // Number of columns in the gridbag layout.\n+    private final static int MAX_COLS = 4;\n+    private final static Insets ROW_INSETS = new java.awt.Insets(0, 12, 0, 0);\n+    private final static Insets HEADER_INSETS = new java.awt.Insets(0, 0, 0, 0);\n+    private final static double GLUE_WEIGHT_X = 1.0;\n+    private final static double TEXT_WEIGHT_X = 0.0;\n+    private final static int LABEL_COLUMN = 0;\n+    private final static int VALUE_COLUMN = 1;\n+    private final static int VALUE_WIDTH = 2;\n+    private final static int LABEL_WIDTH = 1;\n+    private static final Integer[] DEFAULT_ORDERING = new Integer[]{BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TITLE.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH_ID.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_HEADERS.getTypeID()};\n+    private final GridBagLayout gridBagLayout = new GridBagLayout();\n+    private final GridBagConstraints gridBagConstraints = new GridBagConstraints();\n+    private String dataSourceName;\n+    private String sourceFileName;\n+    private Integer artifactTypeId = -1;\n+    private final Map<Integer, List<BlackboardAttribute>> attributeMap = new HashMap<>();\n+    private final Map<Integer, Integer[]> orderingMap = new HashMap<>();\n+\n+    /**\n+     * Creates new form GeneralPurposeArtifactViewer.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    public GeneralPurposeArtifactViewer() {\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        initComponents();\n+    }\n+\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    @Override\n+    public void setArtifact(BlackboardArtifact artifact) {\n+        resetComponent();\n+        if (artifact != null) {\n+            artifactTypeId = artifact.getArtifactTypeID();\n+            try {\n+                extractArtifactData(artifact);\n+            } catch (TskCoreException ex) {\n+                logger.log(Level.WARNING, \"Unable to get attributes for artifact \" + artifact.getArtifactID(), ex);\n+            }\n+            updateView();\n+        }\n+        this.setLayout(this.gridBagLayout);\n+        this.revalidate();\n+        this.repaint();\n+    }\n+\n+    /**\n+     * Extracts data from the artifact to be displayed in the panel.\n+     *\n+     * @param artifact Artifact to show.\n+     *\n+     * @throws TskCoreException\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    private void extractArtifactData(BlackboardArtifact artifact) throws TskCoreException {\n+        // Get all the attributes and group them by the attributeType \n+        for (BlackboardAttribute bba : artifact.getAttributes()) {\n+            List<BlackboardAttribute> attrList = attributeMap.get(bba.getAttributeType().getTypeID());\n+            if (attrList == null) {\n+                attrList = new ArrayList<>();\n+            }\n+            attrList.add(bba);\n+            attributeMap.put(bba.getAttributeType().getTypeID(), attrList);\n+        }\n+        dataSourceName = artifact.getDataSource().getName();\n+        sourceFileName = artifact.getParent().getName();\n+    }\n+\n+    /**\n+     * Reset the panel so that it is empty.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    private void resetComponent() {\n+        // clear the panel \n+        this.removeAll();\n+        gridBagConstraints.anchor = GridBagConstraints.FIRST_LINE_START;\n+        gridBagConstraints.gridy = 0;\n+        gridBagConstraints.gridx = LABEL_COLUMN;\n+        gridBagConstraints.weighty = 0.0;\n+        gridBagConstraints.weightx = TEXT_WEIGHT_X;    // keep components fixed horizontally.\n+        gridBagConstraints.fill = GridBagConstraints.NONE;\n+        gridBagConstraints.insets = ROW_INSETS;\n+        artifactTypeId = -1;\n+        dataSourceName = null;\n+        sourceFileName = null;\n+        attributeMap.clear();\n+    }\n+\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    @Override\n+    public Component getComponent() {\n+        // Slap a vertical scrollbar on the panel.\n+        return new JScrollPane(this, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    @Override\n+    public boolean isSupported(BlackboardArtifact artifact) {\n+        return (artifact != null)\n+                && (artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()\n+                || artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID()\n+                || artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()\n+                || artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID());\n+    }\n+\n+    @NbBundle.Messages({\"GeneralPurposeArtifactViewer.details.attrHeader=Attributes\",\n+        \"GeneralPurposeArtifactViewer.details.sourceHeader=Source\",\n+        \"GeneralPurposeArtifactViewer.details.dataSource=Data Source\",\n+        \"GeneralPurposeArtifactViewer.details.file=File\"})\n+    /**\n+     * This method is called from within the constructor to initialize the form.\n+     * WARNING: Do NOT modify this code. The content of this method is always\n+     * regenerated by the Form Editor.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n+    private void initComponents() {\n+\n+        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n+        this.setLayout(layout);\n+        layout.setHorizontalGroup(\n+            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n+            .addGap(0, 400, Short.MAX_VALUE)\n+        );\n+        layout.setVerticalGroup(\n+            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n+            .addGap(0, 300, Short.MAX_VALUE)\n+        );\n+    }// </editor-fold>//GEN-END:initComponents\n+\n+    /**\n+     * Update the view to reflect the current artifact's details.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    private void updateView() {\n+        if (artifactTypeId != -1) {\n+            addHeader(Bundle.GeneralPurposeArtifactViewer_details_attrHeader());\n+            Integer[] orderingArray = orderingMap.get(artifactTypeId);\n+            if (orderingArray == null) {\n+                orderingArray = DEFAULT_ORDERING;\n+            }\n+            for (Integer attrId : orderingArray) {\n+                moveAttributesFromMapToPanel(attrId);\n+            }\n+            for (int key : attributeMap.keySet()) {\n+                for (BlackboardAttribute bba : attributeMap.get(key)) {\n+                    addNameValueRow(bba.getAttributeType().getDisplayName(), bba.getDisplayString());\n+                }\n+            }\n+            addHeader(Bundle.GeneralPurposeArtifactViewer_details_sourceHeader());\n+            addNameValueRow(Bundle.GeneralPurposeArtifactViewer_details_dataSource(), dataSourceName);\n+            addNameValueRow(Bundle.GeneralPurposeArtifactViewer_details_file(), sourceFileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e14473fdae4233b5760ce5fb453bbaa2741a1b5"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Mzc4NQ==", "bodyText": "I think that this is a case where putting some code in another method actually makes the code harder to follow. Personally, I had to go back and forth a few times between updateView() and moveAttributesFromMapToPanel() before I realized that the code works because moveAttributesFromMapToPanel() removes items from the map (even with the method name saying \"move\"). I think it would be easier to follow if the code in moveAttributesFromMapToPanel() was inline in updateView(), even if it ratchets up the Codacy complexity metrics.\nThis is not absolutely necessary, but I actually think that things would be simpler still if the class had fewer state variables. I believe that artifactTypeId, attributeMap, dataSourceName and sourceFileName could be made local or eliminated. The four methods setArtifact(), extractArtifactData() and updateView() are called together. The extractArtifactData() method could be made into an extractAttributes() method and made to return a Map. Then the BlackboardArtifact and the Map could then be passed to updateView(). This would eliminate that all of that persistent state, which technically becomes inconsistent when attributeMap is cleared. I tend to be leary of state variables that exist simply to support how the code is factored into multiple methods and generally prefer to pass things around on the stack if possible - it makes it easier to ensure that an object is thread safe. Personally, I would have at most a currentArtifact field. Food for thought...", "url": "https://github.com/sleuthkit/autopsy/pull/6447#discussion_r524473785", "createdAt": "2020-11-16T18:12:17Z", "author": {"login": "rcordovano"}, "path": "Core/src/org/sleuthkit/autopsy/contentviewers/artifactviewers/GeneralPurposeArtifactViewer.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Autopsy\n+ *\n+ * Copyright 2020 Basis Technology Corp.\n+ * Contact: carrier <at> sleuthkit <dot> org\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.sleuthkit.autopsy.contentviewers.artifactviewers;\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTextPane;\n+import javax.swing.SwingUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.lookup.ServiceProvider;\n+import org.sleuthkit.autopsy.coreutils.Logger;\n+import org.sleuthkit.autopsy.coreutils.ThreadConfined;\n+import org.sleuthkit.autopsy.discovery.ui.AbstractArtifactDetailsPanel;\n+import org.sleuthkit.datamodel.BlackboardArtifact;\n+import org.sleuthkit.datamodel.BlackboardAttribute;\n+import org.sleuthkit.datamodel.TskCoreException;\n+\n+/**\n+ * Panel to display the details for an Artifact.\n+ */\n+@ServiceProvider(service = ArtifactContentViewer.class)\n+public class GeneralPurposeArtifactViewer extends AbstractArtifactDetailsPanel implements ArtifactContentViewer {\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final Logger logger = Logger.getLogger(GeneralPurposeArtifactViewer.class.getName());\n+    // Number of columns in the gridbag layout.\n+    private final static int MAX_COLS = 4;\n+    private final static Insets ROW_INSETS = new java.awt.Insets(0, 12, 0, 0);\n+    private final static Insets HEADER_INSETS = new java.awt.Insets(0, 0, 0, 0);\n+    private final static double GLUE_WEIGHT_X = 1.0;\n+    private final static double TEXT_WEIGHT_X = 0.0;\n+    private final static int LABEL_COLUMN = 0;\n+    private final static int VALUE_COLUMN = 1;\n+    private final static int VALUE_WIDTH = 2;\n+    private final static int LABEL_WIDTH = 1;\n+    private static final Integer[] DEFAULT_ORDERING = new Integer[]{BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TITLE.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_CREATED.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID(), BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH_ID.getTypeID(),\n+        BlackboardAttribute.ATTRIBUTE_TYPE.TSK_HEADERS.getTypeID()};\n+    private final GridBagLayout gridBagLayout = new GridBagLayout();\n+    private final GridBagConstraints gridBagConstraints = new GridBagConstraints();\n+    private String dataSourceName;\n+    private String sourceFileName;\n+    private Integer artifactTypeId = -1;\n+    private final Map<Integer, List<BlackboardAttribute>> attributeMap = new HashMap<>();\n+    private final Map<Integer, Integer[]> orderingMap = new HashMap<>();\n+\n+    /**\n+     * Creates new form GeneralPurposeArtifactViewer.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    public GeneralPurposeArtifactViewer() {\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        orderingMap.put(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID(), DEFAULT_ORDERING);\n+        initComponents();\n+    }\n+\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    @Override\n+    public void setArtifact(BlackboardArtifact artifact) {\n+        resetComponent();\n+        if (artifact != null) {\n+            artifactTypeId = artifact.getArtifactTypeID();\n+            try {\n+                extractArtifactData(artifact);\n+            } catch (TskCoreException ex) {\n+                logger.log(Level.WARNING, \"Unable to get attributes for artifact \" + artifact.getArtifactID(), ex);\n+            }\n+            updateView();\n+        }\n+        this.setLayout(this.gridBagLayout);\n+        this.revalidate();\n+        this.repaint();\n+    }\n+\n+    /**\n+     * Extracts data from the artifact to be displayed in the panel.\n+     *\n+     * @param artifact Artifact to show.\n+     *\n+     * @throws TskCoreException\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    private void extractArtifactData(BlackboardArtifact artifact) throws TskCoreException {\n+        // Get all the attributes and group them by the attributeType \n+        for (BlackboardAttribute bba : artifact.getAttributes()) {\n+            List<BlackboardAttribute> attrList = attributeMap.get(bba.getAttributeType().getTypeID());\n+            if (attrList == null) {\n+                attrList = new ArrayList<>();\n+            }\n+            attrList.add(bba);\n+            attributeMap.put(bba.getAttributeType().getTypeID(), attrList);\n+        }\n+        dataSourceName = artifact.getDataSource().getName();\n+        sourceFileName = artifact.getParent().getName();\n+    }\n+\n+    /**\n+     * Reset the panel so that it is empty.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    private void resetComponent() {\n+        // clear the panel \n+        this.removeAll();\n+        gridBagConstraints.anchor = GridBagConstraints.FIRST_LINE_START;\n+        gridBagConstraints.gridy = 0;\n+        gridBagConstraints.gridx = LABEL_COLUMN;\n+        gridBagConstraints.weighty = 0.0;\n+        gridBagConstraints.weightx = TEXT_WEIGHT_X;    // keep components fixed horizontally.\n+        gridBagConstraints.fill = GridBagConstraints.NONE;\n+        gridBagConstraints.insets = ROW_INSETS;\n+        artifactTypeId = -1;\n+        dataSourceName = null;\n+        sourceFileName = null;\n+        attributeMap.clear();\n+    }\n+\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    @Override\n+    public Component getComponent() {\n+        // Slap a vertical scrollbar on the panel.\n+        return new JScrollPane(this, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    @Override\n+    public boolean isSupported(BlackboardArtifact artifact) {\n+        return (artifact != null)\n+                && (artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_HISTORY.getTypeID()\n+                || artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_SEARCH_QUERY.getTypeID()\n+                || artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_COOKIE.getTypeID()\n+                || artifact.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_BOOKMARK.getTypeID());\n+    }\n+\n+    @NbBundle.Messages({\"GeneralPurposeArtifactViewer.details.attrHeader=Attributes\",\n+        \"GeneralPurposeArtifactViewer.details.sourceHeader=Source\",\n+        \"GeneralPurposeArtifactViewer.details.dataSource=Data Source\",\n+        \"GeneralPurposeArtifactViewer.details.file=File\"})\n+    /**\n+     * This method is called from within the constructor to initialize the form.\n+     * WARNING: Do NOT modify this code. The content of this method is always\n+     * regenerated by the Form Editor.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n+    private void initComponents() {\n+\n+        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n+        this.setLayout(layout);\n+        layout.setHorizontalGroup(\n+            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n+            .addGap(0, 400, Short.MAX_VALUE)\n+        );\n+        layout.setVerticalGroup(\n+            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n+            .addGap(0, 300, Short.MAX_VALUE)\n+        );\n+    }// </editor-fold>//GEN-END:initComponents\n+\n+    /**\n+     * Update the view to reflect the current artifact's details.\n+     */\n+    @ThreadConfined(type = ThreadConfined.ThreadType.AWT)\n+    private void updateView() {\n+        if (artifactTypeId != -1) {\n+            addHeader(Bundle.GeneralPurposeArtifactViewer_details_attrHeader());\n+            Integer[] orderingArray = orderingMap.get(artifactTypeId);\n+            if (orderingArray == null) {\n+                orderingArray = DEFAULT_ORDERING;\n+            }\n+            for (Integer attrId : orderingArray) {\n+                moveAttributesFromMapToPanel(attrId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e14473fdae4233b5760ce5fb453bbaa2741a1b5"}, "originalPosition": 213}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fac12a2013181c5e9893e58a98c9d737010cd598", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/fac12a2013181c5e9893e58a98c9d737010cd598", "committedDate": "2020-11-16T20:51:58Z", "message": "Merge branch 'develop' of https://github.com/sleuthkit/autopsy into 6781-GeneralPurposeArtifactViewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23326cdf6fcd4cba8691cb8fc1bb0a9a5d108a16", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/23326cdf6fcd4cba8691cb8fc1bb0a9a5d108a16", "committedDate": "2020-11-17T15:45:18Z", "message": "6781 address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4950e0e1652079dfa89b20d4acfc347edf1d423a", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/4950e0e1652079dfa89b20d4acfc347edf1d423a", "committedDate": "2020-11-17T17:15:08Z", "message": "6781 fix saving of details size"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59df1bb378d7779653a69229ece60eabb85213a0", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/59df1bb378d7779653a69229ece60eabb85213a0", "committedDate": "2020-11-18T23:57:34Z", "message": "6781 fix use of invoke later"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2257246eb0d665858ffc714c4aee5b9f829da763", "author": {"user": null}, "url": "https://github.com/sleuthkit/autopsy/commit/2257246eb0d665858ffc714c4aee5b9f829da763", "committedDate": "2020-11-20T16:31:13Z", "message": "6781 fix maximize issue"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2825, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}