{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxOTgzMzc5", "number": 6973, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo0NDozOFrOEEJeTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjo1ODoyNVrOEEKgig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg0OTc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo0NDozOFrOGhlo0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoxNjo1NFrOGhyCtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3Mjg1MQ==", "bodyText": "This is missing support for RFC 7239 based headers.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437872851", "createdAt": "2020-06-10T05:44:38Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3NjA4Nw==", "bodyText": "Yes. No reason those shouldn't be included except that they have more structure and it would take more time to understand them/test, etc.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438076087", "createdAt": "2020-06-10T12:16:54Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3Mjg1MQ=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg2NDQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo1MjoyNVrOGhlx3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoxNzo0NFrOGhyEfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NTE2NA==", "bodyText": "I see this is attempting to support the comma separated list used in the X-Forwarded-For header.\nWhat I don't understand: the indexOf will return an index to first appearance of , in the list. Then this is used to get the part beyond that as the IP.\nLet's have an example:\n10.0.0.1, 123.13.123.1, 134.94.231.0\n\nThe code will result in a substring \" 123.13.123.1, 134.94.231.0\", which is no valid IP.\nIt just extracted the IP of the proxies between the service and the client. Please review the format: X-Forwarded-For: client, proxy1, proxy2\nThis doesn't handle whitespace, too.\n\nI don't think this has been intended here, does it?\nMaybe using commons.lang3.StringUtils.substringBefore() is the easiest way forward, null safe etc.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437875164", "createdAt": "2020-06-10T05:52:25Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3NjU0Mg==", "bodyText": "Straight up bug -  lastIndexOf() was what I intended.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438076542", "createdAt": "2020-06-10T12:17:44Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NTE2NA=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg3Mzg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo1NzowMlrOGhl3lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoyMTowN1rOGhyLrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjYyOA==", "bodyText": "This is very verbose. Wouldn't it make sense to refactor the code of IpAddress.valueOf() to be null safe and use a default value as second parameter? That would render this into a oneliner, much easier to read and understand.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437876628", "createdAt": "2020-06-10T05:57:02Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                    }\n+                }\n+                /*\n+                 * If there was no header/no usable value from the header, use the\n+                 * remoteAddress.\n+                 * \n+                 */\n+                if (address == null) {\n+                    // use the request remote address\n+                    String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n+                    if (remoteAddressFromRequest != null) {\n+                        remoteAddressStr = remoteAddressFromRequest;\n+                        try {\n+                            address = IpAddress.valueOf(remoteAddressStr);\n+                        } catch (IllegalArgumentException iae) {\n+                            address = IpAddress.valueOf(saneDefault);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3ODM4MQ==", "bodyText": "That seems reasonable.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438078381", "createdAt": "2020-06-10T12:21:07Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                    }\n+                }\n+                /*\n+                 * If there was no header/no usable value from the header, use the\n+                 * remoteAddress.\n+                 * \n+                 */\n+                if (address == null) {\n+                    // use the request remote address\n+                    String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n+                    if (remoteAddressFromRequest != null) {\n+                        remoteAddressStr = remoteAddressFromRequest;\n+                        try {\n+                            address = IpAddress.valueOf(remoteAddressStr);\n+                        } catch (IllegalArgumentException iae) {\n+                            address = IpAddress.valueOf(saneDefault);\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjYyOA=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg4MDAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowMDoyMFrOGhl7nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowMDoyMFrOGhl7nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NzY2MQ==", "bodyText": "I think this variable is not used anymore?", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437877661", "createdAt": "2020-06-10T06:00:20Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg4MjcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowMTozMVrOGhl9Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowMTozMVrOGhl9Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3ODA3MA==", "bodyText": "Wouldn't it make sense to refactor this to use a class variable saneDefault directly then?", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437878070", "createdAt": "2020-06-10T06:01:31Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg4NjgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowMzoyOFrOGhl_lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowMzoyOFrOGhl_lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3ODY3OA==", "bodyText": "I truely believe the retrieval of these values should live in SystemConfig to make us future ready for things like MicroProfile Config API. Changing lookups in one place is easier IMHO. And we might think about moving to a DB setting later on.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437878678", "createdAt": "2020-06-10T06:03:28Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzg5MzQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowNjozNVrOGhmDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjowNjozNVrOGhmDlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3OTcwMw==", "bodyText": "I have very strong opinions about doing configuration validation each time a request is hitting Dataverse. (Don't.)", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437879703", "createdAt": "2020-06-10T06:06:35Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzkwMjk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjoxMToxNlrOGhmJuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoyNDozMlrOGhyTDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTI3Mw==", "bodyText": "There is no handling of when the request IS null, which would be a major failure. Instead, the object is created anyway. Either remove the if or throw an exception in case it's null. (Why would that ever happen?) You might think of using @NotNull annotation for the parameter to document that you assume this will be never null.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437881273", "createdAt": "2020-06-10T06:11:16Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4MDI3MQ==", "bodyText": "I believe there are places in the code where null is sent. I'd have to look again to find specific examples but I think they are places where there's internal/async processing and possibly for tests. Refactoring could probably be done to avoid that.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438080271", "createdAt": "2020-06-10T12:24:32Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTI3Mw=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzkxMTE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjoxNTowN1rOGhmOrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMjoyOToyM1rOGhyegQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MjU0MQ==", "bodyText": "Is there a source this behavior is actually more than grey theory? I could imagine that you might have a situation where there are multiple different headers caused by different proxy implementations beyond each other (which is unsupported here). At least the most common de-facto standard X-Forwarded-For is handling multiple proxies differently, see below.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437882541", "createdAt": "2020-06-10T06:15:07Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4MzIwMQ==", "bodyText": "We spent time yesterday looking online for specs/practices and saw that multiple headers are allowed. It wasn't clear if they are in practice. Non-buggy software is supposed to have later proxies put their X-Forwarded-For headers after the initial ones so there is a global order even if there are multiple headers and some headers with multiple values. We debated whether we should try to support this or just flag it and fail, but the challenge is that, if you just use getHeader() you get the first header, which is not the one you'd want, so it looked like you still need to getHeaders() at some point.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438083201", "createdAt": "2020-06-10T12:29:23Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MjU0MQ=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzk2MjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjozNzoxNVrOGhmurQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjozNzoxNVrOGhmurQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDczMw==", "bodyText": "I appreciate the use of .isLocalhost() instead of checking for a String. \ud83d\udc4d", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437890733", "createdAt": "2020-06-10T06:37:15Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzk2NTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjozODoyMVrOGhmwVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjozODoyMVrOGhmwVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MTE1Nw==", "bodyText": "This is very verbose. Please see my comment below about refactoring IpAddress.valueOf() becoming null safe (here: just return null if given).", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437891157", "createdAt": "2020-06-10T06:38:21Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODAxOTMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjo1ODoyNVrOGhnRtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo0Njo1M1rOGh7O0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5OTcwMQ==", "bodyText": "Seriously? This is a malicious hacking attempt and all we do is log it? IMHO this request should be aborted with a 401.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437899701", "createdAt": "2020-06-10T06:58:25Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4NzgxNQ==", "bodyText": "The attempt fails. That said, we couldn't think of a legitimate case for localhost to be sent. IP addresses that can't be parsed (the check before this) is another one where there's probably no reason to tolerate it as the code does now. Using a filter would definitely make it easier/more efficient to just refuse the request.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438087815", "createdAt": "2020-06-10T12:37:51Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5OTcwMQ=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIxNzAxOA==", "bodyText": "To be fair, we don't know for the fact that this is a malicious hacking attempt. Could be a misconfigured proxy, or an honest API scripting mistake, or something of that nature. I will mention this particular warning in the guide, as something to look for.\nI will also recommend that anyone behind a proxy adds %header.x-forwarded-for% (or whatever header it is in their case) to the access log format line in their Payara configuration (something we've been doing on our servers). Then the admin should monitor the log; and specifically look for entries with the localhost address in them - something like 127.0.0.1, 111.222.333.444 - could potentially indicate someone trying to send it along maliciously. An entry like 111.222.333.444, 127.0.0.1 on the other hand would  indicate that the proxy is doing something seriously wrong, possibly messing up the order of the proxies in the comma-separated list. In which case the practice of trusting the header as the source of the true ip address should be discontinued.\nI will also remind everybody in that guide section, that allowing localhost connections to bypass authentication for admin calls is also optional and configurable. And that any Dataverse running behind a proxy that is interested in enabling this mechanism of extracting true IP addresses from headers may consider disabling it after weighing all the risks involved.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438217018", "createdAt": "2020-06-10T15:33:19Z", "author": {"login": "landreev"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5OTcwMQ=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNjY0Mg==", "bodyText": "(I guess the thing to emphasize here is that it's less likely to be a \"malicious attempt\", and much more likely a \"something is very wrong in your configuration\" situation. Normally, this just should not happen. Even if someone is trying to maliciously pretend to be coming from localhost, that address should never end up in the portion of the header where Dataverse would be inclined to use it. Seeing this in the log would indicate that either the header lookup option was activated on a Dataverse that is NOT behind a proxy; or the proxy is handling the headers incorrectly, etc.)", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r438226642", "createdAt": "2020-06-10T15:46:53Z", "author": {"login": "landreev"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5OTcwMQ=="}, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3224, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}