{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxOTgzMzc5", "number": 6973, "title": "Optional use of header to get user IP address", "bodyText": "What this PR does / why we need it: Allows optional specification of an HTTP header as the source of user ip addresses. This is needed to get valid ip addresses for MDC and IP based access control when running Dataverse behind a proxy/load balancer\nWhich issue(s) this PR closes:\nCloses #6970\nSpecial notes for your reviewer:  There are security implications if the ip can be spoofed. The header is explicitly not used/ignored if it reports a localhost (127.0.0.1) address\nSuggestions on how to test this: This should work with/without a header set on a 'normal' test instance (since the header should be null, and should change the reported IP (e.g. as reported in the mdc logs) on a server behind an AWS load balancer when you use 'X-Forwarded-For' from the IP of the load balancer to the correct user IP address.\nDoes this PR introduce a user interface change? If mockups are available, please link/include them here: No\nIs there a release notes update needed for this change?: Yes? Since it affects MDC reporting.\nAdditional documentation:", "createdAt": "2020-06-09T18:19:37Z", "url": "https://github.com/IQSS/dataverse/pull/6973", "merged": true, "mergeCommit": {"oid": "7ff01240271d3651e874d443e49bd76cd2f59b4a"}, "closed": true, "closedAt": "2020-06-17T20:37:53Z", "author": {"login": "qqmyers"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcppFmUAH2gAyNDMxOTgzMzc5OmFhYzA3ZTg1Yzg0NTYxMGY3NzAyZDVlNjAwODkxZTE2ZmU5ZTJkYmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsP7EtgH2gAyNDMxOTgzMzc5OmY1MjBkMzg1MDM0YzE5Y2M2OTI3YTM4OGQ0MzJmZGE0YzU5ZTE1ODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aac07e85c845610f7702d5e600891e16fe9e2dbe", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/aac07e85c845610f7702d5e600891e16fe9e2dbe", "committedDate": "2020-06-09T18:09:12Z", "message": "Optional use of header to get user IP address"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NDc0MjM3", "url": "https://github.com/IQSS/dataverse/pull/6973#pullrequestreview-427474237", "createdAt": "2020-06-09T19:27:46Z", "commit": {"oid": "aac07e85c845610f7702d5e600891e16fe9e2dbe"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b", "committedDate": "2020-06-09T20:53:45Z", "message": "Handling the possible multiple headers and compound values"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NzI2NDAx", "url": "https://github.com/IQSS/dataverse/pull/6973#pullrequestreview-427726401", "createdAt": "2020-06-10T05:44:38Z", "commit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo0NDozOFrOGhlo0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjo1ODoyNVrOGhnRtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3Mjg1MQ==", "bodyText": "This is missing support for RFC 7239 based headers.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437872851", "createdAt": "2020-06-10T05:44:38Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NTE2NA==", "bodyText": "I see this is attempting to support the comma separated list used in the X-Forwarded-For header.\nWhat I don't understand: the indexOf will return an index to first appearance of , in the list. Then this is used to get the part beyond that as the IP.\nLet's have an example:\n10.0.0.1, 123.13.123.1, 134.94.231.0\n\nThe code will result in a substring \" 123.13.123.1, 134.94.231.0\", which is no valid IP.\nIt just extracted the IP of the proxies between the service and the client. Please review the format: X-Forwarded-For: client, proxy1, proxy2\nThis doesn't handle whitespace, too.\n\nI don't think this has been intended here, does it?\nMaybe using commons.lang3.StringUtils.substringBefore() is the easiest way forward, null safe etc.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437875164", "createdAt": "2020-06-10T05:52:25Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjYyOA==", "bodyText": "This is very verbose. Wouldn't it make sense to refactor the code of IpAddress.valueOf() to be null safe and use a default value as second parameter? That would render this into a oneliner, much easier to read and understand.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437876628", "createdAt": "2020-06-10T05:57:02Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                    }\n+                }\n+                /*\n+                 * If there was no header/no usable value from the header, use the\n+                 * remoteAddress.\n+                 * \n+                 */\n+                if (address == null) {\n+                    // use the request remote address\n+                    String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n+                    if (remoteAddressFromRequest != null) {\n+                        remoteAddressStr = remoteAddressFromRequest;\n+                        try {\n+                            address = IpAddress.valueOf(remoteAddressStr);\n+                        } catch (IllegalArgumentException iae) {\n+                            address = IpAddress.valueOf(saneDefault);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NzY2MQ==", "bodyText": "I think this variable is not used anymore?", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437877661", "createdAt": "2020-06-10T06:00:20Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3ODA3MA==", "bodyText": "Wouldn't it make sense to refactor this to use a class variable saneDefault directly then?", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437878070", "createdAt": "2020-06-10T06:01:31Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3ODY3OA==", "bodyText": "I truely believe the retrieval of these values should live in SystemConfig to make us future ready for things like MicroProfile Config API. Changing lookups in one place is easier IMHO. And we might think about moving to a DB setting later on.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437878678", "createdAt": "2020-06-10T06:03:28Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3OTcwMw==", "bodyText": "I have very strong opinions about doing configuration validation each time a request is hitting Dataverse. (Don't.)", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437879703", "createdAt": "2020-06-10T06:06:35Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MTI3Mw==", "bodyText": "There is no handling of when the request IS null, which would be a major failure. Instead, the object is created anyway. Either remove the if or throw an exception in case it's null. (Why would that ever happen?) You might think of using @NotNull annotation for the parameter to document that you assume this will be never null.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437881273", "createdAt": "2020-06-10T06:11:16Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4MjU0MQ==", "bodyText": "Is there a source this behavior is actually more than grey theory? I could imagine that you might have a situation where there are multiple different headers caused by different proxy implementations beyond each other (which is unsupported here). At least the most common de-facto standard X-Forwarded-For is handling multiple proxies differently, see below.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437882541", "createdAt": "2020-06-10T06:15:07Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDczMw==", "bodyText": "I appreciate the use of .isLocalhost() instead of checking for a String. \ud83d\udc4d", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437890733", "createdAt": "2020-06-10T06:37:15Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MTE1Nw==", "bodyText": "This is very verbose. Please see my comment below about refactoring IpAddress.valueOf() becoming null safe (here: just return null if given).", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437891157", "createdAt": "2020-06-10T06:38:21Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5OTcwMQ==", "bodyText": "Seriously? This is a malicious hacking attempt and all we do is log it? IMHO this request should be aborted with a 401.", "url": "https://github.com/IQSS/dataverse/pull/6973#discussion_r437899701", "createdAt": "2020-06-10T06:58:25Z", "author": {"login": "poikilotherm"}, "path": "src/main/java/edu/harvard/iq/dataverse/engine/command/DataverseRequest.java", "diffHunk": "@@ -13,24 +19,118 @@\n  * @author michael\n  */\n public class DataverseRequest {\n-    \n+\n     private final User user;\n     private final IpAddress sourceAddress;\n     \n+    private final static String undefined = \"0.0.0.0\";\n+    private final static String localhost = \"127.0.0.1\";\n+    \n+    private static final Logger logger = Logger.getLogger(DataverseRequest.class.getName());\n+    \n+    private static String headerToUse = System.getProperty(\"dataverse.useripaddresssourceheader\");\n+    \n+    private static final HashSet<String> ALLOWED_HEADERS = new HashSet<String>(Arrays.asList( \n+            \"x-forwarded-for\",\n+            \"proxy-client-ip\",\n+            \"wl-proxy-client-ip\",\n+            \"http_x_forwarded_for\",\n+            \"http_x_forwarded\",\n+            \"http_x_cluster_client_ip\",\n+            \"http_client_ip\",\n+            \"http_forwarded_for\",\n+            \"http_forwarded\",\n+            \"http_via\",\n+            \"remote_addr\" ));\n+     \n+    \n     public DataverseRequest(User aUser, HttpServletRequest aHttpServletRequest) {\n         this.user = aUser;\n \n-        final String undefined = \"0.0.0.0\";\n         String saneDefault = undefined;\n         String remoteAddressStr = saneDefault;\n \n+        IpAddress address = null;\n+\n         if (aHttpServletRequest != null) {\n-            String remoteAddressFromRequest = aHttpServletRequest.getRemoteAddr();\n-            if (remoteAddressFromRequest != null) {\n-                remoteAddressStr = remoteAddressFromRequest;\n+\n+            // Security check - make sure any supplied header is one that is used to forward\n+            // IP addresses (case insensitive)\n+            if (headerToUse != null && ALLOWED_HEADERS.contains(headerToUse.toLowerCase())) {\n+                /*\n+                 * The optional case of using a header to determine the IP address is discussed\n+                 * at length in https://github.com/IQSS/dataverse/pull/6973 and the related\n+                 * issue.\n+                 * \n+                 * The code here is intended to support the use case of a single proxy (load\n+                 * balancer, etc.) as well as providing partial support for the case where two\n+                 * proxies exist (e.g. a campus proxy and an AWS load balancer). In this case,\n+                 * the IP address returned should be that of the proxy nearer the user which\n+                 * would be the correct address to use for making IPGroup access control\n+                 * determinations. This does limit the accuracy of any Make Data Count\n+                 * geolocation determined since it is the proxy's IP that would be geolocated.\n+                 * For a campus proxy, this may be acceptable. This code should be safe in that\n+                 * it won't pick up a spoofed address in any case, but beyond the two proxy\n+                 * case, it is unlikely to provide useful results (why would you want the IP of\n+                 * an intermediate proxy?).\n+                 */\n+                // One can have multiple instances of a given header. They SHOULD be in order.\n+                Enumeration<String> ipEnumeration = aHttpServletRequest.getHeaders(headerToUse);\n+                if (ipEnumeration.hasMoreElements()) {\n+                    // Always get the last header, which SHOULD be from the proxy closest to\n+                    // Dataverse\n+                    String ip = ipEnumeration.nextElement();\n+                    while (ipEnumeration.hasMoreElements()) {\n+                        ip = ipEnumeration.nextElement();\n+                    }\n+                    // Always get the last value if more than one in the string, which should be the\n+                    // IP address closest to the reporting proxy\n+                    int index = ip.indexOf(',');\n+                    if (index >= 0) {\n+                        ip = ip.substring(index + 1);\n+                    }\n+                    /*\n+                     * We should have a valid, single IP address string here. The IpAddress.valueOf\n+                     * call will throw an exception if it can't be parsed into a valid address (e.g.\n+                     * 4 '.' separated short ints for v4), so we just check for null here\n+                     */\n+                    if (ip != null) {\n+                        // This conversion will throw an IllegalArgumentException if it can't be parsed.\n+                        try {\n+                            address = IpAddress.valueOf(ip);\n+                        } catch (IllegalArgumentException iae) {\n+                            logger.warning(\"Ignoring invalid IP address received in header \" + headerToUse + \" : \" + ip);\n+                            address = null;\n+                        }\n+                        if (address!= null && address.isLocalhost()) {\n+                            // Not allowed since it is hard to image why a localhost request would be\n+                            // proxied and we want to protect\n+                            // the internal admin apis that can be restricted to localhost access\n+                            logger.warning(\"Ignoring localhost received as IP address in header \" + headerToUse + \" : \" + ip);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0d4c0cbae5a5c5c4bd23c20ac9f223a6d26833b"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06178a5eeff47f9cabfdc156303542772709d578", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/06178a5eeff47f9cabfdc156303542772709d578", "committedDate": "2020-06-12T17:21:49Z", "message": "bug fix and updates per review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "220b6af9a0c6dfc0f33620286a30a738374d3f01", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/220b6af9a0c6dfc0f33620286a30a738374d3f01", "committedDate": "2020-06-12T17:46:59Z", "message": "null check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1f7f7d14745f0619c94e52ba25483fa2160765b", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/d1f7f7d14745f0619c94e52ba25483fa2160765b", "committedDate": "2020-06-12T18:11:24Z", "message": "typo - nesting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7735fdd4c4f7fd7e62186530af3113fadfef55c0", "author": {"user": {"login": "landreev", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/7735fdd4c4f7fd7e62186530af3113fadfef55c0", "committedDate": "2020-06-14T01:15:20Z", "message": "proxy header address lookup\n\nAdded  a section discussing the security implications of using a proxy supplied header for tracking the addresses of incoming requests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ef125a897dfaf6bd9cbc2328932f27fed3b824e", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/4ef125a897dfaf6bd9cbc2328932f27fed3b824e", "committedDate": "2020-06-14T13:32:15Z", "message": "Merge pull request #41 from landreev/patch-1\n\nproxy header address lookup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjMxMjQw", "url": "https://github.com/IQSS/dataverse/pull/6973#pullrequestreview-430231240", "createdAt": "2020-06-14T15:59:07Z", "commit": {"oid": "4ef125a897dfaf6bd9cbc2328932f27fed3b824e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039191309e080ad63b5965111f30b843fff56071", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/039191309e080ad63b5965111f30b843fff56071", "committedDate": "2020-06-16T22:25:32Z", "message": "fix jvm section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd7598305452fcd210c555f76174c53c6f167665", "author": {"user": {"login": "landreev", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/bd7598305452fcd210c555f76174c53c6f167665", "committedDate": "2020-06-16T22:48:40Z", "message": "formatting fixes for config.rst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "539864bcb76c1e1a993302ad9c3629be3088cf55", "author": {"user": {"login": "landreev", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/539864bcb76c1e1a993302ad9c3629be3088cf55", "committedDate": "2020-06-16T23:14:22Z", "message": "another tiny cosmetic fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d9ce28a57a223398c786af3cad314860bdf4476", "author": {"user": {"login": "landreev", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/9d9ce28a57a223398c786af3cad314860bdf4476", "committedDate": "2020-06-16T23:32:56Z", "message": "another fix... \n\n(this one should finally make the github online previewer work on this file!)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0599c04009193f4e992160908f2c02e5d4b5b30", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/b0599c04009193f4e992160908f2c02e5d4b5b30", "committedDate": "2020-06-17T01:29:14Z", "message": "Merge pull request #42 from landreev/patch-2\n\nformatting fixes for config.rst"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b900fa9c0ecb1723e250030ae898e48871899b0e", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/b900fa9c0ecb1723e250030ae898e48871899b0e", "committedDate": "2020-06-17T12:39:47Z", "message": "add example"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d39199aab91512130acc475ea14a2cfbc415036", "author": {"user": {"login": "landreev", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/1d39199aab91512130acc475ea14a2cfbc415036", "committedDate": "2020-06-17T20:24:07Z", "message": "release note \n\n#6970"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f520d385034c19cc6927a388d432fda4c59e1582", "author": {"user": {"login": "qqmyers", "name": null}}, "url": "https://github.com/IQSS/dataverse/commit/f520d385034c19cc6927a388d432fda4c59e1582", "committedDate": "2020-06-17T20:31:51Z", "message": "Merge pull request #43 from landreev/patch-3\n\n6970-release-note"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 845, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}