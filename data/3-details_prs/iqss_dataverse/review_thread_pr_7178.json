{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1ODMzNjgw", "number": 7178, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoyNzozM1rOEw7oHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDozNDo0MlrOEw7xtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzQ0MDMxOnYy", "diffSide": "RIGHT", "path": "src/main/resources/db/migration/V5.0.0.1__7177-newmetrics.sql", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoyNzozM1rOHmylLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo1Njo0MFrOHmzhHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNjY1NQ==", "bodyText": "I assume this isn't supposed to say \"foo.bar\" but I doubt it's a big deal.", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510436655", "createdAt": "2020-10-22T20:27:33Z", "author": {"login": "pdurbin"}, "path": "src/main/resources/db/migration/V5.0.0.1__7177-newmetrics.sql", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+alter table metric add column if not exists dataverse_id bigint;\n+\n+DO $$\n+BEGIN\n+\n+  BEGIN\n+    alter table metric add constraint fk_metric_dataverse_id FOREIGN KEY (dataverse_id) REFERENCES dataverse(id);\n+  EXCEPTION\n+    WHEN duplicate_object THEN RAISE NOTICE 'Table constraint foo.bar already exists';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MTk5Nw==", "bodyText": ":-) - caught at cut/paste !", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510451997", "createdAt": "2020-10-22T20:56:40Z", "author": {"login": "qqmyers"}, "path": "src/main/resources/db/migration/V5.0.0.1__7177-newmetrics.sql", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+alter table metric add column if not exists dataverse_id bigint;\n+\n+DO $$\n+BEGIN\n+\n+  BEGIN\n+    alter table metric add constraint fk_metric_dataverse_id FOREIGN KEY (dataverse_id) REFERENCES dataverse(id);\n+  EXCEPTION\n+    WHEN duplicate_object THEN RAISE NOTICE 'Table constraint foo.bar already exists';", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNjY1NQ=="}, "originalCommit": {"oid": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzQ0NTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoyOTowMFrOHmyoHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoyOTowMFrOHmyoHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNzQwNQ==", "bodyText": "This method doesn't handle arbitrary JSON. Maybe rename to flatJsonToCsv? And add some docs on when to use it?", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510437405", "createdAt": "2020-10-22T20:29:00Z", "author": {"login": "pdurbin"}, "path": "src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java", "diffHunk": "@@ -1901,4 +1903,16 @@ public static boolean isFileAlreadyUploaded(DataFile dataFile, Map checksumMapNe\n         return false;\n     }\n \n+    public static String jsonToCSV(JsonArray jsonArray, String... headers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzQ2NDg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/edu/harvard/iq/dataverse/api/Metrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDozNDo0MlrOHmyz3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo1NjowNFrOHmzf2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MDQxMw==", "bodyText": "I'm used to the \"orDie\" methods working including the original findDataverseOrDie to work in certain way, to work on unpublished things, to throw a WrappedResponse when it can't be found. Since this method only returns published dataverses maybe it could be renamed? This is just a passing thought. I can also live with it with the current name.", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510440413", "createdAt": "2020-10-22T20:34:42Z", "author": {"login": "pdurbin"}, "path": "src/main/java/edu/harvard/iq/dataverse/api/Metrics.java", "diffHunk": "@@ -26,404 +41,836 @@\n  */\n @Path(\"info/metrics\")\n public class Metrics extends AbstractApiBean {\n+    private static final Logger logger = Logger.getLogger(Metrics.class.getName());\n \n     /** Dataverses */\n-    \n+\n     @GET\n     @Path(\"dataverses\")\n-    public Response getDataversesAllTime(@Context UriInfo uriInfo) {\n-        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getDataversesAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"dataverses/toMonth\")\n-    public Response getDataversesToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"dataverses/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"dataverses\";\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.getDataversesTimeSeries(uriInfo, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.timeseries.csv\");\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/toMonth/{yyyymm}\")\n-    public Response getDataversesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDataversesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"dataversesToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.dataversesToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n-            }\n+        String metricName = \"dataversesToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n \n-        //TODO: Eventually the catch in each endpoint should be more specific\n-        //          and more general errors should be logged.\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.dataversesToMonth(sanitizedyyyymm, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/pastDays/{days}\")\n-    public Response getDataversesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDataversesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"dataversesPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n-        try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.dataversesPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.dataversesPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        return ok(jsonObj);\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n-        }\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/byCategory\")\n-    public Response getDataversesByCategory(@Context UriInfo uriInfo) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesByCategory(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"dataversesByCategory\";\n \n-        try {\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheAllTime(metricName, null);\n+        String metricName = \"dataversesByCategory\";\n \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.dataversesByCategoryToJson(metricsSvc.dataversesByCategory());\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, null, null, jsonArrayString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.dataversesByCategoryToJson(metricsSvc.dataversesByCategory(d)).build();\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.CATEGORY, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.byCategory.csv\");\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/bySubject\")\n-    public Response getDataversesBySubject(@Context UriInfo uriInfo) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesBySubject(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"dataversesBySubject\";\n-        \n-        try {\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheAllTime(metricName, null);\n \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.dataversesBySubjectToJson(metricsSvc.dataversesBySubject());\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, null, null, jsonArrayString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.dataversesBySubjectToJson(metricsSvc.dataversesBySubject(d)).build();\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n         }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.SUBJECT, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.bySubject.csv\");\n     }\n-    \n+\n     /** Datasets */\n-    \n+\n     @GET\n     @Path(\"datasets\")\n-    public Response getDatasetsAllTime(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    public Response getDatasetsAllTime(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation, parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"datasets/toMonth\")\n-    public Response getDatasetsToMonthCurrent(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    @Path(\"datasets/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsTimeSeriest(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"datasets\";\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.getDatasetsTimeSeries(uriInfo, dataLocation, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datasets.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"datasets/toMonth/{yyyymm}\")\n-    public Response getDatasetsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    public Response getDatasetsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"datasetsToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.datasetsToMonth(sanitizedyyyymm, validDataLocation);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, jsonString));\n-            }\n+        String metricName = \"datasetsToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.datasetsToMonth(sanitizedyyyymm, validDataLocation, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"datasets/pastDays/{days}\")\n-    public Response getDatasetsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    public Response getDatasetsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"datasetsPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n-        try {\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), validDataLocation);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.datasetsPastDays(days, validDataLocation);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), validDataLocation, jsonString));\n-            }\n-\n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), validDataLocation, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.datasetsPastDays(days, validDataLocation, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), validDataLocation, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"datasets/bySubject\")\n-    public Response getDatasetsBySubject(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsBySubjectToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsBySubject(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDatasetsBySubjectToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), dataLocation, parentAlias);\n     }\n-  \n+\n     @GET\n     @Path(\"datasets/bySubject/toMonth/{yyyymm}\")\n-    public Response getDatasetsBySubjectToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsBySubjectToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"datasetsBySubjectToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation);\n-            \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.datasetsBySubjectToJson(metricsSvc.datasetsBySubjectToMonth(sanitizedyyyymm, validDataLocation));\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, jsonArrayString));\n-            }\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation, d));\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.datasetsBySubjectToJson(metricsSvc.datasetsBySubjectToMonth(sanitizedyyyymm, validDataLocation, d)).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.SUBJECT, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datasets.bySubject.csv\");\n     }\n-    \n+\n     /** Files */\n     @GET\n     @Path(\"files\")\n-    public Response getFilesAllTime(@Context UriInfo uriInfo) {\n-        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getFilesAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"files/toMonth\")\n-    public Response getFilesToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"files/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"files\";\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.filesTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"files/toMonth/{yyyymm}\")\n-    public Response getFilesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getFilesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"filesToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.filesToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n-            }\n+        String metricName = \"filesToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        logger.fine(\"yyyymm: \" + sanitizedyyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+        logger.fine(\"Returned\");\n+        if (null == jsonObj) { // run query and save\n+            logger.fine(\"Getting filesToMonth : \" + sanitizedyyyymm + \" dvId=\" + ((d==null) ? \"not sent\" : d.getId()));\n+            Long count = metricsSvc.filesToMonth(sanitizedyyyymm, d);\n+            logger.fine(\"count = \" + count);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n     }\n-    \n+\n     @GET\n     @Path(\"files/pastDays/{days}\")\n-    public Response getFilesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getFilesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"filesPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.filesPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+\n+    }\n+\n+    @GET\n+    @Path(\"/files/byType/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesByTypeTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n         try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"filesByType\";\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.filesPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.filesByTypeTimeSeries(d, true);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.CONTENTTYPE, MetricsUtil.COUNT, MetricsUtil.SIZE), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.byType.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"/files/byType\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesByType(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"filesByType\";\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = metricsSvc.filesByType(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.CONTENTTYPE, MetricsUtil.COUNT, MetricsUtil.SIZE), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.byType.csv\");\n     }\n \n     /** Downloads */\n-    \n+\n     @GET\n     @Path(\"downloads\")\n-    public Response getDownloadsAllTime(@Context UriInfo uriInfo) {\n-        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getDownloadsAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"downloads/toMonth\")\n-    public Response getDownloadsToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"downloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"downloads\";\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.downloadsTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"downloads.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"downloads/toMonth/{yyyymm}\")\n-    public Response getDownloadsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {                \n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDownloadsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-        \n+\n         String metricName = \"downloadsToMonth\";\n-        \n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count;\n+            try {\n+                count = metricsSvc.downloadsToMonth(sanitizedyyyymm, d);\n+            } catch (ParseException e) {\n+                return error(BAD_REQUEST, \"Unable to parse supplied date: \" + e.getLocalizedMessage());\n+            }\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+\n+    @GET\n+    @Path(\"downloads/pastDays/{days}\")\n+    public Response getDownloadsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"downloadsPastDays\";\n+\n+        if (days < 1) {\n+            return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n+        }\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.downloadsPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}\")\n+    public Response getMakeDataCountMetricCurrentMonth(@Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getMakeDataCountMetricToMonth(uriInfo, metricSupplied, MetricsUtil.getCurrentMonth(), country, parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getMakeDataCountMetricTimeSeries(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        MakeDataCountUtil.MetricType metricType = null;\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\", \"country\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        try {\n+            metricType = MakeDataCountUtil.MetricType.fromString(metricSupplied);\n+        } catch (IllegalArgumentException ex) {\n+            return error(Response.Status.BAD_REQUEST, ex.getMessage());\n+        }\n+        String metricName = \"MDC-\" + metricType.toString() + ((country == null) ? \"\" : \"-\" + country);\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.mdcMetricTimeSeries(metricType, country, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"makeDataCount.\" + metricType.toString() + \".timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}/toMonth/{yyyymm}\")\n+    public Response getMakeDataCountMetricToMonth(@Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        MakeDataCountUtil.MetricType metricType = null;\n         try {\n-            \n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.downloadsToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\", \"country\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        try {\n+            metricType = MakeDataCountUtil.MetricType.fromString(metricSupplied);\n+        } catch (IllegalArgumentException ex) {\n+            return error(Response.Status.BAD_REQUEST, ex.getMessage());\n+        }\n+        if (country != null) {\n+            country = country.toLowerCase();\n+\n+            if (!MakeDataCountUtil.isValidCountryCode(country)) {\n+                return error(Response.Status.BAD_REQUEST, \"Country must be one of the ISO 1366 Country Codes\");\n             }\n+        }\n+        String metricName = \"MDC-\" + metricType.toString() + ((country == null) ? \"\" : \"-\" + country);\n+\n+        String sanitizedyyyymm = null;\n+        if (yyyymm != null) {\n+            sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        }\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        if (null == jsonObj) { // run query and save\n+            jsonObj = metricsSvc.getMDCDatasetMetrics(metricType, sanitizedyyyymm, country, d);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+    \n+    @GET\n+    @Path(\"filedownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getFileDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+    \n+    @GET\n+    @Path(\"filedownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n         }\n+\n+        String metricName = \"fileDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            jsonArr = metricsSvc.fileDownloads(sanitizedyyyymm, d, false);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"filedownloads.csv\");\n     }\n     \n     @GET\n-    @Path(\"downloads/pastDays/{days}\")\n-    public Response getDownloadsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Path(\"filedownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-                \n-        String metricName = \"downloadsPastDays\";\n-        \n-        if(days < 1) {\n-            return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n+        String metricName = \"fileDownloads\";\n+\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            // Only handling published right now\n+            jsonArr = metricsSvc.fileDownloadsTimeSeries(d, false);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n         }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.DATE, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"filedownloads.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getUniqueDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n         try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"uniqueDownloads\";\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.downloadsPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.uniqueDownloadsTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquedownloads.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"uniqueDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = metricsSvc.uniqueDatasetDownloads(sanitizedyyyymm, d);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquedownloads.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquefiledownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getUniqueFileDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+    \n+    @GET\n+    @Path(\"uniquefiledownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"uniquefileDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            jsonArr = metricsSvc.fileDownloads(sanitizedyyyymm, d, true);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquefiledownloads.csv\");\n+    }\n+    \n+    @GET\n+    @Path(\"uniquefiledownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"uniquefileDownloads\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.fileDownloadsTimeSeries(d, true);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquefiledownloads.timeseries.csv\");\n+    }\n+    \n+    @GET\n+    @Path(\"tree\")\n+    public Response getDataversesTree(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDataversesTreeToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"tree/toMonth/{yyyymm}\")\n+    public Response getDataversesTreeToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"tree\";\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+        if (null == jsonObj) { // run query and save\n+            jsonObj = metricsSvc.getDataverseTree(d, sanitizedyyyymm, DatasetVersion.VersionState.RELEASED);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+        return ok(jsonObj);\n     }\n \n     private void errorIfUnrecongizedQueryParamPassed(UriInfo uriDetails, String[] allowedQueryParams) throws IllegalArgumentException {\n-        for(String theKey : uriDetails.getQueryParameters().keySet()) {\n-            if(!Arrays.stream(allowedQueryParams).anyMatch(theKey::equals)) {\n+        for (String theKey : uriDetails.getQueryParameters().keySet()) {\n+            if (!Arrays.stream(allowedQueryParams).anyMatch(theKey::equals)) {\n                 throw new IllegalArgumentException(\"queryParameter \" + theKey + \" not supported for this endpont\");\n             }\n         }\n-        \n+\n     }\n-    \n+\n+    // Throws a WebApplicationException if alias is not null and Dataverse can't be\n+    // found\n+    private Dataverse findDataverseOrDieIfNotFound(String alias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2"}, "originalPosition": 1087}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MTY3Mg==", "bodyText": "Not sure I understand why this doesn't look like an orDie method - if the alias requested doesn't exist, it throws an exception (a WebApplicationException rather than WrappedResponse to use the updated error handling that's been added). Is it what is returned that is an issue or something else? Or just findPublishedDataverseOrDie ?", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510451672", "createdAt": "2020-10-22T20:56:04Z", "author": {"login": "qqmyers"}, "path": "src/main/java/edu/harvard/iq/dataverse/api/Metrics.java", "diffHunk": "@@ -26,404 +41,836 @@\n  */\n @Path(\"info/metrics\")\n public class Metrics extends AbstractApiBean {\n+    private static final Logger logger = Logger.getLogger(Metrics.class.getName());\n \n     /** Dataverses */\n-    \n+\n     @GET\n     @Path(\"dataverses\")\n-    public Response getDataversesAllTime(@Context UriInfo uriInfo) {\n-        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getDataversesAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"dataverses/toMonth\")\n-    public Response getDataversesToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"dataverses/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"dataverses\";\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.getDataversesTimeSeries(uriInfo, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.timeseries.csv\");\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/toMonth/{yyyymm}\")\n-    public Response getDataversesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDataversesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"dataversesToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.dataversesToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n-            }\n+        String metricName = \"dataversesToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n \n-        //TODO: Eventually the catch in each endpoint should be more specific\n-        //          and more general errors should be logged.\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.dataversesToMonth(sanitizedyyyymm, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/pastDays/{days}\")\n-    public Response getDataversesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDataversesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"dataversesPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n-        try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.dataversesPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.dataversesPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        return ok(jsonObj);\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n-        }\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/byCategory\")\n-    public Response getDataversesByCategory(@Context UriInfo uriInfo) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesByCategory(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"dataversesByCategory\";\n \n-        try {\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheAllTime(metricName, null);\n+        String metricName = \"dataversesByCategory\";\n \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.dataversesByCategoryToJson(metricsSvc.dataversesByCategory());\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, null, null, jsonArrayString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.dataversesByCategoryToJson(metricsSvc.dataversesByCategory(d)).build();\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.CATEGORY, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.byCategory.csv\");\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/bySubject\")\n-    public Response getDataversesBySubject(@Context UriInfo uriInfo) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesBySubject(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"dataversesBySubject\";\n-        \n-        try {\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheAllTime(metricName, null);\n \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.dataversesBySubjectToJson(metricsSvc.dataversesBySubject());\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, null, null, jsonArrayString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.dataversesBySubjectToJson(metricsSvc.dataversesBySubject(d)).build();\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n         }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.SUBJECT, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.bySubject.csv\");\n     }\n-    \n+\n     /** Datasets */\n-    \n+\n     @GET\n     @Path(\"datasets\")\n-    public Response getDatasetsAllTime(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    public Response getDatasetsAllTime(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation, parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"datasets/toMonth\")\n-    public Response getDatasetsToMonthCurrent(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    @Path(\"datasets/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsTimeSeriest(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"datasets\";\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.getDatasetsTimeSeries(uriInfo, dataLocation, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datasets.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"datasets/toMonth/{yyyymm}\")\n-    public Response getDatasetsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    public Response getDatasetsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"datasetsToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.datasetsToMonth(sanitizedyyyymm, validDataLocation);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, jsonString));\n-            }\n+        String metricName = \"datasetsToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.datasetsToMonth(sanitizedyyyymm, validDataLocation, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"datasets/pastDays/{days}\")\n-    public Response getDatasetsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    public Response getDatasetsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"datasetsPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n-        try {\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), validDataLocation);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.datasetsPastDays(days, validDataLocation);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), validDataLocation, jsonString));\n-            }\n-\n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), validDataLocation, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.datasetsPastDays(days, validDataLocation, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), validDataLocation, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"datasets/bySubject\")\n-    public Response getDatasetsBySubject(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsBySubjectToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsBySubject(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDatasetsBySubjectToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), dataLocation, parentAlias);\n     }\n-  \n+\n     @GET\n     @Path(\"datasets/bySubject/toMonth/{yyyymm}\")\n-    public Response getDatasetsBySubjectToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsBySubjectToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"datasetsBySubjectToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation);\n-            \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.datasetsBySubjectToJson(metricsSvc.datasetsBySubjectToMonth(sanitizedyyyymm, validDataLocation));\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, jsonArrayString));\n-            }\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation, d));\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.datasetsBySubjectToJson(metricsSvc.datasetsBySubjectToMonth(sanitizedyyyymm, validDataLocation, d)).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.SUBJECT, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datasets.bySubject.csv\");\n     }\n-    \n+\n     /** Files */\n     @GET\n     @Path(\"files\")\n-    public Response getFilesAllTime(@Context UriInfo uriInfo) {\n-        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getFilesAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"files/toMonth\")\n-    public Response getFilesToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"files/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"files\";\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.filesTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"files/toMonth/{yyyymm}\")\n-    public Response getFilesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getFilesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"filesToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.filesToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n-            }\n+        String metricName = \"filesToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        logger.fine(\"yyyymm: \" + sanitizedyyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+        logger.fine(\"Returned\");\n+        if (null == jsonObj) { // run query and save\n+            logger.fine(\"Getting filesToMonth : \" + sanitizedyyyymm + \" dvId=\" + ((d==null) ? \"not sent\" : d.getId()));\n+            Long count = metricsSvc.filesToMonth(sanitizedyyyymm, d);\n+            logger.fine(\"count = \" + count);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n     }\n-    \n+\n     @GET\n     @Path(\"files/pastDays/{days}\")\n-    public Response getFilesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getFilesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"filesPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.filesPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+\n+    }\n+\n+    @GET\n+    @Path(\"/files/byType/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesByTypeTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n         try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"filesByType\";\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.filesPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.filesByTypeTimeSeries(d, true);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.CONTENTTYPE, MetricsUtil.COUNT, MetricsUtil.SIZE), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.byType.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"/files/byType\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesByType(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"filesByType\";\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = metricsSvc.filesByType(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.CONTENTTYPE, MetricsUtil.COUNT, MetricsUtil.SIZE), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.byType.csv\");\n     }\n \n     /** Downloads */\n-    \n+\n     @GET\n     @Path(\"downloads\")\n-    public Response getDownloadsAllTime(@Context UriInfo uriInfo) {\n-        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getDownloadsAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"downloads/toMonth\")\n-    public Response getDownloadsToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"downloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"downloads\";\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.downloadsTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"downloads.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"downloads/toMonth/{yyyymm}\")\n-    public Response getDownloadsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {                \n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDownloadsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-        \n+\n         String metricName = \"downloadsToMonth\";\n-        \n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count;\n+            try {\n+                count = metricsSvc.downloadsToMonth(sanitizedyyyymm, d);\n+            } catch (ParseException e) {\n+                return error(BAD_REQUEST, \"Unable to parse supplied date: \" + e.getLocalizedMessage());\n+            }\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+\n+    @GET\n+    @Path(\"downloads/pastDays/{days}\")\n+    public Response getDownloadsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"downloadsPastDays\";\n+\n+        if (days < 1) {\n+            return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n+        }\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.downloadsPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}\")\n+    public Response getMakeDataCountMetricCurrentMonth(@Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getMakeDataCountMetricToMonth(uriInfo, metricSupplied, MetricsUtil.getCurrentMonth(), country, parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getMakeDataCountMetricTimeSeries(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        MakeDataCountUtil.MetricType metricType = null;\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\", \"country\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        try {\n+            metricType = MakeDataCountUtil.MetricType.fromString(metricSupplied);\n+        } catch (IllegalArgumentException ex) {\n+            return error(Response.Status.BAD_REQUEST, ex.getMessage());\n+        }\n+        String metricName = \"MDC-\" + metricType.toString() + ((country == null) ? \"\" : \"-\" + country);\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.mdcMetricTimeSeries(metricType, country, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"makeDataCount.\" + metricType.toString() + \".timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}/toMonth/{yyyymm}\")\n+    public Response getMakeDataCountMetricToMonth(@Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        MakeDataCountUtil.MetricType metricType = null;\n         try {\n-            \n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.downloadsToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\", \"country\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        try {\n+            metricType = MakeDataCountUtil.MetricType.fromString(metricSupplied);\n+        } catch (IllegalArgumentException ex) {\n+            return error(Response.Status.BAD_REQUEST, ex.getMessage());\n+        }\n+        if (country != null) {\n+            country = country.toLowerCase();\n+\n+            if (!MakeDataCountUtil.isValidCountryCode(country)) {\n+                return error(Response.Status.BAD_REQUEST, \"Country must be one of the ISO 1366 Country Codes\");\n             }\n+        }\n+        String metricName = \"MDC-\" + metricType.toString() + ((country == null) ? \"\" : \"-\" + country);\n+\n+        String sanitizedyyyymm = null;\n+        if (yyyymm != null) {\n+            sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        }\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        if (null == jsonObj) { // run query and save\n+            jsonObj = metricsSvc.getMDCDatasetMetrics(metricType, sanitizedyyyymm, country, d);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+    \n+    @GET\n+    @Path(\"filedownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getFileDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+    \n+    @GET\n+    @Path(\"filedownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n         }\n+\n+        String metricName = \"fileDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            jsonArr = metricsSvc.fileDownloads(sanitizedyyyymm, d, false);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"filedownloads.csv\");\n     }\n     \n     @GET\n-    @Path(\"downloads/pastDays/{days}\")\n-    public Response getDownloadsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Path(\"filedownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-                \n-        String metricName = \"downloadsPastDays\";\n-        \n-        if(days < 1) {\n-            return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n+        String metricName = \"fileDownloads\";\n+\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            // Only handling published right now\n+            jsonArr = metricsSvc.fileDownloadsTimeSeries(d, false);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n         }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.DATE, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"filedownloads.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getUniqueDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n         try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"uniqueDownloads\";\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.downloadsPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.uniqueDownloadsTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquedownloads.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"uniqueDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = metricsSvc.uniqueDatasetDownloads(sanitizedyyyymm, d);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquedownloads.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquefiledownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getUniqueFileDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+    \n+    @GET\n+    @Path(\"uniquefiledownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"uniquefileDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            jsonArr = metricsSvc.fileDownloads(sanitizedyyyymm, d, true);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquefiledownloads.csv\");\n+    }\n+    \n+    @GET\n+    @Path(\"uniquefiledownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"uniquefileDownloads\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.fileDownloadsTimeSeries(d, true);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquefiledownloads.timeseries.csv\");\n+    }\n+    \n+    @GET\n+    @Path(\"tree\")\n+    public Response getDataversesTree(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDataversesTreeToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"tree/toMonth/{yyyymm}\")\n+    public Response getDataversesTreeToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"tree\";\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+        if (null == jsonObj) { // run query and save\n+            jsonObj = metricsSvc.getDataverseTree(d, sanitizedyyyymm, DatasetVersion.VersionState.RELEASED);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+        return ok(jsonObj);\n     }\n \n     private void errorIfUnrecongizedQueryParamPassed(UriInfo uriDetails, String[] allowedQueryParams) throws IllegalArgumentException {\n-        for(String theKey : uriDetails.getQueryParameters().keySet()) {\n-            if(!Arrays.stream(allowedQueryParams).anyMatch(theKey::equals)) {\n+        for (String theKey : uriDetails.getQueryParameters().keySet()) {\n+            if (!Arrays.stream(allowedQueryParams).anyMatch(theKey::equals)) {\n                 throw new IllegalArgumentException(\"queryParameter \" + theKey + \" not supported for this endpont\");\n             }\n         }\n-        \n+\n     }\n-    \n+\n+    // Throws a WebApplicationException if alias is not null and Dataverse can't be\n+    // found\n+    private Dataverse findDataverseOrDieIfNotFound(String alias) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MDQxMw=="}, "originalCommit": {"oid": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2"}, "originalPosition": 1087}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2377, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}