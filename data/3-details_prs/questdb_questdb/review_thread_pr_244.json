{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMzg3MTc1", "number": 244, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMDoxMDoyMlrOEbTZpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTozMjowMFrOEbTyKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDY0ODcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMDoxMDoyMlrOHFL6-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMDoxMDoyMlrOHFL6-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwMDI1MQ==", "bodyText": "this needs fixing a bit more in so far as not checking if string fits the page when len = -1. I would probably make it looks like this emphasising hot path:\n    public final CharSequence getStr0(long offset, CharSequenceView view) {\n        final int len = getInt(offset);\n        if (len > -1 && offset + len * Character.BYTES + Integer.BYTES <= size) {\n            return view.of(offset + VirtualMemory.STRING_LENGTH_BYTES, len);\n        }\n        \n        if (len == TableUtils.NULL_LEN) {\n            return null;\n        }\n\n        throw CairoException.instance(0).put(\"String is outside of file boundary [offset=\").put(offset).put(\", len=\").put(len).put(']');\n    }", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475200251", "createdAt": "2020-08-23T10:10:22Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -232,7 +232,7 @@ public void getLong256(long offset, Long256Sink sink) {\n \n     public final CharSequence getStr0(long offset, CharSequenceView view) {\n         final int len = getInt(offset);\n-        if (offset + len + Integer.BYTES < size) {\n+        if (offset + len * 2 + Integer.BYTES <= size) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDY4OTY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTowNDo0MlrOHFMPHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTowNDo0MlrOHFMPHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNTQwNw==", "bodyText": "For \"overflown\" symbol index we should just return the high address of underlying memory.", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475205407", "createdAt": "2020-08-23T11:04:42Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java", "diffHunk": "@@ -204,4 +205,19 @@ private void growCharMemToSymbolCount(int symbolCount) {\n     private CharSequence uncachedValue(int key) {\n         return charMem.getStr(offsetMem.getLong(SymbolMapWriter.keyToOffset(key)));\n     }\n+\n+    @Override\n+    public long symbolCharsAddressOf(int symbolIndex) {\n+        if (symbolIndex < symbolCount) {\n+            long offset = offsetMem.getLong(SymbolMapWriter.keyToOffset(symbolIndex));\n+            return charMem.addressOf(offset);\n+        } else if (symbolIndex == symbolCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDY5OTE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/SymbolMapWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToxNjowOFrOHFMTxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1NjoyN1rOHIZJww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNjU5Ng==", "bodyText": "does Hash.hasMem() not work in this case?", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475206596", "createdAt": "2020-08-23T11:16:08Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/SymbolMapWriter.java", "diffHunk": "@@ -234,4 +243,41 @@ private int put0(CharSequence symbol, int hash) {\n         indexWriter.add(hash, offsetOffset);\n         return offsetToKey(offsetOffset);\n     }\n+\n+    public void appendSymbolCharsBlock(long blockLength, long sourceAddress) {\n+        long appendOffset = charMem.getAppendOffset();\n+        try {\n+            charMem.jumpTo(appendOffset);\n+            charMem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            charMem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void commitAppendedBlock(int nSymbolsAdded) {\n+        long offset = charMem.getAppendOffset();\n+        int symbolIndex = getSymbolCount();\n+        int nSymbols = symbolIndex + nSymbolsAdded;\n+        while (symbolIndex < nSymbols) {\n+            long symCharsOffset = offset;\n+            int symLen = charMem.getInt(offset);\n+            offset += Integer.BYTES;\n+            long symCharsOffsetHi = offset + symLen * Character.BYTES;\n+            tmpSymbol.of(charMem.addressOf(offset), charMem.addressOf(symCharsOffsetHi));\n+\n+            long offsetOffset = offsetMem.getAppendOffset();\n+            offsetMem.putLong(symCharsOffset);\n+            int hash = Hash.boundedHash(tmpSymbol, maxHash);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2Mjc1NQ==", "bodyText": "The hashes generated are different", "url": "https://github.com/questdb/questdb/pull/244#discussion_r478562755", "createdAt": "2020-08-27T16:56:27Z", "author": {"login": "patrickSpaceSurfer"}, "path": "core/src/main/java/io/questdb/cairo/SymbolMapWriter.java", "diffHunk": "@@ -234,4 +243,41 @@ private int put0(CharSequence symbol, int hash) {\n         indexWriter.add(hash, offsetOffset);\n         return offsetToKey(offsetOffset);\n     }\n+\n+    public void appendSymbolCharsBlock(long blockLength, long sourceAddress) {\n+        long appendOffset = charMem.getAppendOffset();\n+        try {\n+            charMem.jumpTo(appendOffset);\n+            charMem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            charMem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void commitAppendedBlock(int nSymbolsAdded) {\n+        long offset = charMem.getAppendOffset();\n+        int symbolIndex = getSymbolCount();\n+        int nSymbols = symbolIndex + nSymbolsAdded;\n+        while (symbolIndex < nSymbols) {\n+            long symCharsOffset = offset;\n+            int symLen = charMem.getInt(offset);\n+            offset += Integer.BYTES;\n+            long symCharsOffsetHi = offset + symLen * Character.BYTES;\n+            tmpSymbol.of(charMem.addressOf(offset), charMem.addressOf(symCharsOffsetHi));\n+\n+            long offsetOffset = offsetMem.getAppendOffset();\n+            offsetMem.putLong(symCharsOffset);\n+            int hash = Hash.boundedHash(tmpSymbol, maxHash);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNjU5Ng=="}, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDcwMjk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/TableBlockWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToyMDo1N1rOHFMVpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToyMDo1N1rOHFMVpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzA3OQ==", "bodyText": "This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207079", "createdAt": "2020-08-23T11:20:57Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/TableBlockWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package io.questdb.cairo;\n+\n+import java.io.Closeable;\n+\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.ObjList;\n+import io.questdb.std.str.Path;\n+\n+public class TableBlockWriter implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TableBlockWriter.class);\n+    private TableWriter writer;\n+    private final ObjList<AppendMemory> columns = new ObjList<>();\n+    private final CharSequence root;\n+    private final FilesFacade ff;\n+    private final int mkDirMode;\n+    private final Path path = new Path();\n+\n+    private int rootLen;\n+    private RecordMetadata metadata;\n+    private int columnCount;\n+    private int partitionBy;\n+    private long partitionLo;\n+    private long partitionHi;\n+\n+    public TableBlockWriter(CairoConfiguration configuration) {\n+        root = configuration.getRoot();\n+        this.ff = configuration.getFilesFacade();\n+        this.mkDirMode = configuration.getMkDirMode();\n+    }\n+\n+    public void appendBlock(long timestamp, int columnIndex, long blockLength, long sourceAddress) {\n+        if (timestamp < partitionLo && partitionLo != Long.MAX_VALUE) {\n+            throw CairoException.instance(0).put(\"can only append [timestamp=\").put(timestamp).put(\", partitionLo=\").put(partitionLo).put(']');\n+        }\n+\n+        if (timestamp > partitionHi || partitionLo == Long.MAX_VALUE) {\n+            openPartition(timestamp);\n+        }\n+\n+        AppendMemory mem = columns.getQuick(columnIndex);\n+        long appendOffset = mem.getAppendOffset();\n+        try {\n+            mem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            mem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void appendSymbolCharsBlock(int columnIndex, long blockLength, long sourceAddress) {\n+        writer.getSymbolMapWriter(columnIndex).appendSymbolCharsBlock(blockLength, sourceAddress);\n+    }\n+\n+    public void commitAppendedBlock(long firstTimestamp, long lastTimestamp, long nRowsAdded) {\n+        LOG.info().$(\"committing block write of \").$(nRowsAdded).$(\" rows to \").$(path).$(\" [firstTimestamp=\").$ts(firstTimestamp).$(\", lastTimestamp=\").$ts(lastTimestamp).$(']').$();\n+        writer.commitAppendedBlock(firstTimestamp, lastTimestamp, nRowsAdded);\n+        reset();\n+    }\n+\n+    private void openPartition(long timestamp) {\n+        try {\n+            partitionLo = timestamp;\n+            partitionHi = TableUtils.setPathForPartition(path, partitionBy, timestamp);\n+            int plen = path.length();\n+            if (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+                throw CairoException.instance(ff.errno()).put(\"Cannot create directory: \").put(path);\n+            }\n+\n+            assert columnCount > 0;\n+            for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                final CharSequence name = metadata.getColumnName(columnIndex);\n+                AppendMemory mem = columns.getQuick(columnIndex);\n+                mem.of(ff, TableUtils.dFile(path.trimTo(plen), name), ff.getMapPageSize());\n+                mem.jumpTo(writer.getPrimaryAppendOffset(timestamp, columnIndex));\n+            }\n+            LOG.info().$(\"switched partition to '\").$(path).$('\\'').$();\n+        } finally {\n+            path.trimTo(rootLen);\n+        }\n+    }\n+\n+    public void of(TableWriter writer) {\n+        clear();\n+        this.writer = writer;\n+        metadata = writer.getMetadata();\n+        path.of(root).concat(writer.getName());\n+        rootLen = path.length();\n+        columnCount = metadata.getColumnCount();\n+        partitionBy = writer.getPartitionBy();\n+        int columnsSize = columns.size();\n+        while (columnsSize < columnCount) {\n+            columns.extendAndSet(columnsSize++, new AppendMemory());\n+        }\n+    }\n+\n+    public void clear() {\n+        if (null != writer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDcwNDQzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToyMzowM1rOHFMWYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToyMzowM1rOHFMWYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzI2NQ==", "bodyText": "this algorithm does not take into account column tops. Something that another implementation of framing does. Column top is non-zero when column is added to table after table was populated.", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207265", "createdAt": "2020-08-23T11:23:03Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDcwNjU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToyNTo0N1rOHFMXZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMToyNTo0N1rOHFMXZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzUyNQ==", "bodyText": "can max symbol index be calculated from table reader?", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207525", "createdAt": "2020-08-23T11:25:47Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDcxMDY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTozMDo1N1rOHFMZXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTozMDo1N1rOHFMZXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODAzMQ==", "bodyText": "if we use ContiguousPages the limit of row can be calculated as:\n  if (row < count - 1) \n      hi = getOffset(row+1)\n else \n      hi = pageSize", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475208031", "createdAt": "2020-08-23T11:30:57Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                        }\n+                        nSymbolsProcessed.setQuick(columnIndex, maxSymbolIndex + 1);\n+                    }\n+                }\n+                nRows = -1;\n+            }\n+\n+            return this;\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader) {\n+            this.reader = reader;\n+            columnCount = reader.getMetadata().getColumnCount();\n+            timestampColumnIndex = reader.getMetadata().getTimestampIndex();\n+            columnFrameAddresses.ensureCapacity(columnCount);\n+            columnFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.ensureCapacity(columnCount);\n+            symbolCharsFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.setAll(columnCount, -1);\n+            symbolCharsFrameLengths.setAll(columnCount, 0);\n+            toTop();\n+            return this;\n+        }\n+\n+        @Override\n+        public @Nullable ReplicationPageFrame next() {\n+            while (++partitionIndex < partitionCount) {\n+                nFrameRows = reader.openPartition(partitionIndex);\n+                if (nFrameRows > nFirstFrameRow) {\n+                    final int base = reader.getColumnBase(partitionIndex);\n+                    for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long columnPageAddress = col.getPageAddress(0);\n+                        long columnPageLength;\n+\n+                        int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                        switch (columnType) {\n+                            case ColumnType.STRING: {\n+                                final ReadOnlyColumn strLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateStringPagePosition(col, strLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateStringPagePosition(col, strLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            case ColumnType.BINARY: {\n+                                final ReadOnlyColumn binLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateBinaryPagePosition(col, binLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateBinaryPagePosition(col, binLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            default: {\n+                                int columnSizeBinaryPower = Numbers.msb(ColumnType.sizeOf(reader.getMetadata().getColumnType(columnIndex)));\n+                                columnPageLength = nFrameRows << columnSizeBinaryPower;\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = nFirstFrameRow << columnSizeBinaryPower;\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+                            }\n+                        }\n+\n+                        columnFrameAddresses.setQuick(columnIndex, columnPageAddress);\n+                        columnFrameLengths.setQuick(columnIndex, columnPageLength);\n+\n+                        if (timestampColumnIndex == columnIndex) {\n+                            firstTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress);\n+                            lastTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress + columnPageLength - Long.BYTES);\n+                        }\n+\n+                        if (columnType == ColumnType.SYMBOL) {\n+                            long symbolIndexAddess = columnPageAddress;\n+                            int maxSymbolIndex = 0;\n+                            // TODO: Use vector instructions (rosti?) to find max\n+                            for (int nRow = 0; nRow < nFrameRows; nRow++) {\n+                                int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                                symbolIndexAddess += Integer.BYTES;\n+                                maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                            }\n+\n+                            int nSymbols = nSymbolsProcessed.getQuick(columnIndex);\n+                            if (maxSymbolIndex >= nSymbols) {\n+                                int newNSymbols = maxSymbolIndex + 1;\n+                                SymbolMapReader symReader = reader.getSymbolMapReader(columnIndex);\n+                                long address = symReader.symbolCharsAddressOf(nSymbols);\n+                                long addressHi = symReader.symbolCharsAddressOf(newNSymbols);\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, address);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, addressHi - address);\n+                                nSymbolsProcessed.setQuick(columnIndex, newNSymbols);\n+                            } else {\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, -1);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, 0);\n+                            }\n+                        }\n+                    }\n+\n+                    nFrameRows -= nFirstFrameRow;\n+                    nFirstFrameRow = 0;\n+                    return frame;\n+                }\n+                nFirstFrameRow = 0;\n+            }\n+            return null;\n+        }\n+\n+        private long calculateBinaryPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn binLenCol, long row) {\n+            long columnPageLength;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDcxMTQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTozMjowMFrOHFMZxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxMTozMjowMFrOHFMZxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODEzNQ==", "bodyText": "symbol for all intents and purposes is an INT column\nSymbolTable is global (not partitioned) so it should not be part of the frame", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475208135", "createdAt": "2020-08-23T11:32:00Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                        }\n+                        nSymbolsProcessed.setQuick(columnIndex, maxSymbolIndex + 1);\n+                    }\n+                }\n+                nRows = -1;\n+            }\n+\n+            return this;\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader) {\n+            this.reader = reader;\n+            columnCount = reader.getMetadata().getColumnCount();\n+            timestampColumnIndex = reader.getMetadata().getTimestampIndex();\n+            columnFrameAddresses.ensureCapacity(columnCount);\n+            columnFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.ensureCapacity(columnCount);\n+            symbolCharsFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.setAll(columnCount, -1);\n+            symbolCharsFrameLengths.setAll(columnCount, 0);\n+            toTop();\n+            return this;\n+        }\n+\n+        @Override\n+        public @Nullable ReplicationPageFrame next() {\n+            while (++partitionIndex < partitionCount) {\n+                nFrameRows = reader.openPartition(partitionIndex);\n+                if (nFrameRows > nFirstFrameRow) {\n+                    final int base = reader.getColumnBase(partitionIndex);\n+                    for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long columnPageAddress = col.getPageAddress(0);\n+                        long columnPageLength;\n+\n+                        int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                        switch (columnType) {\n+                            case ColumnType.STRING: {\n+                                final ReadOnlyColumn strLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateStringPagePosition(col, strLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateStringPagePosition(col, strLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            case ColumnType.BINARY: {\n+                                final ReadOnlyColumn binLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateBinaryPagePosition(col, binLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateBinaryPagePosition(col, binLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            default: {\n+                                int columnSizeBinaryPower = Numbers.msb(ColumnType.sizeOf(reader.getMetadata().getColumnType(columnIndex)));\n+                                columnPageLength = nFrameRows << columnSizeBinaryPower;\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = nFirstFrameRow << columnSizeBinaryPower;\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+                            }\n+                        }\n+\n+                        columnFrameAddresses.setQuick(columnIndex, columnPageAddress);\n+                        columnFrameLengths.setQuick(columnIndex, columnPageLength);\n+\n+                        if (timestampColumnIndex == columnIndex) {\n+                            firstTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress);\n+                            lastTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress + columnPageLength - Long.BYTES);\n+                        }\n+\n+                        if (columnType == ColumnType.SYMBOL) {\n+                            long symbolIndexAddess = columnPageAddress;\n+                            int maxSymbolIndex = 0;\n+                            // TODO: Use vector instructions (rosti?) to find max\n+                            for (int nRow = 0; nRow < nFrameRows; nRow++) {\n+                                int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                                symbolIndexAddess += Integer.BYTES;\n+                                maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                            }\n+\n+                            int nSymbols = nSymbolsProcessed.getQuick(columnIndex);\n+                            if (maxSymbolIndex >= nSymbols) {\n+                                int newNSymbols = maxSymbolIndex + 1;\n+                                SymbolMapReader symReader = reader.getSymbolMapReader(columnIndex);\n+                                long address = symReader.symbolCharsAddressOf(nSymbols);\n+                                long addressHi = symReader.symbolCharsAddressOf(newNSymbols);\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, address);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, addressHi - address);\n+                                nSymbolsProcessed.setQuick(columnIndex, newNSymbols);\n+                            } else {\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, -1);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, 0);\n+                            }\n+                        }\n+                    }\n+\n+                    nFrameRows -= nFirstFrameRow;\n+                    nFirstFrameRow = 0;\n+                    return frame;\n+                }\n+                nFirstFrameRow = 0;\n+            }\n+            return null;\n+        }\n+\n+        private long calculateBinaryPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn binLenCol, long row) {\n+            long columnPageLength;\n+            long lastBinLenOffset = (row - 1) << 3;\n+            long lastBinOffset = binLenCol.getLong(lastBinLenOffset);\n+            long lastBinLen = col.getBinLen(lastBinOffset);\n+            if (lastBinLen == TableUtils.NULL_LEN) {\n+                lastBinLen = 0;\n+            }\n+            columnPageLength = lastBinOffset + Long.BYTES + lastBinLen;\n+            return columnPageLength;\n+        }\n+\n+        private long calculateStringPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn strLenCol, long row) {\n+            long columnPageLength;\n+            long lastStrLenOffset = (row - 1) << 3;\n+            long lastStrOffset = strLenCol.getLong(lastStrLenOffset);\n+            int lastStrLen = col.getStrLen(lastStrOffset);\n+            if (lastStrLen == TableUtils.NULL_LEN) {\n+                lastStrLen = 0;\n+            }\n+            columnPageLength = lastStrOffset + VirtualMemory.STRING_LENGTH_BYTES + lastStrLen * 2;\n+            return columnPageLength;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            partitionIndex = -1;\n+            partitionCount = reader.getPartitionCount();\n+            firstTimestamp = Long.MIN_VALUE;\n+            lastTimestamp = 0;\n+            nSymbolsProcessed.setAll(columnCount, 0);\n+        }\n+\n+        @Override\n+        public long size() {\n+            return reader.size();\n+        }\n+\n+        public class ReplicationPageFrame implements PageFrame {\n+\n+            @Override\n+            public long getPageAddress(int columnIndex) {\n+                return columnFrameAddresses.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getPageValueCount(int columnIndex) {\n+                return nFrameRows;\n+            }\n+\n+            @Override\n+            public long getFirstTimestamp() {\n+                return firstTimestamp;\n+            }\n+\n+            @Override\n+            public long getLastTimestamp() {\n+                return lastTimestamp;\n+            }\n+\n+            public int getPartitionIndex() {\n+                return partitionIndex;\n+            }\n+\n+            @Override\n+            public long getPageLength(int columnIndex) {\n+                return columnFrameLengths.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getSymbolCharsPageAddress(int columnIndex) {\n+                return symbolCharsFrameAddresses.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getSymbolCharsPageLength(int columnIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b"}, "originalPosition": 325}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2268, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}