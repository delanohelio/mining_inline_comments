{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NzU0NTQ1", "number": 544, "title": "PG wire improvements. Fixes #450", "bodyText": "This change deals with issues around protocol mechanics, in particular our responses to messages from the client on simple and extended mode.\nFor example:\n\nwe now wait for sync message to send reply back, therefore grouping replies. This means that if client sends messages: P/B/D/E/S, we now send one reply back with 1/2/T/D/C/Z. This means that there is less chatter on the wire because 1. we are sending less messages and 2. the client does not get confused and therefore send less messages.\nfor each message sent by client, we send an acknowledgement back\nstop sending spurious messages\nnamed prepared statements are cached on parse and we correctly bind parameters when receiving named statement on the Bind and Describe messages\nwhen executing 'select', we now send back the number of returned rows\nwhen executing 'set', we now send correct query tag (SET)\nfor empty queries, we reply back with correct message type\nfor queries with no data, we  reply back with 'no data' message type\nrow description now includes column number\nrow descriptions attempts to populate type size and type modifier", "createdAt": "2020-08-10T22:04:34Z", "url": "https://github.com/questdb/questdb/pull/544", "merged": true, "mergeCommit": {"oid": "5fad98cf5d0aa8db025cf8892d9b70f14b8f7455"}, "closed": true, "closedAt": "2020-08-13T20:29:54Z", "author": {"login": "jaugsburger"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5Hih6gH2gAyNDY1NzU0NTQ1Ojc5MGM3Y2VhNjM2OWJiOTE5NjYwYjQxZjVjMGVkOWM2ZWEyNWI4ZTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-mBumAFqTQ2NzEwNTkyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "790c7cea6369bb919660b41f5c0ed9c6ea25b8e3", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/790c7cea6369bb919660b41f5c0ed9c6ea25b8e3", "committedDate": "2020-07-27T20:06:49Z", "message": "PG Wire - Simple Query mode fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8739aab5fdb7d01133e06b4b2a764e1d15f2c266", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/8739aab5fdb7d01133e06b4b2a764e1d15f2c266", "committedDate": "2020-07-29T13:25:52Z", "message": "PG Wire - removing extra message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cb2c6e226e598d243ddcc8131be71bdb06aa6aa", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/3cb2c6e226e598d243ddcc8131be71bdb06aa6aa", "committedDate": "2020-08-10T12:27:32Z", "message": "PG Wire - fixes for simple and extended query  modes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9297adc118a6b180b8d3ad81c5e6986e40a467d", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/a9297adc118a6b180b8d3ad81c5e6986e40a467d", "committedDate": "2020-08-10T21:42:23Z", "message": "PG Wire - tests and small fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/330a16c10681da34815e3e5ffaa0541071e6e81c", "committedDate": "2020-08-10T22:08:08Z", "message": "PG Wire - reverting port change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjY0NTM4", "url": "https://github.com/questdb/questdb/pull/544#pullrequestreview-464664538", "createdAt": "2020-08-11T00:03:25Z", "commit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDowMzoyNVrOG-jx4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMDo0Njo0MVrOG-khhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1MTEwNw==", "bodyText": "AssociativeCache is non-deterministic. Entities that are used together (e.g. portalFactoryCache and statementToBindVariableTypeCache) must be stored together in the same cache. Otherwise it is possible for only one of the caches to lose its value making pair inconsistent.\nTo that end I guess there is no test that would saturate these caches to breaking point. We need one.", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468251107", "createdAt": "2020-08-11T00:03:25Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -249,6 +264,8 @@ public boolean invalid() {\n     public void handleClientOperation(\n             @Transient SqlCompiler compiler,\n             @Transient AssociativeCache<Object> factoryCache,\n+            @Transient AssociativeCache<Object> portalFactoryCache,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1MjM2Mg==", "bodyText": "There is a problem with life cycle of this pool. See comments below in the file", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468252362", "createdAt": "2020-08-11T00:07:46Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -229,6 +242,8 @@ public void close() {\n         Unsafe.free(sendBuffer, sendBufferSize);\n         Unsafe.free(recvBuffer, recvBufferSize);\n         Misc.free(path);\n+        intListPool.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NzA0MA==", "bodyText": "utf8Decode returns decoding status. It cannot be ignored as it indicates corrupt message. Usually when uff8 cannot be decoded BadProtocolException is being thrown", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468257040", "createdAt": "2020-08-11T00:24:42Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -781,6 +800,17 @@ private void executeSelect(\n         currentCursor = factory.getCursor(sqlExecutionContext);\n         prepareRowDescription();\n         sendCursor();\n+        send();\n+    }\n+\n+    @Nullable\n+    private CharSequence getStatementName(long lo, long hi) {\n+        CharacterStoreEntry e = portalCharacterStore.newEntry();\n+        CharSequence statementName = null;\n+        if (hi - lo > 0 && Chars.utf8Decode(lo, hi, e)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NzQzMg==", "bodyText": "name of function argument is inconsistent with every other use. This is portalFactoryCache, right?", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468257432", "createdAt": "2020-08-11T00:26:03Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1132,6 +1233,8 @@ private void processParse(\n             long msgLimit,\n             @Transient SqlCompiler compiler,\n             @Transient AssociativeCache<Object> factoryCache,\n+            @Transient AssociativeCache<Object> statementFactoryCache,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NzY3Nw==", "bodyText": "this pool is being cleared when server stops it seems. E.g. this is heap memory leak.", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468257677", "createdAt": "2020-08-11T00:27:00Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1155,6 +1260,8 @@ private void processParse(\n \n         short parameterCount = getShort(lo);\n \n+        IntList bindVariableTypes = intListPool.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MDQyNQ==", "bodyText": "setupBindVariables is called from parse(). It clears bind variable setters list and re-populates it with whatever bind variables are. The same bindVariableSetters list is also populated from bind() when portal name is specified. So it is possible that this list will have two sets of setters.\nObviously we need a unit test covering this scenario.", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468260425", "createdAt": "2020-08-11T00:36:33Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1403,89 +1560,87 @@ private void sendExecuteTail(int tail) throws PeerDisconnectedException, PeerIsS\n     }\n \n     private void sendExecuteTail() throws PeerDisconnectedException, PeerIsSlowToReadException {\n-        switch (sendCurrentCursorTail) {\n-            case TAIL_SUCCESS:\n-                prepareCommandComplete();\n-                prepareReadyForQuery(responseAsciiSink);\n-                LOG.info().$(\"executed query\").$();\n+        prepareExecuteTail(false);\n+        send(PGConnectionContext.TAIL_NONE);\n+    }\n+\n+    private void setupBindVariable(ObjList<BindVariableSetter> bindVariableSetters, int idx, int pgType) throws SqlException {\n+        switch (pgType) {\n+            case PG_FLOAT8: // FLOAT8 - double\n+                bindVariableService.setDouble(idx, Double.NaN);\n+                bindVariableSetters.add(doubleSetter);\n+                bindVariableSetters.add(doubleTxtSetter);\n                 break;\n-            case PGConnectionContext.TAIL_ERROR:\n-                SqlException e = SqlException.last();\n-                prepareError(e);\n-                prepareReadyForQuery(responseAsciiSink);\n-                LOG.info().$(\"SQL exception [pos=\").$(e.getPosition()).$(\", msg=\").$(e.getFlyweightMessage()).$(']').$();\n+            case PG_INT4: // INT\n+                bindVariableService.setInt(idx, Numbers.INT_NaN);\n+                bindVariableSetters.add(intSetter);\n+                bindVariableSetters.add(intTxtSetter);\n                 break;\n-            default:\n+            case PG_INT8:\n+                bindVariableService.setLong(idx, Numbers.LONG_NaN);\n+                bindVariableSetters.add(longSetter);\n+                bindVariableSetters.add(longTxtSetter);\n+                break;\n+            case PG_FLOAT4:\n+                bindVariableService.setFloat(idx, Float.NaN);\n+                bindVariableSetters.add(floatSetter);\n+                bindVariableSetters.add(floatTxtSetter);\n+                break;\n+            case PG_INT2:\n+                bindVariableService.setByte(idx, (byte) 0);\n+                bindVariableSetters.add(byteSetter);\n+                bindVariableSetters.add(byteTxtSetter);\n+                break;\n+            case PG_BOOL:\n+                bindVariableService.setBoolean(idx, false);\n+                bindVariableSetters.add(booleanSetter);\n+                bindVariableSetters.add(booleanSetter);\n                 break;\n+            case PG_VARCHAR:\n+                bindVariableService.setStr(idx, null);\n+                bindVariableSetters.add(strSetter);\n+                bindVariableSetters.add(strSetter);\n+                break;\n+            case PG_DATE:\n+                bindVariableService.setDate(idx, Numbers.LONG_NaN);\n+                bindVariableSetters.add(noopSetter);\n+                bindVariableSetters.add(noopSetter);\n+                break;\n+            case PG_UNSPECIFIED:\n+            case PG_TIMESTAMP:\n+            case PG_TIMESTAMPZ:\n+                // postgres JDBC driver does not seem to send\n+                // microseconds with its text timestamp\n+                // on top of this parameters such as setDate, setTimestamp\n+                // cause driver to send UNSPECIFIED type\n+                // QuestDB has to know types to resolve function linkage\n+                // at compile time rather than at runtime.\n+                bindVariableService.setDate(idx, Numbers.LONG_NaN);\n+                bindVariableSetters.add(dateSetter);\n+                bindVariableSetters.add(dateSetter);\n+                break;\n+            default:\n+                throw SqlException.$(0, \"unsupported parameter [type=\").put(pgType).put(\", index=\").put(idx).put(']');\n         }\n-        send(PGConnectionContext.TAIL_NONE);\n     }\n \n     private void setupBindVariables(\n             long lo,\n             short pc,\n-            @Transient ObjList<BindVariableSetter> bindVariableSetters\n-    ) throws SqlException {\n+            @Transient ObjList<BindVariableSetter> bindVariableSetters,\n+            IntList bindVariableTypes) throws SqlException {\n         bindVariableSetters.clear();\n-        for (int j = 0; j < pc; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 651}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MDU0OQ==", "bodyText": "here, list is being added to but not cleared beforehand", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468260549", "createdAt": "2020-08-11T00:36:59Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1403,89 +1560,87 @@ private void sendExecuteTail(int tail) throws PeerDisconnectedException, PeerIsS\n     }\n \n     private void sendExecuteTail() throws PeerDisconnectedException, PeerIsSlowToReadException {\n-        switch (sendCurrentCursorTail) {\n-            case TAIL_SUCCESS:\n-                prepareCommandComplete();\n-                prepareReadyForQuery(responseAsciiSink);\n-                LOG.info().$(\"executed query\").$();\n+        prepareExecuteTail(false);\n+        send(PGConnectionContext.TAIL_NONE);\n+    }\n+\n+    private void setupBindVariable(ObjList<BindVariableSetter> bindVariableSetters, int idx, int pgType) throws SqlException {\n+        switch (pgType) {\n+            case PG_FLOAT8: // FLOAT8 - double\n+                bindVariableService.setDouble(idx, Double.NaN);\n+                bindVariableSetters.add(doubleSetter);\n+                bindVariableSetters.add(doubleTxtSetter);\n                 break;\n-            case PGConnectionContext.TAIL_ERROR:\n-                SqlException e = SqlException.last();\n-                prepareError(e);\n-                prepareReadyForQuery(responseAsciiSink);\n-                LOG.info().$(\"SQL exception [pos=\").$(e.getPosition()).$(\", msg=\").$(e.getFlyweightMessage()).$(']').$();\n+            case PG_INT4: // INT\n+                bindVariableService.setInt(idx, Numbers.INT_NaN);\n+                bindVariableSetters.add(intSetter);\n+                bindVariableSetters.add(intTxtSetter);\n                 break;\n-            default:\n+            case PG_INT8:\n+                bindVariableService.setLong(idx, Numbers.LONG_NaN);\n+                bindVariableSetters.add(longSetter);\n+                bindVariableSetters.add(longTxtSetter);\n+                break;\n+            case PG_FLOAT4:\n+                bindVariableService.setFloat(idx, Float.NaN);\n+                bindVariableSetters.add(floatSetter);\n+                bindVariableSetters.add(floatTxtSetter);\n+                break;\n+            case PG_INT2:\n+                bindVariableService.setByte(idx, (byte) 0);\n+                bindVariableSetters.add(byteSetter);\n+                bindVariableSetters.add(byteTxtSetter);\n+                break;\n+            case PG_BOOL:\n+                bindVariableService.setBoolean(idx, false);\n+                bindVariableSetters.add(booleanSetter);\n+                bindVariableSetters.add(booleanSetter);\n                 break;\n+            case PG_VARCHAR:\n+                bindVariableService.setStr(idx, null);\n+                bindVariableSetters.add(strSetter);\n+                bindVariableSetters.add(strSetter);\n+                break;\n+            case PG_DATE:\n+                bindVariableService.setDate(idx, Numbers.LONG_NaN);\n+                bindVariableSetters.add(noopSetter);\n+                bindVariableSetters.add(noopSetter);\n+                break;\n+            case PG_UNSPECIFIED:\n+            case PG_TIMESTAMP:\n+            case PG_TIMESTAMPZ:\n+                // postgres JDBC driver does not seem to send\n+                // microseconds with its text timestamp\n+                // on top of this parameters such as setDate, setTimestamp\n+                // cause driver to send UNSPECIFIED type\n+                // QuestDB has to know types to resolve function linkage\n+                // at compile time rather than at runtime.\n+                bindVariableService.setDate(idx, Numbers.LONG_NaN);\n+                bindVariableSetters.add(dateSetter);\n+                bindVariableSetters.add(dateSetter);\n+                break;\n+            default:\n+                throw SqlException.$(0, \"unsupported parameter [type=\").put(pgType).put(\", index=\").put(idx).put(']');\n         }\n-        send(PGConnectionContext.TAIL_NONE);\n     }\n \n     private void setupBindVariables(\n             long lo,\n             short pc,\n-            @Transient ObjList<BindVariableSetter> bindVariableSetters\n-    ) throws SqlException {\n+            @Transient ObjList<BindVariableSetter> bindVariableSetters,\n+            IntList bindVariableTypes) throws SqlException {\n         bindVariableSetters.clear();\n-        for (int j = 0; j < pc; j++) {\n-            int pgType = getInt(lo + j * Integer.BYTES);\n-            switch (pgType) {\n-                case PG_FLOAT8: // FLOAT8 - double\n-                    bindVariableService.setDouble(j, Double.NaN);\n-                    bindVariableSetters.add(doubleSetter);\n-                    bindVariableSetters.add(doubleTxtSetter);\n-                    break;\n-                case PG_INT4: // INT\n-                    bindVariableService.setInt(j, Numbers.INT_NaN);\n-                    bindVariableSetters.add(intSetter);\n-                    bindVariableSetters.add(intTxtSetter);\n-                    break;\n-                case PG_INT8:\n-                    bindVariableService.setLong(j, Numbers.LONG_NaN);\n-                    bindVariableSetters.add(longSetter);\n-                    bindVariableSetters.add(longTxtSetter);\n-                    break;\n-                case PG_FLOAT4:\n-                    bindVariableService.setFloat(j, Float.NaN);\n-                    bindVariableSetters.add(floatSetter);\n-                    bindVariableSetters.add(floatTxtSetter);\n-                    break;\n-                case PG_INT2:\n-                    bindVariableService.setByte(j, (byte) 0);\n-                    bindVariableSetters.add(byteSetter);\n-                    bindVariableSetters.add(byteTxtSetter);\n-                    break;\n-                case PG_BOOL:\n-                    bindVariableService.setBoolean(j, false);\n-                    bindVariableSetters.add(booleanSetter);\n-                    bindVariableSetters.add(booleanSetter);\n-                    break;\n-                case PG_VARCHAR:\n-                    bindVariableService.setStr(j, null);\n-                    bindVariableSetters.add(strSetter);\n-                    bindVariableSetters.add(strSetter);\n-                    break;\n-                case PG_DATE:\n-                    bindVariableService.setDate(j, Numbers.LONG_NaN);\n-                    bindVariableSetters.add(noopSetter);\n-                    bindVariableSetters.add(noopSetter);\n-                    break;\n-                case PG_UNSPECIFIED:\n-                case PG_TIMESTAMP:\n-                case PG_TIMESTAMPZ:\n-                    // postgres JDBC driver does not seem to send\n-                    // microseconds with its text timestamp\n-                    // on top of this parameters such as setDate, setTimestamp\n-                    // cause driver to send UNSPECIFIED type\n-                    // QuestDB has to know types to resolve function linkage\n-                    // at compile time rather than at runtime.\n-                    bindVariableService.setDate(j, Numbers.LONG_NaN);\n-                    bindVariableSetters.add(dateSetter);\n-                    bindVariableSetters.add(dateSetter);\n-                    break;\n-                default:\n-                    throw SqlException.$(0, \"unsupported parameter [type=\").put(pgType).put(\", index=\").put(j).put(']');\n-            }\n+        for (int idx = 0; idx < pc; idx++) {\n+            int pgType = getInt(lo + idx * Integer.BYTES);\n+            bindVariableTypes.add(pgType);\n+            setupBindVariable(bindVariableSetters, idx, pgType);\n+        }\n+    }\n+\n+    private void setupCachedBindVariables(@Transient ObjList<BindVariableSetter> bindVariableSetters,\n+                                          IntList bindVariableTypes) throws SqlException {\n+        for (int idx = 0; idx < bindVariableTypes.size(); idx++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 719}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MTMxMQ==", "bodyText": "bindVariableTypes should perhaps be a simple java object to begin with. I would add a simple to-do item that we want to re-use these lists.\nRealistically reuse is only possible when \"statement name\" disappears from cache. Then we can add IntList back to some sort of pool.", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468261311", "createdAt": "2020-08-11T00:39:29Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1167,9 +1274,8 @@ private void processParse(\n \n             LOG.debug().$(\"params [count=\").$(parameterCount).$(']').$();\n             lo += Short.BYTES;\n-\n             bindVariableService.clear();\n-            setupBindVariables(lo, parameterCount, bindVariableSetters);\n+            setupBindVariables(lo, parameterCount, bindVariableSetters, bindVariableTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2Mjc4MQ==", "bodyText": "it is possible that peek will yield null with associative cache. Remember that cache liable to loose values when saturated.\nThere are two options here:\n\n\nwe chose different data structure to hold cache information about named statements and clear this structure when named statements go away somehow. Perhaps client closes them?\n\n\nless graceful, but if we can report something on the wire about not being able to find statement by given name - we should do that", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468262781", "createdAt": "2020-08-11T00:44:52Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -990,6 +1041,22 @@ private void processBind(@Transient ObjList<BindVariableSetter> bindVariableSett\n         hi = getStringLength(lo, msgLimit);\n         checkNotTrue(hi == -1, \"bad prepared statement name length [msgType='B']\");\n \n+        CharSequence statementName = getStatementName(lo, hi);\n+        if (statementName != null) {\n+            final Object statement = portalFactoryCache.peek(statementName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MzA1OQ==", "bodyText": "this is another site where statement can be null and this situation is unhandled", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468263059", "createdAt": "2020-08-11T00:45:44Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1014,10 +1082,33 @@ private void processClose() throws PeerDisconnectedException, PeerIsSlowToReadEx\n         send();\n     }\n \n-    private void processDescribe() throws PeerDisconnectedException, PeerIsSlowToReadException {\n+    private void processDescribe(@Transient ObjList<BindVariableSetter> bindVariableSetters,\n+                                 long lo,\n+                                 long msgLimit,\n+                                 @Transient AssociativeCache<Object> portalFactoryCache,\n+                                 @Transient AssociativeCache<Object> statementToBindVariableTypeCache) throws SqlException, BadProtocolException {\n+        lo = lo + 1;\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad portal name length [msgType='D']\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+        if (statementName != null) {\n+            final Object statement = portalFactoryCache.peek(statementName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MzMwMQ==", "bodyText": "we can create these IntLists lazily only when parameterCount > 0", "url": "https://github.com/questdb/questdb/pull/544#discussion_r468263301", "createdAt": "2020-08-11T00:46:41Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1167,9 +1274,8 @@ private void processParse(\n \n             LOG.debug().$(\"params [count=\").$(parameterCount).$(']').$();\n             lo += Short.BYTES;\n-\n             bindVariableService.clear();\n-            setupBindVariables(lo, parameterCount, bindVariableSetters);\n+            setupBindVariables(lo, parameterCount, bindVariableSetters, bindVariableTypes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MTMxMQ=="}, "originalCommit": {"oid": "330a16c10681da34815e3e5ffaa0541071e6e81c"}, "originalPosition": 398}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/60e0e7ec07a74e550ce3965803dd404cc92851d7", "committedDate": "2020-08-12T12:22:36Z", "message": "PG Wire - fixes post PR review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjkxMjk0", "url": "https://github.com/questdb/questdb/pull/544#pullrequestreview-466291294", "createdAt": "2020-08-12T21:30:12Z", "commit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTozMDoxM1rOG_zjjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo1MDozOFrOG_0GbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1ODE1OA==", "bodyText": "this assumes that statement is found, e.g. happy days protocol scenario. We should be prepared for protocol abuse and not NPE here. Perhaps throw BadProtocolException", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469558158", "createdAt": "2020-08-12T21:30:13Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1005,23 +1056,171 @@ private void processBind(@Transient ObjList<BindVariableSetter> bindVariableSett\n             lo += Short.BYTES;\n             bindVariables(lo, msgLimit, parameterCount, bindVariableSetters);\n         }\n-    }\n+        prepareBindComplete();\n+    }\n+\n+    private void processClose(long lo, long msgLimit, CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws BadProtocolException {\n+        final byte type = Unsafe.getUnsafe().getByte(lo);\n+        if (type == 'S') {\n+            lo = lo + 1;\n+            long hi = getStringLength(lo, msgLimit);\n+            checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+            CharSequence statementName = getStatementName(lo, hi);\n+            if (statementName != null) {\n+                final NamedStatementWrapper wrapper = namedStatementMap.get(statementName);\n+                wrapper.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1ODc5Ng==", "bodyText": "for performance reasons this null check should be done outside of the method call. The rationale is that method call does not happen when statement is null", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469558796", "createdAt": "2020-08-12T21:31:36Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1126,101 +1335,19 @@ private void processInitialMessage(long address, int remaining) throws PeerDisco\n         }\n     }\n \n-    private void processParse(\n-            long address,\n-            long lo,\n-            long msgLimit,\n-            @Transient SqlCompiler compiler,\n-            @Transient AssociativeCache<Object> factoryCache,\n-            @Transient ObjList<BindVariableSetter> bindVariableSetters\n-    ) throws BadProtocolException, SqlException, PeerDisconnectedException, PeerIsSlowToReadException {\n-        // 'Parse'\n-        // this appears to be the execution side - we must at least return 'RowDescription'\n-        // possibly more, check QueryExecutionImpl.processResults() in PG driver for more info\n-\n-        long hi = getStringLength(lo, msgLimit);\n-        checkNotTrue(hi == -1, \"bad prepared statement name length\");\n-\n-        lo = hi + 1;\n-\n-        hi = getStringLength(lo, msgLimit);\n-        checkNotTrue(hi == -1, \"bad query text length\");\n-\n-        prepareForNewQuery();\n-        parseQueryText(lo, hi);\n-\n-        lo = hi + 1;\n-\n-        checkNotTrue(lo + Short.BYTES > msgLimit, \"could not read parameter count\");\n-\n-        short parameterCount = getShort(lo);\n-\n-        if (parameterCount > 0) {\n-            if (lo + Short.BYTES + parameterCount * Integer.BYTES > msgLimit) {\n-                LOG.error()\n-                        .$(\"could not read parameters [parameterCount=\").$(parameterCount)\n-                        .$(\", offset=\").$(lo - address)\n-                        .$(\", remaining=\").$(msgLimit - lo)\n-                        .$(']').$();\n-                throw BadProtocolException.INSTANCE;\n-            }\n-\n-            LOG.debug().$(\"params [count=\").$(parameterCount).$(']').$();\n-            lo += Short.BYTES;\n-\n-            bindVariableService.clear();\n-            setupBindVariables(lo, parameterCount, bindVariableSetters);\n-        } else if (parameterCount < 0) {\n-            LOG.error()\n-                    .$(\"invalid parameter count [parameterCount=\").$(parameterCount)\n-                    .$(\", offset=\").$(lo - address)\n-                    .$(']').$();\n-            throw BadProtocolException.INSTANCE;\n-        }\n-\n-        // at this point we may have a current query that is not null\n-        // this is ok to lose reference to this query because we have cache\n-        // of all of them, which is looked up by query text\n-\n-        responseAsciiSink.reset();\n-        final Object statement = factoryCache.peek(queryText);\n-        if (statement == null) {\n-            final CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);\n-            sqlExecutionContext.storeTelemetry(cc.getType(), TelemetryOrigin.PG_WIRE);\n-\n-            switch (cc.getType()) {\n-                case CompiledQuery.SELECT:\n-                    currentFactory = cc.getRecordCursorFactory();\n-                    queryTag = TAG_SELECT;\n-                    factoryCache.put(queryText, currentFactory);\n-                    break;\n-                case CompiledQuery.INSERT:\n-                    currentInsertStatement = cc.getInsertStatement();\n-                    queryTag = TAG_INSERT;\n-                    factoryCache.put(queryText, currentInsertStatement);\n-                    break;\n-                case CompiledQuery.COPY_LOCAL:\n-                    queryTag = TAG_COPY;\n-                    sendCopyInResponse(compiler.getEngine(), cc.getTextLoader());\n-                    break;\n-                default:\n-                    // DDL SQL\n-                    queryTag = TAG_OK;\n-                    prepareParseComplete();\n-                    prepareReadyForQuery(responseAsciiSink);\n-                    LOG.info().$(\"executed DDL\").$();\n-                    send();\n-                    break;\n-            }\n-        } else {\n-            if (statement instanceof RecordCursorFactory) {\n+    private void setupNamedStatement(ObjList<BindVariableSetter> bindVariableSetters, CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap, CharSequence statementName) throws SqlException {\n+        if (statementName != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU1OTY4NA==", "bodyText": "lets put braces here {", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469559684", "createdAt": "2020-08-12T21:33:42Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -781,6 +795,21 @@ private void executeSelect(\n         currentCursor = factory.getCursor(sqlExecutionContext);\n         prepareRowDescription();\n         sendCursor();\n+        send();\n+    }\n+\n+    @Nullable\n+    private CharSequence getStatementName(long lo, long hi) throws BadProtocolException {\n+        CharacterStoreEntry e = portalCharacterStore.newEntry();\n+        CharSequence statementName = null;\n+        if (hi - lo > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MDk0Ng==", "bodyText": "what would happen to this instance if parameterCount == 0 && statementName == null ?", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469560946", "createdAt": "2020-08-12T21:36:28Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1005,23 +1056,171 @@ private void processBind(@Transient ObjList<BindVariableSetter> bindVariableSett\n             lo += Short.BYTES;\n             bindVariables(lo, msgLimit, parameterCount, bindVariableSetters);\n         }\n-    }\n+        prepareBindComplete();\n+    }\n+\n+    private void processClose(long lo, long msgLimit, CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws BadProtocolException {\n+        final byte type = Unsafe.getUnsafe().getByte(lo);\n+        if (type == 'S') {\n+            lo = lo + 1;\n+            long hi = getStringLength(lo, msgLimit);\n+            checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+            CharSequence statementName = getStatementName(lo, hi);\n+            if (statementName != null) {\n+                final NamedStatementWrapper wrapper = namedStatementMap.get(statementName);\n+                wrapper.clear();\n+                bindVarTypesStack.push(wrapper.bindVariableTypes);\n+                namedStatementWrapperStack.push(wrapper);\n+            }\n+        }\n \n-    private void processClose() throws PeerDisconnectedException, PeerIsSlowToReadException {\n-        prepareForNewQuery();\n         sink().put('3'); // close complete\n         sink().putNetworkInt(Integer.BYTES);\n-        send();\n     }\n \n-    private void processDescribe() throws PeerDisconnectedException, PeerIsSlowToReadException {\n+    private void processDescribe(@Transient ObjList<BindVariableSetter> bindVariableSetters,\n+                                 long lo,\n+                                 long msgLimit,\n+                                 @Transient CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws SqlException, BadProtocolException {\n+        lo = lo + 1;\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad portal name length [msgType='D']\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+        setupNamedStatement(bindVariableSetters, namedStatementMap, statementName);\n+\n         if (currentFactory != null) {\n             prepareRowDescription();\n-            send();\n             LOG.info().$(\"described\").$();\n         }\n     }\n \n+    private void processParse(\n+            long address,\n+            long lo,\n+            long msgLimit,\n+            @Transient SqlCompiler compiler,\n+            @Transient AssociativeCache<Object> factoryCache,\n+            @Transient CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap,\n+            @Transient ObjList<BindVariableSetter> bindVariableSetters\n+    ) throws BadProtocolException, SqlException, PeerDisconnectedException, PeerIsSlowToReadException {\n+        // 'Parse'\n+        // this appears to be the execution side - we must at least return 'RowDescription'\n+        // possibly more, check QueryExecutionImpl.processResults() in PG driver for more info\n+\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+\n+        lo = hi + 1;\n+\n+        hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad query text length\");\n+\n+        prepareForNewQuery();\n+        parseQueryText(lo, hi);\n+\n+        lo = hi + 1;\n+\n+        checkNotTrue(lo + Short.BYTES > msgLimit, \"could not read parameter count\");\n+\n+        short parameterCount = getShort(lo);\n+\n+        IntList bindVariableTypes = bindVarTypesStack.pop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NDQ0NA==", "bodyText": "wrapper.clear() sets bindVariableTypes to null. This code proceeded to fill stack with nulls. This seems rushed and untested.", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469564444", "createdAt": "2020-08-12T21:44:33Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1005,23 +1056,171 @@ private void processBind(@Transient ObjList<BindVariableSetter> bindVariableSett\n             lo += Short.BYTES;\n             bindVariables(lo, msgLimit, parameterCount, bindVariableSetters);\n         }\n-    }\n+        prepareBindComplete();\n+    }\n+\n+    private void processClose(long lo, long msgLimit, CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws BadProtocolException {\n+        final byte type = Unsafe.getUnsafe().getByte(lo);\n+        if (type == 'S') {\n+            lo = lo + 1;\n+            long hi = getStringLength(lo, msgLimit);\n+            checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+            CharSequence statementName = getStatementName(lo, hi);\n+            if (statementName != null) {\n+                final NamedStatementWrapper wrapper = namedStatementMap.get(statementName);\n+                wrapper.clear();\n+                bindVarTypesStack.push(wrapper.bindVariableTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NTY0NA==", "bodyText": "We perhaps should have only one, unambiguous indicator that wrapper needs bind variable types. Perhaps \"null\" is better", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469565644", "createdAt": "2020-08-12T21:47:07Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1005,23 +1056,171 @@ private void processBind(@Transient ObjList<BindVariableSetter> bindVariableSett\n             lo += Short.BYTES;\n             bindVariables(lo, msgLimit, parameterCount, bindVariableSetters);\n         }\n-    }\n+        prepareBindComplete();\n+    }\n+\n+    private void processClose(long lo, long msgLimit, CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws BadProtocolException {\n+        final byte type = Unsafe.getUnsafe().getByte(lo);\n+        if (type == 'S') {\n+            lo = lo + 1;\n+            long hi = getStringLength(lo, msgLimit);\n+            checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+            CharSequence statementName = getStatementName(lo, hi);\n+            if (statementName != null) {\n+                final NamedStatementWrapper wrapper = namedStatementMap.get(statementName);\n+                wrapper.clear();\n+                bindVarTypesStack.push(wrapper.bindVariableTypes);\n+                namedStatementWrapperStack.push(wrapper);\n+            }\n+        }\n \n-    private void processClose() throws PeerDisconnectedException, PeerIsSlowToReadException {\n-        prepareForNewQuery();\n         sink().put('3'); // close complete\n         sink().putNetworkInt(Integer.BYTES);\n-        send();\n     }\n \n-    private void processDescribe() throws PeerDisconnectedException, PeerIsSlowToReadException {\n+    private void processDescribe(@Transient ObjList<BindVariableSetter> bindVariableSetters,\n+                                 long lo,\n+                                 long msgLimit,\n+                                 @Transient CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws SqlException, BadProtocolException {\n+        lo = lo + 1;\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad portal name length [msgType='D']\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+        setupNamedStatement(bindVariableSetters, namedStatementMap, statementName);\n+\n         if (currentFactory != null) {\n             prepareRowDescription();\n-            send();\n             LOG.info().$(\"described\").$();\n         }\n     }\n \n+    private void processParse(\n+            long address,\n+            long lo,\n+            long msgLimit,\n+            @Transient SqlCompiler compiler,\n+            @Transient AssociativeCache<Object> factoryCache,\n+            @Transient CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap,\n+            @Transient ObjList<BindVariableSetter> bindVariableSetters\n+    ) throws BadProtocolException, SqlException, PeerDisconnectedException, PeerIsSlowToReadException {\n+        // 'Parse'\n+        // this appears to be the execution side - we must at least return 'RowDescription'\n+        // possibly more, check QueryExecutionImpl.processResults() in PG driver for more info\n+\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+\n+        lo = hi + 1;\n+\n+        hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad query text length\");\n+\n+        prepareForNewQuery();\n+        parseQueryText(lo, hi);\n+\n+        lo = hi + 1;\n+\n+        checkNotTrue(lo + Short.BYTES > msgLimit, \"could not read parameter count\");\n+\n+        short parameterCount = getShort(lo);\n+\n+        IntList bindVariableTypes = bindVarTypesStack.pop();\n+        if (parameterCount > 0) {\n+            if (lo + Short.BYTES + parameterCount * Integer.BYTES > msgLimit) {\n+                LOG.error()\n+                        .$(\"could not read parameters [parameterCount=\").$(parameterCount)\n+                        .$(\", offset=\").$(lo - address)\n+                        .$(\", remaining=\").$(msgLimit - lo)\n+                        .$(']').$();\n+                throw BadProtocolException.INSTANCE;\n+            }\n+\n+            LOG.debug().$(\"params [count=\").$(parameterCount).$(']').$();\n+            lo += Short.BYTES;\n+            bindVariableService.clear();\n+            if (bindVariableTypes == null) {\n+                bindVariableTypes = new IntList();\n+            }\n+            bindVariableTypes.clear();\n+            setupBindVariables(lo, parameterCount, bindVariableSetters, bindVariableTypes);\n+        } else if (parameterCount < 0) {\n+            LOG.error()\n+                    .$(\"invalid parameter count [parameterCount=\").$(parameterCount)\n+                    .$(\", offset=\").$(lo - address)\n+                    .$(']').$();\n+            throw BadProtocolException.INSTANCE;\n+        }\n+\n+        // at this point we may have a current query that is not null\n+        // this is ok to lose reference to this query because we have cache\n+        // of all of them, which is looked up by query text\n+        responseAsciiSink.reset();\n+        final Object statement = factoryCache.peek(queryText);\n+        if (statement == null) {\n+            if (queryText.length() > 0) {\n+                final CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);\n+                sqlExecutionContext.storeTelemetry(cc.getType(), TelemetryOrigin.PG_WIRE);\n+\n+                switch (cc.getType()) {\n+                    case CompiledQuery.SELECT:\n+                        currentFactory = cc.getRecordCursorFactory();\n+                        queryTag = TAG_SELECT;\n+                        factoryCache.put(queryText, currentFactory);\n+                        break;\n+                    case CompiledQuery.INSERT:\n+                        currentInsertStatement = cc.getInsertStatement();\n+                        queryTag = TAG_INSERT;\n+                        factoryCache.put(queryText, currentInsertStatement);\n+                        break;\n+                    case CompiledQuery.COPY_LOCAL:\n+                        queryTag = TAG_COPY;\n+                        sendCopyInResponse(compiler.getEngine(), cc.getTextLoader());\n+                        break;\n+                    case CompiledQuery.SET:\n+                        queryTag = TAG_SET;\n+                        break;\n+                    default:\n+                        // DDL SQL\n+                        queryTag = TAG_OK;\n+                        break;\n+                }\n+            } else {\n+                isEmptyQuery = true;\n+            }\n+        } else {\n+            if (statement instanceof RecordCursorFactory) {\n+                queryTag = TAG_SELECT;\n+                currentFactory = (RecordCursorFactory) statement;\n+            } else if (statement instanceof InsertStatement) {\n+                queryTag = TAG_INSERT;\n+                currentInsertStatement = (InsertStatement) statement;\n+            } else {\n+                assert false;\n+            }\n+        }\n+        //cache named statement\n+        if (statementName != null) {\n+            NamedStatementWrapper wrapper = namedStatementWrapperStack.pop();\n+            if (wrapper == null) {\n+                wrapper = new NamedStatementWrapper();\n+            }\n+            if (currentFactory != null) {\n+                wrapper.selectFactory = currentFactory;\n+            }\n+            if (currentInsertStatement != null) {\n+                wrapper.insertStatement = currentInsertStatement;\n+            }\n+            if (bindVariableTypes != null && bindVariableTypes.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NjE5Ng==", "bodyText": "factory and insert statement are mutually exclusive, we should have else if here", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469566196", "createdAt": "2020-08-12T21:48:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1005,23 +1056,171 @@ private void processBind(@Transient ObjList<BindVariableSetter> bindVariableSett\n             lo += Short.BYTES;\n             bindVariables(lo, msgLimit, parameterCount, bindVariableSetters);\n         }\n-    }\n+        prepareBindComplete();\n+    }\n+\n+    private void processClose(long lo, long msgLimit, CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws BadProtocolException {\n+        final byte type = Unsafe.getUnsafe().getByte(lo);\n+        if (type == 'S') {\n+            lo = lo + 1;\n+            long hi = getStringLength(lo, msgLimit);\n+            checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+            CharSequence statementName = getStatementName(lo, hi);\n+            if (statementName != null) {\n+                final NamedStatementWrapper wrapper = namedStatementMap.get(statementName);\n+                wrapper.clear();\n+                bindVarTypesStack.push(wrapper.bindVariableTypes);\n+                namedStatementWrapperStack.push(wrapper);\n+            }\n+        }\n \n-    private void processClose() throws PeerDisconnectedException, PeerIsSlowToReadException {\n-        prepareForNewQuery();\n         sink().put('3'); // close complete\n         sink().putNetworkInt(Integer.BYTES);\n-        send();\n     }\n \n-    private void processDescribe() throws PeerDisconnectedException, PeerIsSlowToReadException {\n+    private void processDescribe(@Transient ObjList<BindVariableSetter> bindVariableSetters,\n+                                 long lo,\n+                                 long msgLimit,\n+                                 @Transient CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap) throws SqlException, BadProtocolException {\n+        lo = lo + 1;\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad portal name length [msgType='D']\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+        setupNamedStatement(bindVariableSetters, namedStatementMap, statementName);\n+\n         if (currentFactory != null) {\n             prepareRowDescription();\n-            send();\n             LOG.info().$(\"described\").$();\n         }\n     }\n \n+    private void processParse(\n+            long address,\n+            long lo,\n+            long msgLimit,\n+            @Transient SqlCompiler compiler,\n+            @Transient AssociativeCache<Object> factoryCache,\n+            @Transient CharSequenceObjHashMap<NamedStatementWrapper> namedStatementMap,\n+            @Transient ObjList<BindVariableSetter> bindVariableSetters\n+    ) throws BadProtocolException, SqlException, PeerDisconnectedException, PeerIsSlowToReadException {\n+        // 'Parse'\n+        // this appears to be the execution side - we must at least return 'RowDescription'\n+        // possibly more, check QueryExecutionImpl.processResults() in PG driver for more info\n+\n+        long hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad prepared statement name length\");\n+\n+        CharSequence statementName = getStatementName(lo, hi);\n+\n+        lo = hi + 1;\n+\n+        hi = getStringLength(lo, msgLimit);\n+        checkNotTrue(hi == -1, \"bad query text length\");\n+\n+        prepareForNewQuery();\n+        parseQueryText(lo, hi);\n+\n+        lo = hi + 1;\n+\n+        checkNotTrue(lo + Short.BYTES > msgLimit, \"could not read parameter count\");\n+\n+        short parameterCount = getShort(lo);\n+\n+        IntList bindVariableTypes = bindVarTypesStack.pop();\n+        if (parameterCount > 0) {\n+            if (lo + Short.BYTES + parameterCount * Integer.BYTES > msgLimit) {\n+                LOG.error()\n+                        .$(\"could not read parameters [parameterCount=\").$(parameterCount)\n+                        .$(\", offset=\").$(lo - address)\n+                        .$(\", remaining=\").$(msgLimit - lo)\n+                        .$(']').$();\n+                throw BadProtocolException.INSTANCE;\n+            }\n+\n+            LOG.debug().$(\"params [count=\").$(parameterCount).$(']').$();\n+            lo += Short.BYTES;\n+            bindVariableService.clear();\n+            if (bindVariableTypes == null) {\n+                bindVariableTypes = new IntList();\n+            }\n+            bindVariableTypes.clear();\n+            setupBindVariables(lo, parameterCount, bindVariableSetters, bindVariableTypes);\n+        } else if (parameterCount < 0) {\n+            LOG.error()\n+                    .$(\"invalid parameter count [parameterCount=\").$(parameterCount)\n+                    .$(\", offset=\").$(lo - address)\n+                    .$(']').$();\n+            throw BadProtocolException.INSTANCE;\n+        }\n+\n+        // at this point we may have a current query that is not null\n+        // this is ok to lose reference to this query because we have cache\n+        // of all of them, which is looked up by query text\n+        responseAsciiSink.reset();\n+        final Object statement = factoryCache.peek(queryText);\n+        if (statement == null) {\n+            if (queryText.length() > 0) {\n+                final CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);\n+                sqlExecutionContext.storeTelemetry(cc.getType(), TelemetryOrigin.PG_WIRE);\n+\n+                switch (cc.getType()) {\n+                    case CompiledQuery.SELECT:\n+                        currentFactory = cc.getRecordCursorFactory();\n+                        queryTag = TAG_SELECT;\n+                        factoryCache.put(queryText, currentFactory);\n+                        break;\n+                    case CompiledQuery.INSERT:\n+                        currentInsertStatement = cc.getInsertStatement();\n+                        queryTag = TAG_INSERT;\n+                        factoryCache.put(queryText, currentInsertStatement);\n+                        break;\n+                    case CompiledQuery.COPY_LOCAL:\n+                        queryTag = TAG_COPY;\n+                        sendCopyInResponse(compiler.getEngine(), cc.getTextLoader());\n+                        break;\n+                    case CompiledQuery.SET:\n+                        queryTag = TAG_SET;\n+                        break;\n+                    default:\n+                        // DDL SQL\n+                        queryTag = TAG_OK;\n+                        break;\n+                }\n+            } else {\n+                isEmptyQuery = true;\n+            }\n+        } else {\n+            if (statement instanceof RecordCursorFactory) {\n+                queryTag = TAG_SELECT;\n+                currentFactory = (RecordCursorFactory) statement;\n+            } else if (statement instanceof InsertStatement) {\n+                queryTag = TAG_INSERT;\n+                currentInsertStatement = (InsertStatement) statement;\n+            } else {\n+                assert false;\n+            }\n+        }\n+        //cache named statement\n+        if (statementName != null) {\n+            NamedStatementWrapper wrapper = namedStatementWrapperStack.pop();\n+            if (wrapper == null) {\n+                wrapper = new NamedStatementWrapper();\n+            }\n+            if (currentFactory != null) {\n+                wrapper.selectFactory = currentFactory;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2NzA4NQ==", "bodyText": "we should have WeakObjectPool here. It has array dequeue underneath but does the null checking and object instantiation behind the scenes.", "url": "https://github.com/questdb/questdb/pull/544#discussion_r469567085", "createdAt": "2020-08-12T21:50:38Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -104,6 +109,8 @@\n     private final BindVariableSetter strSetter = this::setStrBindVariable;\n     private final BindVariableSetter noopSetter = this::setNoopBindVariable;\n     private final ObjList<ColumnAppender> columnAppenders = new ObjList<>();\n+    private final ObjStack<IntList> bindVarTypesStack = new ObjStack<>(16);\n+    private final ObjStack<NamedStatementWrapper> namedStatementWrapperStack = new ObjStack<>(16);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60e0e7ec07a74e550ce3965803dd404cc92851d7"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a57ada81ce3831fbee322f687909fce140e85e", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/86a57ada81ce3831fbee322f687909fce140e85e", "committedDate": "2020-08-13T14:19:52Z", "message": "PG Wire - close message fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5e739707ec0580d216aed04732d255661b7a16", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/9c5e739707ec0580d216aed04732d255661b7a16", "committedDate": "2020-08-13T15:59:53Z", "message": "PG Wire - removing unnecessary clear() calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2755d7e4008f2e92db8de0f6e32811f757e8e9b", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/b2755d7e4008f2e92db8de0f6e32811f757e8e9b", "committedDate": "2020-08-13T16:05:49Z", "message": "PG Wire - removing superflous null check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2c2f5a5561db5039f5ff80db01ae9b0b5fdccbf", "author": {"user": null}, "url": "https://github.com/questdb/questdb/commit/c2c2f5a5561db5039f5ff80db01ae9b0b5fdccbf", "committedDate": "2020-08-13T18:25:36Z", "message": "PG Wire - added test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39202a410b913af9a61cb9847143584e1930cb04", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/39202a410b913af9a61cb9847143584e1930cb04", "committedDate": "2020-08-13T20:24:35Z", "message": "chore(cutlass): pg-wire code tidy up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTA1OTI5", "url": "https://github.com/questdb/questdb/pull/544#pullrequestreview-467105929", "createdAt": "2020-08-13T20:27:40Z", "commit": {"oid": "39202a410b913af9a61cb9847143584e1930cb04"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3193, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}