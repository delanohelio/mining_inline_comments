{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzgyMDIy", "number": 308, "title": "chore: questdb can be configured to limit the number of in memory rows", "bodyText": "", "createdAt": "2020-05-19T21:44:58Z", "url": "https://github.com/questdb/questdb/pull/308", "merged": true, "mergeCommit": {"oid": "8788449a6261a794da8c9dc6433d9d3af19cb154"}, "closed": true, "closedAt": "2020-05-20T22:42:24Z", "author": {"login": "patrickSpaceSurfer"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABci7jYSgH2gAyNDIwMzgyMDIyOjExMzJjZTY1MzQzNzY5MGU2YjkzNDhmN2Q5NTA4ZjEzYzQ2ZTg4ZDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjRANngFqTQxNTc2NDE3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1132ce653437690e6b9348f7d9508f13c46e88d8", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/1132ce653437690e6b9348f7d9508f13c46e88d8", "committedDate": "2020-05-19T21:42:33Z", "message": "chore: questdb can be configured to limit the number of in memory rows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bc9341c23870b6d6a2b8a546831e475bb3940a9", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/1bc9341c23870b6d6a2b8a546831e475bb3940a9", "committedDate": "2020-05-20T08:48:32Z", "message": "chore: Allow queries that fail for certain exceptions (security) to be cached"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e74c41f8f325316b8283662103c837857f49d4", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/a3e74c41f8f325316b8283662103c837857f49d4", "committedDate": "2020-05-20T10:36:40Z", "message": "chore: Allow queries that fail for certain exceptions (security) to be cached"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2670ca1dbe3d02c94707708e4bdf5ad29e0dc286", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/2670ca1dbe3d02c94707708e4bdf5ad29e0dc286", "committedDate": "2020-05-20T13:30:45Z", "message": "chore: questdb can be configured to limit the number of in memory rows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e46df08a3c5c847e3b5ef542515256f33d7528c3", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/e46df08a3c5c847e3b5ef542515256f33d7528c3", "committedDate": "2020-05-20T15:47:49Z", "message": "chore: Allow queries that fail for certain exceptions (security) to be cached"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0f4d919fd7691c62cf119c330df048fdba6caff", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/f0f4d919fd7691c62cf119c330df048fdba6caff", "committedDate": "2020-05-20T16:07:45Z", "message": "chore: questdb can be configured to limit the number of in memory rows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/b3dce73c5599ea46c177023eded6378f03037e6d", "committedDate": "2020-05-20T16:45:19Z", "message": "chore: questdb can be configured to limit the number of in memory rows"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Njc1Mzkx", "url": "https://github.com/questdb/questdb/pull/308#pullrequestreview-415675391", "createdAt": "2020-05-20T20:06:48Z", "commit": {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDowNjo0OFrOGYb97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDowOTo0MFrOGYcEQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyOQ==", "bodyText": "This is what we were talking about this morning. 99% of the flow goes over mispredicted branch.\nhttps://dzone.com/articles/branch-prediction-in-java\nAdditionally, I would suggest that \"max\" value is set to Long.MAX_VALUE. With this choice of \"allow all\" value branching will look like:\nfinal long cursorSize = baseCursor.size();\nif (cursorSize < maxInMemoryRows) {\n// do the good stuff\n} else {\n      throw ....\n}", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428277229", "createdAt": "2020-05-20T20:06:48Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java", "diffHunk": "@@ -112,7 +113,13 @@ public boolean recordCursorSupportsRandomAccess() {\n     }\n \n     @NotNull\n-    protected RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+    private RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+        long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+        if (maxInMemoryRows >= 0 && baseCursor.size() >= 0 && baseCursor.size() > maxInMemoryRows) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3ODg1MA==", "bodyText": "we have more naughty places that trigger branch issues, but we should stop their proliferation", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428278850", "createdAt": "2020-05-20T20:09:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java", "diffHunk": "@@ -112,7 +113,13 @@ public boolean recordCursorSupportsRandomAccess() {\n     }\n \n     @NotNull\n-    protected RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+    private RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+        long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+        if (maxInMemoryRows >= 0 && baseCursor.size() >= 0 && baseCursor.size() > maxInMemoryRows) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyOQ=="}, "originalCommit": {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/45b63cc11c880f8969f6052bff045a41c24a6857", "committedDate": "2020-05-20T21:35:11Z", "message": "chore: questdb can be configured to limit the number of in memory rows"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NzM0NTQ0", "url": "https://github.com/questdb/questdb/pull/308#pullrequestreview-415734544", "createdAt": "2020-05-20T21:40:26Z", "commit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MDoyNlrOGYeyFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MjozN1rOGYe2kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzM0OA==", "bodyText": "|| baseCursor.size() < 0\nis not necessary :)", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428323348", "createdAt": "2020-05-20T21:40:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java", "diffHunk": "@@ -135,43 +158,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzc2OA==", "bodyText": "same", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428323768", "createdAt": "2020-05-20T21:41:21Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "diffHunk": "@@ -154,43 +178,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyNDQ5Nw==", "bodyText": "this is purely syntax, (no extra code should be generated). But when there is return statement inside if statement, else branch is not necessary", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428324497", "createdAt": "2020-05-20T21:42:37Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "diffHunk": "@@ -154,43 +178,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+                map.setMaxSize(maxInMemoryRows);\n+\n+                // This factory fills gaps in data. To do that we\n+                // have to know all possible key values. Essentially, every time\n+                // we sample we return same set of key values with different\n+                // aggregation results and timestamp\n+\n+                int n = groupByFunctions.size();\n+                final Record baseCursorRecord = baseCursor.getRecord();\n+                while (baseCursor.hasNext()) {\n+                    MapKey key = map.withKey();\n+                    mapSink.copy(baseCursorRecord, key);\n+                    MapValue value = key.createValue();\n+                    if (value.isNew()) {\n+                        // timestamp is always stored in value field 0\n+                        value.putLong(0, Numbers.LONG_NaN);\n+                        // have functions reset their columns to \"zero\" state\n+                        // this would set values for when keys are not found right away\n+                        for (int i = 0; i < n; i++) {\n+                            groupByFunctions.getQuick(i).setNull(value);\n+                        }\n+                    }\n+                }\n+\n+                // empty map? this means that base cursor was empty\n+                if (map.size() == 0) {\n+                    baseCursor.close();\n+                    return EmptyTableRecordCursor.INSTANCE;\n                 }\n-            }\n-        }\n \n-        // empty map? this means that base cursor was empty\n-        if (map.size() == 0) {\n+                // because we pass base cursor twice we have to go back to top\n+                // for the second run\n+                baseCursor.toTop();\n+                boolean next = baseCursor.hasNext();\n+                // we know base cursor has value\n+                assert next;\n+                return initFunctionsAndCursor(executionContext, baseCursor);\n+            } else {\n+                throw LimitOverflowException.instance(maxInMemoryRows);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "originalPosition": 120}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "900655ddb51fbc48f854958fb0ee8125c01f5cdf", "author": {"user": {"login": "patrickSpaceSurfer", "name": "Patrick Mackinlay"}}, "url": "https://github.com/questdb/questdb/commit/900655ddb51fbc48f854958fb0ee8125c01f5cdf", "committedDate": "2020-05-20T22:08:41Z", "message": "chore: questdb can be configured to limit the number of in memory rows"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NzY0MTcy", "url": "https://github.com/questdb/questdb/pull/308#pullrequestreview-415764172", "createdAt": "2020-05-20T22:42:03Z", "commit": {"oid": "900655ddb51fbc48f854958fb0ee8125c01f5cdf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3323, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}