{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxOTA1NDIx", "number": 470, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjowMzo1NVrOEKKwHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTowOTo0MFrOEKd5Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDk3Mzc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjowMzo1NVrOGrDjaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo0MzoxN1rOGrHq7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMDE2OQ==", "bodyText": "if you cannot open \"writerConfig\", constructor will leak \"writer\" instance.", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447800169", "createdAt": "2020-06-30T16:03:55Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MicrosecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMicrosecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NzYzMQ==", "bodyText": "Done", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447867631", "createdAt": "2020-06-30T17:43:17Z", "author": {"login": "mpsq"}, "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MicrosecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMicrosecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMDE2OQ=="}, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDk5MTE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjowODoxN1rOGrDubA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo0MjozNlrOGrHpRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjk4OA==", "bodyText": "ts appears to be in microseconds, putDate() expects millis", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447802988", "createdAt": "2020-06-30T16:08:17Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MicrosecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMicrosecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        try (TableReader reader = new TableReader(cairoConfig, configTableName)) {\n+            final NanosecondClock nanosecondClock = cairoConfig.getNanosecondClock();\n+\n+            if (reader.size() > 0) {\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+                final boolean _enabled = reader.getCursor().getRecord().getBool(1);\n+\n+                if (enabled != _enabled) {\n+                    final TableWriter.Row row = writerConfig.newRow();\n+                    row.putLong256(0, idSink);\n+                    row.putBool(1, enabled);\n+                    row.append();\n+                    writerConfig.commit();\n+                }\n+            } else {\n+                final TableWriter.Row row = writerConfig.newRow();\n+                row.putLong256(0, nanosecondClock.getTicks(), clock.getTicks(), 0, 0);\n+                row.putBool(1, enabled);\n+                row.append();\n+                writerConfig.commit();\n+                reader.reload();\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+            }\n+        }\n+\n+        newRow(TelemetryEvent.UP);\n+    }\n+\n+    public int getTableStatus(Path path, CharSequence tableName) {\n+        return TableUtils.exists(\n+                configuration.getCairoConfiguration().getFilesFacade(),\n+                path,\n+                configuration.getCairoConfiguration().getRoot(),\n+                tableName,\n+                0,\n+                tableName.length()\n+        );\n+    }\n+\n+    private void newRow(short event) {\n+        if (enabled) {\n+            final TableWriter.Row row = writer.newRow();\n+            row.putDate(0, clock.getTicks());\n+            row.putShort(1, event);\n+            row.append();\n+        }\n+    }\n+\n+    private void newRowConsumer(TelemetryTask telemetryRow) {\n+        final TableWriter.Row row = writer.newRow();\n+        row.putDate(0, telemetryRow.ts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NzIwNQ==", "bodyText": "Done", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447867205", "createdAt": "2020-06-30T17:42:36Z", "author": {"login": "mpsq"}, "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MicrosecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMicrosecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        try (TableReader reader = new TableReader(cairoConfig, configTableName)) {\n+            final NanosecondClock nanosecondClock = cairoConfig.getNanosecondClock();\n+\n+            if (reader.size() > 0) {\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+                final boolean _enabled = reader.getCursor().getRecord().getBool(1);\n+\n+                if (enabled != _enabled) {\n+                    final TableWriter.Row row = writerConfig.newRow();\n+                    row.putLong256(0, idSink);\n+                    row.putBool(1, enabled);\n+                    row.append();\n+                    writerConfig.commit();\n+                }\n+            } else {\n+                final TableWriter.Row row = writerConfig.newRow();\n+                row.putLong256(0, nanosecondClock.getTicks(), clock.getTicks(), 0, 0);\n+                row.putBool(1, enabled);\n+                row.append();\n+                writerConfig.commit();\n+                reader.reload();\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+            }\n+        }\n+\n+        newRow(TelemetryEvent.UP);\n+    }\n+\n+    public int getTableStatus(Path path, CharSequence tableName) {\n+        return TableUtils.exists(\n+                configuration.getCairoConfiguration().getFilesFacade(),\n+                path,\n+                configuration.getCairoConfiguration().getRoot(),\n+                tableName,\n+                0,\n+                tableName.length()\n+        );\n+    }\n+\n+    private void newRow(short event) {\n+        if (enabled) {\n+            final TableWriter.Row row = writer.newRow();\n+            row.putDate(0, clock.getTicks());\n+            row.putShort(1, event);\n+            row.append();\n+        }\n+    }\n+\n+    private void newRowConsumer(TelemetryTask telemetryRow) {\n+        final TableWriter.Row row = writer.newRow();\n+        row.putDate(0, telemetryRow.ts);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjk4OA=="}, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTAwMTM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxMDozOFrOGrD0jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxMDozOFrOGrD0jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNDU1OQ==", "bodyText": "I hate to creep the scope here, but it would be super useful to capture execution site, e.g. PG wire, http etc", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447804559", "createdAt": "2020-06-30T16:10:38Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1241,6 +1243,7 @@ private void processQuery(\n         final Object statement = factoryCache.peek(queryText);\n         if (statement == null) {\n             final CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);\n+            sqlExecutionContext.storeTelemetry(cc.getType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTAxMjcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlExecutionContextImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxMjo0N1rOGrD7IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo0Nzo1OVrOGrH1PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjI0MA==", "bodyText": "you absolutely must check the value of the cursor here. When queue is full, cursor == -1, the store has to be a noop. when cursor = -2, next() must be retried", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447806240", "createdAt": "2020-06-30T16:12:47Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlExecutionContextImpl.java", "diffHunk": "@@ -121,6 +135,28 @@ public SqlExecutionInterruptor getSqlExecutionInterruptor() {\n         return interruptor;\n     }\n \n+    @Override\n+    public void storeTelemetry(short event) {\n+        telemetryMethod.store(event);\n+    }\n+\n+    private void doStoreTelemetry(short event) {\n+        final long cursor = telemetryPubSeq.next();\n+        TelemetryTask row = telemetryQueue.get(cursor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDI2OQ==", "bodyText": "Done", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447870269", "createdAt": "2020-06-30T17:47:59Z", "author": {"login": "mpsq"}, "path": "core/src/main/java/io/questdb/griffin/SqlExecutionContextImpl.java", "diffHunk": "@@ -121,6 +135,28 @@ public SqlExecutionInterruptor getSqlExecutionInterruptor() {\n         return interruptor;\n     }\n \n+    @Override\n+    public void storeTelemetry(short event) {\n+        telemetryMethod.store(event);\n+    }\n+\n+    private void doStoreTelemetry(short event) {\n+        final long cursor = telemetryPubSeq.next();\n+        TelemetryTask row = telemetryQueue.get(cursor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjI0MA=="}, "originalCommit": {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDAyMjM2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo0MjowNVrOGrgnJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo0MjowNVrOGrgnJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NjI2MQ==", "bodyText": "consiguration instance like this already exists at the class level (static)", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448276261", "createdAt": "2020-07-01T10:42:05Z", "author": {"login": "bluestreak01"}, "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "diffHunk": "@@ -105,4 +105,20 @@ protected void assertThat(CharSequence expected, RecordCursor cursor, RecordMeta\n         cursor.toTop();\n         assertOnce(expected, cursor, metadata, header);\n     }\n+\n+    protected void assertColumn(CharSequence expected, CharSequence tableName, int index) {\n+        DefaultCairoConfiguration configuration = new DefaultCairoConfiguration(root);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDA1NzE1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/questdb/TelemetryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1Mjo1M1rOGrg8Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1Mjo1M1rOGrg8Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTY3OA==", "bodyText": "engine is unused here", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448281678", "createdAt": "2020-07-01T10:52:53Z", "author": {"login": "bluestreak01"}, "path": "core/src/test/java/io/questdb/TelemetryTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.std.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.test.tools.*;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Properties;\n+\n+public class TelemetryTest extends AbstractCairoTest {\n+    private final static FilesFacade FF = FilesFacadeImpl.INSTANCE;\n+\n+    @Test\n+    public void testTelemetryDisabledByDefault() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDA1OTMwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/questdb/TelemetryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1Mzo0MFrOGrg9rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1Mzo0MFrOGrg9rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MjAzMQ==", "bodyText": "can use existing configuration instance here", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448282031", "createdAt": "2020-07-01T10:53:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/test/java/io/questdb/TelemetryTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.std.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.test.tools.*;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Properties;\n+\n+public class TelemetryTest extends AbstractCairoTest {\n+    private final static FilesFacade FF = FilesFacadeImpl.INSTANCE;\n+\n+    @Test\n+    public void testTelemetryDisabledByDefault() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryCreatesTablesWhenEnabled() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                final TelemetryJob telemetryJob = new TelemetryJob(serverConfiguration, engine, messageBus);\n+\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+\n+                Misc.free(telemetryJob);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryStoresUpAndDownEvents() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            serverConfiguration = new PropServerConfiguration(temp.getRoot().getAbsolutePath(), new Properties()) {\n+                @Override\n+                public CairoConfiguration getCairoConfiguration() {\n+                    return new DefaultCairoConfiguration(root);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDA2MDI3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/questdb/TelemetryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1Mzo1N1rOGrg-Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1Mzo1N1rOGrg-Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MjE4Ng==", "bodyText": "unused method", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448282186", "createdAt": "2020-07-01T10:53:57Z", "author": {"login": "bluestreak01"}, "path": "core/src/test/java/io/questdb/TelemetryTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.std.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.test.tools.*;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Properties;\n+\n+public class TelemetryTest extends AbstractCairoTest {\n+    private final static FilesFacade FF = FilesFacadeImpl.INSTANCE;\n+\n+    @Test\n+    public void testTelemetryDisabledByDefault() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryCreatesTablesWhenEnabled() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                final TelemetryJob telemetryJob = new TelemetryJob(serverConfiguration, engine, messageBus);\n+\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+\n+                Misc.free(telemetryJob);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryStoresUpAndDownEvents() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            serverConfiguration = new PropServerConfiguration(temp.getRoot().getAbsolutePath(), new Properties()) {\n+                @Override\n+                public CairoConfiguration getCairoConfiguration() {\n+                    return new DefaultCairoConfiguration(root);\n+                }\n+            };\n+            configuration = serverConfiguration.getCairoConfiguration();\n+            messageBus = new MessageBusImpl(serverConfiguration);\n+            CairoEngine engine = new CairoEngine(configuration, messageBus);\n+            TelemetryJob telemetryJob = new TelemetryJob(serverConfiguration, engine, messageBus);\n+            Misc.free(telemetryJob);\n+\n+            final String expectedEvent = \"100\\n\" +\n+                    \"101\\n\";\n+            assertColumn(expectedEvent, \"telemetry\", 1);\n+\n+            final String expectedOrigin = \"1\\n\" +\n+                    \"1\\n\";\n+            assertColumn(expectedOrigin, \"telemetry\", 2);\n+\n+            Misc.free(engine);\n+        });\n+    }\n+\n+    private void assertTable(CharSequence expected, CharSequence tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDA3MjczOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1ODowMlrOGrhF8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDo1ODowMlrOGrhF8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NDE0NA==", "bodyText": "returning new instance of configuration on each getCairoConfiguration() call could be inefficient and lead to memory churn in tests. It would be better to implement this method like so:\n            private final CairoConfiguration conf = new DefaultCairoConfiguration(root);\n            @Override\n            public CairoConfiguration getCairoConfiguration() {\n                return conf;\n            }", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448284144", "createdAt": "2020-07-01T10:58:02Z", "author": {"login": "bluestreak01"}, "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "diffHunk": "@@ -51,18 +55,26 @@\n     public static TemporaryFolder temp = new TemporaryFolder();\n     protected static CharSequence root;\n     protected static CairoConfiguration configuration;\n+    protected static PropServerConfiguration serverConfiguration;\n     protected static MessageBus messageBus;\n \n     @BeforeClass\n-    public static void setUp() throws IOException {\n+    public static void setUp() throws IOException, JsonException, ServerConfigurationException {\n         // it is necessary to initialise logger before tests start\n         // logger doesn't relinquish memory until JVM stops\n         // which causes memory leak detector to fail should logger be\n         // created mid-test\n         LOG.info().$(\"begin\").$();\n         root = temp.newFolder(\"dbRoot\").getAbsolutePath();\n-        configuration = new DefaultCairoConfiguration(root);\n-        messageBus = new MessageBusImpl();\n+        TestUtils.copyMimeTypes(temp.getRoot().getAbsolutePath());\n+        serverConfiguration = new PropServerConfiguration(temp.getRoot().getAbsolutePath(), new Properties()) {\n+            @Override\n+            public CairoConfiguration getCairoConfiguration() {\n+                return new DefaultCairoConfiguration(root);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDA5MDM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/ServerMain.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTowMzoyMFrOGrhQcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMzoyMjozOVrOGrlq-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NjgzMg==", "bodyText": "when telemetry is disabled it is better not to create job at all. This would meet potential user expectations such as:\n\ni disabled telemetry\ntelemetry tables are not created", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448286832", "createdAt": "2020-07-01T11:03:20Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/ServerMain.java", "diffHunk": "@@ -139,12 +139,17 @@ public static void main(String[] args) throws Exception {\n         }\n \n         final WorkerPool workerPool = new WorkerPool(configuration.getWorkerPoolConfiguration());\n-        final MessageBus messageBus = new MessageBusImpl();\n+        final MessageBus messageBus = new MessageBusImpl(configuration);\n         final FunctionFactoryCache functionFactoryCache = new FunctionFactoryCache(configuration.getCairoConfiguration(), ServiceLoader.load(FunctionFactory.class));\n \n         LogFactory.configureFromSystemProperties(workerPool);\n         final CairoEngine cairoEngine = new CairoEngine(configuration.getCairoConfiguration(), messageBus);\n         workerPool.assign(cairoEngine.getWriterMaintenanceJob());\n+        final TelemetryJob telemetryJob = new TelemetryJob(configuration, cairoEngine, messageBus);\n+\n+        if (configuration.getTelemetryConfiguration().getEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM1OTE2Mw==", "bodyText": "TelemetryJob is needed even when telemetry is turned off because it is responsible for updating the telemetry_config table, if I remove it, telemetry will always be on from the UI perspective (because the table won't be updated). I will keep this as is.\nAlso the table telemetry_config is always required (again, for the UI).", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448359163", "createdAt": "2020-07-01T13:22:39Z", "author": {"login": "mpsq"}, "path": "core/src/main/java/io/questdb/ServerMain.java", "diffHunk": "@@ -139,12 +139,17 @@ public static void main(String[] args) throws Exception {\n         }\n \n         final WorkerPool workerPool = new WorkerPool(configuration.getWorkerPoolConfiguration());\n-        final MessageBus messageBus = new MessageBusImpl();\n+        final MessageBus messageBus = new MessageBusImpl(configuration);\n         final FunctionFactoryCache functionFactoryCache = new FunctionFactoryCache(configuration.getCairoConfiguration(), ServiceLoader.load(FunctionFactory.class));\n \n         LogFactory.configureFromSystemProperties(workerPool);\n         final CairoEngine cairoEngine = new CairoEngine(configuration.getCairoConfiguration(), messageBus);\n         workerPool.assign(cairoEngine.getWriterMaintenanceJob());\n+        final TelemetryJob telemetryJob = new TelemetryJob(configuration, cairoEngine, messageBus);\n+\n+        if (configuration.getTelemetryConfiguration().getEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NjgzMg=="}, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDA5MzkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTowNDoyOVrOGrhSmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTowNDoyOVrOGrhSmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NzM4Ng==", "bodyText": "There is disjointed syntax here. MessageBus is declared nullable and yet the code behaves as if it was declared NotNull", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448287386", "createdAt": "2020-07-01T11:04:29Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.std.time.MillisecondClock;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MillisecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMillisecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDExMDM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTowOTo0MFrOGrhcnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTowOTo0MFrOGrhcnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4OTk1MQ==", "bodyText": "Accessing record like this is very fragile. Convention is for access like this:\nRecordCursor cursor = reader.getCursor();\nRecord record = cursor.getRecord();\nif (cursor.next()) {\n   record.getLong256...\n} else {\n   // is my table empty?!\n}", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448289951", "createdAt": "2020-07-01T11:09:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.std.time.MillisecondClock;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MillisecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMillisecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short, origin short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            Misc.free(writer);\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        try (TableReader reader = new TableReader(cairoConfig, configTableName)) {\n+            final NanosecondClock nanosecondClock = cairoConfig.getNanosecondClock();\n+\n+            if (reader.size() > 0) {\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+                final boolean _enabled = reader.getCursor().getRecord().getBool(1);\n+\n+                if (enabled != _enabled) {\n+                    final TableWriter.Row row = writerConfig.newRow();\n+                    row.putLong256(0, idSink);\n+                    row.putBool(1, enabled);\n+                    row.append();\n+                    writerConfig.commit();\n+                }\n+            } else {\n+                final MicrosecondClock clock = cairoConfig.getMicrosecondClock();\n+                final TableWriter.Row row = writerConfig.newRow();\n+                row.putLong256(0, nanosecondClock.getTicks(), clock.getTicks(), 0, 0);\n+                row.putBool(1, enabled);\n+                row.append();\n+                writerConfig.commit();\n+                reader.reload();\n+                reader.getCursor().getRecord().getLong256(0, idSink);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2163, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}