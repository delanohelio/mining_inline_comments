{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2NzQ5ODkz", "number": 690, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1Mzo1MVrOE2KaKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMzoxMjozMlrOE2wl5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjI5MDk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/model/QueryModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1Mzo1MVrOHu102g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1Mzo1MVrOHu102g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODQyNg==", "bodyText": "unnecessary toLowerCase()", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518878426", "createdAt": "2020-11-06T16:53:51Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/model/QueryModel.java", "diffHunk": "@@ -258,7 +258,7 @@ public void copyColumnsFrom(QueryModel other) {\n         this.bottomUpColumnNames.addAll(columnNames);\n         for (int i = 0, n = columnNames.size(); i < n; i++) {\n             final CharSequence name = columnNames.getQuick(i);\n-            this.aliasToColumnNameMap.put(name, name);\n+            this.aliasToColumnNameMap.put(Chars.toLowerCase(name), Chars.toLowerCase(name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjI5NDQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NDo0MFrOHu12-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NDo0MFrOHu12-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODk3MQ==", "bodyText": "Unnecessary toLowerCase", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518878971", "createdAt": "2020-11-06T16:54:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -201,7 +201,7 @@ private void addColumnToTranslatingModel(\n             QueryModel validatingModel\n     ) throws SqlException {\n         if (validatingModel != null) {\n-            CharSequence refColumn = column.getAst().token;\n+            CharSequence refColumn = Chars.toLowerCase(column.getAst().token);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMwMDMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NjoxN1rOHu16mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NjoxN1rOHu16mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3OTg5OA==", "bodyText": "\"quick\" was fine, we should not need extra check", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518879898", "createdAt": "2020-11-06T16:56:17Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -729,11 +729,11 @@ private void createSelectColumn(\n         // taking into account that column is pre-aliased, e.g.\n         // \"col, col\" will look like \"col, col col1\"\n \n-        CharSequenceObjHashMap<CharSequence> translatingAliasMap = translatingModel.getColumnNameToAliasMap();\n+        LowerCaseCharSequenceObjHashMap<CharSequence> translatingAliasMap = translatingModel.getColumnNameToAliasMap();\n         int index = translatingAliasMap.keyIndex(columnAst.token);\n         if (index < 0) {\n             // column is already being referenced by translating model\n-            final CharSequence translatedColumnName = translatingAliasMap.valueAtQuick(index);\n+            final CharSequence translatedColumnName = translatingAliasMap.valueAt(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMwMzE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NzowN1rOHu18ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NzowN1rOHu18ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDM3OQ==", "bodyText": "quick was fine", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518880379", "createdAt": "2020-11-06T16:57:07Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -950,7 +950,7 @@ private ExpressionNode doReplaceLiteral(@Transient ExpressionNode node, QueryMod\n                 }\n \n                 if (found) {\n-                    return nextLiteral(map.valueAtQuick(index), node.position);\n+                    return nextLiteral(map.valueAt(index), node.position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMwNDcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NzozNVrOHu19gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1NzozNVrOHu19gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDY0MA==", "bodyText": "\"quick\" was fine", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518880640", "createdAt": "2020-11-06T16:57:35Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -964,7 +964,7 @@ private ExpressionNode doReplaceLiteral(@Transient ExpressionNode node, QueryMod\n             }\n             return nextLiteral(alias, node.position);\n         }\n-        return nextLiteral(map.valueAtQuick(index), node.position);\n+        return nextLiteral(map.valueAt(index), node.position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMwNjM2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1ODowNVrOHu1-mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo1ODowNVrOHu1-mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDkyMA==", "bodyText": "unnecessary", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518880920", "createdAt": "2020-11-06T16:58:05Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -1168,6 +1168,7 @@ private void eraseColumnPrefixInWhereClauses(QueryModel model) throws SqlExcepti\n     }\n \n     private int getIndexOfTableForColumn(QueryModel model, CharSequence column, int dot, int position) throws SqlException {\n+        column = Chars.toLowerCase(column);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxMzY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMDowMFrOHu2DMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMDowMFrOHu2DMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjA5Ng==", "bodyText": "same, pls re-introduce getValueQuick()", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882096", "createdAt": "2020-11-06T17:00:00Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -2287,7 +2288,7 @@ private QueryModel rewriteOrderBy(QueryModel model) throws SqlException {\n \n                         if (index < 0) {\n                             // we have found alias, rewrite order by column\n-                            orderBy.token = map.valueAtQuick(index);\n+                            orderBy.token = map.valueAt(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxNDExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMDowNlrOHu2Deg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMDowNlrOHu2Deg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjE3MA==", "bodyText": "same", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882170", "createdAt": "2020-11-06T17:00:06Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -2317,7 +2318,7 @@ private QueryModel rewriteOrderBy(QueryModel model) throws SqlException {\n                                     index = synthetic.getColumnNameToAliasMap().keyIndex(column);\n \n                                     if (index < 0) {\n-                                        alias = synthetic.getColumnNameToAliasMap().valueAtQuick(index);\n+                                        alias = synthetic.getColumnNameToAliasMap().valueAt(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxNDcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMDoxN1rOHu2D6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMDoxN1rOHu2D6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjI4Mg==", "bodyText": "same", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882282", "createdAt": "2020-11-06T17:00:17Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -2854,7 +2855,7 @@ public void visit(ExpressionNode node) {\n                 // we have table column hit when alias is not found\n                 // in this case expression rewrite is unnecessary\n                 if (index < 0) {\n-                    CharSequence column = aliasToColumnMap.valueAtQuick(index);\n+                    CharSequence column = aliasToColumnMap.valueAt(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMxODA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMToxN1rOHu2GCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMToxN1rOHu2GCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjgyNg==", "bodyText": "when cursor is not fully scrolled down we will have file descriptor leak", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882826", "createdAt": "2020-11-06T17:01:17Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttributeCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attribute()\";\n+    }\n+\n+    @Override\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttributeCatalogueCursorFactory(\n+                        configuration,\n+                        METADATA\n+                )\n+        );\n+    }\n+\n+    private static class AttributeCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttributeClassCatalogueCursor cursor;\n+\n+        public AttributeCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.cursor = new AttributeClassCatalogueCursor(configuration, path);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttributeClassCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final DiskReadingRecord diskReadingRecord = new DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final ReadOnlyColumn metaMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private int tableId = 1000;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttributeClassCatalogueCursor(CairoConfiguration configuration, Path path) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.metaMem = new OnePageMemory();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+            metaMem.close();\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return diskReadingRecord;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (findFileStruct == 0) {\n+                findFileStruct = ff.findFirst(path.trimTo(plimit).$());\n+                if (findFileStruct > 0) {\n+                    return next0();\n+                }\n+\n+                findFileStruct = 0;\n+                return false;\n+            }\n+\n+            return next0();\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public long size() {\n+            return -1;\n+        }\n+\n+        private boolean next0() {\n+            do {\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (\n+                                ff.findType(findFileStruct) == Files.DT_DIR\n+                                        && !Chars.equals(nativeLPSZ, '.')\n+                                        && !Chars.equals(nativeLPSZ, \"..\")\n+                        ) {\n+                            path.trimTo(plimit);\n+                            path.concat(pname);\n+                            if (ff.exists(path.concat(TableUtils.META_FILE_NAME).$())) {\n+                                foundMetadataFile = true;\n+                                metaMem.of(ff, path, ff.getPageSize(), ff.length(path));\n+                                columnCount = metaMem.getInt(TableUtils.META_OFFSET_COUNT);\n+                                tableId = metaMem.getInt(TableUtils.META_OFFSET_TABLE_ID);\n+                            }\n+                        }\n+                        hasNextFile = ff.findNext(findFileStruct) > 0;\n+                    }\n+                }\n+\n+                if (foundMetadataFile) {\n+                    long offset = TableUtils.getColumnNameOffset(columnCount);\n+                    for (int i = 0; i < columnCount; i++) {\n+                        CharSequence name = metaMem.getStr(offset);\n+                        if (columnIndex == i) {\n+                            diskReadingRecord.name = name;\n+                            diskReadingRecord.columnNumber = (short) (i + 1);\n+                            diskReadingRecord.tableId = tableId;\n+                            columnIndex++;\n+                            if (columnIndex == columnCount) {\n+                                readNextFileFromDisk = true;\n+                                columnIndex = 0;\n+                            } else {\n+                                readNextFileFromDisk = false;\n+                            }\n+                            return true;\n+                        }\n+                        offset += ReadOnlyMemory.getStorageLength(name);\n+                    }\n+                }\n+            } while (hasNextFile);\n+\n+            ff.findClose(findFileStruct);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMyMzM2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/std/Chars.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMjo1M1rOHu2JZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMjo1M1rOHu2JZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzY4Ng==", "bodyText": "toLowerCase should be on both sides", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518883686", "createdAt": "2020-11-06T17:02:53Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/std/Chars.java", "diffHunk": "@@ -230,6 +230,39 @@ public static boolean equalsIgnoreCaseNc(CharSequence l, CharSequence r) {\n         return l != null && equalsIgnoreCase(l, r);\n     }\n \n+    public static boolean equalsLowerCase(CharSequence l, int lLo, int lHi, CharSequence r, int rLo, int rHi) {\n+        if (l == r) {\n+            return true;\n+        }\n+\n+        int ll = lHi - lLo;\n+        if (ll != rHi - rLo) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < ll; i++) {\n+            if (Character.toLowerCase(l.charAt(i + lLo)) != r.charAt(i + rLo)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMyMzU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/std/Chars.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMzowMFrOHu2Jjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMzowMFrOHu2Jjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzcyNg==", "bodyText": "same", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518883726", "createdAt": "2020-11-06T17:03:00Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/std/Chars.java", "diffHunk": "@@ -230,6 +230,39 @@ public static boolean equalsIgnoreCaseNc(CharSequence l, CharSequence r) {\n         return l != null && equalsIgnoreCase(l, r);\n     }\n \n+    public static boolean equalsLowerCase(CharSequence l, int lLo, int lHi, CharSequence r, int rLo, int rHi) {\n+        if (l == r) {\n+            return true;\n+        }\n+\n+        int ll = lHi - lLo;\n+        if (ll != rHi - rLo) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < ll; i++) {\n+            if (Character.toLowerCase(l.charAt(i + lLo)) != r.charAt(i + rLo)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean equalsLowerCase(@NotNull CharSequence l, CharSequence r) {\n+        int ll;\n+        if ((ll = l.length()) != r.length()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < ll; i++) {\n+            if (Character.toLowerCase(l.charAt(i)) != r.charAt(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1ODU0NjkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMzoxMjozMlrOHvuKOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMzoxMjozMlrOHvuKOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwMTQwMg==", "bodyText": "perhaps this class can also (like Path) be at factory level so we do not need to allocate to re-execute the cursor", "url": "https://github.com/questdb/questdb/pull/690#discussion_r519801402", "createdAt": "2020-11-09T13:12:32Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttributeCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attribute()\";\n+    }\n+\n+    @Override\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttributeCatalogueCursorFactory(\n+                        configuration,\n+                        METADATA\n+                )\n+        );\n+    }\n+\n+    private static class AttributeCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttributeClassCatalogueCursor cursor;\n+\n+        public AttributeCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.cursor = new AttributeClassCatalogueCursor(configuration, path);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttributeClassCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final DiskReadingRecord diskReadingRecord = new DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final ReadOnlyColumn metaMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private int tableId = 1000;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttributeClassCatalogueCursor(CairoConfiguration configuration, Path path) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.metaMem = new OnePageMemory();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+            metaMem.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e1a66ea5483559b7b8585f93472ac022ab42ead"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2150, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}