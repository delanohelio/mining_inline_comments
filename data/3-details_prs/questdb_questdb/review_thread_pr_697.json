{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5OTA1OTk2", "number": 697, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDoxMDozNVrOE4LaBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowOToyNFrOE5X4qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzQyNTk2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDoxMDozNVrOHx8fUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDoxMDozNVrOHx8fUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMzMzMA==", "bodyText": "the goal of the SQL is to enumerate table columns like PG does\n nspname | relname  |  attname   | atttypid | attnotnull | atttypmod | attlen | typtypmod | attnum | attidentity | adsrc | description | typbasetype | typtype\n---------+----------+------------+----------+------------+-----------+--------+-----------+--------+-------------+-------+-------------+-------------+---------\n public  | po_items | po_no      |       23 | t          |        -1 |      4 |        -1 |      1 |             |       |             |           0 | b\n public  | po_items | item_no    |       23 | t          |        -1 |      4 |        -1 |      2 |             |       |             |           0 | b\n public  | po_items | product_no |       23 | f          |        -1 |      4 |        -1 |      3 |             |       |             |           0 | b\n public  | po_items | qty        |       23 | f          |        -1 |      4 |        -1 |      4 |             |       |             |           0 | b\n public  | po_items | net_price  |     1700 | f          |        -1 |     -1 |        -1 |      5 |             |       |             |           0 | b\n(5 rows)", "url": "https://github.com/questdb/questdb/pull/697#discussion_r522133330", "createdAt": "2020-11-12T14:10:35Z", "author": {"login": "bluestreak01"}, "path": "core/src/test/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactoryTest.java", "diffHunk": "@@ -262,17 +262,61 @@ public void testPgAttributeFuncWith2Tables() throws Exception {\n     @Test\n     public void testPgAttributeFuncWith2TablesLimit1() throws Exception {\n         assertQuery(\n-                \"attrelid\\tattname\\tattnum\\n\" +\n-                        \"1\\ta\\t1\\n\",\n+                \"attrelid\\tattname\\tattnum\\tatttypid\\tattnotnull\\tatttypmod\\tattlen\\tattidentity\\tattisdropped\\n\" +\n+                        \"1\\ta\\t1\\t0\\tfalse\\t0\\t0\\t\\tfalse\\n\",\n                 \"pg_catalog.pg_attribute order by 1 limit 1;\",\n                 \"create table x(a int)\",\n                 null,\n                 \"create table y(a double, b string)\",\n-                \"attrelid\\tattname\\tattnum\\n\" +\n-                        \"1\\ta\\t1\\n\",\n+                \"attrelid\\tattname\\tattnum\\tatttypid\\tattnotnull\\tatttypmod\\tattlen\\tattidentity\\tattisdropped\\n\" +\n+                        \"1\\ta\\t1\\t0\\tfalse\\t0\\t0\\t\\tfalse\\n\",\n                 true,\n                 false,\n                 true\n         );\n     }\n+\n+    @Test\n+    public void testSecondKafkaMetadataQuery() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3242e5185e292cc57b7231d68bad76e6369b3973"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzQyODE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDoxMToxMFrOHx8gpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDoxMToxMFrOHx8gpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMzY3MA==", "bodyText": "the aim of the SQL is to enum columns. Having constant 0 out of the field isn't going to work", "url": "https://github.com/questdb/questdb/pull/697#discussion_r522133670", "createdAt": "2020-11-12T14:11:10Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -236,6 +246,12 @@ public int getStrLen(int col) {\n         metadata.add(new TableColumnMetadata(\"attrelid\", ColumnType.INT, null));\n         metadata.add(new TableColumnMetadata(\"attname\", ColumnType.STRING, null));\n         metadata.add(new TableColumnMetadata(\"attnum\", ColumnType.SHORT, null));\n+        metadata.add(new TableColumnMetadata(\"atttypid\", ColumnType.INT, null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3242e5185e292cc57b7231d68bad76e6369b3973"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc3MTM3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGOids.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MjoyM1rOHzwrSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0MjoyM1rOHzwrSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNjkzNw==", "bodyText": "make it a list", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524036937", "createdAt": "2020-11-16T09:42:23Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGOids.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.pgwire;\n+\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.std.IntHashSet;\n+import io.questdb.std.IntIntHashMap;\n+import io.questdb.std.IntList;\n+import io.questdb.std.IntObjHashMap;\n+\n+public class PGOids {\n+\n+    public static final int PG_VARCHAR = 1043;\n+    public static final int PG_TIMESTAMP = 1114;\n+    public static final int PG_TIMESTAMPZ = 1184;\n+    public static final int PG_FLOAT8 = 701;\n+    public static final int PG_FLOAT4 = 700;\n+    public static final int PG_INT4 = 23;\n+    public static final int PG_INT2 = 21;\n+    public static final int PG_INT8 = 20;\n+    public static final int PG_NUMERIC = 1700;\n+    public static final int PG_BOOL = 16;\n+    public static final int PG_CHAR = 18;\n+    public static final int PG_DATE = 1082;\n+    public static final int PG_BYTEA = 17;\n+    public static final int PG_UNSPECIFIED = 0;\n+    public static final IntList TYPE_OIDS = new IntList();\n+    public static final IntHashSet PG_TYPE_OIDS = new IntHashSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc3NDgxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGOids.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Mjo1NFrOHzwtaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Mjo1NFrOHzwtaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNzQ4MA==", "bodyText": "populate with explicit values", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524037480", "createdAt": "2020-11-16T09:42:54Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGOids.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.pgwire;\n+\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.std.IntHashSet;\n+import io.questdb.std.IntIntHashMap;\n+import io.questdb.std.IntList;\n+import io.questdb.std.IntObjHashMap;\n+\n+public class PGOids {\n+\n+    public static final int PG_VARCHAR = 1043;\n+    public static final int PG_TIMESTAMP = 1114;\n+    public static final int PG_TIMESTAMPZ = 1184;\n+    public static final int PG_FLOAT8 = 701;\n+    public static final int PG_FLOAT4 = 700;\n+    public static final int PG_INT4 = 23;\n+    public static final int PG_INT2 = 21;\n+    public static final int PG_INT8 = 20;\n+    public static final int PG_NUMERIC = 1700;\n+    public static final int PG_BOOL = 16;\n+    public static final int PG_CHAR = 18;\n+    public static final int PG_DATE = 1082;\n+    public static final int PG_BYTEA = 17;\n+    public static final int PG_UNSPECIFIED = 0;\n+    public static final IntList TYPE_OIDS = new IntList();\n+    public static final IntHashSet PG_TYPE_OIDS = new IntHashSet();\n+    public static final IntIntHashMap PG_TYPE_TO_INTERNAL_TYPE_MAP = new IntIntHashMap();\n+    public static final IntObjHashMap<CharSequence> PG_TYPE_TO_NAME = new IntObjHashMap<>();\n+\n+    static {\n+        TYPE_OIDS.extendAndSet(ColumnType.STRING, PG_VARCHAR); // VARCHAR\n+        TYPE_OIDS.extendAndSet(ColumnType.TIMESTAMP, PG_TIMESTAMP); // TIMESTAMP\n+        TYPE_OIDS.extendAndSet(ColumnType.DOUBLE, PG_FLOAT8); // FLOAT8\n+        TYPE_OIDS.extendAndSet(ColumnType.FLOAT, PG_FLOAT4); // FLOAT4\n+        TYPE_OIDS.extendAndSet(ColumnType.INT, PG_INT4); // INT4\n+        TYPE_OIDS.extendAndSet(ColumnType.SHORT, PG_INT2); // INT2\n+        TYPE_OIDS.extendAndSet(ColumnType.CHAR, PG_CHAR);\n+        TYPE_OIDS.extendAndSet(ColumnType.SYMBOL, PG_VARCHAR); // NAME\n+        TYPE_OIDS.extendAndSet(ColumnType.LONG, PG_INT8); // INT8\n+        TYPE_OIDS.extendAndSet(ColumnType.BYTE, PG_INT2); // INT2\n+        TYPE_OIDS.extendAndSet(ColumnType.BOOLEAN, PG_BOOL); // BOOL\n+        TYPE_OIDS.extendAndSet(ColumnType.DATE, PG_TIMESTAMP); // DATE\n+        TYPE_OIDS.extendAndSet(ColumnType.BINARY, PG_BYTEA); // BYTEA\n+        TYPE_OIDS.extendAndSet(ColumnType.LONG256, PG_NUMERIC); // NUMERIC\n+\n+        for (int i = 0, n = TYPE_OIDS.size(); i < n; i++) {\n+            PG_TYPE_OIDS.add(TYPE_OIDS.getQuick(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTc4MjA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttrDefCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0NDowMFrOHzwyHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0NDowMFrOHzwyHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzODY4Nw==", "bodyText": "close fd once at the end", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524038687", "createdAt": "2020-11-16T09:44:00Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttrDefCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttrDefCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final Log LOG = LogFactory.getLog(DescriptionCatalogueFunctionFactory.class);\n+    static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attrdef()\";\n+    }\n+\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttrDefCatalogueCursorFactory(configuration, METADATA)\n+        );\n+    }\n+\n+    private static class AttrDefCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttrDefCatalogueCursor cursor;\n+        private final long tempMem;\n+\n+        public AttrDefCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.tempMem = Unsafe.malloc(Integer.BYTES);\n+            this.cursor = new AttrDefCatalogueCursor(configuration, path, tempMem);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+            Unsafe.free(tempMem, Integer.BYTES);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttrDefCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final AttrDefCatalogueCursor.DiskReadingRecord diskReadingRecord = new AttrDefCatalogueCursor.DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final int[] intValues = new int[4];\n+        private final long tempMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttrDefCatalogueCursor(CairoConfiguration configuration, Path path, long tempMem) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.tempMem = tempMem;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return diskReadingRecord;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (findFileStruct == 0) {\n+                findFileStruct = ff.findFirst(path.trimTo(plimit).$());\n+                if (findFileStruct > 0) {\n+                    return next0();\n+                }\n+\n+                findFileStruct = 0;\n+                return false;\n+            }\n+\n+            return next0();\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public long size() {\n+            return -1;\n+        }\n+\n+        private boolean next0() {\n+            do {\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgwMjUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttrDefCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Njo1OFrOHzw-vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0Njo1OFrOHzw-vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MTkxNw==", "bodyText": "remove array, only one int column is present", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524041917", "createdAt": "2020-11-16T09:46:58Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttrDefCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttrDefCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final Log LOG = LogFactory.getLog(DescriptionCatalogueFunctionFactory.class);\n+    static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attrdef()\";\n+    }\n+\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttrDefCatalogueCursorFactory(configuration, METADATA)\n+        );\n+    }\n+\n+    private static class AttrDefCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttrDefCatalogueCursor cursor;\n+        private final long tempMem;\n+\n+        public AttrDefCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.tempMem = Unsafe.malloc(Integer.BYTES);\n+            this.cursor = new AttrDefCatalogueCursor(configuration, path, tempMem);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+            Unsafe.free(tempMem, Integer.BYTES);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttrDefCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final AttrDefCatalogueCursor.DiskReadingRecord diskReadingRecord = new AttrDefCatalogueCursor.DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final int[] intValues = new int[4];\n+        private final long tempMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttrDefCatalogueCursor(CairoConfiguration configuration, Path path, long tempMem) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.tempMem = tempMem;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return diskReadingRecord;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (findFileStruct == 0) {\n+                findFileStruct = ff.findFirst(path.trimTo(plimit).$());\n+                if (findFileStruct > 0) {\n+                    return next0();\n+                }\n+\n+                findFileStruct = 0;\n+                return false;\n+            }\n+\n+            return next0();\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public long size() {\n+            return -1;\n+        }\n+\n+        private boolean next0() {\n+            do {\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);\n+                                    }\n+                                } else {\n+                                    LOG.error().$(\"could not read metadata [file=\").$(path).$(']').$();\n+                                }\n+                            }\n+                        }\n+                        hasNextFile = ff.findNext(findFileStruct) > 0;\n+                    }\n+                }\n+\n+                if (foundMetadataFile) {\n+                    for (int i = 0; i < columnCount; i++) {\n+                        if (columnIndex == i) {\n+                            diskReadingRecord.columnNumber = (short) (i + 1);\n+                            columnIndex++;\n+                            if (columnIndex == columnCount) {\n+                                readNextFileFromDisk = true;\n+                                columnIndex = 0;\n+                            } else {\n+                                readNextFileFromDisk = false;\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                }\n+            } while (hasNextFile);\n+\n+            ff.findClose(findFileStruct);\n+            findFileStruct = 0;\n+            hasNextFile = true;\n+            foundMetadataFile = false;\n+            intValues[0] = -1;\n+            return false;\n+        }\n+\n+        private class DiskReadingRecord implements Record {\n+\n+            public short columnNumber = 0;\n+\n+            @Override\n+            public int getInt(int col) {\n+                return intValues[col];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgxMjU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODoyOVrOHzxFWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODoyOVrOHzxFWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzYxMQ==", "bodyText": "use sparse arrays like shortValues, populate in next() and dereference using column index", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524043611", "createdAt": "2020-11-16T09:48:29Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -203,15 +207,16 @@ private boolean next0() {\n             public CharSequence name = null;\n             public short columnNumber = 0;\n             public int tableId = 0;\n+            public int type = -1;\n \n             @Override\n             public short getShort(int col) {\n-                return columnNumber;\n+                return col == 2 ? columnNumber : col == 6 ? getTypeSize() : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgxMzkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODo0MVrOHzxGVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo0ODo0MVrOHzxGVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0Mzg2Mw==", "bodyText": "same, use sparse arrays", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524043863", "createdAt": "2020-11-16T09:48:41Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -203,15 +207,16 @@ private boolean next0() {\n             public CharSequence name = null;\n             public short columnNumber = 0;\n             public int tableId = 0;\n+            public int type = -1;\n \n             @Override\n             public short getShort(int col) {\n-                return columnNumber;\n+                return col == 2 ? columnNumber : col == 6 ? getTypeSize() : 0;\n             }\n \n             @Override\n             public int getInt(int col) {\n-                return tableId;\n+                return col == 0 ? tableId : col == 3 ? type : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTgyNzk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1MDozNlrOHzxPLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1MjowNFrOHzxVwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NjEyNQ==", "bodyText": "lets investigate what PG expects for attidentity. Character.MIN_VALUE is not the same as null", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524046125", "createdAt": "2020-11-16T09:50:36Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -224,10 +229,25 @@ public CharSequence getStrB(int col) {\n                 return name;\n             }\n \n+            @Override\n+            public boolean getBool(int col) {\n+                return false;\n+            }\n+\n+            @Override\n+            public char getChar(int col) {\n+                return Character.MIN_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0Njg5Nw==", "bodyText": "try 0", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524046897", "createdAt": "2020-11-16T09:51:17Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -224,10 +229,25 @@ public CharSequence getStrB(int col) {\n                 return name;\n             }\n \n+            @Override\n+            public boolean getBool(int col) {\n+                return false;\n+            }\n+\n+            @Override\n+            public char getChar(int col) {\n+                return Character.MIN_VALUE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NjEyNQ=="}, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NzgwOQ==", "bodyText": "or add a comment on what this means", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524047809", "createdAt": "2020-11-16T09:52:04Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -224,10 +229,25 @@ public CharSequence getStrB(int col) {\n                 return name;\n             }\n \n+            @Override\n+            public boolean getBool(int col) {\n+                return false;\n+            }\n+\n+            @Override\n+            public char getChar(int col) {\n+                return Character.MIN_VALUE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NjEyNQ=="}, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTg2NjcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1NjowMVrOHzxn5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1NjowMVrOHzxn5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1MjQ1Mg==", "bodyText": "PG_TYPE_TO_INTERNAL_TYPE_MAP is not used for anything other than working out size of type. Change the data structure to provide size right away without call to sizeof() and if", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524052452", "createdAt": "2020-11-16T09:56:01Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -224,10 +229,25 @@ public CharSequence getStrB(int col) {\n                 return name;\n             }\n \n+            @Override\n+            public boolean getBool(int col) {\n+                return false;\n+            }\n+\n+            @Override\n+            public char getChar(int col) {\n+                return Character.MIN_VALUE;\n+            }\n+\n             @Override\n             public int getStrLen(int col) {\n                 return getStr(col).length();\n             }\n+\n+            private short getTypeSize() {\n+                short size = (short) ColumnType.sizeOf(PG_TYPE_TO_INTERNAL_TYPE_MAP.get(type));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTg3NzM3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1NzozMVrOHzxu7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1NzozMVrOHzxu7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1NDI1NQ==", "bodyText": "ff.close(fd) is same as above", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524054255", "createdAt": "2020-11-16T09:57:31Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "diffHunk": "@@ -156,46 +158,86 @@ public long size() {\n \n         private boolean next0() {\n             do {\n-                final long pname = ff.findName(findFileStruct);\n-                nativeLPSZ.of(pname);\n-                if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n-                    path.trimTo(plimit);\n-                    if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n-                        // open metadata file and read id\n-                        long fd = ff.openRO(path);\n-                        if (fd > -1) {\n-                            if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n-                                intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n-                                ff.close(fd);\n-                                return true;\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            diskReadingRecord.columnNumber = 0;\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTg5MDQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1OToyOFrOHzx3vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwOTo1OToyOFrOHzx3vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1NjUwOQ==", "bodyText": "add a comment", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524056509", "createdAt": "2020-11-16T09:59:28Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "diffHunk": "@@ -214,7 +256,7 @@ public int getStrLen(int col) {\n         final GenericRecordMetadata metadata = new GenericRecordMetadata();\n         metadata.add(new TableColumnMetadata(\"objoid\", ColumnType.INT, null));\n         metadata.add(new TableColumnMetadata(\"classoid\", ColumnType.INT, null));\n-        metadata.add(new TableColumnMetadata(\"objsubid\", ColumnType.INT, null));\n+        metadata.add(new TableColumnMetadata(\"objsubid\", ColumnType.SHORT, null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTkxMjIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowMjozOFrOHzyF1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowMjozOFrOHzyF1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MDExNw==", "bodyText": "use sparse array", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524060117", "createdAt": "2020-11-16T10:02:38Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "diffHunk": "@@ -156,46 +158,86 @@ public long size() {\n \n         private boolean next0() {\n             do {\n-                final long pname = ff.findName(findFileStruct);\n-                nativeLPSZ.of(pname);\n-                if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n-                    path.trimTo(plimit);\n-                    if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n-                        // open metadata file and read id\n-                        long fd = ff.openRO(path);\n-                        if (fd > -1) {\n-                            if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n-                                intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n-                                ff.close(fd);\n-                                return true;\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            diskReadingRecord.columnNumber = 0;\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);\n+                                    }\n+                                } else {\n+                                    LOG.error().$(\"could not read metadata [file=\").$(path).$(']').$();\n+                                }\n                             }\n-                            LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n-                            ff.close(fd);\n-                        } else {\n-                            LOG.error().$(\"could not read metadata [file=\").$(path).$(']').$();\n                         }\n-                        intValues[0] = -1;\n-                        return true;\n+                        hasNextFile = ff.findNext(findFileStruct) > 0;\n+                        if (foundMetadataFile) {\n+                            readNextFileFromDisk = false;\n+                            return true;\n+                        }\n                     }\n                 }\n-            } while (ff.findNext(findFileStruct) > 0);\n+\n+                if (foundMetadataFile) {\n+                    for (int i = 0; i < columnCount + 1; i++) {\n+                        if (columnIndex == i) {\n+                            diskReadingRecord.columnNumber = (short) (i + 1);\n+                            columnIndex++;\n+                            if (columnIndex == columnCount) {\n+                                readNextFileFromDisk = true;\n+                                columnIndex = 0;\n+                            } else {\n+                                readNextFileFromDisk = false;\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                }\n+            } while (hasNextFile);\n \n             ff.findClose(findFileStruct);\n             findFileStruct = 0;\n+            hasNextFile = true;\n+            foundMetadataFile = false;\n+            intValues[0] = -1;\n             return false;\n         }\n \n         private class DiskReadingRecord implements Record {\n \n+            public short columnNumber = 0;\n \n             @Override\n             public int getInt(int col) {\n                 return intValues[col];\n             }\n \n+            @Override\n+            public short getShort(int col) {\n+                return columnNumber;\n+            }\n+\n             @Override\n             public CharSequence getStr(int col) {\n-                return \"table\";\n+                return columnNumber == 0 ? \"table\" : \"column\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTkyMDU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/PrefixedTypeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowMzo1OFrOHzyLYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowMzo1OFrOHzyLYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MTUzOQ==", "bodyText": "check if base type does the same and remove if duplicate", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524061539", "createdAt": "2020-11-16T10:03:58Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/PrefixedTypeCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.griffin.engine.functions.GenericRecordCursorFactory;\n+import io.questdb.std.ObjList;\n+\n+public class PrefixedTypeCatalogueFunctionFactory extends TypeCatalogueFunctionFactory {\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_type()\";\n+    }\n+\n+    @Override\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTkyNTM5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueCursor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowNDo0MVrOHzyOXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowNDo0MVrOHzyOXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MjMwMQ==", "bodyText": "use sparse array", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524062301", "createdAt": "2020-11-16T10:04:41Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueCursor.java", "diffHunk": "@@ -69,28 +62,51 @@ public void toTop() {\n \n     @Override\n     public long size() {\n-        return 1;\n+        return rowCount;\n     }\n \n-    private class DescriptionCatalogueRecord implements Record {\n-\n+    private class TypeCatalogueRecord implements Record {\n         @Override\n         public int getInt(int col) {\n-            return intColumns[col][row];\n+            return col == 0 ? PG_TYPE_OIDS.get(row) : col == 4 ? PgOIDs.PG_PUBLIC_OID : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTk0MTk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueCursor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowNzoxNVrOHzyZMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowNzoxNVrOHzyZMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2NTA3NA==", "bodyText": "PG_TYPE_TO_NAME should be an array (dense)", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524065074", "createdAt": "2020-11-16T10:07:15Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueCursor.java", "diffHunk": "@@ -69,28 +62,51 @@ public void toTop() {\n \n     @Override\n     public long size() {\n-        return 1;\n+        return rowCount;\n     }\n \n-    private class DescriptionCatalogueRecord implements Record {\n-\n+    private class TypeCatalogueRecord implements Record {\n         @Override\n         public int getInt(int col) {\n-            return intColumns[col][row];\n+            return col == 0 ? PG_TYPE_OIDS.get(row) : col == 4 ? PgOIDs.PG_PUBLIC_OID : 0;\n         }\n \n         @Override\n         public CharSequence getStr(int col) {\n-            return descriptions[row];\n+            return PG_TYPE_TO_NAME.get(PG_TYPE_OIDS.get(row));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTk1NjI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueFunctionFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowOToyNFrOHzyipg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDowOToyNFrOHzyipg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2NzQ5NA==", "bodyText": "check if this factory overrides isCursor()\nisCursor must return true for all factories that return cursor instance", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524067494", "createdAt": "2020-11-16T10:09:24Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueFunctionFactory.java", "diffHunk": "@@ -24,32 +24,15 @@\n \n package io.questdb.griffin.engine.functions.catalogue;\n \n-import io.questdb.cairo.*;\n+import io.questdb.cairo.CairoConfiguration;\n import io.questdb.cairo.sql.Function;\n-import io.questdb.cairo.sql.RecordCursor;\n-import io.questdb.cairo.sql.RecordMetadata;\n import io.questdb.griffin.FunctionFactory;\n-import io.questdb.griffin.SqlExecutionContext;\n-import io.questdb.griffin.engine.EmptyTableRecordCursor;\n import io.questdb.griffin.engine.functions.CursorFunction;\n-import io.questdb.std.Misc;\n+import io.questdb.griffin.engine.functions.GenericRecordCursorFactory;\n import io.questdb.std.ObjList;\n-import io.questdb.std.str.Path;\n \n public class TypeCatalogueFunctionFactory implements FunctionFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2153, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}