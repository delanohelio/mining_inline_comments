{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3Nzg4MTkw", "number": 421, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTozMDoxNFrOEKeRpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0ODozOVrOEY2jKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDE3MjUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTozMDoxNFrOGriDCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxMjozMlrOGr4LAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTc4NA==", "bodyText": "don't yield - just go for it right away", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448299784", "createdAt": "2020-07-01T11:30:14Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;\n+                retryHolder.lastRunTimestamp = now;\n+                retryHolder.waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+        long now = 0;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.attempt + 1, retryHolder.waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);\n+        }\n+    }\n+\n+    // Process incoming queue and put it on priority queue with next timestamp to rerun\n+    private boolean processInQueue() {\n+        while (true) {\n+            long cursor = inSubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjI3NQ==", "bodyText": "Done", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662275", "createdAt": "2020-07-01T23:12:32Z", "author": {"login": "ideoma"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;\n+                retryHolder.lastRunTimestamp = now;\n+                retryHolder.waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+        long now = 0;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.attempt + 1, retryHolder.waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);\n+        }\n+    }\n+\n+    // Process incoming queue and put it on priority queue with next timestamp to rerun\n+    private boolean processInQueue() {\n+        while (true) {\n+            long cursor = inSubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTc4NA=="}, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDI5ODg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxMTozMlrOGrjQ2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxMjo1NVrOGr4Ldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxOTcwNg==", "bodyText": "It feels that this class should be a job?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448319706", "createdAt": "2020-07-01T12:11:32Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjM5MA==", "bodyText": "Made it SynchronizedJob", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662390", "createdAt": "2020-07-01T23:12:55Z", "author": {"login": "ideoma"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxOTcwNg=="}, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDMwODc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/std/ObjQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxNDo1NFrOGrjW2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxMzo0NFrOGr4MZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTI0Mw==", "bodyText": "why can't we use ObjArrayDequeue directly?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448321243", "createdAt": "2020-07-01T12:14:54Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/std/ObjQueue.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.std;\n+\n+public class ObjQueue<T> implements Mutable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjYzMQ==", "bodyText": "Removed changes to ObjStack and removed ObjQueue since I didn't use it at the end. Left new tests on ObjStack only", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662631", "createdAt": "2020-07-01T23:13:44Z", "author": {"login": "ideoma"}, "path": "core/src/main/java/io/questdb/std/ObjQueue.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.std;\n+\n+public class ObjQueue<T> implements Mutable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTI0Mw=="}, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDMxMDUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/std/ObjStack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxNToyNlrOGrjX9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxMzo1OFrOGr4MpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTUyNQ==", "bodyText": "Same here, we need to have second delegate that doesn't seem to add any value.", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448321525", "createdAt": "2020-07-01T12:15:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/std/ObjStack.java", "diffHunk": "@@ -24,93 +24,46 @@\n \n package io.questdb.std;\n \n-import java.util.Arrays;\n-\n public class ObjStack<T> implements Mutable {\n-    private static final int MIN_INITIAL_CAPACITY = 8;\n-    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n-    private T[] elements;\n-    private int head;\n-    private int tail;\n-    private int mask;\n+    private final ObjArrayDequeue<T> dequeue;\n \n     public ObjStack() {\n-        this(DEFAULT_INITIAL_CAPACITY);\n+        dequeue = new ObjArrayDequeue<>();\n     }\n \n     public ObjStack(int initialCapacity) {\n-        allocateElements(initialCapacity);\n+        dequeue = new ObjArrayDequeue<>(initialCapacity);\n     }\n \n     public void clear() {\n-        if (head != tail) {\n-            head = tail = 0;\n-            Arrays.fill(elements, null);\n-        }\n+        dequeue.clear();\n     }\n \n     public boolean notEmpty() {\n-        return head != tail;\n+        return dequeue.notEmpty();\n     }\n \n     public T peek() {\n-        return elements[head];\n+        return dequeue.peekLast();\n     }\n \n     public T peek(int n) {\n-        return elements[(head + n) & mask];\n+        return dequeue.peekLast(n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjY5Mw==", "bodyText": "Reverted", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662693", "createdAt": "2020-07-01T23:13:58Z", "author": {"login": "ideoma"}, "path": "core/src/main/java/io/questdb/std/ObjStack.java", "diffHunk": "@@ -24,93 +24,46 @@\n \n package io.questdb.std;\n \n-import java.util.Arrays;\n-\n public class ObjStack<T> implements Mutable {\n-    private static final int MIN_INITIAL_CAPACITY = 8;\n-    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n-    private T[] elements;\n-    private int head;\n-    private int tail;\n-    private int mask;\n+    private final ObjArrayDequeue<T> dequeue;\n \n     public ObjStack() {\n-        this(DEFAULT_INITIAL_CAPACITY);\n+        dequeue = new ObjArrayDequeue<>();\n     }\n \n     public ObjStack(int initialCapacity) {\n-        allocateElements(initialCapacity);\n+        dequeue = new ObjArrayDequeue<>(initialCapacity);\n     }\n \n     public void clear() {\n-        if (head != tail) {\n-            head = tail = 0;\n-            Arrays.fill(elements, null);\n-        }\n+        dequeue.clear();\n     }\n \n     public boolean notEmpty() {\n-        return head != tail;\n+        return dequeue.notEmpty();\n     }\n \n     public T peek() {\n-        return elements[head];\n+        return dequeue.peekLast();\n     }\n \n     public T peek(int n) {\n-        return elements[(head + n) & mask];\n+        return dequeue.peekLast(n);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTUyNQ=="}, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDMyMDM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxODoyNlrOGrjd0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoxNDoyNVrOGr4NIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMzAyNQ==", "bodyText": "why don't we have these attributes on the context itself and not use holder? This way we don't really need to create objects for retries?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448323025", "createdAt": "2020-07-01T12:18:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjgxNw==", "bodyText": "Done", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662817", "createdAt": "2020-07-01T23:14:25Z", "author": {"login": "ideoma"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMzAyNQ=="}, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk0MTYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzozODo1M1rOHBWLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzozODo1M1rOHBWLIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3MzkyMQ==", "bodyText": "This is a race condition. done() releases slot, which can be written to right after done() and right before RetryHolder is retried. This can lead to unpredictable results.\nRetryHolder needs to be copied off before releasing queue slot", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471173921", "createdAt": "2020-08-16T23:38:53Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                inQueue.get(cursor).retry = retry;;\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.retry.getAttemptDetails().attempt + 1, retryHolder.retry.getAttemptDetails().waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk0MjQzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/RetryHolder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzozOTo0MFrOHBWLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzozOTo0MFrOHBWLiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDAyNQ==", "bodyText": "perhaps RetryHolder is redundant here. Priority queue can take comparator.", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174025", "createdAt": "2020-08-16T23:39:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/RetryHolder.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+public class RetryHolder implements Comparable<RetryHolder> {\n+    public Retry retry;\n+\n+    @Override\n+    public int compareTo(@NotNull RetryHolder o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk0Mjg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0MDowNlrOHBWLwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0MDowNlrOHBWLwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDA4MA==", "bodyText": "size of priority queue should be configurable", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174080", "createdAt": "2020-08-16T23:40:06Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk0MzE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0MDozMFrOHBWL6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0MDozMFrOHBWL6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDEyMg==", "bodyText": "this should also be configurable", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174122", "createdAt": "2020-08-16T23:40:30Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk0NjMzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0NDoxOFrOHBWNgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0NDoxOFrOHBWNgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDUyOA==", "bodyText": "queue is full?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174528", "createdAt": "2020-08-16T23:44:18Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk0OTY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0Nzo1OVrOHBWPIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0Nzo1OVrOHBWPIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDk0Nw==", "bodyText": "Is this tested?\nI could be wrong here, but when this exception is thrown out of runReruns it would be not be handled at all?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174947", "createdAt": "2020-08-16T23:47:59Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDk1MDE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0ODozOVrOHBWPag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0ODozOVrOHBWPag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NTAxOA==", "bodyText": "when queue is full exception out of this method looks unhandled", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471175018", "createdAt": "2020-08-16T23:48:39Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                inQueue.get(cursor).retry = retry;;\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2226, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}