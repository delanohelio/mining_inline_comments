{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3Nzg4MTkw", "number": 421, "title": "Wait on writer locks when processing json requests", "bodyText": "", "createdAt": "2020-06-22T08:55:41Z", "url": "https://github.com/questdb/questdb/pull/421", "merged": true, "mergeCommit": {"oid": "f1fc3935366134decdcf2a401567dedae86a3250"}, "closed": true, "closedAt": "2020-11-06T17:09:38Z", "author": {"login": "ideoma"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsSpDegH2gAyNDM3Nzg4MTkwOjY1MjlkNTc4ZTFiMjc1MzFmNGFhNjRlMzJkMTMzOTg0ZjhiODZkOTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZ6IDfAFqTUyNTMzOTU2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6529d578e1b27531f4aa64e32d133984f8b86d90", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/6529d578e1b27531f4aa64e32d133984f8b86d90", "committedDate": "2020-06-17T23:41:53Z", "message": "Naive implementation of wait and resume of inserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ee03ffd304aa42883f856d7d60f4221158b8d69", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/0ee03ffd304aa42883f856d7d60f4221158b8d69", "committedDate": "2020-06-18T22:25:16Z", "message": "Fix re usage of JsonQueryProcessor in HttpRequestProcessor on retries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b90693af3e36ee789e9818011eef1a4e46280c5", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/9b90693af3e36ee789e9818011eef1a4e46280c5", "committedDate": "2020-06-21T00:25:26Z", "message": "Create WaitProcessor to reschedule retries."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87c1635129d690102fb026fc389c53f4adebb4d6", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/87c1635129d690102fb026fc389c53f4adebb4d6", "committedDate": "2020-06-21T00:36:03Z", "message": "Cleanup. Use RetryOperationException instead EntryUnavailableException to schedule a retry."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae84ee89db0afdeaaa287e5166c61c9f0dbe912f", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/ae84ee89db0afdeaaa287e5166c61c9f0dbe912f", "committedDate": "2020-06-22T09:41:55Z", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be52bfbe89a716e89b462fd62fd92a753bde878c", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/be52bfbe89a716e89b462fd62fd92a753bde878c", "committedDate": "2020-06-22T09:48:12Z", "message": "Refactoring / cleanup - remove unnecessary EmptyRescheduleContext"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc1fa1a0fda9dea48bd0a64fac0fa565f8c01f64", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/bc1fa1a0fda9dea48bd0a64fac0fa565f8c01f64", "committedDate": "2020-06-28T23:17:40Z", "message": "Multipart import retry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40f0217ee279279cd7c3fa50abc2de96dd1506f9", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/40f0217ee279279cd7c3fa50abc2de96dd1506f9", "committedDate": "2020-06-29T00:03:09Z", "message": "Fix double quote in query parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d145b4cc4e15fadd5bcee65ad718d4070623849e", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/d145b4cc4e15fadd5bcee65ad718d4070623849e", "committedDate": "2020-06-29T09:52:24Z", "message": "More tests on concurrent import."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5078a7a1651e45e5daa6942f8b791c1c91f20982", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/5078a7a1651e45e5daa6942f8b791c1c91f20982", "committedDate": "2020-06-30T23:33:09Z", "message": "Fix multipart import retry concurrent failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee81c5874af60ab0a5109bda8ffd10bb66791780", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/ee81c5874af60ab0a5109bda8ffd10bb66791780", "committedDate": "2020-06-30T23:55:56Z", "message": "Remove excessive logging, restore refactored test to working version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/8572d548c771383aa95fface1aa21da2e73ac3f0", "committedDate": "2020-07-01T11:09:18Z", "message": "Better code formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzg0NzY3", "url": "https://github.com/questdb/questdb/pull/421#pullrequestreview-440784767", "createdAt": "2020-07-01T11:30:13Z", "commit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMTozMDoxNFrOGriDCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxODoyNlrOGrjd0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTc4NA==", "bodyText": "don't yield - just go for it right away", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448299784", "createdAt": "2020-07-01T11:30:14Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;\n+                retryHolder.lastRunTimestamp = now;\n+                retryHolder.waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+        long now = 0;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.attempt + 1, retryHolder.waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);\n+        }\n+    }\n+\n+    // Process incoming queue and put it on priority queue with next timestamp to rerun\n+    private boolean processInQueue() {\n+        while (true) {\n+            long cursor = inSubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxOTcwNg==", "bodyText": "It feels that this class should be a job?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448319706", "createdAt": "2020-07-01T12:11:32Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTI0Mw==", "bodyText": "why can't we use ObjArrayDequeue directly?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448321243", "createdAt": "2020-07-01T12:14:54Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/std/ObjQueue.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.std;\n+\n+public class ObjQueue<T> implements Mutable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTUyNQ==", "bodyText": "Same here, we need to have second delegate that doesn't seem to add any value.", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448321525", "createdAt": "2020-07-01T12:15:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/std/ObjStack.java", "diffHunk": "@@ -24,93 +24,46 @@\n \n package io.questdb.std;\n \n-import java.util.Arrays;\n-\n public class ObjStack<T> implements Mutable {\n-    private static final int MIN_INITIAL_CAPACITY = 8;\n-    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n-    private T[] elements;\n-    private int head;\n-    private int tail;\n-    private int mask;\n+    private final ObjArrayDequeue<T> dequeue;\n \n     public ObjStack() {\n-        this(DEFAULT_INITIAL_CAPACITY);\n+        dequeue = new ObjArrayDequeue<>();\n     }\n \n     public ObjStack(int initialCapacity) {\n-        allocateElements(initialCapacity);\n+        dequeue = new ObjArrayDequeue<>(initialCapacity);\n     }\n \n     public void clear() {\n-        if (head != tail) {\n-            head = tail = 0;\n-            Arrays.fill(elements, null);\n-        }\n+        dequeue.clear();\n     }\n \n     public boolean notEmpty() {\n-        return head != tail;\n+        return dequeue.notEmpty();\n     }\n \n     public T peek() {\n-        return elements[head];\n+        return dequeue.peekLast();\n     }\n \n     public T peek(int n) {\n-        return elements[(head + n) & mask];\n+        return dequeue.peekLast(n);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMzAyNQ==", "bodyText": "why don't we have these attributes on the context itself and not use holder? This way we don't really need to create objects for retries?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448323025", "createdAt": "2020-07-01T12:18:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f0e1e59d15d8a113f37a6542a3857ec005e190f", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/4f0e1e59d15d8a113f37a6542a3857ec005e190f", "committedDate": "2020-07-01T12:25:22Z", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "338ddc15ee8b6baf255e9968244ffa4c3bfdb5b5", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/338ddc15ee8b6baf255e9968244ffa4c3bfdb5b5", "committedDate": "2020-07-01T23:11:50Z", "message": "PR feedback.\n- wait processor to be a job\n- retry parameters stored within retry-\n- reverted changes to ObjStack"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c456f3f9f3782db3d11d95744a53a31f69e242b", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/9c456f3f9f3782db3d11d95744a53a31f69e242b", "committedDate": "2020-07-01T23:24:19Z", "message": "Merge remote-tracking branch 'upstream/master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e683f743819e760b418b99d24696e3e38c6b065", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/0e683f743819e760b418b99d24696e3e38c6b065", "committedDate": "2020-07-01T23:27:34Z", "message": "Merge remote-tracking branch 'upstream/master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbbc9c6887895362cf66c1c579deabb80d3789eb", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/bbbc9c6887895362cf66c1c579deabb80d3789eb", "committedDate": "2020-07-02T09:14:42Z", "message": "Cleanup, file headers added, unused code deleted."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "committedDate": "2020-08-15T22:39:03Z", "message": "Do not restore state in HttpMultipartContentParser to the previous state when retry exception handled. Instead roll it over to next token to prepare to continue after processor successfully retried."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MTA1NDMx", "url": "https://github.com/questdb/questdb/pull/421#pullrequestreview-468105431", "createdAt": "2020-08-16T23:38:53Z", "commit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzozODo1M1rOHBWLIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQyMzo0ODozOVrOHBWPag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3MzkyMQ==", "bodyText": "This is a race condition. done() releases slot, which can be written to right after done() and right before RetryHolder is retried. This can lead to unpredictable results.\nRetryHolder needs to be copied off before releasing queue slot", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471173921", "createdAt": "2020-08-16T23:38:53Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                inQueue.get(cursor).retry = retry;;\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.retry.getAttemptDetails().attempt + 1, retryHolder.retry.getAttemptDetails().waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDAyNQ==", "bodyText": "perhaps RetryHolder is redundant here. Priority queue can take comparator.", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174025", "createdAt": "2020-08-16T23:39:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/RetryHolder.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+public class RetryHolder implements Comparable<RetryHolder> {\n+    public Retry retry;\n+\n+    @Override\n+    public int compareTo(@NotNull RetryHolder o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDA4MA==", "bodyText": "size of priority queue should be configurable", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174080", "createdAt": "2020-08-16T23:40:06Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDEyMg==", "bodyText": "this should also be configurable", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174122", "createdAt": "2020-08-16T23:40:30Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDUyOA==", "bodyText": "queue is full?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174528", "createdAt": "2020-08-16T23:44:18Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDk0Nw==", "bodyText": "Is this tested?\nI could be wrong here, but when this exception is thrown out of runReruns it would be not be handled at all?", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174947", "createdAt": "2020-08-16T23:47:59Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NTAxOA==", "bodyText": "when queue is full exception out of this method looks unhandled", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471175018", "createdAt": "2020-08-16T23:48:39Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                inQueue.get(cursor).retry = retry;;\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd"}, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07d73190d2383517dc906355e1d0903ed4e17ba5", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/07d73190d2383517dc906355e1d0903ed4e17ba5", "committedDate": "2020-08-26T23:00:28Z", "message": "PR feedback fixes. Handling retry queues capacity exceeded situation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1f1bcd3353521a2b8356a5d4f68e61fdcf3b7a4", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/a1f1bcd3353521a2b8356a5d4f68e61fdcf3b7a4", "committedDate": "2020-08-26T23:29:38Z", "message": "Handling retry queues capacity exceeded situation in TextImportProcessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fb4cd790af74b3828452bd90312a37aa72d5a48", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/7fb4cd790af74b3828452bd90312a37aa72d5a48", "committedDate": "2020-09-15T13:37:43Z", "message": "Testing wait retry with PeerIsSlowToReadException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1d379f71ce969dba6b26e02aa62788d0fbc6373", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/b1d379f71ce969dba6b26e02aa62788d0fbc6373", "committedDate": "2020-09-17T21:55:43Z", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "702416b2fb6345ecd51ff86db8fc6c442d4d1700", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/702416b2fb6345ecd51ff86db8fc6c442d4d1700", "committedDate": "2020-09-19T23:11:34Z", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3e84e99044ebfaa2f36bf19dbdb80e26bcd3572", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/e3e84e99044ebfaa2f36bf19dbdb80e26bcd3572", "committedDate": "2020-09-22T15:01:09Z", "message": "Making retries work after merge from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "263d55a037af0edee9e4133bd865803e5dd6106d", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/263d55a037af0edee9e4133bd865803e5dd6106d", "committedDate": "2020-09-29T17:11:41Z", "message": "Retry query tests with slow peer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f745f86262ec57fdb4596294944fa481d8736cc9", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/f745f86262ec57fdb4596294944fa481d8736cc9", "committedDate": "2020-10-05T00:31:16Z", "message": "Fix import failing when not enough lines read from client.\nFix errors on sending error back to slow client."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11d31d5c80b079b0a3c2a38b859011bc70562357", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/11d31d5c80b079b0a3c2a38b859011bc70562357", "committedDate": "2020-10-05T08:29:32Z", "message": "Rename expected exception in failing text import test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cb0316e8f5ea3ff6a652c7ded1c349f5c7051e7", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/0cb0316e8f5ea3ff6a652c7ded1c349f5c7051e7", "committedDate": "2020-10-07T00:01:11Z", "message": "Schedule channel to read when not enough lines received in Text Import.\nCover server disconnect exception on retry processing in Http Context."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3e891c66cbcca76e441a24546406981bb610792", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/e3e891c66cbcca76e441a24546406981bb610792", "committedDate": "2020-10-13T22:44:11Z", "message": "PR comment minor refactoring:\n- move new exceptions to http package\n- few renaming\n- code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ab5e324dcd5965f7f6d316949db2f7f41d18767", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/8ab5e324dcd5965f7f6d316949db2f7f41d18767", "committedDate": "2020-10-20T00:02:17Z", "message": "- Test small http receive buffer with text import\n- In text import, save the import status before releasing the writer to the pool to not access the writer if interrupted by slow receiver."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9147fc22850be61ad57401e1e0cca437921edf08", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/9147fc22850be61ad57401e1e0cca437921edf08", "committedDate": "2020-10-20T15:20:42Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c6e55c358e364920151b99d516675eba0c3da45", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/8c6e55c358e364920151b99d516675eba0c3da45", "committedDate": "2020-10-20T15:45:29Z", "message": "Fix merger from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a87e90bf8abee96681b49806edb372893e54977d", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/a87e90bf8abee96681b49806edb372893e54977d", "committedDate": "2020-10-22T23:26:40Z", "message": "Fix master merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04799213139c9f255b5fd2261a02c18350f35694", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/04799213139c9f255b5fd2261a02c18350f35694", "committedDate": "2020-10-23T15:46:54Z", "message": "Merge branch 'writer-wait-next' of https://github.com/ideoma/questdb into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcacfa4ca437b204d70e2ef450afe166335f9dea", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/bcacfa4ca437b204d70e2ef450afe166335f9dea", "committedDate": "2020-10-23T22:55:48Z", "message": "Enable all the tests, small cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38d5d3a177c1f109eb2eb3cbc0ffcf2a3131479b", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/38d5d3a177c1f109eb2eb3cbc0ffcf2a3131479b", "committedDate": "2020-10-28T00:36:45Z", "message": "Testing with slow text import sender and receiver."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd949c0d68f3a8ca07b36fe7a8efb135f0a10440", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/fd949c0d68f3a8ca07b36fe7a8efb135f0a10440", "committedDate": "2020-10-29T12:58:15Z", "message": "Test to reproduce HttpMultipartContentParser break on boundary"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "109c9fcfad157d5963c157e98c8cc55fe690b787", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/109c9fcfad157d5963c157e98c8cc55fe690b787", "committedDate": "2020-10-30T10:36:30Z", "message": "Merge branch 'master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43310da0f62587fc51274c706b4e95b4e0bff1de", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/43310da0f62587fc51274c706b4e95b4e0bff1de", "committedDate": "2020-10-30T14:13:18Z", "message": "Merge branch 'master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1ebb014cadd55b83dd71197741ad275753c03ac", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/f1ebb014cadd55b83dd71197741ad275753c03ac", "committedDate": "2020-10-30T18:15:50Z", "message": "Merge branch 'master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ddd6ea61e88eda8cc29bc747206cc6dddf625e3", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/1ddd6ea61e88eda8cc29bc747206cc6dddf625e3", "committedDate": "2020-11-03T00:21:32Z", "message": "Multipart parsing with retry tests.\nAvoiding to request to read more if retry happens on chunk before boundary."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "975edaabb0dd2ad048fe43e4b8c65f7942d3d31b", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/975edaabb0dd2ad048fe43e4b8c65f7942d3d31b", "committedDate": "2020-11-04T00:30:07Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37e72c583e35d46bd74a0dcf9e1267bd32f062c9", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/37e72c583e35d46bd74a0dcf9e1267bd32f062c9", "committedDate": "2020-11-04T13:35:54Z", "message": "Merge branch 'master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edcff1913c45558316ba3d3456ae48e53d43bf40", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/edcff1913c45558316ba3d3456ae48e53d43bf40", "committedDate": "2020-11-04T14:40:21Z", "message": "Merge branch 'master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59c536634bf33777257fe8802f8ce583bf894c61", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/59c536634bf33777257fe8802f8ce583bf894c61", "committedDate": "2020-11-05T00:19:06Z", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/cutlass/http/processors/JsonQueryProcessor.java\n#\tcore/src/main/java/io/questdb/cutlass/http/processors/TextImportProcessor.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffc5c308acf30aaa31ccf53c270128d1498e5ec8", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/ffc5c308acf30aaa31ccf53c270128d1498e5ec8", "committedDate": "2020-11-05T00:27:33Z", "message": "Fix edge case of slow sender on text import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e035f635420d218cf48b809c3337685a09527865", "author": {"user": {"login": "bluestreak01", "name": "Vlad Ilyushchenko"}}, "url": "https://github.com/questdb/questdb/commit/e035f635420d218cf48b809c3337685a09527865", "committedDate": "2020-11-05T13:11:47Z", "message": "Merge branch 'master' into writer-wait-next"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb5a03997f5ee5701501892d32df0b3fed2205d4", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/bb5a03997f5ee5701501892d32df0b3fed2205d4", "committedDate": "2020-11-06T10:57:29Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "576ae1dc1eee1887787307a2369eadfa95bc0d19", "author": {"user": {"login": "ideoma", "name": "Alex Pelagenko"}}, "url": "https://github.com/questdb/questdb/commit/576ae1dc1eee1887787307a2369eadfa95bc0d19", "committedDate": "2020-11-06T16:48:29Z", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpServerConfiguration.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzM5NTY3", "url": "https://github.com/questdb/questdb/pull/421#pullrequestreview-525339567", "createdAt": "2020-11-06T17:08:38Z", "commit": {"oid": "576ae1dc1eee1887787307a2369eadfa95bc0d19"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3245, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}