{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5MTQ1NTA1", "number": 236, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0MjoyN1rOD3SP8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1NDo1MVrOD3SlSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mjk3MjY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo0MjoyN1rOGNdOaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo1Mjo1N1rOGNp6yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzQ5Ng==", "bodyText": "the name & type check can be done here, here is example:\n        TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) throws TextException {\n            this.names = names;\n            this.types = types;\n            if (timestampIndexCol == null) {\n                timestampIndex = -1;\n            } else {\n                timestampIndex = names.indexOf(timestampIndexCol);\n                if (timestampIndex == -1) {\n                    throw TextException.$(\"invalid timestamp column '\").put(timestampIndexCol).put('\\'');\n                }\n                if (types.getQuick(timestampIndex).getType() != ColumnType.TIMESTAMP) {\n                    throw TextException.$(\"not a timestamp '\").put(timestampIndexCol).put('\\'');\n                }\n            }\n            return this;\n        }", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416763496", "createdAt": "2020-04-28T16:42:27Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -320,14 +325,12 @@ public CharSequence getTableName() {\n         }\n \n         @Override\n-        public int getTimestampIndex() {\n-            // not yet on protocol\n-            return -1;\n-        }\n+        public int getTimestampIndex() { return timestampIndex; }\n \n         TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) {\n             this.names = names;\n             this.types = types;\n+            timestampIndex = names.indexOf(timestampIndexCol);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb9518708811394ba2067f5d783109b8a3d0419f"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2OTgzNQ==", "bodyText": "Additionally at end of prepareTable we could get timestamp adapter only once:\ntimestampAdapter = (TimestampAdapter) types.getQuick(timestampIndex);\nAdditionally i would suggest two lambdas returning Row. One lambda will use timestamp index, the other will get row without timestamp. This will simplify onFields", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416769835", "createdAt": "2020-04-28T16:51:33Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -320,14 +325,12 @@ public CharSequence getTableName() {\n         }\n \n         @Override\n-        public int getTimestampIndex() {\n-            // not yet on protocol\n-            return -1;\n-        }\n+        public int getTimestampIndex() { return timestampIndex; }\n \n         TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) {\n             this.names = names;\n             this.types = types;\n+            timestampIndex = names.indexOf(timestampIndexCol);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzQ5Ng=="}, "originalCommit": {"oid": "bb9518708811394ba2067f5d783109b8a3d0419f"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTQ2NA==", "bodyText": "I didn't even notice prepareTable existed. As for the lambdas, doing the try catch inside a lambda and then having some control flow in onFields seemed more complex than just leaving the check at the start of onFields.", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416971464", "createdAt": "2020-04-28T22:52:57Z", "author": {"login": "clickingbuttons"}, "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -320,14 +325,12 @@ public CharSequence getTableName() {\n         }\n \n         @Override\n-        public int getTimestampIndex() {\n-            // not yet on protocol\n-            return -1;\n-        }\n+        public int getTimestampIndex() { return timestampIndex; }\n \n         TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) {\n             this.names = names;\n             this.types = types;\n+            timestampIndex = names.indexOf(timestampIndexCol);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzQ5Ng=="}, "originalCommit": {"oid": "bb9518708811394ba2067f5d783109b8a3d0419f"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzAyNzI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjo1NDo1MVrOGNdwMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo1MzozOFrOGNp7jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjE0Nw==", "bodyText": "the error handling here needs to either:\n\nWhen atomicity == SKIP_ALL, throw CairoException. There is no need to rollback row, it hasn't been created\ndo the logging but exit method via return.", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416772147", "createdAt": "2020-04-28T16:54:51Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -118,17 +115,32 @@ public long getWrittenLineCount() {\n         return writer == null ? 0 : writer.size() - _size;\n     }\n \n-    public void of(CharSequence name, boolean overwrite, boolean durable, int atomicity) {\n+    public void of(CharSequence name, boolean overwrite, boolean durable, int atomicity, int partitionBy, CharSequence timestampIndexCol) {\n         this.tableName = name;\n         this.overwrite = overwrite;\n         this.durable = durable;\n         this.atomicity = atomicity;\n+        this.partitionBy = partitionBy;\n+        this.timestampIndexCol = timestampIndexCol;\n     }\n \n     @Override\n     public void onFields(long line, ObjList<DirectByteCharSequence> values, int valuesLength) {\n-        final TableWriter.Row w = writer.newRow();\n+        long timestamp = 0L;\n+        if (timestampIndex != -1 && types.getQuick(timestampIndex).getType() == ColumnType.TIMESTAMP) {\n+            TimestampAdapter adapter = (TimestampAdapter) types.getQuick(timestampIndex);\n+            final DirectByteCharSequence dbcs = values.getQuick(timestampIndex);\n+            try {\n+                timestamp = adapter.getTimestamp(dbcs);\n+            } catch (NumericException e) {\n+                logError(line, timestampIndex, dbcs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb9518708811394ba2067f5d783109b8a3d0419f"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTY2Mw==", "bodyText": "I opted for the second.", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416971663", "createdAt": "2020-04-28T22:53:38Z", "author": {"login": "clickingbuttons"}, "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -118,17 +115,32 @@ public long getWrittenLineCount() {\n         return writer == null ? 0 : writer.size() - _size;\n     }\n \n-    public void of(CharSequence name, boolean overwrite, boolean durable, int atomicity) {\n+    public void of(CharSequence name, boolean overwrite, boolean durable, int atomicity, int partitionBy, CharSequence timestampIndexCol) {\n         this.tableName = name;\n         this.overwrite = overwrite;\n         this.durable = durable;\n         this.atomicity = atomicity;\n+        this.partitionBy = partitionBy;\n+        this.timestampIndexCol = timestampIndexCol;\n     }\n \n     @Override\n     public void onFields(long line, ObjList<DirectByteCharSequence> values, int valuesLength) {\n-        final TableWriter.Row w = writer.newRow();\n+        long timestamp = 0L;\n+        if (timestampIndex != -1 && types.getQuick(timestampIndex).getType() == ColumnType.TIMESTAMP) {\n+            TimestampAdapter adapter = (TimestampAdapter) types.getQuick(timestampIndex);\n+            final DirectByteCharSequence dbcs = values.getQuick(timestampIndex);\n+            try {\n+                timestamp = adapter.getTimestamp(dbcs);\n+            } catch (NumericException e) {\n+                logError(line, timestampIndex, dbcs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjE0Nw=="}, "originalCommit": {"oid": "bb9518708811394ba2067f5d783109b8a3d0419f"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2264, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}