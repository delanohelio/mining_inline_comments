{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzgyMDIy", "number": 308, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDowNjo0OFrOD-X6uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MjozN1rOD-ZsIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzMwMTY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDowNjo0OFrOGYb97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDowOTo0MFrOGYcEQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyOQ==", "bodyText": "This is what we were talking about this morning. 99% of the flow goes over mispredicted branch.\nhttps://dzone.com/articles/branch-prediction-in-java\nAdditionally, I would suggest that \"max\" value is set to Long.MAX_VALUE. With this choice of \"allow all\" value branching will look like:\nfinal long cursorSize = baseCursor.size();\nif (cursorSize < maxInMemoryRows) {\n// do the good stuff\n} else {\n      throw ....\n}", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428277229", "createdAt": "2020-05-20T20:06:48Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java", "diffHunk": "@@ -112,7 +113,13 @@ public boolean recordCursorSupportsRandomAccess() {\n     }\n \n     @NotNull\n-    protected RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+    private RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+        long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+        if (maxInMemoryRows >= 0 && baseCursor.size() >= 0 && baseCursor.size() > maxInMemoryRows) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3ODg1MA==", "bodyText": "we have more naughty places that trigger branch issues, but we should stop their proliferation", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428278850", "createdAt": "2020-05-20T20:09:40Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNoneRecordCursorFactory.java", "diffHunk": "@@ -112,7 +113,13 @@ public boolean recordCursorSupportsRandomAccess() {\n     }\n \n     @NotNull\n-    protected RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+    private RecordCursor initFunctionsAndCursor(SqlExecutionContext executionContext, RecordCursor baseCursor) {\n+        long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+        if (maxInMemoryRows >= 0 && baseCursor.size() >= 0 && baseCursor.size() > maxInMemoryRows) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyOQ=="}, "originalCommit": {"oid": "b3dce73c5599ea46c177023eded6378f03037e6d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzU4NDY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MDoyNlrOGYeyFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MDoyNlrOGYeyFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzM0OA==", "bodyText": "|| baseCursor.size() < 0\nis not necessary :)", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428323348", "createdAt": "2020-05-20T21:40:26Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillNullRecordCursorFactory.java", "diffHunk": "@@ -135,43 +158,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzU4NzEzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MToyMVrOGYezuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MToyMVrOGYezuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzc2OA==", "bodyText": "same", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428323768", "createdAt": "2020-05-20T21:41:21Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "diffHunk": "@@ -154,43 +178,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzU5MjAwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MjozN1rOGYe2kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMTo0MjozN1rOGYe2kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyNDQ5Nw==", "bodyText": "this is purely syntax, (no extra code should be generated). But when there is return statement inside if statement, else branch is not necessary", "url": "https://github.com/questdb/questdb/pull/308#discussion_r428324497", "createdAt": "2020-05-20T21:42:37Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByFillValueRecordCursorFactory.java", "diffHunk": "@@ -154,43 +178,54 @@ public void close() {\n     @Override\n     public RecordCursor getCursor(SqlExecutionContext executionContext) {\n         final RecordCursor baseCursor = base.getCursor(executionContext);\n-        map.clear();\n-\n-        // This factory fills gaps in data. To do that we\n-        // have to know all possible key values. Essentially, every time\n-        // we sample we return same set of key values with different\n-        // aggregation results and timestamp\n-\n-        int n = groupByFunctions.size();\n-        final Record baseCursorRecord = baseCursor.getRecord();\n-        while (baseCursor.hasNext()) {\n-            MapKey key = map.withKey();\n-            mapSink.copy(baseCursorRecord, key);\n-            MapValue value = key.createValue();\n-            if (value.isNew()) {\n-                // timestamp is always stored in value field 0\n-                value.putLong(0, Numbers.LONG_NaN);\n-                // have functions reset their columns to \"zero\" state\n-                // this would set values for when keys are not found right away\n-                for (int i = 0; i < n; i++) {\n-                    groupByFunctions.getQuick(i).setNull(value);\n+        try {\n+            map.clear();\n+            long maxInMemoryRows = executionContext.getCairoSecurityContext().getMaxInMemoryRows();\n+            if (maxInMemoryRows > baseCursor.size() || baseCursor.size() < 0) {\n+                map.setMaxSize(maxInMemoryRows);\n+\n+                // This factory fills gaps in data. To do that we\n+                // have to know all possible key values. Essentially, every time\n+                // we sample we return same set of key values with different\n+                // aggregation results and timestamp\n+\n+                int n = groupByFunctions.size();\n+                final Record baseCursorRecord = baseCursor.getRecord();\n+                while (baseCursor.hasNext()) {\n+                    MapKey key = map.withKey();\n+                    mapSink.copy(baseCursorRecord, key);\n+                    MapValue value = key.createValue();\n+                    if (value.isNew()) {\n+                        // timestamp is always stored in value field 0\n+                        value.putLong(0, Numbers.LONG_NaN);\n+                        // have functions reset their columns to \"zero\" state\n+                        // this would set values for when keys are not found right away\n+                        for (int i = 0; i < n; i++) {\n+                            groupByFunctions.getQuick(i).setNull(value);\n+                        }\n+                    }\n+                }\n+\n+                // empty map? this means that base cursor was empty\n+                if (map.size() == 0) {\n+                    baseCursor.close();\n+                    return EmptyTableRecordCursor.INSTANCE;\n                 }\n-            }\n-        }\n \n-        // empty map? this means that base cursor was empty\n-        if (map.size() == 0) {\n+                // because we pass base cursor twice we have to go back to top\n+                // for the second run\n+                baseCursor.toTop();\n+                boolean next = baseCursor.hasNext();\n+                // we know base cursor has value\n+                assert next;\n+                return initFunctionsAndCursor(executionContext, baseCursor);\n+            } else {\n+                throw LimitOverflowException.instance(maxInMemoryRows);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b63cc11c880f8969f6052bff045a41c24a6857"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2282, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}