{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NTI1NTgw", "number": 713, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMjo0ODoyMFrOE-o2ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMjo0ODo0NlrOE-o3KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTE2NDkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/line/tcp/LineTcpMeasurementScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMjo0ODoyMFrOH75muA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMjo0ODoyMFrOH75muA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU3MTgzMg==", "bodyText": "// owner when \"old\" owner is fully done. This is a volatile variable on the event, used by both threads", "url": "https://github.com/questdb/questdb/pull/713#discussion_r532571832", "createdAt": "2020-11-30T12:48:20Z", "author": {"login": "patrickSpaceSurfer"}, "path": "core/src/main/java/io/questdb/cutlass/line/tcp/LineTcpMeasurementScheduler.java", "diffHunk": "@@ -552,41 +563,51 @@ private boolean drainQueue() {\n                         eventProcessed = true;\n                     }\n                 }\n+\n+                // by not releasing cursor we force the sequence to return us the same value over and over\n+                // until cursor value is released\n                 if (eventProcessed) {\n                     sequence.done(cursor);\n                 }\n             }\n         }\n \n-        private void handleEventException(LineTcpMeasurementEvent event, Parser parser, CairoException ex) {\n-            LOG.error()\n-                    .$(\"could not create parser, measurement will be skipped [jobName=\").$(jobName)\n-                    .$(\", table=\").$(event.getTableName())\n-                    .$(\", ex=\").$(ex.getFlyweightMessage())\n-                    .$(\", errno=\").$(ex.getErrno())\n-                    .$(']').$();\n-            Misc.free(parser);\n-            parserCache.remove(event.getTableName());\n-        }\n-\n         private void processNextEvent(LineTcpMeasurementEvent event) {\n-            Parser parser = parserCache.get(event.getTableName());\n+            final int index = parserCache.keyIndex(event.getTableName());\n+            Parser parser = null;\n             try {\n-                if (null != parser) {\n+                if (index < 0) {\n+                    parser = parserCache.valueAt(index);\n                     parser.processEvent(event);\n                 } else {\n                     parser = new Parser();\n                     parser.processFirstEvent(engine, securityContext, event);\n                     LOG.info().$(\"created parser [jobName=\").$(jobName).$(\" table=\").$(event.getTableName()).$(']').$();\n-                    parserCache.put(Chars.toString(event.getTableName()), parser);\n+                    parserCache.putAt(index, Chars.toString(event.getTableName()), parser);\n                 }\n             } catch (CairoException ex) {\n-                handleEventException(event, parser, ex);\n+                LOG.error()\n+                        .$(\"could not create parser, measurement will be skipped [jobName=\").$(jobName)\n+                        .$(\", table=\").$(event.getTableName())\n+                        .$(\", ex=\").$(ex.getFlyweightMessage())\n+                        .$(\", errno=\").$(ex.getErrno())\n+                        .$(']').$();\n+\n+                Misc.free(parser);\n+\n+                if (index < 0) {\n+                    parserCache.removeAt(index);\n+                }\n             }\n         }\n \n         private boolean processRebalance(LineTcpMeasurementEvent event) {\n             if (event.rebalanceToThreadId == id) {\n+                // This thread is now a declared owner of the table, but it can only become actual\n+                // owner when \"old\" over is fully done. This is a volatile variable on the event, used by both threads", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a297c1546e7ebf7d47c84fa8877960efb56c780"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTE2NjQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cutlass/line/tcp/LineTcpMeasurementScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMjo0ODo0NlrOH75noA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMjo0ODo0NlrOH75noA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU3MjA2NA==", "bodyText": "// to handover the table. The starting point is \"false\" and the \"old\" owner thread will eventually set this", "url": "https://github.com/questdb/questdb/pull/713#discussion_r532572064", "createdAt": "2020-11-30T12:48:46Z", "author": {"login": "patrickSpaceSurfer"}, "path": "core/src/main/java/io/questdb/cutlass/line/tcp/LineTcpMeasurementScheduler.java", "diffHunk": "@@ -552,41 +563,51 @@ private boolean drainQueue() {\n                         eventProcessed = true;\n                     }\n                 }\n+\n+                // by not releasing cursor we force the sequence to return us the same value over and over\n+                // until cursor value is released\n                 if (eventProcessed) {\n                     sequence.done(cursor);\n                 }\n             }\n         }\n \n-        private void handleEventException(LineTcpMeasurementEvent event, Parser parser, CairoException ex) {\n-            LOG.error()\n-                    .$(\"could not create parser, measurement will be skipped [jobName=\").$(jobName)\n-                    .$(\", table=\").$(event.getTableName())\n-                    .$(\", ex=\").$(ex.getFlyweightMessage())\n-                    .$(\", errno=\").$(ex.getErrno())\n-                    .$(']').$();\n-            Misc.free(parser);\n-            parserCache.remove(event.getTableName());\n-        }\n-\n         private void processNextEvent(LineTcpMeasurementEvent event) {\n-            Parser parser = parserCache.get(event.getTableName());\n+            final int index = parserCache.keyIndex(event.getTableName());\n+            Parser parser = null;\n             try {\n-                if (null != parser) {\n+                if (index < 0) {\n+                    parser = parserCache.valueAt(index);\n                     parser.processEvent(event);\n                 } else {\n                     parser = new Parser();\n                     parser.processFirstEvent(engine, securityContext, event);\n                     LOG.info().$(\"created parser [jobName=\").$(jobName).$(\" table=\").$(event.getTableName()).$(']').$();\n-                    parserCache.put(Chars.toString(event.getTableName()), parser);\n+                    parserCache.putAt(index, Chars.toString(event.getTableName()), parser);\n                 }\n             } catch (CairoException ex) {\n-                handleEventException(event, parser, ex);\n+                LOG.error()\n+                        .$(\"could not create parser, measurement will be skipped [jobName=\").$(jobName)\n+                        .$(\", table=\").$(event.getTableName())\n+                        .$(\", ex=\").$(ex.getFlyweightMessage())\n+                        .$(\", errno=\").$(ex.getErrno())\n+                        .$(']').$();\n+\n+                Misc.free(parser);\n+\n+                if (index < 0) {\n+                    parserCache.removeAt(index);\n+                }\n             }\n         }\n \n         private boolean processRebalance(LineTcpMeasurementEvent event) {\n             if (event.rebalanceToThreadId == id) {\n+                // This thread is now a declared owner of the table, but it can only become actual\n+                // owner when \"old\" over is fully done. This is a volatile variable on the event, used by both threads\n+                // to handover the table. The starting point is \"false\" and the \"old\" over thread will eventually set this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a297c1546e7ebf7d47c84fa8877960efb56c780"}, "originalPosition": 194}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2155, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}