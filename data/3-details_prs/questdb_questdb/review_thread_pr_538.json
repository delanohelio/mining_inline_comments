{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Njg0MzA3", "number": 538, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNzozMVrOEWZY5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0NjoyMlrOEW6oEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIwMTAxOnYy", "diffSide": "RIGHT", "path": "core/src/main/c/freebsd/files.c", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNzozMVrOG9sD7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDoyNToxOFrOG-JDgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODIyMw==", "bodyText": "perhaps we should extract method body into an inlined function and use the same function in both critical and non-critial JNI wrappers", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467338223", "createdAt": "2020-08-08T00:37:31Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/c/freebsd/files.c", "diffHunk": "@@ -0,0 +1,60 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+#include \"../share/files.h\"\n+#include <sys/mman.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <stdio.h>\n+ \n+JNIEXPORT jlong JNICALL JavaCritical_io_questdb_std_Files_mremap0\n+        (jlong fd, jlong address, jlong previousLen, jlong newLen, jlong offset, jint flags) {\n+    int prot = 0;\n+\n+    if (flags == com_questdb_std_Files_MAP_RO) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyODk4Nw==", "bodyText": "The non critical function is only used by JVM's that dont support the critical path (most do and certainly the openjdk does) and by code running in interpreted mode (according to the docs I read, but this has never happened to me). Certainly in my past experiments with the openjdk when I didn't even have a non critical function prototype it was never called. However, the docs say we need a non critical function prototype...", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467728987", "createdAt": "2020-08-10T07:28:26Z", "author": {"login": "patrickSpaceSurfer"}, "path": "core/src/main/c/freebsd/files.c", "diffHunk": "@@ -0,0 +1,60 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+#include \"../share/files.h\"\n+#include <sys/mman.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <stdio.h>\n+ \n+JNIEXPORT jlong JNICALL JavaCritical_io_questdb_std_Files_mremap0\n+        (jlong fd, jlong address, jlong previousLen, jlong newLen, jlong offset, jint flags) {\n+    int prot = 0;\n+\n+    if (flags == com_questdb_std_Files_MAP_RO) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODIyMw=="}, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgxMzI0OA==", "bodyText": "I was trying to make a point about code duplication.  Both function can exist they can just call an inlinable C function", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467813248", "createdAt": "2020-08-10T10:25:18Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/c/freebsd/files.c", "diffHunk": "@@ -0,0 +1,60 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+#include \"../share/files.h\"\n+#include <sys/mman.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <stdio.h>\n+ \n+JNIEXPORT jlong JNICALL JavaCritical_io_questdb_std_Files_mremap0\n+        (jlong fd, jlong address, jlong previousLen, jlong newLen, jlong offset, jint flags) {\n+    int prot = 0;\n+\n+    if (flags == com_questdb_std_Files_MAP_RO) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODIyMw=="}, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIwMTM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/c/freebsd/files.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNzo1MlrOG9sEIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozNzo1MlrOG9sEIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODI3Mw==", "bodyText": "comments can go away perhaps?", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467338273", "createdAt": "2020-08-08T00:37:52Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/c/freebsd/files.c", "diffHunk": "@@ -0,0 +1,60 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+#include \"../share/files.h\"\n+#include <sys/mman.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <stdio.h>\n+ \n+JNIEXPORT jlong JNICALL JavaCritical_io_questdb_std_Files_mremap0\n+        (jlong fd, jlong address, jlong previousLen, jlong newLen, jlong offset, jint flags) {\n+    int prot = 0;\n+\n+    if (flags == com_questdb_std_Files_MAP_RO) {\n+        prot = PROT_READ;\n+    } else if (flags == com_questdb_std_Files_MAP_RW) {\n+        prot = PROT_READ | PROT_WRITE;\n+    }\n+\n+    void *orgAddr = (void *) address;\n+    void *newAddr = mmap(orgAddr, (size_t) newLen, prot, MAP_SHARED, (int) fd, offset);\n+    if (orgAddr != newAddr) {\n+        int rc = munmap(orgAddr, (size_t) previousLen);\n+//        if (rc != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIwMjkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDozOTo0M1rOG9sE9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwOToyMjowNVrOG-HMLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODQ4NA==", "bodyText": "this is a better implementation than legacy virtual memory. Perhaps we should go ahead and replace virtual memory usages with this class.\nAdditionally class is not fully tested. There are a number of gaps. Using this impl instead of VirtualMemory will subject code to better testing.", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467338484", "createdAt": "2020-08-08T00:39:43Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc4MjcwMw==", "bodyText": "I have created a use_contiguous branch, will move everything over to ContiguousVirtualMemory there", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467782703", "createdAt": "2020-08-10T09:22:05Z", "author": {"login": "patrickSpaceSurfer"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODQ4NA=="}, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxOTIwNzMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDo0MzozMlrOG9sHOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDo0MzozMlrOG9sHOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTA2Nw==", "bodyText": "exception should say \"could not\" rather than \"cannot\"", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467339067", "createdAt": "2020-08-08T00:43:32Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -81,12 +84,26 @@ public void of(FilesFacade ff, LPSZ name, long pageSize, long size) {\n             throw CairoException.instance(ff.errno()).put(\"Cannot open file: \").put(name);\n         }\n \n+        map(ff, name, size);\n+    }\n+\n+    protected void map(FilesFacade ff, LPSZ name, long size) {\n         this.size = size;\n-        this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n-        this.absolutePointer = page;\n+        if (size > 0) {\n+            this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n+            if (page == FilesFacade.MAP_FAILED) {\n+                close();\n+                throw CairoException.instance(ff.errno()).put(\"Cannot mmap \").put(name).put(\" [size=\").put(size).put(\", fd=\").put(fd).put(']');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU1NDY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoxOTo0MVrOG-aFIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoxOTo0MVrOG-aFIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjE5Mg==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092192", "createdAt": "2020-08-10T18:19:41Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU1NTQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoxOTo1MlrOG-aFig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoxOTo1MlrOG-aFig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjI5OA==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092298", "createdAt": "2020-08-10T18:19:52Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU1NjU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMDoxMFrOG-aGNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMDoxMFrOG-aGNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjQ3MQ==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092471", "createdAt": "2020-08-10T18:20:10Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU1NzY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMDozMlrOG-aG6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMDozMlrOG-aG6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjY0OA==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092648", "createdAt": "2020-08-10T18:20:32Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU1OTEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMDo1M1rOG-aHuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMDo1M1rOG-aHuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Mjg1Ng==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092856", "createdAt": "2020-08-10T18:20:53Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU1OTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMTowMVrOG-aH8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMTowMVrOG-aH8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjkxNQ==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092915", "createdAt": "2020-08-10T18:21:01Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2MDc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMToyNVrOG-aIyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMToyNVrOG-aIyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzEzMQ==", "bodyText": "constants like that should be Character.BYTES", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093131", "createdAt": "2020-08-10T18:21:25Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 278}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2MjA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMTo0NlrOG-aJjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMTo0NlrOG-aJjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzMyNg==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093326", "createdAt": "2020-08-10T18:21:46Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2MzA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMjowNVrOG-aKKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMjowNVrOG-aKKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzQ4MQ==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093481", "createdAt": "2020-08-10T18:22:05Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2NDQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMjozMVrOG-aLCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMjozMVrOG-aLCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzcwNw==", "bodyText": "untested and unused", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093707", "createdAt": "2020-08-10T18:22:31Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {\n+        if (value == 0)\n+            return putNullStr();\n+        else {\n+            checkLimits(6);\n+            final long offset = getAppendOffset();\n+            putInt(1);\n+            Unsafe.getUnsafe().putChar(appendAddress, value);\n+            appendAddress += Character.BYTES;\n+            return offset;\n+        }\n+    }\n+\n+    public final long putStr(CharSequence value, int pos, int len) {\n+        if (value == null) {\n+            return putNullStr();\n+        }\n+        return putStr0(value, pos, len);\n+    }\n+\n+    public void putStr(long offset, CharSequence value) {\n+        if (value == null) {\n+            putNullStr(offset);\n+        } else {\n+            putStr(offset, value, 0, value.length());\n+        }\n+    }\n+\n+    public void putStr(long offset, CharSequence value, int pos, int len) {\n+        checkLimits(offset, len * 2 + STRING_LENGTH_BYTES);\n+        putInt(offset, len);\n+        copyStrChars(value, pos, len, baseAddress + offset + STRING_LENGTH_BYTES);\n+    }\n+\n+    /**\n+     * Skips given number of bytes. Same as logically appending 0-bytes. Advantage of this method is that\n+     * no memory write takes place.\n+     *\n+     * @param bytes number of bytes to skip\n+     */\n+    public void skip(long bytes) {\n+        checkLimits(bytes);\n+        appendAddress += bytes;\n+    }\n+\n+    public void zero() {\n+        long baseLength = baseAddressHi - baseAddress;\n+        Unsafe.getUnsafe().setMemory(baseAddress, baseLength, (byte) 0);\n+    }\n+\n+    private void putLong256Null() {\n+        checkLimits(32);\n+        Unsafe.getUnsafe().putLong(appendAddress, Long256Impl.NULL_LONG256.getLong0());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES, Long256Impl.NULL_LONG256.getLong1());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 2, Long256Impl.NULL_LONG256.getLong2());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 3, Long256Impl.NULL_LONG256.getLong3());\n+    }\n+\n+    private long putStr0(CharSequence value, int pos, int len) {\n+        checkLimits(len * 2 + STRING_LENGTH_BYTES);\n+        final long offset = getAppendOffset();\n+        putInt(len);\n+        copyStrChars(value, pos, len, appendAddress);\n+        appendAddress += len * 2;\n+        return offset;\n+    }\n+\n+    protected void releaseMemory() {\n+        if (baseAddress != 0) {\n+            long baseLength = baseAddressHi - baseAddress;\n+            Unsafe.free(baseAddress, baseLength);\n+            handleMemoryReleased();\n+        }\n+    }\n+\n+    protected long remapMemory(long newSize) {\n+        if (baseAddress == 0) {\n+            return Unsafe.malloc(newSize);\n+        }\n+        long oldSize = getMemorySize();\n+        return Unsafe.realloc(baseAddress, oldSize, newSize);\n+    }\n+\n+    protected final void handleMemoryTruncated(long newSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 483}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2NTc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMjo1NVrOG-aL4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMjo1NVrOG-aL4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzkyMA==", "bodyText": "exception untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093920", "createdAt": "2020-08-10T18:22:55Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {\n+        if (value == 0)\n+            return putNullStr();\n+        else {\n+            checkLimits(6);\n+            final long offset = getAppendOffset();\n+            putInt(1);\n+            Unsafe.getUnsafe().putChar(appendAddress, value);\n+            appendAddress += Character.BYTES;\n+            return offset;\n+        }\n+    }\n+\n+    public final long putStr(CharSequence value, int pos, int len) {\n+        if (value == null) {\n+            return putNullStr();\n+        }\n+        return putStr0(value, pos, len);\n+    }\n+\n+    public void putStr(long offset, CharSequence value) {\n+        if (value == null) {\n+            putNullStr(offset);\n+        } else {\n+            putStr(offset, value, 0, value.length());\n+        }\n+    }\n+\n+    public void putStr(long offset, CharSequence value, int pos, int len) {\n+        checkLimits(offset, len * 2 + STRING_LENGTH_BYTES);\n+        putInt(offset, len);\n+        copyStrChars(value, pos, len, baseAddress + offset + STRING_LENGTH_BYTES);\n+    }\n+\n+    /**\n+     * Skips given number of bytes. Same as logically appending 0-bytes. Advantage of this method is that\n+     * no memory write takes place.\n+     *\n+     * @param bytes number of bytes to skip\n+     */\n+    public void skip(long bytes) {\n+        checkLimits(bytes);\n+        appendAddress += bytes;\n+    }\n+\n+    public void zero() {\n+        long baseLength = baseAddressHi - baseAddress;\n+        Unsafe.getUnsafe().setMemory(baseAddress, baseLength, (byte) 0);\n+    }\n+\n+    private void putLong256Null() {\n+        checkLimits(32);\n+        Unsafe.getUnsafe().putLong(appendAddress, Long256Impl.NULL_LONG256.getLong0());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES, Long256Impl.NULL_LONG256.getLong1());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 2, Long256Impl.NULL_LONG256.getLong2());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 3, Long256Impl.NULL_LONG256.getLong3());\n+    }\n+\n+    private long putStr0(CharSequence value, int pos, int len) {\n+        checkLimits(len * 2 + STRING_LENGTH_BYTES);\n+        final long offset = getAppendOffset();\n+        putInt(len);\n+        copyStrChars(value, pos, len, appendAddress);\n+        appendAddress += len * 2;\n+        return offset;\n+    }\n+\n+    protected void releaseMemory() {\n+        if (baseAddress != 0) {\n+            long baseLength = baseAddressHi - baseAddress;\n+            Unsafe.free(baseAddress, baseLength);\n+            handleMemoryReleased();\n+        }\n+    }\n+\n+    protected long remapMemory(long newSize) {\n+        if (baseAddress == 0) {\n+            return Unsafe.malloc(newSize);\n+        }\n+        long oldSize = getMemorySize();\n+        return Unsafe.realloc(baseAddress, oldSize, newSize);\n+    }\n+\n+    protected final void handleMemoryTruncated(long newSize) {\n+        assert newSize <= getMemorySize();\n+        assert baseAddress != 0;\n+        baseAddressHi = baseAddress + newSize;\n+        if (appendAddress > baseAddressHi) {\n+            appendAddress = baseAddressHi;\n+        }\n+    }\n+\n+    protected final void handleMemoryReleased() {\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    protected final void setPageSize(long pageSize) {\n+        this.pageSize = Numbers.ceilPow2(pageSize);\n+    }\n+\n+    protected final long getMemorySize() {\n+        return baseAddressHi - baseAddress;\n+    }\n+\n+    private void checkAndExtend(long addressHi) {\n+        assert appendAddress <= baseAddressHi;\n+        assert addressHi >= baseAddress;\n+        if (addressHi > baseAddressHi) {\n+            doExtend(addressHi);\n+        }\n+    }\n+\n+    protected final void checkLimits(long size) {\n+        checkAndExtend(appendAddress + size);\n+    }\n+\n+    protected final void checkLimits(long offset, long size) {\n+        checkAndExtend(baseAddress + offset + size);\n+    }\n+\n+    private void doExtend(long addressHi) {\n+        long newSize = addressHi - baseAddress;\n+        long nPages = (newSize / pageSize) + 1;\n+        newSize = nPages * pageSize;\n+        long oldSize = getMemorySize();\n+        LOG.info().$(\"extending [oldSize=\").$(oldSize).$(\", newSize=\").$(newSize).$(']').$();\n+        if (nPages > maxPages) {\n+            throw LimitOverflowException.instance().put(\"Maximum number of pages (\").put(maxPages).put(\") breached in VirtualMemory\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 529}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2NzE4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMzoyNFrOG-aMyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMzoyNFrOG-aMyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NDE1NQ==", "bodyText": "exception untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468094155", "createdAt": "2020-08-10T18:23:24Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {\n+        if (value == 0)\n+            return putNullStr();\n+        else {\n+            checkLimits(6);\n+            final long offset = getAppendOffset();\n+            putInt(1);\n+            Unsafe.getUnsafe().putChar(appendAddress, value);\n+            appendAddress += Character.BYTES;\n+            return offset;\n+        }\n+    }\n+\n+    public final long putStr(CharSequence value, int pos, int len) {\n+        if (value == null) {\n+            return putNullStr();\n+        }\n+        return putStr0(value, pos, len);\n+    }\n+\n+    public void putStr(long offset, CharSequence value) {\n+        if (value == null) {\n+            putNullStr(offset);\n+        } else {\n+            putStr(offset, value, 0, value.length());\n+        }\n+    }\n+\n+    public void putStr(long offset, CharSequence value, int pos, int len) {\n+        checkLimits(offset, len * 2 + STRING_LENGTH_BYTES);\n+        putInt(offset, len);\n+        copyStrChars(value, pos, len, baseAddress + offset + STRING_LENGTH_BYTES);\n+    }\n+\n+    /**\n+     * Skips given number of bytes. Same as logically appending 0-bytes. Advantage of this method is that\n+     * no memory write takes place.\n+     *\n+     * @param bytes number of bytes to skip\n+     */\n+    public void skip(long bytes) {\n+        checkLimits(bytes);\n+        appendAddress += bytes;\n+    }\n+\n+    public void zero() {\n+        long baseLength = baseAddressHi - baseAddress;\n+        Unsafe.getUnsafe().setMemory(baseAddress, baseLength, (byte) 0);\n+    }\n+\n+    private void putLong256Null() {\n+        checkLimits(32);\n+        Unsafe.getUnsafe().putLong(appendAddress, Long256Impl.NULL_LONG256.getLong0());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES, Long256Impl.NULL_LONG256.getLong1());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 2, Long256Impl.NULL_LONG256.getLong2());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 3, Long256Impl.NULL_LONG256.getLong3());\n+    }\n+\n+    private long putStr0(CharSequence value, int pos, int len) {\n+        checkLimits(len * 2 + STRING_LENGTH_BYTES);\n+        final long offset = getAppendOffset();\n+        putInt(len);\n+        copyStrChars(value, pos, len, appendAddress);\n+        appendAddress += len * 2;\n+        return offset;\n+    }\n+\n+    protected void releaseMemory() {\n+        if (baseAddress != 0) {\n+            long baseLength = baseAddressHi - baseAddress;\n+            Unsafe.free(baseAddress, baseLength);\n+            handleMemoryReleased();\n+        }\n+    }\n+\n+    protected long remapMemory(long newSize) {\n+        if (baseAddress == 0) {\n+            return Unsafe.malloc(newSize);\n+        }\n+        long oldSize = getMemorySize();\n+        return Unsafe.realloc(baseAddress, oldSize, newSize);\n+    }\n+\n+    protected final void handleMemoryTruncated(long newSize) {\n+        assert newSize <= getMemorySize();\n+        assert baseAddress != 0;\n+        baseAddressHi = baseAddress + newSize;\n+        if (appendAddress > baseAddressHi) {\n+            appendAddress = baseAddressHi;\n+        }\n+    }\n+\n+    protected final void handleMemoryReleased() {\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    protected final void setPageSize(long pageSize) {\n+        this.pageSize = Numbers.ceilPow2(pageSize);\n+    }\n+\n+    protected final long getMemorySize() {\n+        return baseAddressHi - baseAddress;\n+    }\n+\n+    private void checkAndExtend(long addressHi) {\n+        assert appendAddress <= baseAddressHi;\n+        assert addressHi >= baseAddress;\n+        if (addressHi > baseAddressHi) {\n+            doExtend(addressHi);\n+        }\n+    }\n+\n+    protected final void checkLimits(long size) {\n+        checkAndExtend(appendAddress + size);\n+    }\n+\n+    protected final void checkLimits(long offset, long size) {\n+        checkAndExtend(baseAddress + offset + size);\n+    }\n+\n+    private void doExtend(long addressHi) {\n+        long newSize = addressHi - baseAddress;\n+        long nPages = (newSize / pageSize) + 1;\n+        newSize = nPages * pageSize;\n+        long oldSize = getMemorySize();\n+        LOG.info().$(\"extending [oldSize=\").$(oldSize).$(\", newSize=\").$(newSize).$(']').$();\n+        if (nPages > maxPages) {\n+            throw LimitOverflowException.instance().put(\"Maximum number of pages (\").put(maxPages).put(\") breached in VirtualMemory\");\n+        }\n+        long appendOffset = appendAddress - baseAddress;\n+        baseAddress = remapMemory(newSize);\n+        baseAddressHi = baseAddress + newSize;\n+        appendAddress = baseAddress + appendOffset;\n+    }\n+\n+    public class CharSequenceView extends AbstractCharSequence {\n+        private int len;\n+        private long offset;\n+\n+        @Override\n+        public int length() {\n+            return len;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            return ContiguousVirtualMemory.this.getChar(offset + index * 2L);\n+        }\n+\n+        CharSequenceView of(long offset, int len) {\n+            this.offset = offset;\n+            this.len = len;\n+            return this;\n+        }\n+    }\n+\n+    private class ByteSequenceView implements BinarySequence {\n+        private long offset;\n+        private long len = -1;\n+\n+        @Override\n+        public byte byteAt(long index) {\n+            return getByte(offset + index);\n+        }\n+\n+        @Override\n+        public void copyTo(long address, final long start, final long length) {\n+            long bytesRemaining = Math.min(length, this.len - start);\n+            long offset = this.offset + start;\n+            Unsafe.getUnsafe().copyMemory(baseAddress + offset, address, bytesRemaining);\n+        }\n+\n+        @Override\n+        public long length() {\n+            return len;\n+        }\n+\n+        ByteSequenceView of(long offset, long len) {\n+            this.offset = offset;\n+            this.len = len;\n+            return this;\n+        }\n+    }\n+\n+    private class InPageLong256FromCharSequenceDecoder extends Long256FromCharSequenceDecoder {\n+        private void putLong256(CharSequence hexString) {\n+            final int len;\n+            if (hexString == null || (len = hexString.length()) == 0) {\n+                putLong256Null();\n+                appendAddress += Long256.BYTES;\n+            } else {\n+                putLong256(hexString, 2, len);\n+            }\n+        }\n+\n+        private void putLong256(CharSequence hexString, int start, int end) {\n+            try {\n+                inPageLong256Decoder.decode(hexString, start, end);\n+            } catch (NumericException e) {\n+                throw CairoException.instance(0).put(\"invalid long256 [hex=\").put(hexString).put(']');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 601}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU2ODYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ExtendableOnePageMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMzo0OVrOG-aNqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyMzo0OVrOG-aNqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NDM3OA==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468094378", "createdAt": "2020-08-10T18:23:49Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ExtendableOnePageMemory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.LPSZ;\n+\n+public class ExtendableOnePageMemory extends OnePageMemory {\n+    public ExtendableOnePageMemory(FilesFacade ff, LPSZ name, long size) {\n+        super(ff, name, size);\n+    }\n+\n+    public ExtendableOnePageMemory() {\n+        super();\n+    }\n+\n+    @Override\n+    protected void map(FilesFacade ff, LPSZ name, long size) {\n+        size = Math.min(ff.length(fd), size);\n+        super.map(ff, name, size);\n+    }\n+\n+    @Override\n+    public void grow(long newSize) {\n+        final long fileSize = ff.length(fd);\n+        newSize = Math.max(newSize, fileSize);\n+        if (newSize <= size) {\n+            return;\n+        }\n+\n+        long offset = absolutePointer - page;\n+        long previousSize = size;\n+        if (previousSize > 0) {\n+            page = ff.mremap(fd, page, previousSize, newSize, 0, Files.MAP_RO);\n+        } else {\n+            assert page == -1;\n+            page = ff.mmap(fd, newSize, 0, Files.MAP_RO);\n+        }\n+        if (page == FilesFacade.MAP_FAILED) {\n+            close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDU3MDE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyNDoxOFrOG-aOjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODoyNDoxOFrOG-aOjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NDYwNg==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468094606", "createdAt": "2020-08-10T18:24:18Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -81,12 +84,26 @@ public void of(FilesFacade ff, LPSZ name, long pageSize, long size) {\n             throw CairoException.instance(ff.errno()).put(\"Cannot open file: \").put(name);\n         }\n \n+        map(ff, name, size);\n+    }\n+\n+    protected void map(FilesFacade ff, LPSZ name, long size) {\n         this.size = size;\n-        this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n-        this.absolutePointer = page;\n+        if (size > 0) {\n+            this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n+            if (page == FilesFacade.MAP_FAILED) {\n+                close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDY0NTk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0NjoxMlrOG-a8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0NjoxMlrOG-a8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjMxMg==", "bodyText": "unused", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468106312", "createdAt": "2020-08-10T18:46:12Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNDY0NjU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0NjoyMlrOG-a8mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODo0NjoyMlrOG-a8mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjM5NA==", "bodyText": "untested", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468106394", "createdAt": "2020-08-10T18:46:22Z", "author": {"login": "bluestreak01"}, "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2179, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}