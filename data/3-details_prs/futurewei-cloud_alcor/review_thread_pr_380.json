{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMzYxMTYx", "number": 380, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjoxNzoxNlrOEitQDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1ODoxMFrOElzFwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI4NDI4OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjoxNzoxNlrOHQvU2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzo1MToyMVrOHSNbYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDY0OQ==", "bodyText": "@kevin-zhonghao This function is for updateSubnetRouteTable, why the 'check resource' uses  checkVpcDefaultRouteTableWebJsonResourceIsValid(resource)", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r487314649", "createdAt": "2020-09-11T22:17:16Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -15,14 +15,287 @@\n */\n package com.futurewei.alcor.route.controller;\n \n+import com.futurewei.alcor.common.entity.ResponseId;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.exception.ParameterNullOrEmptyException;\n+import com.futurewei.alcor.common.exception.ResourceNotValidException;\n import com.futurewei.alcor.common.logging.*;\n+import com.futurewei.alcor.common.stats.DurationStatistics;\n+import com.futurewei.alcor.route.exception.CanNotFindSubnet;\n+import com.futurewei.alcor.route.exception.CanNotFindVpc;\n+import com.futurewei.alcor.route.exception.ExistMultipleSubnetRouteTable;\n+import com.futurewei.alcor.route.exception.VpcRouterContainsSubnetRoutingTables;\n+import com.futurewei.alcor.route.service.RouteTableDatabaseService;\n+import com.futurewei.alcor.route.service.RouterDatabaseService;\n+import com.futurewei.alcor.route.service.RouterService;\n+import com.futurewei.alcor.route.utils.RestPreconditionsUtil;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestBody;\n+import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RestController;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import static org.springframework.web.bind.annotation.RequestMethod.*;\n+\n @RestController\n @ComponentScan(value = \"com.futurewei.alcor.common.stats\")\n public class RouterController {\n \n     private Logger logger = LoggerFactory.getLogger();\n \n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private RouterService routerService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/router\"})\n+    @DurationStatistics\n+    public RouterWebJson getOrCreateVpcRouter(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        Router router = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            router = this.routerService.getOrCreateVpcRouter(projectid, vpcid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouterWebJson(router);\n+    }\n+\n+    @RequestMapping(\n+            method = DELETE,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/router\"})\n+    @DurationStatistics\n+    public ResponseId deleteVpcRouter(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        String routerId = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routerId = this.routerService.deleteVpcRouter(projectid, vpcid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (VpcRouterContainsSubnetRoutingTables e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        }\n+\n+        return new ResponseId(routerId);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/vpcroutetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson getOrCreateVpcRouteTable(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routetable = this.routerService.getOrCreateVpcRouteTable(projectid, vpcid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routetable);\n+    }\n+\n+    @RequestMapping(\n+            method = PUT,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/vpcroutetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson updateVpcRouteTable(@PathVariable String projectid, @PathVariable String vpcid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkVpcDefaultRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }\n+\n+            routetable = this.routerService.updateVpcRouteTable(projectid, vpcid, resource);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routetable);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/routetables\"})\n+    @DurationStatistics\n+    public RouteTablesWebJson getVpcRouteTables(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        List<RouteTable> routetables = new ArrayList<>();\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routetables = this.routerService.getVpcRouteTables(projectid, vpcid);\n+\n+        } catch (Exception e) {\n+            throw e;\n+        }\n+\n+        return new RouteTablesWebJson(routetables);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/routetables/{routetableid}\"})\n+    @DurationStatistics\n+    public RouteTableWebJson getVpcRouteTableById(@PathVariable String projectid, @PathVariable String routetableid) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(routetableid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routetable = this.routeTableDatabaseService.getByRouteTableId(routetableid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routetable);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson getOrCreateSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid) throws Exception {\n+\n+        RouteTable routeTable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routeTable = this.routerService.getOrCreateSubnetRouteTable(projectid, subnetid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (ExistMultipleSubnetRouteTable e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" , subnetId: \" + subnetid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routeTable);\n+    }\n+\n+    @RequestMapping(\n+            method = PUT,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson updateSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkVpcDefaultRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NjQxOQ==", "bodyText": "That's a name mistake, it's already changed to checkSubnetRouteTableWebJsonResourceIsValid", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488856419", "createdAt": "2020-09-15T17:51:21Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/controller/RouterController.java", "diffHunk": "@@ -15,14 +15,287 @@\n */\n package com.futurewei.alcor.route.controller;\n \n+import com.futurewei.alcor.common.entity.ResponseId;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.exception.ParameterNullOrEmptyException;\n+import com.futurewei.alcor.common.exception.ResourceNotValidException;\n import com.futurewei.alcor.common.logging.*;\n+import com.futurewei.alcor.common.stats.DurationStatistics;\n+import com.futurewei.alcor.route.exception.CanNotFindSubnet;\n+import com.futurewei.alcor.route.exception.CanNotFindVpc;\n+import com.futurewei.alcor.route.exception.ExistMultipleSubnetRouteTable;\n+import com.futurewei.alcor.route.exception.VpcRouterContainsSubnetRoutingTables;\n+import com.futurewei.alcor.route.service.RouteTableDatabaseService;\n+import com.futurewei.alcor.route.service.RouterDatabaseService;\n+import com.futurewei.alcor.route.service.RouterService;\n+import com.futurewei.alcor.route.utils.RestPreconditionsUtil;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestBody;\n+import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RestController;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+\n+import static org.springframework.web.bind.annotation.RequestMethod.*;\n+\n @RestController\n @ComponentScan(value = \"com.futurewei.alcor.common.stats\")\n public class RouterController {\n \n     private Logger logger = LoggerFactory.getLogger();\n \n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private RouterService routerService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/router\"})\n+    @DurationStatistics\n+    public RouterWebJson getOrCreateVpcRouter(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        Router router = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            router = this.routerService.getOrCreateVpcRouter(projectid, vpcid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouterWebJson(router);\n+    }\n+\n+    @RequestMapping(\n+            method = DELETE,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/router\"})\n+    @DurationStatistics\n+    public ResponseId deleteVpcRouter(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        String routerId = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routerId = this.routerService.deleteVpcRouter(projectid, vpcid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (VpcRouterContainsSubnetRoutingTables e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        }\n+\n+        return new ResponseId(routerId);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/vpcroutetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson getOrCreateVpcRouteTable(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routetable = this.routerService.getOrCreateVpcRouteTable(projectid, vpcid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routetable);\n+    }\n+\n+    @RequestMapping(\n+            method = PUT,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/vpcroutetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson updateVpcRouteTable(@PathVariable String projectid, @PathVariable String vpcid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkVpcDefaultRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }\n+\n+            routetable = this.routerService.updateVpcRouteTable(projectid, vpcid, resource);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (CanNotFindVpc e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" : \" + vpcid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routetable);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/vpcs/{vpcid}/routetables\"})\n+    @DurationStatistics\n+    public RouteTablesWebJson getVpcRouteTables(@PathVariable String projectid, @PathVariable String vpcid) throws Exception {\n+\n+        List<RouteTable> routetables = new ArrayList<>();\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(vpcid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routetables = this.routerService.getVpcRouteTables(projectid, vpcid);\n+\n+        } catch (Exception e) {\n+            throw e;\n+        }\n+\n+        return new RouteTablesWebJson(routetables);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/routetables/{routetableid}\"})\n+    @DurationStatistics\n+    public RouteTableWebJson getVpcRouteTableById(@PathVariable String projectid, @PathVariable String routetableid) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(routetableid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routetable = this.routeTableDatabaseService.getByRouteTableId(routetableid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routetable);\n+    }\n+\n+    @RequestMapping(\n+            method = GET,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson getOrCreateSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid) throws Exception {\n+\n+        RouteTable routeTable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            routeTable = this.routerService.getOrCreateSubnetRouteTable(projectid, subnetid);\n+\n+        } catch (ParameterNullOrEmptyException e) {\n+            throw e;\n+        } catch (ExistMultipleSubnetRouteTable e) {\n+            logger.log(Level.WARNING, e.getMessage() + \" , subnetId: \" + subnetid);\n+            throw e;\n+        } catch (DatabasePersistenceException e) {\n+            throw e;\n+        }\n+\n+        return new RouteTableWebJson(routeTable);\n+    }\n+\n+    @RequestMapping(\n+            method = PUT,\n+            value = {\"/project/{projectid}/subnets/{subnetid}/routetable\"})\n+    @DurationStatistics\n+    public RouteTableWebJson updateSubnetRouteTable(@PathVariable String projectid, @PathVariable String subnetid, @RequestBody RouteTableWebJson resource) throws Exception {\n+\n+        RouteTable routetable = null;\n+\n+        try {\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(subnetid);\n+            RestPreconditionsUtil.verifyParameterNotNullorEmpty(projectid);\n+            RestPreconditionsUtil.verifyResourceFound(projectid);\n+\n+            // check resource\n+            if (!RouteManagerUtil.checkVpcDefaultRouteTableWebJsonResourceIsValid(resource)) {\n+                throw new ResourceNotValidException(\"request resource is invalid\");\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDY0OQ=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQzNTU0OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzo1MzoxMFrOHQwrBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODoyOTowNVrOHSOssw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNjcxMA==", "bodyText": "What's the DEFAULT_TARGET value here?\nFor the VPC local network, such as 10.0.0.0/16, it's TARGET should be 'local' (same as AWS).", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r487336710", "createdAt": "2020-09-11T23:53:10Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODE3Ng==", "bodyText": "We may need to define several type for TARGET, such as 'local', 'internet_gw', 'nat_gw', etc..., similar to AWS.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488018176", "createdAt": "2020-09-14T15:22:18Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNjcxMA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg2ODIyMA==", "bodyText": "DEFAULT_TARGET = \"Local\"", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488868220", "createdAt": "2020-09-15T18:12:34Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNjcxMA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NzIzNQ==", "bodyText": "okay ~ I will create the Target Enum", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488877235", "createdAt": "2020-09-15T18:29:05Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNjcxMA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQ0MDgzOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzo1NzoxNFrOHQwt9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOToyNzo1MVrOHSREGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNzQ2MA==", "bodyText": "Router doesn't have type, it's owner should look like \"VPC:vpc_id\".", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r487337460", "createdAt": "2020-09-11T23:57:14Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNTk5NA==", "bodyText": "Sure", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488915994", "createdAt": "2020-09-15T19:27:51Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNzQ2MA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQxNjQyOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozMDo1MFrOHRawzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDoyMTo1M1rOHSTJAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNjMxOQ==", "bodyText": "The logic here is not correct! We shouldn't block the updating for VPC default routing table when there are subnets using it. So, I think we don't need to check 'if the VPC router contains subnet routing table' here.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488026319", "createdAt": "2020-09-14T15:30:50Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzU1OQ==", "bodyText": "Instead, we need to check if there is any subnet exists in the VPC. If VPC contains subnet, we cannot delete VPC router and VPC default routing table.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488027559", "createdAt": "2020-09-14T15:32:30Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNjMxOQ=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1MDAxOQ==", "bodyText": "Yeah you are right, I'll modify the checking process", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488950019", "createdAt": "2020-09-15T20:21:53Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNjMxOQ=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ1NDc2OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTozOToyMFrOHRbIlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTowNzowOFrOHSUkzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjQwNA==", "bodyText": "These lines of code same as the lines in the getOrCreateVpcRouter function. Since one VPC has only one router and default routing table. Should we merge createDefaultVpcRouteTable into getOrCreateVpcRouter ?", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488032404", "createdAt": "2020-09-14T15:39:20Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3MzUxNw==", "bodyText": "Although some codes here are same as createDefaultVpcRouter, it is not convenient to merge them. They are used for different method and the parameters passed in are dfferent, either", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488973517", "createdAt": "2020-09-15T21:07:08Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjQwNA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ2OTAyOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0MjozNFrOHRbRTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzoxMjozMVrOHSaCzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNDYzOA==", "bodyText": "VPC default route table has only one for each VPC. We shouldn't look-up all routing tables to get it.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488034638", "createdAt": "2020-09-14T15:42:34Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA2MzExNw==", "bodyText": "Already add a field \"vpcDefaultRouteTableId\" in Router to map vpc default route table", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r489063117", "createdAt": "2020-09-15T23:12:31Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNDYzOA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ3NDg3OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0Mzo1N1rOHRbU9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMToxODozN1rOHSU6Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNTU3NA==", "bodyText": "We don't need to check this, see my comment in the  deleteVpcRouter.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488035574", "createdAt": "2020-09-14T15:43:57Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3ODk1OQ==", "bodyText": "sure", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488978959", "createdAt": "2020-09-15T21:18:37Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNTU3NA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ5MTQxOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0NzozNVrOHRbfXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMjowMTo1MVrOHSWwRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODIzOA==", "bodyText": "This function should return all routing tables within this VPC, including VPC default routing table and all subnets' routing tables, not just only VPC default route table.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488038238", "createdAt": "2020-09-14T15:47:35Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAwOTIyMQ==", "bodyText": "What is returned here is a List", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r489009221", "createdAt": "2020-09-15T22:01:51Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODIzOA=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzQ5NzIyOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo0ODo1NlrOHRbi-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMjowNDowNVrOHSW3Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTE2Mg==", "bodyText": "I am not quite understand the logic here. Why you return new ArrayList<RouteTable>() when you cannot find router?", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488039162", "createdAt": "2020-09-14T15:48:56Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return new ArrayList<RouteTable>();\n+        }\n+        return router.getVpcRouteTable();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAxMDk3OA==", "bodyText": "I changed here return null, is it correct?", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r489010978", "createdAt": "2020-09-15T22:04:05Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return new ArrayList<RouteTable>();\n+        }\n+        return router.getVpcRouteTable();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTE2Mg=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzUyOTU1OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo1NjoxNlrOHRb29w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMjo1Njo0OFrOHSZWQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NDI3OQ==", "bodyText": "We may need to change this API's name. Each subnet has a default routing table which is the VPC default route table. If user change it for a subnet, the subnet will create its own route table. Therefore, here we just need to return the current subnet's route table. If the subnet doesn't have a route table which means it uses VPC default route table, we just return VPC's default route table. If the subnet contains its own route table, then we just return its current route table.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488044279", "createdAt": "2020-09-14T15:56:16Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return new ArrayList<RouteTable>();\n+        }\n+        return router.getVpcRouteTable();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateSubnetRouteTable(String projectId, String subnetId) throws CacheException, ExistMultipleSubnetRouteTable, DatabasePersistenceException {\n+        RouteTable routeTable = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NTc2NQ==", "bodyText": "So, just change getOrCreateSubnetRouteTable to getSubnetRouteTable. This API can also apply to Neutron router, since Neutron is explicitly create subnet route table, so just return what it has in the subnet.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488045765", "createdAt": "2020-09-14T15:58:31Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return new ArrayList<RouteTable>();\n+        }\n+        return router.getVpcRouteTable();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateSubnetRouteTable(String projectId, String subnetId) throws CacheException, ExistMultipleSubnetRouteTable, DatabasePersistenceException {\n+        RouteTable routeTable = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NDI3OQ=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA1MTcxMw==", "bodyText": "NP", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r489051713", "createdAt": "2020-09-15T22:56:48Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return new ArrayList<RouteTable>();\n+        }\n+        return router.getVpcRouteTable();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateSubnetRouteTable(String projectId, String subnetId) throws CacheException, ExistMultipleSubnetRouteTable, DatabasePersistenceException {\n+        RouteTable routeTable = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NDI3OQ=="}, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzU2ODAxOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNjowNTozNlrOHRcPEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNjowNTozNlrOHRcPEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA1MDQ0OQ==", "bodyText": "If we follow the logic and comments I gave before, we should able to get the subnet's routing table with subnet_id and update its routing rules. If the subnet doesn't have its own route table, that's mean it currently uses VPC's default route table. Then we just create a new route table for it and push routing rules it has into the route table.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r488050449", "createdAt": "2020-09-14T16:05:36Z", "author": {"login": "cj-chung"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, owner, ports, projectId, true, null, null);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if the VPC router contains subnet routing table\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        if (vpcRouteTable == null || vpcRouteTable.size() == 0) {\n+            return null;\n+        }\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.PRIVATE_SUBNET.getRouteTableType().equals(routeTableType) || RouteTableType.PUBLIC_SUBNET.getRouteTableType().equals(routeTableType)) {\n+                throw new VpcRouterContainsSubnetRoutingTables();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, RouteConstant.DEFAULT_TARGET, RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC, owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType().getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                routeTable = vpcRouteTable;\n+                vpcRouteTables.remove(vpcRouteTable);\n+                break;\n+            }\n+        }\n+\n+        if (routeTable == null) {\n+            String routeTableId = inRoutetable.getId();\n+            if (routeTableId == null) {\n+                routeTableId = UUID.randomUUID().toString();\n+                inRoutetable.setId(routeTableId);\n+            }\n+            inRoutetable.setRouteTableType(RouteTableType.VPC);\n+            vpcRouteTables.add(inRoutetable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return inRoutetable;\n+        } else {\n+            List<RouteEntry> routeEntities = routeTable.getRouteEntities();\n+            List<RouteEntry> inRouteEntities = inRoutetable.getRouteEntities();\n+\n+            for (RouteEntry routeEntry : routeEntities) {\n+                if (!inRouteEntities.contains(routeEntry)) {\n+                    // TODO: check if existing rules are currently used by other subnet\u2019s routing table\n+                }\n+            }\n+            routeTable.setRouteEntities(inRouteEntities);\n+            vpcRouteTables.add(routeTable);\n+            router.setVpcRouteTable(vpcRouteTables);\n+            this.routerDatabaseService.addRouter(router);\n+\n+            return routeTable;\n+        }\n+\n+    }\n+\n+    @Override\n+    public List<RouteTable> getVpcRouteTables(String projectId, String vpcId) throws CanNotFindVpc {\n+        VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+        VpcEntity vpcEntity = vpcResponse.getNetwork();\n+        Router router = vpcEntity.getRouter();\n+        if (router == null) {\n+            return new ArrayList<RouteTable>();\n+        }\n+        return router.getVpcRouteTable();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateSubnetRouteTable(String projectId, String subnetId) throws CacheException, ExistMultipleSubnetRouteTable, DatabasePersistenceException {\n+        RouteTable routeTable = null;\n+\n+        Map<String, RouteTable> routeTableMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = subnetId;\n+        queryParams.put(\"owner\", values);\n+\n+        routeTableMap = this.routeTableDatabaseService.getAllRouteTables(queryParams);\n+        if (routeTableMap == null) {\n+            routeTableMap = new HashMap<>();\n+        }\n+\n+        if (routeTableMap.size() == 0) {\n+            // TODO: call subnet API to create Subnet route table and route rule\n+            return routeTable;\n+        } else if (routeTableMap.size() > 1) {\n+            throw new ExistMultipleSubnetRouteTable();\n+        } else {\n+            for (Map.Entry<String, RouteTable> entry : routeTableMap.entrySet()) {\n+                routeTable = (RouteTable)entry.getValue();\n+            }\n+        }\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateSubnetRouteTable(String projectId, String subnetId, RouteTableWebJson resource) throws CacheException, DatabasePersistenceException, ExistMultipleSubnetRouteTable {\n+        RouteTable routeTable = new RouteTable();\n+        RouteTable inRoutetable = resource.getRoutetable();\n+        // Get or create a router for a Subnet\n+        routeTable = getOrCreateSubnetRouteTable(projectId, subnetId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e45fc5f8999e75a07aa82c506079cb276849c1e"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY1MDc0OnYy", "diffSide": "RIGHT", "path": "lib/src/main/java/com/futurewei/alcor/common/enumClass/RouteTableType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo0NDoyNVrOHVd33Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjoxMDozNFrOHVkKGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MTU4MQ==", "bodyText": "@kevin-zhonghao @cj-chung We might want to describe each enum value a bit more, either in the code or in the design doc.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492271581", "createdAt": "2020-09-21T18:44:25Z", "author": {"login": "xieus"}, "path": "lib/src/main/java/com/futurewei/alcor/common/enumClass/RouteTableType.java", "diffHunk": "@@ -20,7 +20,8 @@\n     PUBLIC_SUBNET(\"public_subnet\"),\n     PRIVATE_SUBNET(\"private_subnet\"),\n     VPC(\"vpc\"),\n-    NEUTRON(\"neutron\");\n+    NEUTRON_ROUTER(\"neutron_router\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NDU1NQ==", "bodyText": "Agree", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492374555", "createdAt": "2020-09-21T22:10:34Z", "author": {"login": "kevin-zhonghao"}, "path": "lib/src/main/java/com/futurewei/alcor/common/enumClass/RouteTableType.java", "diffHunk": "@@ -20,7 +20,8 @@\n     PUBLIC_SUBNET(\"public_subnet\"),\n     PRIVATE_SUBNET(\"private_subnet\"),\n     VPC(\"vpc\"),\n-    NEUTRON(\"neutron\");\n+    NEUTRON_ROUTER(\"neutron_router\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3MTU4MQ=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY3MDc3OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/ExistMultipleSubnetRouteTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1MDowOFrOHVeELw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjoxMTo0OVrOHVkMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NDczNQ==", "bodyText": "ExistingMutlipleSubnetRouteTable\n=>OwnMultipleSubnetRouteTablesException\n\"exist multiple subnet routetable searched by subnet id\"\n=> \"There exist multiple subnet route tables for the same subnet id\"", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492274735", "createdAt": "2020-09-21T18:50:08Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/ExistMultipleSubnetRouteTable.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.exception;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+@ResponseStatus(code= HttpStatus.INTERNAL_SERVER_ERROR, reason=\"exist multiple subnet routetable searched by subnet id\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NTA5Nw==", "bodyText": "Agree", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492375097", "createdAt": "2020-09-21T22:11:49Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/ExistMultipleSubnetRouteTable.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.exception;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+@ResponseStatus(code= HttpStatus.INTERNAL_SERVER_ERROR, reason=\"exist multiple subnet routetable searched by subnet id\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NDczNQ=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY3MzMwOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/ExistMultipleVpcRouter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1MDo1NFrOHVeFyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjoxMjowNlrOHVkMrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NTE0Ng==", "bodyText": "Please update class name and description based on the comment above.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492275146", "createdAt": "2020-09-21T18:50:54Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/ExistMultipleVpcRouter.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.exception;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+@ResponseStatus(code= HttpStatus.INTERNAL_SERVER_ERROR, reason=\"exist multiple vpc router searched by vpc id\")\n+public class ExistMultipleVpcRouter extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NTIxNA==", "bodyText": "NP", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492375214", "createdAt": "2020-09-21T22:12:06Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/ExistMultipleVpcRouter.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.exception;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+@ResponseStatus(code= HttpStatus.INTERNAL_SERVER_ERROR, reason=\"exist multiple vpc router searched by vpc id\")\n+public class ExistMultipleVpcRouter extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NTE0Ng=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY3ODgwOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/VpcContainsSubnet.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1MjoyOFrOHVeJRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjoxMzo1NlrOHVkP1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NjAzOQ==", "bodyText": "VpcContainsSubnet => VpcNonEmptyException\n\"there are some subnets exist in the VPC. We cannot delete VPC router and VPC default routing table.\"\n=> VPC router and route tables can't be deleted as the associated VPC contains subnets", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492276039", "createdAt": "2020-09-21T18:52:28Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/VpcContainsSubnet.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.exception;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+@ResponseStatus(code= HttpStatus.CONFLICT, reason=\"there are some subnets exist in the VPC. We cannot delete VPC router and VPC default routing table.\")\n+public class VpcContainsSubnet extends Exception{\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NjAyMg==", "bodyText": "Agree", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492376022", "createdAt": "2020-09-21T22:13:56Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/exception/VpcContainsSubnet.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.exception;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+@ResponseStatus(code= HttpStatus.CONFLICT, reason=\"there are some subnets exist in the VPC. We cannot delete VPC router and VPC default routing table.\")\n+public class VpcContainsSubnet extends Exception{\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NjAzOQ=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY4NDAwOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NDowN1rOHVeMfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjoxNTowN1rOHVkRwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3Njg2MQ==", "bodyText": "Why do we need getRouteTableType()", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492276861", "createdAt": "2020-09-21T18:54:07Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -98,7 +98,7 @@ public NeutronRouterWebRequestObject saveRouterAndRouterExtraAttribute(NeutronRo\n             String routeTableId = UUID.randomUUID().toString();\n             routeTable.setId(routeTableId);\n             routeTable.setRouteEntities(routeEntities);\n-            routeTable.setRouteTableType(RouteTableType.NEUTRON);\n+            routeTable.setRouteTableType(RouteTableType.NEUTRON_ROUTER.getRouteTableType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NjUxMw==", "bodyText": "Because I changed the RouteTableType field class type", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492376513", "createdAt": "2020-09-21T22:15:07Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -98,7 +98,7 @@ public NeutronRouterWebRequestObject saveRouterAndRouterExtraAttribute(NeutronRo\n             String routeTableId = UUID.randomUUID().toString();\n             routeTable.setId(routeTableId);\n             routeTable.setRouteEntities(routeEntities);\n-            routeTable.setRouteTableType(RouteTableType.NEUTRON);\n+            routeTable.setRouteTableType(RouteTableType.NEUTRON_ROUTER.getRouteTableType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3Njg2MQ=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY4NTc5OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NDozNlrOHVeNiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NDozNlrOHVeNiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NzEzMQ==", "bodyText": "Should stick to RouteTableType.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492277131", "createdAt": "2020-09-21T18:54:36Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -444,11 +444,11 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         if (routeTable == null) {\n             return null;\n         }\n-        RouteTableType routeTableType = routeTable.getRouteTableType();\n+        String routeTableType = routeTable.getRouteTableType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY4ODE3OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NToxMlrOHVeO9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NToxMlrOHVeO9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NzQ5Mw==", "bodyText": "Enum can do comparison easier. No need to convert it to String.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492277493", "createdAt": "2020-09-21T18:55:12Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/NeutronRouterServiceImpl.java", "diffHunk": "@@ -444,11 +444,11 @@ public ConnectedSubnetsWebResponse getConnectedSubnets(String projectId, String\n         if (routeTable == null) {\n             return null;\n         }\n-        RouteTableType routeTableType = routeTable.getRouteTableType();\n+        String routeTableType = routeTable.getRouteTableType();\n \n         if (routeTableType == null) {\n             return null;\n-        } else if(routeTableType.getRouteTableType().equals(\"neutron\")){\n+        } else if(routeTableType.equals(\"neutron\")){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY5MDI5OnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NTo0OFrOHVeQXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjoxNTozMlrOHVkSjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3Nzg1Mw==", "bodyText": "Remove if usused.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492277853", "createdAt": "2020-09-21T18:55:48Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.enumClass.VpcRouteTarget;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.exception.ResourceNotFoundException;\n+import com.futurewei.alcor.common.exception.ResourcePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.subnet.SubnetEntity;\n+import com.futurewei.alcor.web.entity.subnet.SubnetWebJson;\n+import com.futurewei.alcor.web.entity.subnet.SubnetsWebJson;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private VpcRouterToSubnetService vpcRouterToSubnetService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, VpcRouteTarget.LOCAL.getVpcRouteTarget(), RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC.getRouteTableType(), owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, \"VPC:\" + owner, ports, projectId, true, null, null, routeTableId);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if there is any subnet exists in the VPC\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        SubnetsWebJson subnetsWebJson = this.vpcRouterToSubnetService.getSubnetsByVpcId(projectId, vpcId);\n+        if (subnetsWebJson != null) {\n+            ArrayList<SubnetEntity> subnets = subnetsWebJson.getSubnets();\n+            if (subnets != null && subnets.size() > 0) {\n+                throw new VpcContainsSubnet();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+            }\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, VpcRouteTarget.LOCAL.getVpcRouteTarget(), RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC.getRouteTableType(), owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter, ResourceNotFoundException, ResourcePersistenceException {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+//        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+//            String routeTableType = vpcRouteTable.getRouteTableType();\n+//            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+//                routeTable = vpcRouteTable;\n+//                vpcRouteTables.remove(vpcRouteTable);\n+//                break;\n+//            }\n+//        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NjcxOQ==", "bodyText": "Sure", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492376719", "createdAt": "2020-09-21T22:15:32Z", "author": {"login": "kevin-zhonghao"}, "path": "services/route_manager/src/main/java/com/futurewei/alcor/route/service/Impl/RouterServiceImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+Copyright 2019 The Alcor Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+*/\n+package com.futurewei.alcor.route.service.Impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.enumClass.RouteTableType;\n+import com.futurewei.alcor.common.enumClass.VpcRouteTarget;\n+import com.futurewei.alcor.common.exception.DatabasePersistenceException;\n+import com.futurewei.alcor.common.exception.ResourceNotFoundException;\n+import com.futurewei.alcor.common.exception.ResourcePersistenceException;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n+import com.futurewei.alcor.route.entity.RouteConstant;\n+import com.futurewei.alcor.route.exception.*;\n+import com.futurewei.alcor.route.service.*;\n+import com.futurewei.alcor.route.utils.RouteManagerUtil;\n+import com.futurewei.alcor.web.entity.route.*;\n+import com.futurewei.alcor.web.entity.subnet.SubnetEntity;\n+import com.futurewei.alcor.web.entity.subnet.SubnetWebJson;\n+import com.futurewei.alcor.web.entity.subnet.SubnetsWebJson;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcWebJson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.*;\n+\n+@Service\n+public class RouterServiceImpl implements RouterService {\n+\n+    private Logger logger = LoggerFactory.getLogger();\n+\n+    @Autowired\n+    private RouterDatabaseService routerDatabaseService;\n+\n+    @Autowired\n+    private VpcRouterToVpcService vpcRouterToVpcService;\n+\n+    @Autowired\n+    private VpcRouterToSubnetService vpcRouterToSubnetService;\n+\n+    @Autowired\n+    private RouteTableDatabaseService routeTableDatabaseService;\n+\n+    @Autowired\n+    private RouteEntryDatabaseService routeEntryDatabaseService;\n+\n+\n+    @Override\n+    public Router getOrCreateVpcRouter(String projectId, String vpcId) throws CanNotFindVpc, DatabasePersistenceException, CacheException, ExistMultipleVpcRouter {\n+        Router router = null;\n+\n+        // If VPC already has a router, return the router state\n+        Map<String, Router> routerMap = null;\n+        Map<String, Object[]> queryParams = new HashMap<>();\n+        Object[] values = new Object[1];\n+        values[0] = vpcId;\n+        queryParams.put(\"owner\", values);\n+\n+        routerMap = this.routerDatabaseService.getAllRouters(queryParams);\n+\n+        if (routerMap == null) {\n+            routerMap = new HashMap<>();\n+        }\n+\n+        if (routerMap.size() > 1) {\n+            throw new ExistMultipleVpcRouter();\n+        } else if (routerMap.size() == 1) {\n+            for (Map.Entry<String, Router> entry : routerMap.entrySet()) {\n+                router = (Router)entry.getValue();\n+                return router;\n+            }\n+        } else {\n+            // get vpc entity to create default route table and route route rule\n+            VpcWebJson vpcResponse = this.vpcRouterToVpcService.getVpcWebJson(projectId, vpcId);\n+            VpcEntity vpcEntity = vpcResponse.getNetwork();\n+\n+\n+            // If VPC doesn\u2019t have a router, create a new router, create a VPC routing table and pump-in the VPC default routing rules\n+            router = createDefaultVpcRouter(projectId, vpcEntity);\n+        }\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public Router createDefaultVpcRouter(String projectId, VpcEntity vpcEntity) throws DatabasePersistenceException {\n+        String routerId = UUID.randomUUID().toString();\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = vpcEntity.getId();\n+        String destination = vpcEntity.getCidr();\n+        List<RouteTable> vpcRouteTables = new ArrayList<>();\n+        List<String> ports = new ArrayList<>();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", destination, VpcRouteTarget.LOCAL.getVpcRouteTarget(), RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC.getRouteTableType(), owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        Router router = new Router(projectId, routerId, \"default_vpc_router\", \"\",\n+                null, vpcRouteTables, \"VPC:\" + owner, ports, projectId, true, null, null, routeTableId);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return router;\n+    }\n+\n+    @Override\n+    public String deleteVpcRouter(String projectId, String vpcId) throws Exception {\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+        if (router == null) {\n+            return null;\n+        }\n+\n+        // check if there is any subnet exists in the VPC\n+        List<RouteTable> vpcRouteTable = router.getVpcRouteTable();\n+        SubnetsWebJson subnetsWebJson = this.vpcRouterToSubnetService.getSubnetsByVpcId(projectId, vpcId);\n+        if (subnetsWebJson != null) {\n+            ArrayList<SubnetEntity> subnets = subnetsWebJson.getSubnets();\n+            if (subnets != null && subnets.size() > 0) {\n+                throw new VpcContainsSubnet();\n+            }\n+        }\n+\n+        // delete router and route tables\n+        this.routerDatabaseService.deleteRouter(router.getId());\n+        for (RouteTable routeTable : vpcRouteTable) {\n+            String routeTableType = routeTable.getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                this.routeTableDatabaseService.deleteRouteTable(routeTable.getId());\n+            }\n+        }\n+\n+        return router.getId();\n+    }\n+\n+    @Override\n+    public RouteTable getOrCreateVpcRouteTable(String projectId, String vpcId) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter {\n+        RouteTable routeTable = null;\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // If VPC has a VPC routing table, return the routing table\u2019s state\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+            String routeTableType = vpcRouteTable.getRouteTableType();\n+            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+                return vpcRouteTable;\n+            }\n+        }\n+\n+        // If VPC doesn\u2019t have a VPC routing table, this operation will create a VPC routing table and pump-in the VPC default routing rules.\n+        routeTable = createDefaultVpcRouteTable(projectId, router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable createDefaultVpcRouteTable(String projectId, Router router) throws DatabasePersistenceException {\n+        String routeTableId = UUID.randomUUID().toString();\n+        String routeEntryId = UUID.randomUUID().toString();\n+        String owner = router.getOwner();\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+        List<RouteEntry> routeEntities = new ArrayList<>();\n+\n+        // create a VPC routing table and pump-in the VPC default routing rules\n+        RouteEntry routeEntry = new RouteEntry(projectId, routeEntryId, \"default_vpc_routeEntry\", \"\", null, VpcRouteTarget.LOCAL.getVpcRouteTarget(), RouteConstant.DEFAULT_PRIORITY, routeTableId, null);\n+        routeEntities.add(routeEntry);\n+        this.routeEntryDatabaseService.addRouteEntry(routeEntry);\n+\n+        RouteTable routeTable = new RouteTable(projectId, routeTableId, \"default_vpc_routeTable\", \"\", routeEntities, RouteTableType.VPC.getRouteTableType(), owner);\n+        vpcRouteTables.add(routeTable);\n+        this.routeTableDatabaseService.addRouteTable(routeTable);\n+\n+        vpcRouteTables.add(routeTable);\n+        router.setVpcRouteTable(vpcRouteTables);\n+        this.routerDatabaseService.addRouter(router);\n+\n+        return routeTable;\n+    }\n+\n+    @Override\n+    public RouteTable updateVpcRouteTable(String projectId, String vpcId, RouteTableWebJson resource) throws DatabasePersistenceException, CanNotFindVpc, CacheException, ExistMultipleVpcRouter, ResourceNotFoundException, ResourcePersistenceException {\n+        RouteTable routeTable = null;\n+        RouteTable inRoutetable = resource.getRoutetable();\n+\n+        // Get or create a router for a Vpc\n+        Router router = getOrCreateVpcRouter(projectId, vpcId);\n+\n+        // check if there is a vpc default routetable\n+        List<RouteTable> vpcRouteTables = router.getVpcRouteTable();\n+//        for (RouteTable vpcRouteTable : vpcRouteTables) {\n+//            String routeTableType = vpcRouteTable.getRouteTableType();\n+//            if (RouteTableType.VPC.getRouteTableType().equals(routeTableType)) {\n+//                routeTable = vpcRouteTable;\n+//                vpcRouteTables.remove(vpcRouteTable);\n+//                break;\n+//            }\n+//        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3Nzg1Mw=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY5NTIyOnYy", "diffSide": "RIGHT", "path": "services/route_manager/src/test/java/com/futurewei/alcor/route/NeutronRouterTests.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NzoxOVrOHVeTfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NzoxOVrOHVeTfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODY1NQ==", "bodyText": "Same. Should get rid of getRouteTableType() here.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492278655", "createdAt": "2020-09-21T18:57:19Z", "author": {"login": "xieus"}, "path": "services/route_manager/src/test/java/com/futurewei/alcor/route/NeutronRouterTests.java", "diffHunk": "@@ -542,7 +542,7 @@ public void removeRoutesToNeutronRouter_RouterOrSubnetAndPortNotExistOrNotVisibl\n     public void getConnectedSubnets_pass () throws Exception {\n         Mockito.when(routerDatabaseService.getByRouterId(UnitTestConfig.routerId))\n                 .thenReturn(new Router(){{setId(UnitTestConfig.routerId);setPorts(new ArrayList<>());\n-                    setNeutronRouteTable(new RouteTable(){{setRouteEntities(new ArrayList<>());setRouteTableType(RouteTableType.NEUTRON);}});}});\n+                    setNeutronRouteTable(new RouteTable(){{setRouteEntities(new ArrayList<>());setRouteTableType(RouteTableType.NEUTRON_ROUTER.getRouteTableType());}});}});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDY5ODI1OnYy", "diffSide": "RIGHT", "path": "web/src/main/java/com/futurewei/alcor/web/entity/route/RouteTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1ODoxMFrOHVeVWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowOTo0OFrOHVkIuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3OTEzMA==", "bodyText": "Keep RouteTableType if possible.", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492279130", "createdAt": "2020-09-21T18:58:10Z", "author": {"login": "xieus"}, "path": "web/src/main/java/com/futurewei/alcor/web/entity/route/RouteTable.java", "diffHunk": "@@ -29,15 +29,15 @@\n     private List<RouteEntry> routeEntities;\n \n     @JsonProperty(\"route_table_type\")\n-    private RouteTableType routeTableType;\n+    private String routeTableType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3NDIwMQ==", "bodyText": "If I keep RouteTableType, it is difficult to mock requestBody in UTs", "url": "https://github.com/futurewei-cloud/alcor/pull/380#discussion_r492374201", "createdAt": "2020-09-21T22:09:48Z", "author": {"login": "kevin-zhonghao"}, "path": "web/src/main/java/com/futurewei/alcor/web/entity/route/RouteTable.java", "diffHunk": "@@ -29,15 +29,15 @@\n     private List<RouteEntry> routeEntities;\n \n     @JsonProperty(\"route_table_type\")\n-    private RouteTableType routeTableType;\n+    private String routeTableType;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3OTEzMA=="}, "originalCommit": {"oid": "a5d875c684447222305e91e92ec5779dcdf179a6"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4394, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}