{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0NDEwMzA0", "number": 418, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo1OTowOVrOE1G8tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzoxMDozOFrOE1hiFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTIzODMxOnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo1OTowOVrOHtMn-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTozNDowMVrOHuTaAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDgwOA==", "bodyText": "Based on the requirement listed on Issue #448, this transformNorthToSouth method has more than 500+ lines of codes and needs major refactor. The refactor so far doesn't break down the method to improve code readability and reduce potential risk of NPE.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517154808", "createdAt": "2020-11-04T07:59:09Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -16,73 +16,173 @@\n \n package com.futurewei.alcor.dataplane.utils;\n \n-import com.futurewei.alcor.dataplane.exception.ClientOfDPMFailureException;\n-import com.futurewei.alcor.dataplane.exception.DPMFailureException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n import com.futurewei.alcor.dataplane.service.GoalStateService;\n import com.futurewei.alcor.schema.*;\n import com.futurewei.alcor.schema.Port.PortState;\n-import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n-import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n-import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n-import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n+import org.jetbrains.annotations.Nullable;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n import org.springframework.stereotype.Component;\n-import com.futurewei.alcor.common.logging.Logger;\n-import com.futurewei.alcor.common.logging.LoggerFactory;\n-\n \n import java.util.*;\n-import java.util.logging.Level;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n \n import static com.futurewei.alcor.schema.Port.PortConfiguration.FixedIp;\n+import static com.futurewei.alcor.schema.Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER;\n \n @Component\n public class GoalStateManager {\n-    public static final int FORMAT_REVISION_NUMBER = 1;\n-    @Autowired private GoalStateService goalStateService;\n+  public static final int FORMAT_REVISION_NUMBER = 1;\n+  @Autowired private GoalStateService goalStateService;\n   private static final Logger LOG = LoggerFactory.getLogger();\n \n-  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration)\n-  {\n-    LOG.log(Level.INFO,\n-            \"### networkConf str: \"+networkConfiguration.toString());\n-    ExclusionStrategy myExclusionStrategy =\n-            new ExclusionStrategy() {\n-              @Override\n-              public boolean shouldSkipField(FieldAttributes fa) {\n-                return fa.getName().equals(\"tenantId\");\n-              }\n-\n-              @Override\n-              public boolean shouldSkipClass(Class<?> clazz) {\n-                return false;\n-              }\n-            };\n-    Gson gson = new GsonBuilder().setExclusionStrategies(myExclusionStrategy).create();\n-    LOG.log(Level.INFO,\"###############\");\n-    LOG.log(Level.INFO,gson.toJson(networkConfiguration));\n+  /**\n+   * convert and parse dpm input to dpm internal data structure\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  private void convert(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    final List<NeighborInfo> neighborInfos = networkConfiguration.getNeighborInfos();\n+\n+    final List<InternalPortEntity> portEntities = networkConfiguration.getPortEntities();\n+    for (InternalSubnetEntity internalSubnetEntity : networkConfiguration.getSubnets())\n+      subnetIdSubnetsMap.put(internalSubnetEntity.getId(), internalSubnetEntity);\n+\n+    // for newly created ports\n+    for (InternalPortEntity internalPortEntity : portEntities) {\n+      portIdPortMap.put(internalPortEntity.getId(), internalPortEntity);\n+\n+      for (PortEntity.FixedIp ip : internalPortEntity.getFixedIps()) {\n+        Set<String> fixedIpsSet = hostIpFixedIpsMap.get(internalPortEntity.getBindingHostIP());\n+        if (fixedIpsSet == null) fixedIpsSet = new TreeSet<>();\n+        Set<String> subnetIdsSet = hostIpSubnetIdsMap.get(internalPortEntity.getBindingHostIP());\n+        if (subnetIdsSet == null) subnetIdsSet = new TreeSet<>();\n+        fixedIpsSet.add(ip.getIpAddress());\n+        subnetIdsSet.add(ip.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getBindingHostIP(), fixedIpsSet);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getBindingHostIP(), subnetIdsSet);\n+\n+        ipPortIdMap.put(ip.getIpAddress(), internalPortEntity.getId());\n+        ipHostIpMap.put(ip.getIpAddress(), internalPortEntity.getBindingHostIP());\n+        ipSubnetIdMap.put(ip.getIpAddress(), ip.getSubnetId());\n+        ipMacMap.put(ip.getIpAddress(), internalPortEntity.getMacAddress());\n+      }\n+    }\n+    // for neighbor infos\n+    if (neighborInfos != null) {\n+      for (NeighborInfo internalPortEntity : neighborInfos) {\n+        ipPortIdMap.put(internalPortEntity.getPortIp(), internalPortEntity.getPortId());\n+        ipHostIpMap.put(internalPortEntity.getPortIp(), internalPortEntity.getHostIp());\n+        portIdNeighborInfoMap.put(internalPortEntity.getPortIp(), internalPortEntity);\n+        String portIp = internalPortEntity.getPortIp();\n+        Set<String> fixedIps = hostIpFixedIpsMap.get(internalPortEntity.getHostIp());\n+        if (fixedIps == null) fixedIps = new TreeSet<>();\n+        Set<String> subnetIds = hostIpSubnetIdsMap.get(internalPortEntity.getHostIp());\n+        if (subnetIds == null) subnetIds = new TreeSet<>();\n+        fixedIps.add(portIp);\n+        subnetIds.add(internalPortEntity.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getHostIp(), fixedIps);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getHostIp(), subnetIds);\n+        ipPortIdMap.put(portIp, internalPortEntity.getPortId());\n+        ipHostIpMap.put(portIp, internalPortEntity.getHostIp());\n+        ipSubnetIdMap.put(portIp, internalPortEntity.getSubnetId());\n+        ipMacMap.put(portIp, internalPortEntity.getPortMac());\n+      }\n+    }\n+  }\n+  /**\n+   * print dpm input msg\n+   *\n+   * @param networkConfiguration msg\n+   */\n+  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration) {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    try {\n+      String json = objectMapper.writeValueAsString(networkConfiguration);\n+      LOG.log(Level.INFO, \"@@@input json str: \" + json);\n+\n+    } catch (JsonProcessingException e) {\n+      LOG.log(Level.SEVERE, e.getMessage());\n+    }\n   }\n   /**\n    * transform client of dpm msg to aca protobuf format\n    *\n-   * @param networkConfiguration  msg to be transformmed\n+   * @param networkConfiguration msg to be transformmed\n    * @return Map<String, Goalstate.GoalState>\n    * @throws RuntimeException Various exceptions that may occur during the send process\n    */\n-  public Map<String, Goalstate.GoalState> transformNorthToSouth(\n+  @Async\n+  public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODI4OQ==", "bodyText": "changed in 7ccbc91", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517818289", "createdAt": "2020-11-05T06:29:29Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -16,73 +16,173 @@\n \n package com.futurewei.alcor.dataplane.utils;\n \n-import com.futurewei.alcor.dataplane.exception.ClientOfDPMFailureException;\n-import com.futurewei.alcor.dataplane.exception.DPMFailureException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n import com.futurewei.alcor.dataplane.service.GoalStateService;\n import com.futurewei.alcor.schema.*;\n import com.futurewei.alcor.schema.Port.PortState;\n-import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n-import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n-import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n-import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n+import org.jetbrains.annotations.Nullable;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n import org.springframework.stereotype.Component;\n-import com.futurewei.alcor.common.logging.Logger;\n-import com.futurewei.alcor.common.logging.LoggerFactory;\n-\n \n import java.util.*;\n-import java.util.logging.Level;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n \n import static com.futurewei.alcor.schema.Port.PortConfiguration.FixedIp;\n+import static com.futurewei.alcor.schema.Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER;\n \n @Component\n public class GoalStateManager {\n-    public static final int FORMAT_REVISION_NUMBER = 1;\n-    @Autowired private GoalStateService goalStateService;\n+  public static final int FORMAT_REVISION_NUMBER = 1;\n+  @Autowired private GoalStateService goalStateService;\n   private static final Logger LOG = LoggerFactory.getLogger();\n \n-  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration)\n-  {\n-    LOG.log(Level.INFO,\n-            \"### networkConf str: \"+networkConfiguration.toString());\n-    ExclusionStrategy myExclusionStrategy =\n-            new ExclusionStrategy() {\n-              @Override\n-              public boolean shouldSkipField(FieldAttributes fa) {\n-                return fa.getName().equals(\"tenantId\");\n-              }\n-\n-              @Override\n-              public boolean shouldSkipClass(Class<?> clazz) {\n-                return false;\n-              }\n-            };\n-    Gson gson = new GsonBuilder().setExclusionStrategies(myExclusionStrategy).create();\n-    LOG.log(Level.INFO,\"###############\");\n-    LOG.log(Level.INFO,gson.toJson(networkConfiguration));\n+  /**\n+   * convert and parse dpm input to dpm internal data structure\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  private void convert(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    final List<NeighborInfo> neighborInfos = networkConfiguration.getNeighborInfos();\n+\n+    final List<InternalPortEntity> portEntities = networkConfiguration.getPortEntities();\n+    for (InternalSubnetEntity internalSubnetEntity : networkConfiguration.getSubnets())\n+      subnetIdSubnetsMap.put(internalSubnetEntity.getId(), internalSubnetEntity);\n+\n+    // for newly created ports\n+    for (InternalPortEntity internalPortEntity : portEntities) {\n+      portIdPortMap.put(internalPortEntity.getId(), internalPortEntity);\n+\n+      for (PortEntity.FixedIp ip : internalPortEntity.getFixedIps()) {\n+        Set<String> fixedIpsSet = hostIpFixedIpsMap.get(internalPortEntity.getBindingHostIP());\n+        if (fixedIpsSet == null) fixedIpsSet = new TreeSet<>();\n+        Set<String> subnetIdsSet = hostIpSubnetIdsMap.get(internalPortEntity.getBindingHostIP());\n+        if (subnetIdsSet == null) subnetIdsSet = new TreeSet<>();\n+        fixedIpsSet.add(ip.getIpAddress());\n+        subnetIdsSet.add(ip.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getBindingHostIP(), fixedIpsSet);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getBindingHostIP(), subnetIdsSet);\n+\n+        ipPortIdMap.put(ip.getIpAddress(), internalPortEntity.getId());\n+        ipHostIpMap.put(ip.getIpAddress(), internalPortEntity.getBindingHostIP());\n+        ipSubnetIdMap.put(ip.getIpAddress(), ip.getSubnetId());\n+        ipMacMap.put(ip.getIpAddress(), internalPortEntity.getMacAddress());\n+      }\n+    }\n+    // for neighbor infos\n+    if (neighborInfos != null) {\n+      for (NeighborInfo internalPortEntity : neighborInfos) {\n+        ipPortIdMap.put(internalPortEntity.getPortIp(), internalPortEntity.getPortId());\n+        ipHostIpMap.put(internalPortEntity.getPortIp(), internalPortEntity.getHostIp());\n+        portIdNeighborInfoMap.put(internalPortEntity.getPortIp(), internalPortEntity);\n+        String portIp = internalPortEntity.getPortIp();\n+        Set<String> fixedIps = hostIpFixedIpsMap.get(internalPortEntity.getHostIp());\n+        if (fixedIps == null) fixedIps = new TreeSet<>();\n+        Set<String> subnetIds = hostIpSubnetIdsMap.get(internalPortEntity.getHostIp());\n+        if (subnetIds == null) subnetIds = new TreeSet<>();\n+        fixedIps.add(portIp);\n+        subnetIds.add(internalPortEntity.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getHostIp(), fixedIps);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getHostIp(), subnetIds);\n+        ipPortIdMap.put(portIp, internalPortEntity.getPortId());\n+        ipHostIpMap.put(portIp, internalPortEntity.getHostIp());\n+        ipSubnetIdMap.put(portIp, internalPortEntity.getSubnetId());\n+        ipMacMap.put(portIp, internalPortEntity.getPortMac());\n+      }\n+    }\n+  }\n+  /**\n+   * print dpm input msg\n+   *\n+   * @param networkConfiguration msg\n+   */\n+  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration) {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    try {\n+      String json = objectMapper.writeValueAsString(networkConfiguration);\n+      LOG.log(Level.INFO, \"@@@input json str: \" + json);\n+\n+    } catch (JsonProcessingException e) {\n+      LOG.log(Level.SEVERE, e.getMessage());\n+    }\n   }\n   /**\n    * transform client of dpm msg to aca protobuf format\n    *\n-   * @param networkConfiguration  msg to be transformmed\n+   * @param networkConfiguration msg to be transformmed\n    * @return Map<String, Goalstate.GoalState>\n    * @throws RuntimeException Various exceptions that may occur during the send process\n    */\n-  public Map<String, Goalstate.GoalState> transformNorthToSouth(\n+  @Async\n+  public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDgwOA=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzNTQwMA==", "bodyText": "The major logic of transformNorthToSouth method has been moved to GoalStateTransformer, and with some logics pulled out, which is a positive move.\nHowever, I have to point out that the major complexity remains in GoalStateTransformer, and the code remains long and prone to error or NPE (see a potential issue in line 258 of GoalStateTransformer as pointed out there).", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517835400", "createdAt": "2020-11-05T07:17:56Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -16,73 +16,173 @@\n \n package com.futurewei.alcor.dataplane.utils;\n \n-import com.futurewei.alcor.dataplane.exception.ClientOfDPMFailureException;\n-import com.futurewei.alcor.dataplane.exception.DPMFailureException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n import com.futurewei.alcor.dataplane.service.GoalStateService;\n import com.futurewei.alcor.schema.*;\n import com.futurewei.alcor.schema.Port.PortState;\n-import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n-import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n-import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n-import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n+import org.jetbrains.annotations.Nullable;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n import org.springframework.stereotype.Component;\n-import com.futurewei.alcor.common.logging.Logger;\n-import com.futurewei.alcor.common.logging.LoggerFactory;\n-\n \n import java.util.*;\n-import java.util.logging.Level;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n \n import static com.futurewei.alcor.schema.Port.PortConfiguration.FixedIp;\n+import static com.futurewei.alcor.schema.Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER;\n \n @Component\n public class GoalStateManager {\n-    public static final int FORMAT_REVISION_NUMBER = 1;\n-    @Autowired private GoalStateService goalStateService;\n+  public static final int FORMAT_REVISION_NUMBER = 1;\n+  @Autowired private GoalStateService goalStateService;\n   private static final Logger LOG = LoggerFactory.getLogger();\n \n-  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration)\n-  {\n-    LOG.log(Level.INFO,\n-            \"### networkConf str: \"+networkConfiguration.toString());\n-    ExclusionStrategy myExclusionStrategy =\n-            new ExclusionStrategy() {\n-              @Override\n-              public boolean shouldSkipField(FieldAttributes fa) {\n-                return fa.getName().equals(\"tenantId\");\n-              }\n-\n-              @Override\n-              public boolean shouldSkipClass(Class<?> clazz) {\n-                return false;\n-              }\n-            };\n-    Gson gson = new GsonBuilder().setExclusionStrategies(myExclusionStrategy).create();\n-    LOG.log(Level.INFO,\"###############\");\n-    LOG.log(Level.INFO,gson.toJson(networkConfiguration));\n+  /**\n+   * convert and parse dpm input to dpm internal data structure\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  private void convert(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    final List<NeighborInfo> neighborInfos = networkConfiguration.getNeighborInfos();\n+\n+    final List<InternalPortEntity> portEntities = networkConfiguration.getPortEntities();\n+    for (InternalSubnetEntity internalSubnetEntity : networkConfiguration.getSubnets())\n+      subnetIdSubnetsMap.put(internalSubnetEntity.getId(), internalSubnetEntity);\n+\n+    // for newly created ports\n+    for (InternalPortEntity internalPortEntity : portEntities) {\n+      portIdPortMap.put(internalPortEntity.getId(), internalPortEntity);\n+\n+      for (PortEntity.FixedIp ip : internalPortEntity.getFixedIps()) {\n+        Set<String> fixedIpsSet = hostIpFixedIpsMap.get(internalPortEntity.getBindingHostIP());\n+        if (fixedIpsSet == null) fixedIpsSet = new TreeSet<>();\n+        Set<String> subnetIdsSet = hostIpSubnetIdsMap.get(internalPortEntity.getBindingHostIP());\n+        if (subnetIdsSet == null) subnetIdsSet = new TreeSet<>();\n+        fixedIpsSet.add(ip.getIpAddress());\n+        subnetIdsSet.add(ip.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getBindingHostIP(), fixedIpsSet);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getBindingHostIP(), subnetIdsSet);\n+\n+        ipPortIdMap.put(ip.getIpAddress(), internalPortEntity.getId());\n+        ipHostIpMap.put(ip.getIpAddress(), internalPortEntity.getBindingHostIP());\n+        ipSubnetIdMap.put(ip.getIpAddress(), ip.getSubnetId());\n+        ipMacMap.put(ip.getIpAddress(), internalPortEntity.getMacAddress());\n+      }\n+    }\n+    // for neighbor infos\n+    if (neighborInfos != null) {\n+      for (NeighborInfo internalPortEntity : neighborInfos) {\n+        ipPortIdMap.put(internalPortEntity.getPortIp(), internalPortEntity.getPortId());\n+        ipHostIpMap.put(internalPortEntity.getPortIp(), internalPortEntity.getHostIp());\n+        portIdNeighborInfoMap.put(internalPortEntity.getPortIp(), internalPortEntity);\n+        String portIp = internalPortEntity.getPortIp();\n+        Set<String> fixedIps = hostIpFixedIpsMap.get(internalPortEntity.getHostIp());\n+        if (fixedIps == null) fixedIps = new TreeSet<>();\n+        Set<String> subnetIds = hostIpSubnetIdsMap.get(internalPortEntity.getHostIp());\n+        if (subnetIds == null) subnetIds = new TreeSet<>();\n+        fixedIps.add(portIp);\n+        subnetIds.add(internalPortEntity.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getHostIp(), fixedIps);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getHostIp(), subnetIds);\n+        ipPortIdMap.put(portIp, internalPortEntity.getPortId());\n+        ipHostIpMap.put(portIp, internalPortEntity.getHostIp());\n+        ipSubnetIdMap.put(portIp, internalPortEntity.getSubnetId());\n+        ipMacMap.put(portIp, internalPortEntity.getPortMac());\n+      }\n+    }\n+  }\n+  /**\n+   * print dpm input msg\n+   *\n+   * @param networkConfiguration msg\n+   */\n+  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration) {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    try {\n+      String json = objectMapper.writeValueAsString(networkConfiguration);\n+      LOG.log(Level.INFO, \"@@@input json str: \" + json);\n+\n+    } catch (JsonProcessingException e) {\n+      LOG.log(Level.SEVERE, e.getMessage());\n+    }\n   }\n   /**\n    * transform client of dpm msg to aca protobuf format\n    *\n-   * @param networkConfiguration  msg to be transformmed\n+   * @param networkConfiguration msg to be transformmed\n    * @return Map<String, Goalstate.GoalState>\n    * @throws RuntimeException Various exceptions that may occur during the send process\n    */\n-  public Map<String, Goalstate.GoalState> transformNorthToSouth(\n+  @Async\n+  public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDgwOA=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNDQ5Nw==", "bodyText": "per discussion , we would leave this later and merge for now since logic change needs contract change", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518314497", "createdAt": "2020-11-05T19:34:01Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -16,73 +16,173 @@\n \n package com.futurewei.alcor.dataplane.utils;\n \n-import com.futurewei.alcor.dataplane.exception.ClientOfDPMFailureException;\n-import com.futurewei.alcor.dataplane.exception.DPMFailureException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n import com.futurewei.alcor.dataplane.service.GoalStateService;\n import com.futurewei.alcor.schema.*;\n import com.futurewei.alcor.schema.Port.PortState;\n-import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n-import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n-import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n-import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n+import org.jetbrains.annotations.Nullable;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n import org.springframework.stereotype.Component;\n-import com.futurewei.alcor.common.logging.Logger;\n-import com.futurewei.alcor.common.logging.LoggerFactory;\n-\n \n import java.util.*;\n-import java.util.logging.Level;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n \n import static com.futurewei.alcor.schema.Port.PortConfiguration.FixedIp;\n+import static com.futurewei.alcor.schema.Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER;\n \n @Component\n public class GoalStateManager {\n-    public static final int FORMAT_REVISION_NUMBER = 1;\n-    @Autowired private GoalStateService goalStateService;\n+  public static final int FORMAT_REVISION_NUMBER = 1;\n+  @Autowired private GoalStateService goalStateService;\n   private static final Logger LOG = LoggerFactory.getLogger();\n \n-  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration)\n-  {\n-    LOG.log(Level.INFO,\n-            \"### networkConf str: \"+networkConfiguration.toString());\n-    ExclusionStrategy myExclusionStrategy =\n-            new ExclusionStrategy() {\n-              @Override\n-              public boolean shouldSkipField(FieldAttributes fa) {\n-                return fa.getName().equals(\"tenantId\");\n-              }\n-\n-              @Override\n-              public boolean shouldSkipClass(Class<?> clazz) {\n-                return false;\n-              }\n-            };\n-    Gson gson = new GsonBuilder().setExclusionStrategies(myExclusionStrategy).create();\n-    LOG.log(Level.INFO,\"###############\");\n-    LOG.log(Level.INFO,gson.toJson(networkConfiguration));\n+  /**\n+   * convert and parse dpm input to dpm internal data structure\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  private void convert(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    final List<NeighborInfo> neighborInfos = networkConfiguration.getNeighborInfos();\n+\n+    final List<InternalPortEntity> portEntities = networkConfiguration.getPortEntities();\n+    for (InternalSubnetEntity internalSubnetEntity : networkConfiguration.getSubnets())\n+      subnetIdSubnetsMap.put(internalSubnetEntity.getId(), internalSubnetEntity);\n+\n+    // for newly created ports\n+    for (InternalPortEntity internalPortEntity : portEntities) {\n+      portIdPortMap.put(internalPortEntity.getId(), internalPortEntity);\n+\n+      for (PortEntity.FixedIp ip : internalPortEntity.getFixedIps()) {\n+        Set<String> fixedIpsSet = hostIpFixedIpsMap.get(internalPortEntity.getBindingHostIP());\n+        if (fixedIpsSet == null) fixedIpsSet = new TreeSet<>();\n+        Set<String> subnetIdsSet = hostIpSubnetIdsMap.get(internalPortEntity.getBindingHostIP());\n+        if (subnetIdsSet == null) subnetIdsSet = new TreeSet<>();\n+        fixedIpsSet.add(ip.getIpAddress());\n+        subnetIdsSet.add(ip.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getBindingHostIP(), fixedIpsSet);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getBindingHostIP(), subnetIdsSet);\n+\n+        ipPortIdMap.put(ip.getIpAddress(), internalPortEntity.getId());\n+        ipHostIpMap.put(ip.getIpAddress(), internalPortEntity.getBindingHostIP());\n+        ipSubnetIdMap.put(ip.getIpAddress(), ip.getSubnetId());\n+        ipMacMap.put(ip.getIpAddress(), internalPortEntity.getMacAddress());\n+      }\n+    }\n+    // for neighbor infos\n+    if (neighborInfos != null) {\n+      for (NeighborInfo internalPortEntity : neighborInfos) {\n+        ipPortIdMap.put(internalPortEntity.getPortIp(), internalPortEntity.getPortId());\n+        ipHostIpMap.put(internalPortEntity.getPortIp(), internalPortEntity.getHostIp());\n+        portIdNeighborInfoMap.put(internalPortEntity.getPortIp(), internalPortEntity);\n+        String portIp = internalPortEntity.getPortIp();\n+        Set<String> fixedIps = hostIpFixedIpsMap.get(internalPortEntity.getHostIp());\n+        if (fixedIps == null) fixedIps = new TreeSet<>();\n+        Set<String> subnetIds = hostIpSubnetIdsMap.get(internalPortEntity.getHostIp());\n+        if (subnetIds == null) subnetIds = new TreeSet<>();\n+        fixedIps.add(portIp);\n+        subnetIds.add(internalPortEntity.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getHostIp(), fixedIps);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getHostIp(), subnetIds);\n+        ipPortIdMap.put(portIp, internalPortEntity.getPortId());\n+        ipHostIpMap.put(portIp, internalPortEntity.getHostIp());\n+        ipSubnetIdMap.put(portIp, internalPortEntity.getSubnetId());\n+        ipMacMap.put(portIp, internalPortEntity.getPortMac());\n+      }\n+    }\n+  }\n+  /**\n+   * print dpm input msg\n+   *\n+   * @param networkConfiguration msg\n+   */\n+  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration) {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    try {\n+      String json = objectMapper.writeValueAsString(networkConfiguration);\n+      LOG.log(Level.INFO, \"@@@input json str: \" + json);\n+\n+    } catch (JsonProcessingException e) {\n+      LOG.log(Level.SEVERE, e.getMessage());\n+    }\n   }\n   /**\n    * transform client of dpm msg to aca protobuf format\n    *\n-   * @param networkConfiguration  msg to be transformmed\n+   * @param networkConfiguration msg to be transformmed\n    * @return Map<String, Goalstate.GoalState>\n    * @throws RuntimeException Various exceptions that may occur during the send process\n    */\n-  public Map<String, Goalstate.GoalState> transformNorthToSouth(\n+  @Async\n+  public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDgwOA=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI2Mjg2OnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODowNjo0OVrOHtM2iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNjoyOTowMVrOHt1HBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1ODUzNg==", "bodyText": "This block of codes have four for-loop, potentially quite costly. Pls try to improve this part.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517158536", "createdAt": "2020-11-04T08:06:49Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODExNw==", "bodyText": "removed one loop in 7ccbc91 , for extra check we need to optimized the contract", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517818117", "createdAt": "2020-11-05T06:29:01Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1ODUzNg=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI2ODMxOnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODowODo0MFrOHtM5_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNjoyOToxNVrOHt1HSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1OTQyMA==", "bodyText": "How do we ensure that this selected SubnetEntity has the right VPC id?", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517159420", "createdAt": "2020-11-04T08:08:40Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 558}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgwNDg2OA==", "bodyText": "I don't understand your question, do you mean one port could belong to 2 VPC? if not then any subnet info could lead to same vpc id", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517804868", "createdAt": "2020-11-05T05:44:35Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1OTQyMA=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 558}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODE4Ng==", "bodyText": "anyway I changed to use vpc entities in 7ccbc91", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517818186", "createdAt": "2020-11-05T06:29:15Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1OTQyMA=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 558}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTI4MjIzOnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMjo0NlrOHtNCOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNTozOTowNFrOHt0M9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MTUzMQ==", "bodyText": "Is it possible that ipHostIpMap.get(nip) == null?", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517161531", "createdAt": "2020-11-04T08:12:46Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()\n+                                      .iterator()\n+                                      .next()\n+                                      .getVpcId())\n+                              .setFormatVersion(FORMAT_REVISION_NUMBER)\n+                              .setAdminStateUp(true)\n+                              .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                              .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                              .addAllFixedIps(fixedIps)\n+                              .setId(portStateWithEverythingFilledNB.getId())\n+                              .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n+                              .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n+                              .build();\n+\n+                      final PortState portStateSB =\n+                          PortState.newBuilder()\n+                              .setConfiguration(portConfiguration)\n+                              .setOperationType(Common.OperationType.CREATE)\n+                              .build();\n+\n+                      portStateHashSet.add(portStateSB);\n+                    });\n+              }\n \n+              // avoid duplicate\n+\n+              if (networkConfiguration.getNeighborTable() != null\n+                  && neighborStates.size() == 0\n+                  && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                  for (String ip :\n+                      hostIpFixedIpsMap.values().stream()\n+                          .flatMap(alist -> alist.stream())\n+                          .collect(Collectors.toList())) {\n+                    {\n+                      Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                      Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                      if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                        if (!hostIpSubnetIdsMap\n+                            .get(currentGroupHostIp)\n+                            .iterator()\n+                            .next()\n+                            .equals(ipSubnetIdMap.get(ip))) {\n+                          l2 = Neighbor.NeighborType.L3;\n+                          l3 = Neighbor.NeighborType.L2;\n                         }\n-                      });\n+                      }\n+\n+                      if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l3,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } // if contains ip in neighbor info\n+                    }\n+                  }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                  for (String ip :\n+                      hostIpFixedIpsMap.values().stream()\n+                          .flatMap(alist -> alist.stream())\n+                          .collect(Collectors.toList())) {\n+                    Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                    Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                    if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                      if (!hostIpSubnetIdsMap\n+                          .get(currentGroupHostIp)\n+                          .iterator()\n+                          .next()\n+                          .equals(ipSubnetIdMap.get(ip))) {\n+                        l2 = Neighbor.NeighborType.L3;\n+                        l3 = Neighbor.NeighborType.L2;\n+                      }\n+                    }\n+\n+                    final InternalPortEntity portStateWithEverythingFilledNB =\n+                        portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                    if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                      Set<InternalSubnetEntity> ss =\n+                          portStateWithEverythingFilledNB.getSubnetEntities();\n+                      final InternalSubnetEntity next = ss.iterator().next();\n+                      if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l2,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } else {\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l3,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } // end if internal size==1 sn>2\n+                      brandNewIps.add(ip);\n+                    }\n+                  }\n+                  // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                  if (!ipHostIpMap.get(nip).equals(currentGroupHostIp)) continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 699}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgwMzI1NA==", "bodyText": "it's impossible since nip <- brandNewIps <- ip <-port which is previously constructed in convert method", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517803254", "createdAt": "2020-11-05T05:39:04Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()\n+                                      .iterator()\n+                                      .next()\n+                                      .getVpcId())\n+                              .setFormatVersion(FORMAT_REVISION_NUMBER)\n+                              .setAdminStateUp(true)\n+                              .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                              .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                              .addAllFixedIps(fixedIps)\n+                              .setId(portStateWithEverythingFilledNB.getId())\n+                              .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n+                              .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n+                              .build();\n+\n+                      final PortState portStateSB =\n+                          PortState.newBuilder()\n+                              .setConfiguration(portConfiguration)\n+                              .setOperationType(Common.OperationType.CREATE)\n+                              .build();\n+\n+                      portStateHashSet.add(portStateSB);\n+                    });\n+              }\n \n+              // avoid duplicate\n+\n+              if (networkConfiguration.getNeighborTable() != null\n+                  && neighborStates.size() == 0\n+                  && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                  for (String ip :\n+                      hostIpFixedIpsMap.values().stream()\n+                          .flatMap(alist -> alist.stream())\n+                          .collect(Collectors.toList())) {\n+                    {\n+                      Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                      Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                      if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                        if (!hostIpSubnetIdsMap\n+                            .get(currentGroupHostIp)\n+                            .iterator()\n+                            .next()\n+                            .equals(ipSubnetIdMap.get(ip))) {\n+                          l2 = Neighbor.NeighborType.L3;\n+                          l3 = Neighbor.NeighborType.L2;\n                         }\n-                      });\n+                      }\n+\n+                      if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l3,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } // if contains ip in neighbor info\n+                    }\n+                  }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                  for (String ip :\n+                      hostIpFixedIpsMap.values().stream()\n+                          .flatMap(alist -> alist.stream())\n+                          .collect(Collectors.toList())) {\n+                    Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                    Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                    if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                      if (!hostIpSubnetIdsMap\n+                          .get(currentGroupHostIp)\n+                          .iterator()\n+                          .next()\n+                          .equals(ipSubnetIdMap.get(ip))) {\n+                        l2 = Neighbor.NeighborType.L3;\n+                        l3 = Neighbor.NeighborType.L2;\n+                      }\n+                    }\n+\n+                    final InternalPortEntity portStateWithEverythingFilledNB =\n+                        portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                    if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                      Set<InternalSubnetEntity> ss =\n+                          portStateWithEverythingFilledNB.getSubnetEntities();\n+                      final InternalSubnetEntity next = ss.iterator().next();\n+                      if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l2,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } else {\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l3,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } // end if internal size==1 sn>2\n+                      brandNewIps.add(ip);\n+                    }\n+                  }\n+                  // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                  if (!ipHostIpMap.get(nip).equals(currentGroupHostIp)) continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MTUzMQ=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 699}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTU2NTg5OnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/DataPlanePrinter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNjo1OToyM1rOHt1uqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMzoxNTozMVrOHuaUmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyODI2NA==", "bodyText": "We will need a license statement on new file.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517828264", "createdAt": "2020-11-05T06:59:23Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/DataPlanePrinter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.futurewei.alcor.dataplane.utils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyNzgwMA==", "bodyText": "addressed in 3acad53", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518427800", "createdAt": "2020-11-05T23:15:31Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/DataPlanePrinter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.futurewei.alcor.dataplane.utils;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyODI2NA=="}, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTU3MzQ2OnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateTransformer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzowMjozMFrOHt1zEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMzoxNDo1MlrOHuaTlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyOTM5Mg==", "bodyText": "Can op = null? This is another potential NPE when trying to setOperationType(op) in next line.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517829392", "createdAt": "2020-11-05T07:02:30Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateTransformer.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.schema.*;\n+import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n+import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n+import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n+import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n+\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n+\n+\n+public class GoalStateTransformer {\n+    private final GoalStateManager goalStateManager;\n+\n+    public GoalStateTransformer(GoalStateManager goalStateManager) {\n+        this.goalStateManager = goalStateManager;\n+    }\n+\n+    /**\n+     * transform client of dpm msg to aca protobuf format\n+     *\n+     * @param networkConfiguration msg to be transformmed\n+     * @return Map<String, Goalstate.GoalState>\n+     * @throws RuntimeException Various exceptions that may occur during the\n+     * send process\n+     */\n+    @Async\n+    public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(NetworkConfiguration networkConfiguration) throws RuntimeException {\n+\n+        Map<String, String> ipPortIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipMacMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipSubnetIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipHostIpMap = new ConcurrentHashMap<String, String>();\n+        Map<String, Set<String>> hostIpFixedIpsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, Set<String>> hostIpSubnetIdsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, InternalSubnetEntity> subnetIdSubnetsMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portIdPortMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, NeighborInfo> portIdNeighborInfoMap = new ConcurrentHashMap<String, NeighborInfo>();\n+\n+        // print entry input for debug usage\n+        goalStateManager.printNetworkConfiguration(networkConfiguration);\n+        goalStateManager.getDPMPreparer().convert(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap);\n+\n+        Map<String, Set<String>> portsInSameSubnetMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameSubenetMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+        // L3\n+        Map<String, Set<String>> portsInSameVpcMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameVpcMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+\n+        InternalPortEntity[] portStatesArr = networkConfiguration.getPortEntities().toArray(new InternalPortEntity[0]);\n+        InternalSubnetEntity[] subnetArr = networkConfiguration.getSubnets().toArray(new InternalSubnetEntity[0]);\n+        VpcEntity[] vpcArr = networkConfiguration.getVpcs().toArray(new VpcEntity[0]);\n+\n+        // TODO need to v2 subnet and vpc part when logic is\n+        //  clear and integration done\n+        Map<String, List<InternalPortEntity>> mapGroupedByHostIp = new ConcurrentHashMap();\n+        Map<String, InternalSubnetEntity> subnetMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, VpcEntity> vpcMap = new ConcurrentHashMap<String, VpcEntity>();\n+        // construct map from list\n+        for (InternalSubnetEntity s : subnetArr) {\n+            subnetMap.put(s.getId(), s);\n+        }\n+\n+        for (VpcEntity vpc : vpcArr) {\n+            vpcMap.put(vpc.getId(), vpc);\n+        }\n+        // group nb msg by ip\n+        int portCounter = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            }\n+        }\n+\n+        int portCounterL3 = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            }\n+        }\n+\n+        // construct sb msg by ip\n+        Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<String, Goalstate.GoalState>();\n+        // TODO would opt this part when perf needed\n+        hostIpSubnetIdsMap.keySet().forEach(currentGroupHostIp -> {\n+            Set<Port.PortState> portStateHashSet = new HashSet<Port.PortState>();\n+            Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<String, Neighbor.NeighborState>();\n+            Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n+            Set<Vpc.VpcState> vpcStateSet = new HashSet();\n+            Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+            final List<InternalPortEntity> internalPortEntitySet = mapGroupedByHostIp.get(currentGroupHostIp);\n+            if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(portStateWithEverythingFilledNB -> {\n+                    List<Port.PortConfiguration.FixedIp> fixedIps = new ArrayList();\n+                    boolean isExistingPort = false;\n+                    final List<PortEntity.FixedIp> fixedIps1 = portStateWithEverythingFilledNB.getFixedIps();\n+                    for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(Port.PortConfiguration.FixedIp.newBuilder().setSubnetId(fixedIp.getSubnetId()).setIpAddress(fixedIp.getIpAddress()).build());\n+                        if (portIdNeighborInfoMap.values().stream().filter(e -> e.getPortId().equals(ipPortIdMap.get(fixedIp.getIpAddress()))).count() == 0) {\n+                            DHCP.DHCPConfiguration dhcpConfiguration = DHCP.DHCPConfiguration.newBuilder().setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setSubnetId(fixedIp.getSubnetId()).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setIpv4Address(fixedIp.getIpAddress()).build();\n+                            DHCP.DHCPState dhcpState = DHCP.DHCPState.newBuilder().setConfiguration(dhcpConfiguration).build();\n+                            dhcpStateList.add(dhcpState);\n+                        }\n+                    }\n+                    String name = portStateWithEverythingFilledNB.getName() == null ? \"\" : portStateWithEverythingFilledNB.getName();\n+\n+                    Port.PortConfiguration portConfiguration = Port.PortConfiguration.newBuilder().setName(name).setProjectId(portStateWithEverythingFilledNB.getProjectId()).setVpcId(portStateWithEverythingFilledNB.getVpcEntities().iterator().next().getId()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setAdminStateUp(true).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).addAllFixedIps(fixedIps).setId(portStateWithEverythingFilledNB.getId()).setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE).setMessageTypeValue(Common.MessageType.FULL_VALUE).build();\n+\n+                    final Port.PortState portStateSB = Port.PortState.newBuilder().setConfiguration(portConfiguration).setOperationType(Common.OperationType.CREATE).build();\n+\n+                    portStateHashSet.add(portStateSB);\n+                });\n+            }\n+\n+            // avoid duplicate\n+\n+            if (networkConfiguration.getNeighborTable() != null && neighborStates.size() == 0 && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        {\n+                            Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                            Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                            if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                                if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                    l2 = Neighbor.NeighborType.L3;\n+                                    l3 = Neighbor.NeighborType.L2;\n+                                }\n+                            }\n+\n+                            if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // if contains ip in neighbor info\n+                        }\n+                    }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        final InternalPortEntity portStateWithEverythingFilledNB = portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                        if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                            Set<InternalSubnetEntity> ss = portStateWithEverythingFilledNB.getSubnetEntities();\n+                            final InternalSubnetEntity next = ss.iterator().next();\n+                            if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l2);\n+                            } else {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // end if internal size==1 sn>2\n+                            brandNewIps.add(ip);\n+                        }\n+                    }\n+                    // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                    if (!ipHostIpMap.get(nip).equals(currentGroupHostIp))\n+                        continue;\n+                    for (String eip : portIdNeighborInfoMap.keySet()) {\n+\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(nip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        if (ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) { // ip 2.2\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l2);\n+                        } // inner if end\n+                    } // 2nd loop end\n+                } // current nip end\n+            } // if size==0\n+\n+            // lookup subnet entity\n+            for (String sid : ipSubnetIdMap.values()) {\n+                InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(sid);\n+                if (subnetEntity1 == null) {\n+                    GoalStateManager.LOG.log(Level.SEVERE, sid +\n+                            \"subnet is MISSING\");\n+                    continue;\n+                }\n+                goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                // lookup vpc entity\n+                final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n+                Vpc.VpcConfiguration vpcConfiguration = Vpc.VpcConfiguration.newBuilder().setId(vpcEntity.getId()).setCidr(vpcEntity.getCidr()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).build();\n+                Vpc.VpcState vpcState = Vpc.VpcState.newBuilder().setConfiguration(vpcConfiguration).setOperationTypeValue(Common.OperationType.CREATE_VALUE).setOperationType(Common.OperationType.CREATE).build();\n+                vpcStateSet.add(vpcState);\n+            }\n+\n+            List<Router.RouterState> routerStateList = new ArrayList<Router.RouterState>();\n+            if (networkConfiguration.getInternalRouterInfos() != null && neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                for (InternalRouterInfo internalRouterInfo : networkConfiguration.getInternalRouterInfos()) {\n+                    final List<InternalSubnetRoutingTable> subnetRoutingTables = internalRouterInfo.getRouterConfiguration().getSubnetRoutingTables();\n+                    final List<Router.RouterConfiguration.SubnetRoutingTable> subnetRoutingTables2 = new ArrayList<Router.RouterConfiguration.SubnetRoutingTable>();\n+                    for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+                        if (neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                            final InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(internalSubnetRoutingTable.getSubnetId());\n+\n+                            goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                        }\n+\n+                        Router.RouterConfiguration.SubnetRoutingTable subnetRoutingTable = Router.RouterConfiguration.SubnetRoutingTable.newBuilder().setSubnetId(internalSubnetRoutingTable.getSubnetId()).buildPartial();\n+                        List<Router.RouterConfiguration.RoutingRule> routingRuleList = new ArrayList<Router.RouterConfiguration.RoutingRule>();\n+                        for (InternalRoutingRule internalRoutingRule : internalSubnetRoutingTable.getRoutingRules()) {\n+                            Router.DestinationType destinationType =\n+                                    Router.DestinationType.INTERNET;\n+                            Router.RouterConfiguration.RoutingRuleExtraInfo routingRuleExtraInfo = Router.RouterConfiguration.RoutingRuleExtraInfo.newBuilder().setDestinationType(destinationType).setNextHopMac(internalRoutingRule.getRoutingRuleExtraInfo().getNextHopMac()).build();\n+                            Common.OperationType op = goalStateManager.getGoalStateHelper().getOperationType(internalRoutingRule.getOperationType().equals(OperationType.CREATE), internalRoutingRule.getOperationType().equals(OperationType.INFO), Common.OperationType.INFO, internalRoutingRule.getOperationType().equals(OperationType.DELETE), Common.OperationType.DELETE, internalRoutingRule.getOperationType().equals(OperationType.UPDATE), Common.OperationType.UPDATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNDk3Nw==", "bodyText": "op is used internally and could not be null, but let me just change that per discussion", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518314977", "createdAt": "2020-11-05T19:34:39Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateTransformer.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.schema.*;\n+import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n+import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n+import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n+import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n+\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n+\n+\n+public class GoalStateTransformer {\n+    private final GoalStateManager goalStateManager;\n+\n+    public GoalStateTransformer(GoalStateManager goalStateManager) {\n+        this.goalStateManager = goalStateManager;\n+    }\n+\n+    /**\n+     * transform client of dpm msg to aca protobuf format\n+     *\n+     * @param networkConfiguration msg to be transformmed\n+     * @return Map<String, Goalstate.GoalState>\n+     * @throws RuntimeException Various exceptions that may occur during the\n+     * send process\n+     */\n+    @Async\n+    public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(NetworkConfiguration networkConfiguration) throws RuntimeException {\n+\n+        Map<String, String> ipPortIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipMacMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipSubnetIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipHostIpMap = new ConcurrentHashMap<String, String>();\n+        Map<String, Set<String>> hostIpFixedIpsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, Set<String>> hostIpSubnetIdsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, InternalSubnetEntity> subnetIdSubnetsMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portIdPortMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, NeighborInfo> portIdNeighborInfoMap = new ConcurrentHashMap<String, NeighborInfo>();\n+\n+        // print entry input for debug usage\n+        goalStateManager.printNetworkConfiguration(networkConfiguration);\n+        goalStateManager.getDPMPreparer().convert(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap);\n+\n+        Map<String, Set<String>> portsInSameSubnetMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameSubenetMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+        // L3\n+        Map<String, Set<String>> portsInSameVpcMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameVpcMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+\n+        InternalPortEntity[] portStatesArr = networkConfiguration.getPortEntities().toArray(new InternalPortEntity[0]);\n+        InternalSubnetEntity[] subnetArr = networkConfiguration.getSubnets().toArray(new InternalSubnetEntity[0]);\n+        VpcEntity[] vpcArr = networkConfiguration.getVpcs().toArray(new VpcEntity[0]);\n+\n+        // TODO need to v2 subnet and vpc part when logic is\n+        //  clear and integration done\n+        Map<String, List<InternalPortEntity>> mapGroupedByHostIp = new ConcurrentHashMap();\n+        Map<String, InternalSubnetEntity> subnetMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, VpcEntity> vpcMap = new ConcurrentHashMap<String, VpcEntity>();\n+        // construct map from list\n+        for (InternalSubnetEntity s : subnetArr) {\n+            subnetMap.put(s.getId(), s);\n+        }\n+\n+        for (VpcEntity vpc : vpcArr) {\n+            vpcMap.put(vpc.getId(), vpc);\n+        }\n+        // group nb msg by ip\n+        int portCounter = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            }\n+        }\n+\n+        int portCounterL3 = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            }\n+        }\n+\n+        // construct sb msg by ip\n+        Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<String, Goalstate.GoalState>();\n+        // TODO would opt this part when perf needed\n+        hostIpSubnetIdsMap.keySet().forEach(currentGroupHostIp -> {\n+            Set<Port.PortState> portStateHashSet = new HashSet<Port.PortState>();\n+            Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<String, Neighbor.NeighborState>();\n+            Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n+            Set<Vpc.VpcState> vpcStateSet = new HashSet();\n+            Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+            final List<InternalPortEntity> internalPortEntitySet = mapGroupedByHostIp.get(currentGroupHostIp);\n+            if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(portStateWithEverythingFilledNB -> {\n+                    List<Port.PortConfiguration.FixedIp> fixedIps = new ArrayList();\n+                    boolean isExistingPort = false;\n+                    final List<PortEntity.FixedIp> fixedIps1 = portStateWithEverythingFilledNB.getFixedIps();\n+                    for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(Port.PortConfiguration.FixedIp.newBuilder().setSubnetId(fixedIp.getSubnetId()).setIpAddress(fixedIp.getIpAddress()).build());\n+                        if (portIdNeighborInfoMap.values().stream().filter(e -> e.getPortId().equals(ipPortIdMap.get(fixedIp.getIpAddress()))).count() == 0) {\n+                            DHCP.DHCPConfiguration dhcpConfiguration = DHCP.DHCPConfiguration.newBuilder().setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setSubnetId(fixedIp.getSubnetId()).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setIpv4Address(fixedIp.getIpAddress()).build();\n+                            DHCP.DHCPState dhcpState = DHCP.DHCPState.newBuilder().setConfiguration(dhcpConfiguration).build();\n+                            dhcpStateList.add(dhcpState);\n+                        }\n+                    }\n+                    String name = portStateWithEverythingFilledNB.getName() == null ? \"\" : portStateWithEverythingFilledNB.getName();\n+\n+                    Port.PortConfiguration portConfiguration = Port.PortConfiguration.newBuilder().setName(name).setProjectId(portStateWithEverythingFilledNB.getProjectId()).setVpcId(portStateWithEverythingFilledNB.getVpcEntities().iterator().next().getId()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setAdminStateUp(true).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).addAllFixedIps(fixedIps).setId(portStateWithEverythingFilledNB.getId()).setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE).setMessageTypeValue(Common.MessageType.FULL_VALUE).build();\n+\n+                    final Port.PortState portStateSB = Port.PortState.newBuilder().setConfiguration(portConfiguration).setOperationType(Common.OperationType.CREATE).build();\n+\n+                    portStateHashSet.add(portStateSB);\n+                });\n+            }\n+\n+            // avoid duplicate\n+\n+            if (networkConfiguration.getNeighborTable() != null && neighborStates.size() == 0 && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        {\n+                            Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                            Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                            if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                                if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                    l2 = Neighbor.NeighborType.L3;\n+                                    l3 = Neighbor.NeighborType.L2;\n+                                }\n+                            }\n+\n+                            if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // if contains ip in neighbor info\n+                        }\n+                    }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        final InternalPortEntity portStateWithEverythingFilledNB = portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                        if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                            Set<InternalSubnetEntity> ss = portStateWithEverythingFilledNB.getSubnetEntities();\n+                            final InternalSubnetEntity next = ss.iterator().next();\n+                            if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l2);\n+                            } else {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // end if internal size==1 sn>2\n+                            brandNewIps.add(ip);\n+                        }\n+                    }\n+                    // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                    if (!ipHostIpMap.get(nip).equals(currentGroupHostIp))\n+                        continue;\n+                    for (String eip : portIdNeighborInfoMap.keySet()) {\n+\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(nip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        if (ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) { // ip 2.2\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l2);\n+                        } // inner if end\n+                    } // 2nd loop end\n+                } // current nip end\n+            } // if size==0\n+\n+            // lookup subnet entity\n+            for (String sid : ipSubnetIdMap.values()) {\n+                InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(sid);\n+                if (subnetEntity1 == null) {\n+                    GoalStateManager.LOG.log(Level.SEVERE, sid +\n+                            \"subnet is MISSING\");\n+                    continue;\n+                }\n+                goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                // lookup vpc entity\n+                final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n+                Vpc.VpcConfiguration vpcConfiguration = Vpc.VpcConfiguration.newBuilder().setId(vpcEntity.getId()).setCidr(vpcEntity.getCidr()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).build();\n+                Vpc.VpcState vpcState = Vpc.VpcState.newBuilder().setConfiguration(vpcConfiguration).setOperationTypeValue(Common.OperationType.CREATE_VALUE).setOperationType(Common.OperationType.CREATE).build();\n+                vpcStateSet.add(vpcState);\n+            }\n+\n+            List<Router.RouterState> routerStateList = new ArrayList<Router.RouterState>();\n+            if (networkConfiguration.getInternalRouterInfos() != null && neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                for (InternalRouterInfo internalRouterInfo : networkConfiguration.getInternalRouterInfos()) {\n+                    final List<InternalSubnetRoutingTable> subnetRoutingTables = internalRouterInfo.getRouterConfiguration().getSubnetRoutingTables();\n+                    final List<Router.RouterConfiguration.SubnetRoutingTable> subnetRoutingTables2 = new ArrayList<Router.RouterConfiguration.SubnetRoutingTable>();\n+                    for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+                        if (neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                            final InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(internalSubnetRoutingTable.getSubnetId());\n+\n+                            goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                        }\n+\n+                        Router.RouterConfiguration.SubnetRoutingTable subnetRoutingTable = Router.RouterConfiguration.SubnetRoutingTable.newBuilder().setSubnetId(internalSubnetRoutingTable.getSubnetId()).buildPartial();\n+                        List<Router.RouterConfiguration.RoutingRule> routingRuleList = new ArrayList<Router.RouterConfiguration.RoutingRule>();\n+                        for (InternalRoutingRule internalRoutingRule : internalSubnetRoutingTable.getRoutingRules()) {\n+                            Router.DestinationType destinationType =\n+                                    Router.DestinationType.INTERNET;\n+                            Router.RouterConfiguration.RoutingRuleExtraInfo routingRuleExtraInfo = Router.RouterConfiguration.RoutingRuleExtraInfo.newBuilder().setDestinationType(destinationType).setNextHopMac(internalRoutingRule.getRoutingRuleExtraInfo().getNextHopMac()).build();\n+                            Common.OperationType op = goalStateManager.getGoalStateHelper().getOperationType(internalRoutingRule.getOperationType().equals(OperationType.CREATE), internalRoutingRule.getOperationType().equals(OperationType.INFO), Common.OperationType.INFO, internalRoutingRule.getOperationType().equals(OperationType.DELETE), Common.OperationType.DELETE, internalRoutingRule.getOperationType().equals(OperationType.UPDATE), Common.OperationType.UPDATE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyOTM5Mg=="}, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyNzU0Mg==", "bodyText": "addressed in 3acad53", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518427542", "createdAt": "2020-11-05T23:14:52Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateTransformer.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.schema.*;\n+import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n+import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n+import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n+import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n+\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n+\n+\n+public class GoalStateTransformer {\n+    private final GoalStateManager goalStateManager;\n+\n+    public GoalStateTransformer(GoalStateManager goalStateManager) {\n+        this.goalStateManager = goalStateManager;\n+    }\n+\n+    /**\n+     * transform client of dpm msg to aca protobuf format\n+     *\n+     * @param networkConfiguration msg to be transformmed\n+     * @return Map<String, Goalstate.GoalState>\n+     * @throws RuntimeException Various exceptions that may occur during the\n+     * send process\n+     */\n+    @Async\n+    public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(NetworkConfiguration networkConfiguration) throws RuntimeException {\n+\n+        Map<String, String> ipPortIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipMacMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipSubnetIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipHostIpMap = new ConcurrentHashMap<String, String>();\n+        Map<String, Set<String>> hostIpFixedIpsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, Set<String>> hostIpSubnetIdsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, InternalSubnetEntity> subnetIdSubnetsMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portIdPortMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, NeighborInfo> portIdNeighborInfoMap = new ConcurrentHashMap<String, NeighborInfo>();\n+\n+        // print entry input for debug usage\n+        goalStateManager.printNetworkConfiguration(networkConfiguration);\n+        goalStateManager.getDPMPreparer().convert(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap);\n+\n+        Map<String, Set<String>> portsInSameSubnetMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameSubenetMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+        // L3\n+        Map<String, Set<String>> portsInSameVpcMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameVpcMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+\n+        InternalPortEntity[] portStatesArr = networkConfiguration.getPortEntities().toArray(new InternalPortEntity[0]);\n+        InternalSubnetEntity[] subnetArr = networkConfiguration.getSubnets().toArray(new InternalSubnetEntity[0]);\n+        VpcEntity[] vpcArr = networkConfiguration.getVpcs().toArray(new VpcEntity[0]);\n+\n+        // TODO need to v2 subnet and vpc part when logic is\n+        //  clear and integration done\n+        Map<String, List<InternalPortEntity>> mapGroupedByHostIp = new ConcurrentHashMap();\n+        Map<String, InternalSubnetEntity> subnetMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, VpcEntity> vpcMap = new ConcurrentHashMap<String, VpcEntity>();\n+        // construct map from list\n+        for (InternalSubnetEntity s : subnetArr) {\n+            subnetMap.put(s.getId(), s);\n+        }\n+\n+        for (VpcEntity vpc : vpcArr) {\n+            vpcMap.put(vpc.getId(), vpc);\n+        }\n+        // group nb msg by ip\n+        int portCounter = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            }\n+        }\n+\n+        int portCounterL3 = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            }\n+        }\n+\n+        // construct sb msg by ip\n+        Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<String, Goalstate.GoalState>();\n+        // TODO would opt this part when perf needed\n+        hostIpSubnetIdsMap.keySet().forEach(currentGroupHostIp -> {\n+            Set<Port.PortState> portStateHashSet = new HashSet<Port.PortState>();\n+            Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<String, Neighbor.NeighborState>();\n+            Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n+            Set<Vpc.VpcState> vpcStateSet = new HashSet();\n+            Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+            final List<InternalPortEntity> internalPortEntitySet = mapGroupedByHostIp.get(currentGroupHostIp);\n+            if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(portStateWithEverythingFilledNB -> {\n+                    List<Port.PortConfiguration.FixedIp> fixedIps = new ArrayList();\n+                    boolean isExistingPort = false;\n+                    final List<PortEntity.FixedIp> fixedIps1 = portStateWithEverythingFilledNB.getFixedIps();\n+                    for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(Port.PortConfiguration.FixedIp.newBuilder().setSubnetId(fixedIp.getSubnetId()).setIpAddress(fixedIp.getIpAddress()).build());\n+                        if (portIdNeighborInfoMap.values().stream().filter(e -> e.getPortId().equals(ipPortIdMap.get(fixedIp.getIpAddress()))).count() == 0) {\n+                            DHCP.DHCPConfiguration dhcpConfiguration = DHCP.DHCPConfiguration.newBuilder().setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setSubnetId(fixedIp.getSubnetId()).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setIpv4Address(fixedIp.getIpAddress()).build();\n+                            DHCP.DHCPState dhcpState = DHCP.DHCPState.newBuilder().setConfiguration(dhcpConfiguration).build();\n+                            dhcpStateList.add(dhcpState);\n+                        }\n+                    }\n+                    String name = portStateWithEverythingFilledNB.getName() == null ? \"\" : portStateWithEverythingFilledNB.getName();\n+\n+                    Port.PortConfiguration portConfiguration = Port.PortConfiguration.newBuilder().setName(name).setProjectId(portStateWithEverythingFilledNB.getProjectId()).setVpcId(portStateWithEverythingFilledNB.getVpcEntities().iterator().next().getId()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setAdminStateUp(true).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).addAllFixedIps(fixedIps).setId(portStateWithEverythingFilledNB.getId()).setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE).setMessageTypeValue(Common.MessageType.FULL_VALUE).build();\n+\n+                    final Port.PortState portStateSB = Port.PortState.newBuilder().setConfiguration(portConfiguration).setOperationType(Common.OperationType.CREATE).build();\n+\n+                    portStateHashSet.add(portStateSB);\n+                });\n+            }\n+\n+            // avoid duplicate\n+\n+            if (networkConfiguration.getNeighborTable() != null && neighborStates.size() == 0 && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        {\n+                            Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                            Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                            if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                                if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                    l2 = Neighbor.NeighborType.L3;\n+                                    l3 = Neighbor.NeighborType.L2;\n+                                }\n+                            }\n+\n+                            if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // if contains ip in neighbor info\n+                        }\n+                    }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        final InternalPortEntity portStateWithEverythingFilledNB = portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                        if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                            Set<InternalSubnetEntity> ss = portStateWithEverythingFilledNB.getSubnetEntities();\n+                            final InternalSubnetEntity next = ss.iterator().next();\n+                            if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l2);\n+                            } else {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // end if internal size==1 sn>2\n+                            brandNewIps.add(ip);\n+                        }\n+                    }\n+                    // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                    if (!ipHostIpMap.get(nip).equals(currentGroupHostIp))\n+                        continue;\n+                    for (String eip : portIdNeighborInfoMap.keySet()) {\n+\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(nip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        if (ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) { // ip 2.2\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l2);\n+                        } // inner if end\n+                    } // 2nd loop end\n+                } // current nip end\n+            } // if size==0\n+\n+            // lookup subnet entity\n+            for (String sid : ipSubnetIdMap.values()) {\n+                InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(sid);\n+                if (subnetEntity1 == null) {\n+                    GoalStateManager.LOG.log(Level.SEVERE, sid +\n+                            \"subnet is MISSING\");\n+                    continue;\n+                }\n+                goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                // lookup vpc entity\n+                final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n+                Vpc.VpcConfiguration vpcConfiguration = Vpc.VpcConfiguration.newBuilder().setId(vpcEntity.getId()).setCidr(vpcEntity.getCidr()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).build();\n+                Vpc.VpcState vpcState = Vpc.VpcState.newBuilder().setConfiguration(vpcConfiguration).setOperationTypeValue(Common.OperationType.CREATE_VALUE).setOperationType(Common.OperationType.CREATE).build();\n+                vpcStateSet.add(vpcState);\n+            }\n+\n+            List<Router.RouterState> routerStateList = new ArrayList<Router.RouterState>();\n+            if (networkConfiguration.getInternalRouterInfos() != null && neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                for (InternalRouterInfo internalRouterInfo : networkConfiguration.getInternalRouterInfos()) {\n+                    final List<InternalSubnetRoutingTable> subnetRoutingTables = internalRouterInfo.getRouterConfiguration().getSubnetRoutingTables();\n+                    final List<Router.RouterConfiguration.SubnetRoutingTable> subnetRoutingTables2 = new ArrayList<Router.RouterConfiguration.SubnetRoutingTable>();\n+                    for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+                        if (neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                            final InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(internalSubnetRoutingTable.getSubnetId());\n+\n+                            goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                        }\n+\n+                        Router.RouterConfiguration.SubnetRoutingTable subnetRoutingTable = Router.RouterConfiguration.SubnetRoutingTable.newBuilder().setSubnetId(internalSubnetRoutingTable.getSubnetId()).buildPartial();\n+                        List<Router.RouterConfiguration.RoutingRule> routingRuleList = new ArrayList<Router.RouterConfiguration.RoutingRule>();\n+                        for (InternalRoutingRule internalRoutingRule : internalSubnetRoutingTable.getRoutingRules()) {\n+                            Router.DestinationType destinationType =\n+                                    Router.DestinationType.INTERNET;\n+                            Router.RouterConfiguration.RoutingRuleExtraInfo routingRuleExtraInfo = Router.RouterConfiguration.RoutingRuleExtraInfo.newBuilder().setDestinationType(destinationType).setNextHopMac(internalRoutingRule.getRoutingRuleExtraInfo().getNextHopMac()).build();\n+                            Common.OperationType op = goalStateManager.getGoalStateHelper().getOperationType(internalRoutingRule.getOperationType().equals(OperationType.CREATE), internalRoutingRule.getOperationType().equals(OperationType.INFO), Common.OperationType.INFO, internalRoutingRule.getOperationType().equals(OperationType.DELETE), Common.OperationType.DELETE, internalRoutingRule.getOperationType().equals(OperationType.UPDATE), Common.OperationType.UPDATE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyOTM5Mg=="}, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTU5MTY5OnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzowOTo0MVrOHt19vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMzoxNToyNFrOHuaUbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjEyNw==", "bodyText": "What is this method for? It looks like a very customized \"getOperationType\".", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517832127", "createdAt": "2020-11-05T07:09:41Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyNzYyNA==", "bodyText": "addressed in 3acad53", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518427624", "createdAt": "2020-11-05T23:15:03Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjEyNw=="}, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyNzc1Ng==", "bodyText": "per discussion, actually i think the previous was good", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518427756", "createdAt": "2020-11-05T23:15:24Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjEyNw=="}, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTU5MzgwOnYy", "diffSide": "RIGHT", "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzoxMDozOFrOHt1_Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTozNDo1MVrOHuTcjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjQ1OA==", "bodyText": "Does the parameter Common.Opeartion delete always means \"resource deletion\" or has different meaning in different usage?", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517832458", "createdAt": "2020-11-05T07:10:38Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,\n+      boolean equals2,\n+      Common.OperationType delete,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNTE1MA==", "bodyText": "yes, first", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r518315150", "createdAt": "2020-11-05T19:34:51Z", "author": {"login": "haboy52581"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,\n+      boolean equals2,\n+      Common.OperationType delete,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjQ1OA=="}, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 187}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4428, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}