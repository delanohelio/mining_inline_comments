{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2ODI4MjU2", "number": 292, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzoxODo0NVrOENICbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoxOToxMFrOEPmIiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTk4NjM3OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzoxODo0NVrOGvojkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzoxODo0NVrOGvojkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwMDcyMw==", "bodyText": "In the message, let us add the exact conflicted MAC address.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r452600723", "createdAt": "2020-07-10T03:18:45Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "diffHunk": "@@ -100,13 +94,26 @@ public MacState getMacStateByMacAddress(String macAddress) throws ParameterNullO\n     public MacState createMacState(MacState macState) throws ParameterNullOrEmptyException, MacRepositoryTransactionErrorException, MacRangeInvalidException, MacAddressUniquenessViolationException, MacAddressFullException, MacAddressRetryLimitExceedException {\n         if (macState == null)\n             throw (new ParameterNullOrEmptyException(MacManagerConstant.MAC_EXCEPTION_PARAMETER_NULL_EMPTY));\n+\n+        String macAddress = macState.getMacAddress();\n+        if(!StringUtils.isEmpty(macAddress)){\n+            try {\n+                MacState dbMacState = macStateRepository.findItem(macAddress);\n+                if(dbMacState != null){\n+                    throw new MacAddressUniquenessViolationException(\"mac address is in use!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8148a7dd02e0887c9430c60fcb5775bac102017c"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjAxOTczOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0MDowOFrOGvo2fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzo0NToxOFrOGzTnfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNTU2NA==", "bodyText": "I know this is not your code @Gzure Looking back this line of code will impact the performance significantly. As we are do a major refactor, let us take this opportunity to get rid of the \"default range\" and use a range selector.\nIn the MacRangeRepository or a new repository, create a table to track the utilization of each range.\nOption 1 Explicit update:\nEvery allocation request always goes to that table to pick up the latest range with least utilization,  and increment the count after an allocation request or decrease the count after a release request.\nThis option is easy to implement at a cost of write performance (more DB access!).\nOption 2 In-Memory Counter with Background Monitoring:\nEach Mac Manager Instance has an in-memory counter that tracks the utilization of each range. The counter gets updated by a running monitoring thread in a periodic manner. This thread should run not very frequently, say every 30 minutes or so, and keep the counter always up-to-date. The allocation/release request only needs to read the in-memory counter but no obligation to update it.\nNOTE that when every Mac Manager instance launches or restart, it also needs to initialize its in-memory counter.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r452605564", "createdAt": "2020-07-10T03:40:08Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "diffHunk": "@@ -100,13 +94,26 @@ public MacState getMacStateByMacAddress(String macAddress) throws ParameterNullO\n     public MacState createMacState(MacState macState) throws ParameterNullOrEmptyException, MacRepositoryTransactionErrorException, MacRangeInvalidException, MacAddressUniquenessViolationException, MacAddressFullException, MacAddressRetryLimitExceedException {\n         if (macState == null)\n             throw (new ParameterNullOrEmptyException(MacManagerConstant.MAC_EXCEPTION_PARAMETER_NULL_EMPTY));\n+\n+        String macAddress = macState.getMacAddress();\n+        if(!StringUtils.isEmpty(macAddress)){\n+            try {\n+                MacState dbMacState = macStateRepository.findItem(macAddress);\n+                if(dbMacState != null){\n+                    throw new MacAddressUniquenessViolationException(\"mac address is in use!\");\n+                }\n+                macStateRepository.addItem(macState);\n+                return macState;\n+            } catch (CacheException e) {\n+                throw new MacRepositoryTransactionErrorException(\"create mac address failed :\" + e.getMessage());\n+            }\n+        }\n+\n         String rangeId = MacManagerConstant.DEFAULT_RANGE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8148a7dd02e0887c9430c60fcb5775bac102017c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTk2Ng==", "bodyText": "We could consider it as a future improvement we might not hit the issue in short term.\nCreate a tracking item #302. Please ack on that item so that it could be assigned to you @Gzure", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456451966", "createdAt": "2020-07-17T13:45:18Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/service/implement/MacServiceImpl.java", "diffHunk": "@@ -100,13 +94,26 @@ public MacState getMacStateByMacAddress(String macAddress) throws ParameterNullO\n     public MacState createMacState(MacState macState) throws ParameterNullOrEmptyException, MacRepositoryTransactionErrorException, MacRangeInvalidException, MacAddressUniquenessViolationException, MacAddressFullException, MacAddressRetryLimitExceedException {\n         if (macState == null)\n             throw (new ParameterNullOrEmptyException(MacManagerConstant.MAC_EXCEPTION_PARAMETER_NULL_EMPTY));\n+\n+        String macAddress = macState.getMacAddress();\n+        if(!StringUtils.isEmpty(macAddress)){\n+            try {\n+                MacState dbMacState = macStateRepository.findItem(macAddress);\n+                if(dbMacState != null){\n+                    throw new MacAddressUniquenessViolationException(\"mac address is in use!\");\n+                }\n+                macStateRepository.addItem(macState);\n+                return macState;\n+            } catch (CacheException e) {\n+                throw new MacRepositoryTransactionErrorException(\"create mac address failed :\" + e.getMessage());\n+            }\n+        }\n+\n         String rangeId = MacManagerConstant.DEFAULT_RANGE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNTU2NA=="}, "originalCommit": {"oid": "8148a7dd02e0887c9430c60fcb5775bac102017c"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzYyNDI3OnYy", "diffSide": "RIGHT", "path": "web/src/main/java/com/futurewei/alcor/web/entity/mac/MacRange.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTowNDo0MlrOGzWlKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTowNDo0MlrOGzWlKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDUyMA==", "bodyText": "Clean up MacRange.bitset in next round.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456500520", "createdAt": "2020-07-17T15:04:42Z", "author": {"login": "xieus"}, "path": "web/src/main/java/com/futurewei/alcor/web/entity/mac/MacRange.java", "diffHunk": "@@ -35,8 +36,9 @@\n     @JsonProperty(\"state\")\n     private String state;\n \n-    @JsonIgnore\n-    private BitSet bitSet;\n+    private long capacity;\n+//    @JsonIgnore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzY0NTcwOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/MacPoolApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxMDoxMVrOGzWyMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxMDoxMVrOGzWyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMzg1Ng==", "bodyText": "let us use verb for method name just for consistency.\nrangeSize => getRangeSize\nrangeAvailableSize => getRangeRemainingCapacity", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456503856", "createdAt": "2020-07-17T15:10:11Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/MacPoolApi.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+\n+import java.util.Set;\n+\n+public interface MacPoolApi {\n+\n+    /**\n+     * allocate a new mac\n+     * @return\n+     */\n+    String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException;\n+\n+    /**\n+     * allocate multi macs once\n+     * @param size\n+     * @return\n+     */\n+    Set<String> allocateBulk(String oui, MacRange macRange, int size)  throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException ;\n+\n+    /**\n+     * reclaim a mac\n+     * @param rangeId\n+     * @param mac\n+     * @return\n+     */\n+    Boolean reclaim(String rangeId, String oui, String mac);\n+\n+    /**\n+     * allocate a new mac form foreign\n+     * @param rangeId\n+     * @param oui\n+     * @param mac\n+     */\n+    void markMac(String rangeId, String oui, String mac) throws CacheException, DistributedLockException;\n+\n+    /**\n+     * get a range total size\n+     * @param rangeId\n+     * @return\n+     */\n+    long rangeSize(String rangeId) throws CacheException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzY1MDgyOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/MacPoolApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxMToyNlrOGzW1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxMToyNlrOGzW1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwNDY2MA==", "bodyText": "This is an excellent interface which allows different implementation of allocation algorithm and performance comparison.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456504660", "createdAt": "2020-07-17T15:11:26Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/MacPoolApi.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+\n+import java.util.Set;\n+\n+public interface MacPoolApi {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzY1MzcwOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxMjoxNlrOGzW3Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxMjoxNlrOGzW3Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwNTEyMw==", "bodyText": "We will need to get some performance number for this new allocation algorithm. @Gzure", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456505123", "createdAt": "2020-07-17T15:12:16Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzY3NzkwOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxODoxN1rOGzXFVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToxOToyNVrOGzXIIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwODc1Nw==", "bodyText": "Need to add these new configurations in application.properties and kubernetes yaml files (configMap session) @Gzure", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456508757", "createdAt": "2020-07-17T15:18:17Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwOTQ3NA==", "bodyText": "A recommended format is like\nmacmanager.pool.low_request_numers = 10\nmacmanager.pool.middle_request_numers = 20\nmacmanager.pool.high_request_numers = 60\n....", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456509474", "createdAt": "2020-07-17T15:19:25Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwODc1Nw=="}, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzcyODAzOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTozMTozOVrOGzXkRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTozMTozOVrOGzXkRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNjY3Ng==", "bodyText": "Recommend to rename loadRate to usedRatio", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456516676", "createdAt": "2020-07-17T15:31:39Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzc1NzE3OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTozOTo1N1rOGzX2gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTozOTo1N1rOGzX2gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyMTM0NA==", "bodyText": "macs.add(i)? @Gzure", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456521344", "createdAt": "2020-07-17T15:39:57Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzc2NTA4OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo0MjoxNVrOGzX7ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo0MjoxNVrOGzX7ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyMjYwMg==", "bodyText": "Recommend to give a more specific name like\ncheckMulti => retrieveMultiMacAddresses\ncheck => tryAllocateMacAddress", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456522602", "createdAt": "2020-07-17T15:42:15Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Boolean reclaim(String rangeId, String oui, String mac) {\n+        try {\n+            Long macLong = macToLong(getMacSuffix(oui, mac));\n+            return macRangeMappingRepository.releaseMac(rangeId, macLong);\n+        } catch (CacheException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long rangeSize(String rangeId) throws CacheException {\n+        return macRangeMappingRepository.size(rangeId);\n+    }\n+\n+    @Override\n+    public long rangeAvailableSize(MacRange macRange) throws CacheException {\n+        long size = macRangeMappingRepository.size(macRange.getRangeId());\n+        return macRange.getCapacity() - size;\n+    }\n+\n+    @Override\n+    public void markMac(String rangeId, String oui, String mac) throws CacheException {\n+        Long macLong = macToLong(getMacSuffix(oui, mac));\n+        macRangeMappingRepository.putIfAbsent(rangeId, macLong);\n+    }\n+\n+    private int getRequestNumbers(float loadRate){\n+        if (loadRate < LOW_LOAD_FACTOR){\n+            return lowRequestNumbers;\n+        }else if (loadRate < MIDDLE_LOAD_FACTOR){\n+            return middleRequestNumbers;\n+        }else if (loadRate < HIGH_LOAD_FACTOR){\n+            return highRequestNumbers;\n+        }\n+        return topRequestNumbers;\n+    }\n+\n+    private boolean check(String rangeId, Long macLong){\n+        try {\n+            return macRangeMappingRepository.putIfAbsent(rangeId, macLong);\n+        } catch (CacheException e) {\n+            return false;\n+        }\n+    }\n+\n+    private Set<Long> checkMulti(String rangeId, Set<Long> macs){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzc4NTQ5OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo0Nzo0NFrOGzYHsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo0Nzo0NFrOGzYHsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNTc0Nw==", "bodyText": "The \"if(newAllocateMacs.size() >= size)\" loop needs to move inside the for loop. Otherwise, we allocate more than what is needed.\n@Gzure Please try to fix this issue in next PR.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456525747", "createdAt": "2020-07-17T15:47:44Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzc4OTA4OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo0ODo0MFrOGzYJxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo0ODo0MFrOGzYJxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNjI3Ng==", "bodyText": "reclaim => release", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456526276", "createdAt": "2020-07-17T15:48:40Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Boolean reclaim(String rangeId, String oui, String mac) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzc5MzY1OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo1MDowMVrOGzYMyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo1MDowMVrOGzYMyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNzA0OQ==", "bodyText": "The method name \"macRangeMappingRepository.size\" is recommended to change to\nmacRangeMappingRepository.getUsedCapacity", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456527049", "createdAt": "2020-07-17T15:50:01Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/RandomMacPoolImpl.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+@Component\n+public class RandomMacPoolImpl implements MacPoolApi {\n+\n+    private static final int MUTIL_QUERY_THRESHOLD = 50;\n+\n+    private static final float BOTTOM_LOAD_FACTOR = 0.1f;\n+    private static final float LOW_LOAD_FACTOR = 0.25f;\n+    private static final float MIDDLE_LOAD_FACTOR = 0.5f;\n+    private static final float HIGH_LOAD_FACTOR = 0.75f;\n+\n+    @Value(\"${low-request-numbers: 10}\")\n+    private int lowRequestNumbers;\n+\n+    @Value(\"${middle-request-numbers: 20}\")\n+    private int middleRequestNumbers;\n+\n+    @Value(\"${high-request-numbers: 60}\")\n+    private int highRequestNumbers;\n+\n+    @Value(\"${top-request-numbers: 400}\")\n+    private int topRequestNumbers;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException {\n+\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        float loadRate = (float) used/macRange.getCapacity();\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+            if (loadRate < BOTTOM_LOAD_FACTOR) {\n+                if(check(rangeId, next)){\n+                    return longToMac(oui, next);\n+                }\n+            }else {\n+                int requestNumbers = getRequestNumbers(loadRate);\n+                requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+                long left = next - requestNumbers / 2;\n+                long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+                if (left < start) {\n+                    right += start - left;\n+                    left = start;\n+                }\n+\n+                if (right > end) {\n+                    left -= right - end;\n+                    right = end + 1;\n+                }\n+\n+                if(requestNumbers > MUTIL_QUERY_THRESHOLD){\n+                    Set<Long> macs = new HashSet<>();\n+                    for (long i = left; i < right; i++) {\n+                        macs.add(i);\n+                    }\n+                    Set<Long> newMacs = checkMulti(rangeId, macs);\n+                    if(newMacs != null){\n+                        for(Long macLong: newMacs){\n+                            if(check(rangeId, macLong)){\n+                                return longToMac(oui, macLong);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    for (long i = left; i < right; i++) {\n+                        if(check(rangeId, i)){\n+                            return longToMac(oui, i);\n+                        };\n+                    }\n+                }\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException, MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocateMacs = new HashSet<>(size);\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        String fromHexSuffix = getMacSuffix(oui, macRange.getFrom());\n+        String toHexSuffix = getMacSuffix(oui, macRange.getTo());\n+        long start = macToLong(fromHexSuffix);\n+        long end = macToLong(toHexSuffix);\n+\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int retryTime = 0;\n+        do {\n+            if(retryTime >= nRetryLimit){\n+                throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+            }\n+            long next = RandomUtils.nextLong(start, end);\n+\n+            int requestNumbers = size;\n+            requestNumbers = requestNumbers > macRange.getCapacity() ? (int) macRange.getCapacity() : requestNumbers;\n+            long left = next - requestNumbers / 2;\n+            long right = next + requestNumbers / 2 + requestNumbers % 2;\n+\n+            if (left < start) {\n+                right += start - left;\n+                left = start;\n+            }\n+\n+            if (right > end) {\n+                left -= right - end;\n+                right = end + 1;\n+            }\n+\n+            Set<Long> macs = new HashSet<>();\n+            for (long i = left; i < right; i++) {\n+                macs.add(next);\n+            }\n+            Set<Long> newMacs = checkMulti(rangeId, macs);\n+            if(newMacs != null){\n+                for(Long macLong: newMacs){\n+                    if(check(rangeId, macLong)){\n+                        newAllocateMacs.add(longToMac(oui, macLong));\n+                    }\n+                }\n+            }\n+            if (newAllocateMacs.size() >= size){\n+                return newAllocateMacs;\n+            }\n+            retryTime ++;\n+        }while(retryTime < nRetryLimit);\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Boolean reclaim(String rangeId, String oui, String mac) {\n+        try {\n+            Long macLong = macToLong(getMacSuffix(oui, mac));\n+            return macRangeMappingRepository.releaseMac(rangeId, macLong);\n+        } catch (CacheException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public long rangeSize(String rangeId) throws CacheException {\n+        return macRangeMappingRepository.size(rangeId);\n+    }\n+\n+    @Override\n+    public long rangeAvailableSize(MacRange macRange) throws CacheException {\n+        long size = macRangeMappingRepository.size(macRange.getRangeId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzg1NDA3OnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjowODowOFrOGzYzcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjowODowOFrOGzYzcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzNjk0NQ==", "bodyText": "I don't think we should increase Used value in this case.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456536945", "createdAt": "2020-07-17T16:08:08Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException {\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNubs = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNubs);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        macRangePartitionRepository.addItem(macRangePartition);\n+                        return longToMac(oui, macLong);\n+                    }else{\n+                        // if not put success, it already allocated\n+                        macRangePartition.incUsed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzg3MjMwOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoxMzo0N1rOGzY_Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMTo0MjowOFrOGz0Q7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzOTkwNw==", "bodyText": "If put is not successful, we shouldn't increase the Used value, right?", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456539907", "createdAt": "2020-07-17T16:13:47Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException {\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNubs = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNubs);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        macRangePartitionRepository.addItem(macRangePartition);\n+                        return longToMac(oui, macLong);\n+                    }else{\n+                        // if not put success, it already allocated\n+                        macRangePartition.incUsed();\n+                        needUpdate = true;\n+                    }\n+                }\n+\n+                if (needUpdate) {\n+                    macRangePartitionRepository.addItem(macRangePartition);\n+                }\n+\n+            } finally {\n+                try {\n+                    lock.unlock(id);\n+                } catch (DistributedLockException e) {\n+                    logger.error(\"unlock cluster lock {} failed: {}\", id, e.getMessage());\n+                }\n+            }\n+        }\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocatedMacs = new HashSet<>();\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used + size >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNums = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNums);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        needUpdate = true;\n+                        newAllocatedMacs.add(longToMac(oui, macLong));\n+                        if(newAllocatedMacs.size() >= size){\n+                            macRangePartitionRepository.addItem(macRangePartition);\n+                            return newAllocatedMacs;\n+                        }\n+                    }else{\n+                        // if not put success, it already allocated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4Njg2Mw==", "bodyText": "If the MAC address fails to be added to the MAC address table, the MAC address is in use.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456986863", "createdAt": "2020-07-20T01:42:08Z", "author": {"login": "Gzure"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException {\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNubs = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNubs);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        macRangePartitionRepository.addItem(macRangePartition);\n+                        return longToMac(oui, macLong);\n+                    }else{\n+                        // if not put success, it already allocated\n+                        macRangePartition.incUsed();\n+                        needUpdate = true;\n+                    }\n+                }\n+\n+                if (needUpdate) {\n+                    macRangePartitionRepository.addItem(macRangePartition);\n+                }\n+\n+            } finally {\n+                try {\n+                    lock.unlock(id);\n+                } catch (DistributedLockException e) {\n+                    logger.error(\"unlock cluster lock {} failed: {}\", id, e.getMessage());\n+                }\n+            }\n+        }\n+        throw new MacAddressRetryLimitExceedException(MacManagerConstant.MAC_EXCEPTION_RETRY_LIMIT_EXCEED);\n+    }\n+\n+    @Override\n+    public Set<String> allocateBulk(String oui, MacRange macRange, int size) throws MacAddressFullException,\n+            MacAddressRetryLimitExceedException, CacheException{\n+        Set<String> newAllocatedMacs = new HashSet<>();\n+        String rangeId = macRange.getRangeId();\n+        long used = macRangeMappingRepository.size(rangeId);\n+        if(used + size >= macRange.getCapacity()){\n+            throw new MacAddressFullException(MacManagerConstant.MAC_EXCEPTION_MACADDRESS_FULL);\n+        }\n+\n+        int partitionNums = (int) (macRange.getCapacity()/PARTITION_SIZE + 1);\n+        int partitionIndex = 0;\n+        int retryTime = 0;\n+        while (retryTime < nRetryLimit) {\n+\n+            boolean locked = false;\n+            while (!locked) {\n+                partitionIndex = RandomUtils.nextInt(0, partitionNums);\n+                locked = lock.tryLock(rangeId + \"_\" + partitionIndex);\n+            }\n+\n+            String id = rangeId + \"_\" + partitionIndex;\n+            try {\n+                boolean needUpdate = false;\n+                MacRangePartition macRangePartition = macRangePartitionRepository.findItem(id);\n+\n+                // if null create a new one\n+                if (macRangePartition == null) {\n+                    macRangePartition = new MacRangePartition(id, partitionIndex, PARTITION_SIZE * partitionIndex,\n+                            PARTITION_SIZE * (partitionIndex + 1));\n+                    needUpdate = true;\n+                }\n+\n+                while (macRangePartition.getUsed() < macRangePartition.getTotal()) {\n+                    long macLong = generate(macRangePartition);\n+                    if(check(rangeId, macLong)) {\n+                        macRangePartition.incUsed();\n+                        needUpdate = true;\n+                        newAllocatedMacs.add(longToMac(oui, macLong));\n+                        if(newAllocatedMacs.size() >= size){\n+                            macRangePartitionRepository.addItem(macRangePartition);\n+                            return newAllocatedMacs;\n+                        }\n+                    }else{\n+                        // if not put success, it already allocated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzOTkwNw=="}, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Nzg4ODcyOnYy", "diffSide": "RIGHT", "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoxOToxMFrOGzZJYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoxOToxMFrOGzZJYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0MjU2MQ==", "bodyText": "Going through the whole algorithm, we didn't find the usage of MacRangePartition.setBitSet.\nIn the current implementation, it seems that the allocation is still using the range-level BitSet, instead of using the partition-level BitSet. If we have partition-level bitset, the range-level one should be abandoned.\nLet us discuss more in next open-source meeting.", "url": "https://github.com/futurewei-cloud/alcor/pull/292#discussion_r456542561", "createdAt": "2020-07-17T16:19:10Z", "author": {"login": "xieus"}, "path": "services/mac_manager/src/main/java/com/futurewei/alcor/macmanager/pool/impl/BitmapPoolImpl.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ *\n+ * Copyright 2019 The Alcor Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *         you may not use this file except in compliance with the License.\n+ *         You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *         Unless required by applicable law or agreed to in writing, software\n+ *         distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *         See the License for the specific language governing permissions and\n+ *         limitations under the License.\n+ * /\n+ */\n+\n+package com.futurewei.alcor.macmanager.pool.impl;\n+\n+import com.futurewei.alcor.common.db.CacheException;\n+import com.futurewei.alcor.common.db.CacheFactory;\n+import com.futurewei.alcor.common.db.DistributedLockFactory;\n+import com.futurewei.alcor.common.db.IDistributedLock;\n+import com.futurewei.alcor.common.exception.DistributedLockException;\n+import com.futurewei.alcor.macmanager.dao.MacRangeMappingRepository;\n+import com.futurewei.alcor.macmanager.dao.MacRangePartitionRepository;\n+import com.futurewei.alcor.macmanager.dao.MacStateRepository;\n+import com.futurewei.alcor.macmanager.exception.MacAddressFullException;\n+import com.futurewei.alcor.macmanager.exception.MacAddressRetryLimitExceedException;\n+import com.futurewei.alcor.macmanager.exception.MacRepositoryTransactionErrorException;\n+import com.futurewei.alcor.macmanager.pool.MacPoolApi;\n+import com.futurewei.alcor.macmanager.utils.MacManagerConstant;\n+import com.futurewei.alcor.web.entity.mac.MacRange;\n+import com.futurewei.alcor.web.entity.mac.MacRangePartition;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.futurewei.alcor.macmanager.utils.MacUtils.*;\n+\n+//@Component\n+public class BitmapPoolImpl implements MacPoolApi {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(BitmapPoolImpl.class);\n+\n+    private static final int PARTITION_SIZE = 4096;\n+\n+    @Value(\"${macmanager.retrylimit}\")\n+    private long nRetryLimit;\n+\n+    @Autowired\n+    private MacRangePartitionRepository macRangePartitionRepository;\n+\n+    @Autowired\n+    private MacRangeMappingRepository macRangeMappingRepository;\n+\n+    private final IDistributedLock lock;\n+\n+    @Autowired\n+    public BitmapPoolImpl(DistributedLockFactory cacheFactory){\n+        lock = cacheFactory.getDistributedLock(MacRangePartition.class);\n+    }\n+\n+    @Override\n+    public String allocate(String oui, MacRange macRange) throws MacAddressFullException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c15d8679d1a23aa56c1ac604501a0fa525767a"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4582, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}