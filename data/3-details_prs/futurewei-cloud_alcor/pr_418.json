{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0NDEwMzA0", "number": 418, "title": "[Data Plane Mgr] L3 Implementation", "bodyText": "L3 Implementation v0.1:\nhandle brand new created p1-p4:\n{\n  \"vpcs_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"name\": \"test_vpc\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.0.0/16\"\n    }\n  ],\n  \"subnets_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"name\": \"test_subnet2\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.2.0/24\",\n      \"gateway_ip\": \"192.168.2.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88889\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:55\"\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"name\": \"test_subnet3\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.3.0/24\",\n      \"gateway_ip\": \"192.168.3.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88888\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:54\"\n    }\n  ],\n  \"neighbor_table\": [\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.2.2\",\n      \"neighbor_ip\": \"192.168.2.3\"\n    },\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.2\",\n      \"neighbor_ip\": \"192.168.3.3\"\n    },\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.2\",\n      \"neighbor_ip\": \"192.168.3.4\"\n    },\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.3\",\n      \"neighbor_ip\": \"192.168.3.4\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.2\",\n      \"neighbor_ip\": \"192.168.3.3\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.2\",\n      \"neighbor_ip\": \"192.168.3.2\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.2\",\n      \"neighbor_ip\": \"192.168.3.4\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.3\",\n      \"neighbor_ip\": \"192.168.3.3\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.3\",\n      \"neighbor_ip\": \"192.168.3.2\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.3\",\n      \"neighbor_ip\": \"192.168.3.4\"\n    }\n  ],\n  \"neighbor_info\": [],\n  \"routers_internal\": [\n    {\n      \"operation_type\": \"CREATE\",\n      \"configuration\": {\n        \"format_version\": 1,\n        \"revision_number\": 1,\n        \"request_id\": \"req-2c7a9f33-709f-4bb7-97f4-7105b20df6a7\",\n        \"id\": \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\",\n        \"message_type\": \"FULL\",\n        \"host_dvr_mac\": \"AA-BB-CC-A9-0F-EC\",\n        \"subnet_routing_tables\": [\n          {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n            \"routing_rules\": [\n              {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n                \"name\": \"rule1\",\n                \"destination\": \"10.0.2.0/24\",\n                \"next_hop_ip\": \"10.0.2.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FC\"\n                }\n              }\n            ]\n          }\n          ,\n            {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n            \"routing_rules\": [\n              {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f51\",\n                \"name\": \"rule2\",\n                \"destination\": \"10.0.3.0/24\",\n                \"next_hop_ip\": \"10.0.3.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FF\"\n                }\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ],\n  \"ports_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\",\n      \"name\": \"test_cni_port2\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.187\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:55\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"neighbor_host_ip\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.2.2\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_0\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\",\n      \"name\": \"test_cni_port1\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.187\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:56\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"neighbor_host_ip\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.3.4\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_0\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d6\",\n      \"name\": \"test_cni_port4\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.163\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:57\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.3.2\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_1\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d7\",\n      \"name\": \"test_cni_port5\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.163\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:58\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.3.3\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n        },\n        {\n          \"ip_address\": \"192.168.2.3\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_1\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    }\n  ],\n  \"security_groups_internal\": [\n    {}\n  ]\n}\nhandle update fixedIP:\n{\n  \"vpcs_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"name\": \"test_vpc\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.0.0/16\"\n    }\n  ],\n  \"subnets_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"name\": \"test_subnet2\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.2.0/24\",\n      \"gateway_ip\": \"192.168.2.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88889\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:55\"\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"name\": \"test_subnet3\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.3.0/24\",\n      \"gateway_ip\": \"192.168.3.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88888\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:54\"\n    }\n  ],\n  \"neighbor_table\": [\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.5\",\n      \"neighbor_ip\": \"192.168.3.4\"\n    },\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.5\",\n      \"neighbor_ip\": \"192.168.3.3\"\n    },\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.5\",\n      \"neighbor_ip\": \"192.168.3.2\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.2.5\",\n      \"neighbor_ip\": \"192.168.2.3\"\n    },\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.3.5\",\n      \"neighbor_ip\": \"192.168.2.2\"\n    }\n  ],\n  \"neighbor_info\": [\n    {\n      \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\",\n      \"host_ip\": \"10.213.43.187\",\n      \"host_id\": \"ephost_0\",\n     \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"port_ip\": \"192.168.2.2\",\n      \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"port_mac\": \"86:ea:77:ad:52:55\"\n    },\n    {\n      \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d6\",\n      \"host_ip\": \"10.213.43.163\",\n      \"host_id\": \"ephost_1\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"port_ip\": \"192.168.3.2\",\n      \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"port_mac\": \"86:ea:77:ad:52:57\"\n    },\n    {\n      \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d7\",\n      \"host_ip\": \"10.213.43.163\",\n      \"host_id\": \"ephost_1\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"port_ip\": \"192.168.2.3\",\n      \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"port_mac\": \"86:ea:77:ad:52:58\"\n    },\n    {\n      \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d7\",\n      \"host_ip\": \"10.213.43.163\",\n      \"host_id\": \"ephost_1\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"port_ip\": \"192.168.3.3\",\n      \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"port_mac\": \"86:ea:77:ad:52:58\"\n    },\n    {\n      \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\",\n      \"host_ip\": \"10.213.43.187\",\n      \"host_id\": \"ephost_1\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"port_ip\": \"192.168.3.4\",\n      \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"port_mac\": \"86:ea:77:ad:52:55\"\n    }\n  ],\n  \"routers_internal\": [\n    {\n      \"operation_type\": \"CREATE\",\n      \"configuration\": {\n        \"format_version\": 1,\n        \"revision_number\": 1,\n        \"request_id\": \"req-2c7a9f33-709f-4bb7-97f4-7105b20df6a7\",\n        \"id\": \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\",\n        \"message_type\": \"FULL\",\n        \"host_dvr_mac\": \"AA-BB-CC-A9-0F-EC\",\n        \"subnet_routing_tables\": [\n          {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n            \"routing_rules\": [\n              {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n                \"name\": \"rule1\",\n                \"destination\": \"10.0.2.0/24\",\n                \"next_hop_ip\": \"10.0.2.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FC\"\n                }\n              }\n            ]\n          }\n          ,\n            {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n            \"routing_rules\": [\n              {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f51\",\n                \"name\": \"rule2\",\n                \"destination\": \"10.0.3.0/24\",\n                \"next_hop_ip\": \"10.0.3.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FF\"\n                }\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ],\n \"ports_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\",\n      \"name\": \"test_cni_port5\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.187\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:55\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.3.5\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_1\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    }\n  ],\n  \"security_groups_internal\": [\n    {}\n  ]\n}\nThe updated scenario:\nCreate port1 with ip 192.168.2.2 on 187\nCreate port2 with ip 192.168.3.4 on 187\nCreate port3 with ip 192.168.3.2 on 163\nHere is the input and output, confirmed by @xieus @er1cthe0ne \n1.Input:\n \n {\n  \"vpcs_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"name\": \"test_vpc\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.0.0/16\"\n    }\n  ],\n  \"subnets_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"name\": \"test_subnet2\",\n      \"description\": \"\",\n     \"cidr\": \"192.168.2.0/24\",\n      \"gateway_ip\": \"192.168.2.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88889\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:55\"\n    }\n  ],\n  \"neighbor_table\": null,\n  \"neighbor_info\": null,\n  \"routers_internal\": null,\n  \"ports_internal\": [\n  {\n    \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n    \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\",\n    \"name\": \"test_cni_port2\",\n    \"description\": \"\",\n    \"binding_host_ip\": \"10.213.43.187\",\n    \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n   \"tenant_id\": null,\n    \"admin_state_up\": true,\n    \"mac_address\": \"86:ea:77:ad:52:55\",\n    \"veth_name\": \"veth0\",\n    \"device_id\": null,\n    \"device_owner\": null,\n    \"status\": null,\n    \"fixed_ips\": [\n      {\n        \"ip_address\": \"192.168.2.2\",\n        \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      }\n    ],\n    \"allowed_address_pairs\": null,\n    \"extra_dhcp_opts\": null,\n    \"security_groups\": null,\n    \"binding:host_id\": \"ephost_0\",\n    \"binding:profile\": null,\n    \"binding:vnic_type\": null,\n    \"network_ns\": \"/var/run/netns/test_netw_ns\",\n    \"dnsName\": null,\n    \"dnsAssignment\": null,\n    \"fast_path\": true\n  }\n  ],\n  \"security_groups_internal\": [\n    {}\n  ]\n}\nOutput:\n10.213.43.187=subnet_states {\n  operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.2.0/24\"\n  }\n}\nport_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\"\n    message_type: FULL\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    name: \"test_cni_port2\"\n    mac_address: \"86:ea:77:ad:52:55\"\n    admin_state_up: true\n    fixed_ips {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      ip_address: \"192.168.2.2\"\n    }\n  }\n}\nsecurity_group_states {\n  configuration {\n  }\n}\ndhcp_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n    mac_address: \"86:ea:77:ad:52:55\"\n    ipv4_address: \"192.168.2.2\"\n  }\n}\n] \n2. Input:\n{\n  \"vpcs_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"name\": \"test_vpc\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.0.0/16\"\n    }\n  ],\n  \"subnets_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"name\": \"test_subnet2\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.2.0/24\",\n      \"gateway_ip\": \"192.168.2.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88889\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:55\"\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"name\": \"test_subnet3\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.3.0/24\",\n      \"gateway_ip\": \"192.168.3.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88888\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:54\"\n    }\n  ],\n  \"neighbor_table\": [\n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.3.4\",\n      \"neighbor_ip\": \"192.168.2.2\"\n    }\n  ],\n  \"neighbor_info\": [\n  {\n    \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\",\n    \"host_ip\": \"10.213.43.187\",\n    \"host_id\": \"ephost_0\",\n   \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n    \"port_ip\": \"192.168.2.2\",\n    \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n   \"port_mac\": \"86:ea:77:ad:52:55\"\n  }\n  ],\n  \"routers_internal\": [\n    {\n      \"operation_type\": \"CREATE\",\n      \"configuration\": {\n        \"format_version\": 1,\n        \"revision_number\": 1,\n        \"request_id\": \"req-2c7a9f33-709f-4bb7-97f4-7105b20df6a7\",\n        \"id\": \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\",\n        \"message_type\": \"FULL\",\n        \"host_dvr_mac\": \"AA-BB-CC-A9-0F-EC\",\n        \"subnet_routing_tables\": [\n          {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n            \"routing_rules\": [\n             {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n                \"name\": \"rule1\",\n                \"destination\": \"10.0.2.0/24\",\n                \"next_hop_ip\": \"10.0.2.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FC\"\n                }\n              }\n            ]\n          }\n          ,\n            {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n            \"routing_rules\": [\n              {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f51\",\n                \"name\": \"rule2\",\n                \"destination\": \"10.0.3.0/24\",\n                \"next_hop_ip\": \"10.0.3.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FF\"\n                }\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ],\n  \"ports_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\",\n      \"name\": \"test_cni_port1\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.187\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:56\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.3.4\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_0\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    }\n  ],\n  \"security_groups_internal\": [\n    {}\n  ]\n} \n \nOutput:\n10.213.43.187=subnet_states {\n  operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.2.0/24\"\n  }\n}\nsubnet_states {\n operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.3.0/24\"\n  }\n}\nport_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\"\n    message_type: FULL\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    name: \"test_cni_port1\"\n    mac_address: \"86:ea:77:ad:52:56\"\n    admin_state_up: true\n    fixed_ips {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      ip_address: \"192.168.3.4\"\n    }\n  }\n}\nneighbor_states {\n  configuration {\n    format_version: 1\n    revision_number: 2\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    mac_address: \"86:ea:77:ad:52:56\"\n    host_ip_address: \"10.213.43.187\"\n    fixed_ips {\n      neighbor_type: L3\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      ip_address: \"192.168.3.4\"\n    }\n  }\n}\nneighbor_states {\n  configuration {\n    format_version: 1\n    revision_number: 2\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    mac_address: \"86:ea:77:ad:52:55\"\n    host_ip_address: \"10.213.43.187\"\n    fixed_ips {\n      neighbor_type: L3\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      ip_address: \"192.168.2.2\"\n    }\n  }\n}\nsecurity_group_states {\n  configuration {\n  }\n}\ndhcp_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n    mac_address: \"86:ea:77:ad:52:56\"\n    ipv4_address: \"192.168.3.4\"\n  }\n}\nrouter_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    id: \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\"\n    message_type: FULL\n    host_dvr_mac_address: \"AA-BB-CC-A9-0F-EC\"\n    subnet_routing_tables {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      routing_rules {\n        id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n        name: \"rule1\"\n        destination: \"10.0.2.0/24\"\n        next_hop_ip: \"10.0.2.1\"\n        priority: 100\n        routing_rule_extra_info {\n          next_hop_mac: \"AA-BB-CC-B9-EE-FC\"\n        }\n      }\n    }\n    subnet_routing_tables {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      routing_rules {\n        id: \"3dda2801-d675-4688-a63f-dcda8d327f51\"\n        name: \"rule2\"\n        destination: \"10.0.3.0/24\"\n        next_hop_ip: \"10.0.3.1\"\n        priority: 100\n        routing_rule_extra_info {\n          next_hop_mac: \"AA-BB-CC-B9-EE-FF\"\n        }\n      }\n    }\n  }\n}\n] \n3.Input:\n{\n  \"vpcs_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"name\": \"test_vpc\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.0.0/16\"\n    }\n  ],\n  \"subnets_internal\": [\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n      \"name\": \"test_subnet2\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.2.0/24\",\n      \"gateway_ip\": \"192.168.2.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88889\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:55\"\n    },\n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"network_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n      \"name\": \"test_subnet3\",\n      \"description\": \"\",\n      \"cidr\": \"192.168.3.0/24\",\n      \"gateway_ip\": \"192.168.3.1\",\n      \"availability_zone\": \"uswest-1\",\n      \"dhcp_enable\": false,\n      \"primary_dns\": null,\n      \"secondary_dns\": null,\n      \"dns_list\": null,\n      \"tunnel_id\": \"88888\",\n      \"gatewayMacs\": \"96:ea:77:ad:52:54\"\n    }\n  ],\n  \"neighbor_table\": [\n \n    {\n      \"neighbor_type\": \"L3\",\n      \"local_ip\": \"192.168.3.2\",\n      \"neighbor_ip\": \"192.168.2.2\"\n    },\n    {\n      \"neighbor_type\": \"L2\",\n      \"local_ip\": \"192.168.3.2\",\n      \"neighbor_ip\": \"192.168.3.4\"\n    }\n  ],\n  \"neighbor_info\": [\n  {\n    \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\",\n    \"host_ip\": \"10.213.43.187\",\n    \"host_id\": \"ephost_0\",\n   \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n    \"port_ip\": \"192.168.2.2\",\n    \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n   \"port_mac\": \"86:ea:77:ad:52:55\"\n  },\n  {\n    \"port_id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\",\n    \"host_ip\": \"10.213.43.187\",\n    \"host_id\": \"ephost_1\",\n    \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n    \"port_ip\": \"192.168.3.4\",\n    \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n    \"port_mac\": \"86:ea:77:ad:52:55\"\n  }\n  ],\n  \"routers_internal\": [\n    {\n      \"operation_type\": \"CREATE\",\n      \"configuration\": {\n        \"format_version\": 1,\n        \"revision_number\": 1,\n        \"request_id\": \"req-2c7a9f33-709f-4bb7-97f4-7105b20df6a7\",\n        \"id\": \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\",\n        \"message_type\": \"FULL\",\n        \"host_dvr_mac\": \"AA-BB-CC-A9-0F-EC\",\n        \"subnet_routing_tables\": [\n          {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594f\",\n            \"routing_rules\": [\n             {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n                \"name\": \"rule1\",\n                \"destination\": \"10.0.2.0/24\",\n                \"next_hop_ip\": \"10.0.2.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FC\"\n                }\n              }\n            ]\n          }\n          ,\n            {\n            \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\",\n            \"routing_rules\": [\n              {\n                \"operation_type\": \"CREATE\",\n                \"id\": \"3dda2801-d675-4688-a63f-dcda8d327f51\",\n                \"name\": \"rule2\",\n                \"destination\": \"10.0.3.0/24\",\n                \"next_hop_ip\": \"10.0.3.1\",\n                \"priority\": 100,\n                \"routing_rule_extra_info\": {\n                  \"destination_type\": \"INTERNET_GW\",\n                  \"next_hop_mac\": \"AA-BB-CC-B9-EE-FF\"\n                }\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ],\n  \"ports_internal\": [\n \n    {\n      \"project_id\": \"3dda2801-d675-4688-a63f-dcda8d327f50\",\n      \"id\": \"f37810eb-7f83-45fa-a4d4-1b31e75399d6\",\n      \"name\": \"test_cni_port4\",\n      \"description\": \"\",\n      \"binding_host_ip\": \"10.213.43.163\",\n      \"vpc_id\": \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\",\n      \"tenant_id\": null,\n      \"admin_state_up\": true,\n      \"mac_address\": \"86:ea:77:ad:52:57\",\n      \"veth_name\": \"veth0\",\n      \"device_id\": null,\n      \"device_owner\": null,\n      \"status\": null,\n      \"fixed_ips\": [\n        {\n          \"ip_address\": \"192.168.3.2\",\n          \"subnet_id\": \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n        }\n      ],\n      \"allowed_address_pairs\": null,\n      \"extra_dhcp_opts\": null,\n      \"security_groups\": null,\n      \"binding:host_id\": \"ephost_1\",\n      \"binding:profile\": null,\n      \"binding:vnic_type\": null,\n      \"network_ns\": \"/var/run/netns/test_netw_ns\",\n      \"dnsName\": null,\n      \"dnsAssignment\": null,\n      \"fast_path\": true\n    }\n  ],\n  \"security_groups_internal\": [\n    {}\n  ]\n}\n \n \nOutput:\n10.213.43.187=subnet_states {\n  operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.2.0/24\"\n  }\n}\nsubnet_states {\n  operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.3.0/24\"\n  }\n}\nneighbor_states {\n  configuration {\n    format_version: 1\n    revision_number: 2\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d6\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    mac_address: \"86:ea:77:ad:52:57\"\n    host_ip_address: \"10.213.43.163\"\n    fixed_ips {\n      neighbor_type: L3\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      ip_address: \"192.168.3.2\"\n    }\n  }\n}\nsecurity_group_states {\n  configuration {\n  }\n}\nrouter_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    id: \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\"\n    message_type: FULL\n    host_dvr_mac_address: \"AA-BB-CC-A9-0F-EC\"\n    subnet_routing_tables {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      routing_rules {\n        id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n       name: \"rule1\"\n        destination: \"10.0.2.0/24\"\n        next_hop_ip: \"10.0.2.1\"\n        priority: 100\n        routing_rule_extra_info {\n          next_hop_mac: \"AA-BB-CC-B9-EE-FC\"\n        }\n      }\n    }\n    subnet_routing_tables {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      routing_rules {\n        id: \"3dda2801-d675-4688-a63f-dcda8d327f51\"\n        name: \"rule2\"\n        destination: \"10.0.3.0/24\"\n        next_hop_ip: \"10.0.3.1\"\n        priority: 100\n        routing_rule_extra_info {\n          next_hop_mac: \"AA-BB-CC-B9-EE-FF\"\n        }\n      }\n    }\n  }\n}\n, 10.213.43.163=subnet_states {\n  operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.2.0/24\"\n  }\n}\nsubnet_states {\n  operation_type: INFO\n  configuration {\n    format_version: 1\n    id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    cidr: \"192.168.3.0/24\"\n  }\n}\nport_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d6\"\n    message_type: FULL\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    name: \"test_cni_port4\"\n    mac_address: \"86:ea:77:ad:52:57\"\n    admin_state_up: true\n    fixed_ips {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      ip_address: \"192.168.3.2\"\n    }\n  }\n}\nneighbor_states {\n  configuration {\n    format_version: 1\n    revision_number: 2\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d3\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    mac_address: \"86:ea:77:ad:52:55\"\n    host_ip_address: \"10.213.43.187\"\n    fixed_ips {\n      neighbor_type: L3\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      ip_address: \"192.168.2.2\"\n    }\n  }\n}\nneighbor_states {\n  configuration {\n    format_version: 1\n    revision_number: 2\n    id: \"f37810eb-7f83-45fa-a4d4-1b31e75399d2\"\n    project_id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n    vpc_id: \"9192a4d4-ffff-4ece-b3f0-8d36e3d88038\"\n    mac_address: \"86:ea:77:ad:52:55\"\n    host_ip_address: \"10.213.43.187\"\n    fixed_ips {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      ip_address: \"192.168.3.4\"\n    }\n  }\n}\nsecurity_group_states {\n  configuration {\n  }\n}\ndhcp_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n    mac_address: \"86:ea:77:ad:52:57\"\n    ipv4_address: \"192.168.3.2\"\n  }\n}\nrouter_states {\n  configuration {\n    format_version: 1\n    revision_number: 1\n    id: \"64e339bb-1a6c-47bd-9ee7-a0cf81a35172\"\n    message_type: FULL\n    host_dvr_mac_address: \"AA-BB-CC-A9-0F-EC\"\n    subnet_routing_tables {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594f\"\n      routing_rules {\n        id: \"3dda2801-d675-4688-a63f-dcda8d327f50\"\n        name: \"rule1\"\n        destination: \"10.0.2.0/24\"\n        next_hop_ip: \"10.0.2.1\"\n        priority: 100\n        routing_rule_extra_info {\n          next_hop_mac: \"AA-BB-CC-B9-EE-FC\"\n        }\n      }\n    }\n    subnet_routing_tables {\n      subnet_id: \"a87e0f87-a2d9-44ef-9194-9a62f178594e\"\n      routing_rules {\n        id: \"3dda2801-d675-4688-a63f-dcda8d327f51\"\n        name: \"rule2\"\n        destination: \"10.0.3.0/24\"\n        next_hop_ip: \"10.0.3.1\"\n        priority: 100\n        routing_rule_extra_info {\n          next_hop_mac: \"AA-BB-CC-B9-EE-FF\"\n        }\n      }\n    }\n  }\n}\n]", "createdAt": "2020-10-15T21:58:38Z", "url": "https://github.com/futurewei-cloud/alcor/pull/418", "merged": true, "mergeCommit": {"oid": "a09a31c8ff0dac774d1c6e622213d0a8dd2a9053"}, "closed": true, "closedAt": "2020-11-09T17:47:49Z", "author": {"login": "haboy52581"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7z_s0gH2gAyNTA0NDEwMzA0OjZkZTJjMGQzYmFhYTcxZDdkNTRmMjRlMjA3NDkzZWI0ZmZiZTU2ZDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda4egKAFqTUyNjUwMzE5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6de2c0d3baaa71d7d54f24e207493eb4ffbe56d2", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/6de2c0d3baaa71d7d54f24e207493eb4ffbe56d2", "committedDate": "2020-08-05T05:02:21Z", "message": "add dhcp/router/gateway/l2/l3 neighbor to port\n\nadd dhcp/router/gateway/l2/l3 neighbor to port creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f32721615f2e7bf52773d3da5eb9f1205e8bbe1", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/9f32721615f2e7bf52773d3da5eb9f1205e8bbe1", "committedDate": "2020-08-05T22:23:34Z", "message": "change according to discussion this morning 08/05\n\nchange subnet info according to discussion this morning 08/05"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eca251942033a6076b78fdc25b83dfcac234aea", "author": {"user": null}, "url": "https://github.com/futurewei-cloud/alcor/commit/5eca251942033a6076b78fdc25b83dfcac234aea", "committedDate": "2020-10-05T16:51:51Z", "message": "Merge branch 'master' of https://github.com/futurewei-cloud/alcor into master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2915e6cae4ce35e9dcf5c51159378e289a68910a", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/2915e6cae4ce35e9dcf5c51159378e289a68910a", "committedDate": "2020-10-05T16:56:48Z", "message": "add routesinfo to network conf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3f79dcb1bd68f727d6cba258426f8cf9c5c8093", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/f3f79dcb1bd68f727d6cba258426f8cf9c5c8093", "committedDate": "2020-10-05T17:16:13Z", "message": "change to internal router info from router table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a90538ab17d99e93785d7b5f8025a6863d3774a8", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/a90538ab17d99e93785d7b5f8025a6863d3774a8", "committedDate": "2020-10-06T00:32:27Z", "message": "change tostring and add set/getter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b30b6a6cadbce7f86cc0130125f7b1d53f91852", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/5b30b6a6cadbce7f86cc0130125f7b1d53f91852", "committedDate": "2020-10-06T00:41:05Z", "message": "fix adoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93b8e780313168ec145cd953c24efa4d8790abc6", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/93b8e780313168ec145cd953c24efa4d8790abc6", "committedDate": "2020-10-06T19:09:11Z", "message": "change var name of router"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1171987b882c105d4056a409bfc7526c352bf30d", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/1171987b882c105d4056a409bfc7526c352bf30d", "committedDate": "2020-10-06T23:02:46Z", "message": "address the tab replacement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49863d5b5151bb777213d3a26a0ea75ae80bb058", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/49863d5b5151bb777213d3a26a0ea75ae80bb058", "committedDate": "2020-10-15T21:50:56Z", "message": "add l3 impl v0.1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b593cdcef425199a59de97fe455d1172e8372e30", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/b593cdcef425199a59de97fe455d1172e8372e30", "committedDate": "2020-10-15T21:53:51Z", "message": "add l3 impl v0.2 cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80ffd45ca5d594bf7684f76c44d9783c7010e965", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/80ffd45ca5d594bf7684f76c44d9783c7010e965", "committedDate": "2020-10-16T23:35:57Z", "message": "not check name passing in null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19589752b0ea261e0b2416ee12153cd53acc4df8", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/19589752b0ea261e0b2416ee12153cd53acc4df8", "committedDate": "2020-10-16T23:48:07Z", "message": "print json input"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ef79b7d815cedbc5758e4fcd4b86cadfd911615", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/1ef79b7d815cedbc5758e4fcd4b86cadfd911615", "committedDate": "2020-10-17T00:10:34Z", "message": "fix build error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "894db52e4d2c4601a5001b68caffa53b02d913c8", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/894db52e4d2c4601a5001b68caffa53b02d913c8", "committedDate": "2020-10-19T22:40:47Z", "message": "add support for scenario3 and fix atomic issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af5876d9323e4e19f400b72b2066cbd583804465", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/af5876d9323e4e19f400b72b2066cbd583804465", "committedDate": "2020-10-19T20:54:28Z", "message": "add fixedips in port states"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f58aff6392d40bd044421fc1689f2b9f436c489d", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/f58aff6392d40bd044421fc1689f2b9f436c489d", "committedDate": "2020-10-22T01:02:53Z", "message": "to adapt to single empty first port creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "254b4bf95e24c6675ee9eb5a659ada3945d00683", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/254b4bf95e24c6675ee9eb5a659ada3945d00683", "committedDate": "2020-10-22T16:19:14Z", "message": "add tunnelId to sb and field to web class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05b740ccefa95219d9635d9d319d111100053024", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/05b740ccefa95219d9635d9d319d111100053024", "committedDate": "2020-10-22T22:15:36Z", "message": "revert subnetentity and add gatewaymac and ip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8a02c25d15b792cae1923bb69a810fab739048f", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/f8a02c25d15b792cae1923bb69a810fab739048f", "committedDate": "2020-10-23T02:00:24Z", "message": "use null as init value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9911eab117b35928d3b9574947f390381c724399", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/9911eab117b35928d3b9574947f390381c724399", "committedDate": "2020-10-23T02:04:54Z", "message": "use null as init value 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f5ee1232cb210b82b1491454390473143e7ffe7", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/8f5ee1232cb210b82b1491454390473143e7ffe7", "committedDate": "2020-10-23T04:28:55Z", "message": "make sure for complicated scenario work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "721303db2cb6dc19b29f910205bc20eb97b0adf9", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/721303db2cb6dc19b29f910205bc20eb97b0adf9", "committedDate": "2020-10-23T04:34:09Z", "message": "fix build break"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71f1d3444aabd69bd8d374beaefa0468f3c8a28c", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/71f1d3444aabd69bd8d374beaefa0468f3c8a28c", "committedDate": "2020-10-26T18:24:36Z", "message": "add subnet missing check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5706b7597a8b2b13ffe4b1a955ea37789ba5504", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/b5706b7597a8b2b13ffe4b1a955ea37789ba5504", "committedDate": "2020-10-28T21:57:44Z", "message": "add previous change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10c449251d0829fd3f05c32a8a46e0ca83aa163d", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/10c449251d0829fd3f05c32a8a46e0ca83aa163d", "committedDate": "2020-10-29T17:39:25Z", "message": "add sync"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab372aeb5d96dd52c8f5a6aef67315fab3385cbe", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/ab372aeb5d96dd52c8f5a6aef67315fab3385cbe", "committedDate": "2020-10-27T01:38:44Z", "message": "fix issue during integration using router payload new"}, "afterCommit": {"oid": "6d4fafbc587f9556a17431ff16d452f61888a5ce", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/6d4fafbc587f9556a17431ff16d452f61888a5ce", "committedDate": "2020-10-29T17:42:27Z", "message": "Merge branch 'master' into feature/add-route-to-nc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df7e4682c5be466b8612ba16888b8b1e92afe392", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/df7e4682c5be466b8612ba16888b8b1e92afe392", "committedDate": "2020-10-29T18:47:45Z", "message": "change sync to async"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d4fafbc587f9556a17431ff16d452f61888a5ce", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/6d4fafbc587f9556a17431ff16d452f61888a5ce", "committedDate": "2020-10-29T17:42:27Z", "message": "Merge branch 'master' into feature/add-route-to-nc"}, "afterCommit": {"oid": "df7e4682c5be466b8612ba16888b8b1e92afe392", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/df7e4682c5be466b8612ba16888b8b1e92afe392", "committedDate": "2020-10-29T18:47:45Z", "message": "change sync to async"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06b6a290a0fbe58ae7d79cb4874ef9226d8b3408", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/06b6a290a0fbe58ae7d79cb4874ef9226d8b3408", "committedDate": "2020-10-29T21:35:07Z", "message": "check L3 then deploy route"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87d7bdae6b03c1e2a03640af580f53388d6f8617", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/87d7bdae6b03c1e2a03640af580f53388d6f8617", "committedDate": "2020-10-29T21:50:56Z", "message": "check L3 then deploy route2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfddb9edbd5c49b482315ecf0614ff4f141c020d", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/dfddb9edbd5c49b482315ecf0614ff4f141c020d", "committedDate": "2020-10-29T21:59:07Z", "message": "check L3 then deploy route3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02c3d1d8becf1e5aff3bdf5ccb0d1fe96bd72561", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/02c3d1d8becf1e5aff3bdf5ccb0d1fe96bd72561", "committedDate": "2020-11-03T22:28:34Z", "message": "fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/1da6acb24b06f8a18cb677337909797b87719fb7", "committedDate": "2020-11-03T23:45:57Z", "message": "refactor dpm code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMTE0MDE3", "url": "https://github.com/futurewei-cloud/alcor/pull/418#pullrequestreview-523114017", "createdAt": "2020-11-04T07:59:09Z", "commit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo1OTowOVrOHtMn-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo1OTowOVrOHtMn-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDgwOA==", "bodyText": "Based on the requirement listed on Issue #448, this transformNorthToSouth method has more than 500+ lines of codes and needs major refactor. The refactor so far doesn't break down the method to improve code readability and reduce potential risk of NPE.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517154808", "createdAt": "2020-11-04T07:59:09Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -16,73 +16,173 @@\n \n package com.futurewei.alcor.dataplane.utils;\n \n-import com.futurewei.alcor.dataplane.exception.ClientOfDPMFailureException;\n-import com.futurewei.alcor.dataplane.exception.DPMFailureException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n import com.futurewei.alcor.dataplane.service.GoalStateService;\n import com.futurewei.alcor.schema.*;\n import com.futurewei.alcor.schema.Port.PortState;\n-import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n-import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n-import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n-import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n+import org.jetbrains.annotations.Nullable;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n import org.springframework.stereotype.Component;\n-import com.futurewei.alcor.common.logging.Logger;\n-import com.futurewei.alcor.common.logging.LoggerFactory;\n-\n \n import java.util.*;\n-import java.util.logging.Level;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n \n import static com.futurewei.alcor.schema.Port.PortConfiguration.FixedIp;\n+import static com.futurewei.alcor.schema.Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER;\n \n @Component\n public class GoalStateManager {\n-    public static final int FORMAT_REVISION_NUMBER = 1;\n-    @Autowired private GoalStateService goalStateService;\n+  public static final int FORMAT_REVISION_NUMBER = 1;\n+  @Autowired private GoalStateService goalStateService;\n   private static final Logger LOG = LoggerFactory.getLogger();\n \n-  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration)\n-  {\n-    LOG.log(Level.INFO,\n-            \"### networkConf str: \"+networkConfiguration.toString());\n-    ExclusionStrategy myExclusionStrategy =\n-            new ExclusionStrategy() {\n-              @Override\n-              public boolean shouldSkipField(FieldAttributes fa) {\n-                return fa.getName().equals(\"tenantId\");\n-              }\n-\n-              @Override\n-              public boolean shouldSkipClass(Class<?> clazz) {\n-                return false;\n-              }\n-            };\n-    Gson gson = new GsonBuilder().setExclusionStrategies(myExclusionStrategy).create();\n-    LOG.log(Level.INFO,\"###############\");\n-    LOG.log(Level.INFO,gson.toJson(networkConfiguration));\n+  /**\n+   * convert and parse dpm input to dpm internal data structure\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  private void convert(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    final List<NeighborInfo> neighborInfos = networkConfiguration.getNeighborInfos();\n+\n+    final List<InternalPortEntity> portEntities = networkConfiguration.getPortEntities();\n+    for (InternalSubnetEntity internalSubnetEntity : networkConfiguration.getSubnets())\n+      subnetIdSubnetsMap.put(internalSubnetEntity.getId(), internalSubnetEntity);\n+\n+    // for newly created ports\n+    for (InternalPortEntity internalPortEntity : portEntities) {\n+      portIdPortMap.put(internalPortEntity.getId(), internalPortEntity);\n+\n+      for (PortEntity.FixedIp ip : internalPortEntity.getFixedIps()) {\n+        Set<String> fixedIpsSet = hostIpFixedIpsMap.get(internalPortEntity.getBindingHostIP());\n+        if (fixedIpsSet == null) fixedIpsSet = new TreeSet<>();\n+        Set<String> subnetIdsSet = hostIpSubnetIdsMap.get(internalPortEntity.getBindingHostIP());\n+        if (subnetIdsSet == null) subnetIdsSet = new TreeSet<>();\n+        fixedIpsSet.add(ip.getIpAddress());\n+        subnetIdsSet.add(ip.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getBindingHostIP(), fixedIpsSet);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getBindingHostIP(), subnetIdsSet);\n+\n+        ipPortIdMap.put(ip.getIpAddress(), internalPortEntity.getId());\n+        ipHostIpMap.put(ip.getIpAddress(), internalPortEntity.getBindingHostIP());\n+        ipSubnetIdMap.put(ip.getIpAddress(), ip.getSubnetId());\n+        ipMacMap.put(ip.getIpAddress(), internalPortEntity.getMacAddress());\n+      }\n+    }\n+    // for neighbor infos\n+    if (neighborInfos != null) {\n+      for (NeighborInfo internalPortEntity : neighborInfos) {\n+        ipPortIdMap.put(internalPortEntity.getPortIp(), internalPortEntity.getPortId());\n+        ipHostIpMap.put(internalPortEntity.getPortIp(), internalPortEntity.getHostIp());\n+        portIdNeighborInfoMap.put(internalPortEntity.getPortIp(), internalPortEntity);\n+        String portIp = internalPortEntity.getPortIp();\n+        Set<String> fixedIps = hostIpFixedIpsMap.get(internalPortEntity.getHostIp());\n+        if (fixedIps == null) fixedIps = new TreeSet<>();\n+        Set<String> subnetIds = hostIpSubnetIdsMap.get(internalPortEntity.getHostIp());\n+        if (subnetIds == null) subnetIds = new TreeSet<>();\n+        fixedIps.add(portIp);\n+        subnetIds.add(internalPortEntity.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getHostIp(), fixedIps);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getHostIp(), subnetIds);\n+        ipPortIdMap.put(portIp, internalPortEntity.getPortId());\n+        ipHostIpMap.put(portIp, internalPortEntity.getHostIp());\n+        ipSubnetIdMap.put(portIp, internalPortEntity.getSubnetId());\n+        ipMacMap.put(portIp, internalPortEntity.getPortMac());\n+      }\n+    }\n+  }\n+  /**\n+   * print dpm input msg\n+   *\n+   * @param networkConfiguration msg\n+   */\n+  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration) {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    try {\n+      String json = objectMapper.writeValueAsString(networkConfiguration);\n+      LOG.log(Level.INFO, \"@@@input json str: \" + json);\n+\n+    } catch (JsonProcessingException e) {\n+      LOG.log(Level.SEVERE, e.getMessage());\n+    }\n   }\n   /**\n    * transform client of dpm msg to aca protobuf format\n    *\n-   * @param networkConfiguration  msg to be transformmed\n+   * @param networkConfiguration msg to be transformmed\n    * @return Map<String, Goalstate.GoalState>\n    * @throws RuntimeException Various exceptions that may occur during the send process\n    */\n-  public Map<String, Goalstate.GoalState> transformNorthToSouth(\n+  @Async\n+  public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMTE4ODA0", "url": "https://github.com/futurewei-cloud/alcor/pull/418#pullrequestreview-523118804", "createdAt": "2020-11-04T08:06:49Z", "commit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODowNjo0OVrOHtM2iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODoxMjo0NlrOHtNCOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1ODUzNg==", "bodyText": "This block of codes have four for-loop, potentially quite costly. Pls try to improve this part.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517158536", "createdAt": "2020-11-04T08:06:49Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1OTQyMA==", "bodyText": "How do we ensure that this selected SubnetEntity has the right VPC id?", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517159420", "createdAt": "2020-11-04T08:08:40Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 558}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MTUzMQ==", "bodyText": "Is it possible that ipHostIpMap.get(nip) == null?", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517161531", "createdAt": "2020-11-04T08:12:46Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -113,221 +213,453 @@ public boolean shouldSkipClass(Class<?> clazz) {\n       InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n       if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n         List<InternalPortEntity> portStates = new ArrayList<>();\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap,\n-                neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap,\n-                vpcMap, portCounter, bindingHostIP, currentPortEntity,\n-                portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       } else {\n         List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n-        portCounter = bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates);\n+        portCounter =\n+            bindHostWithPorts(\n+                portsInSameSubnetMap,\n+                neighborInfoInSameSubenetMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounter,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                2);\n       }\n     }\n \n-    portsInSameSubnetMap.keySet().stream()\n-        .forEach(\n-            sid -> {\n-              for (String pid : portsInSameSubnetMap.get(sid)) {\n-                final Set<NeighborInfo> neighborInfos = neighborInfoInSameSubenetMap.get(sid);\n-                final InternalPortEntity internalPortEntity = portMap.get(pid);\n-                if (internalPortEntity == null) {\n-                  LOG.log(Level.WARNING, (\n-                      \"portId: \"\n-                          + pid\n-                          + \" provided in neighbor but NOT in port_internal, skip for now, likely to be dpm client error\"));\n-                  continue;\n-                }\n-                try {\n-                  final Set<NeighborInfo> neighborInfos3 = new HashSet<>();\n-                  for (NeighborInfo n : neighborInfos) {\n-                    if (!n.getHostIp().equals(internalPortEntity.getBindingHostIP()))\n-                      neighborInfos3.add(n);\n-                  }\n-\n-                  if (internalPortEntity.getInternalNeighborInfo1() == null\n-                      || internalPortEntity.getInternalNeighborInfo1().isEmpty()) {\n-                    final Set<NeighborInfo> neighborInfos2 = new HashSet<>();\n-                    neighborInfos2.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos2);\n-                  } else {\n-                    final Set<NeighborInfo> neighborInfos1 =\n-                        internalPortEntity.getInternalNeighborInfo1();\n-                    neighborInfos1.addAll(neighborInfos3);\n-                    internalPortEntity.setInternalNeighborInfo1(neighborInfos);\n-                  }\n-                } catch (Exception e) {\n-                  e.printStackTrace();\n-                  LOG.log(Level.WARNING,\n-                          e.getMessage());\n-                  throw new DPMFailureException(e.getMessage());\n-                }\n-              }\n-            });\n+    int portCounterL3 = 0;\n+    for (InternalPortEntity portEntityNB : portStatesArr) {\n+      portMap.put(portEntityNB.getId(), portEntityNB);\n+      String bindingHostIP = portEntityNB.getBindingHostIP();\n+      InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+      if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+        List<InternalPortEntity> portStates = new ArrayList<>();\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      } else {\n+        List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+        portCounterL3 =\n+            bindHostWithPorts(\n+                portsInSameVpcMap,\n+                neighborInfoInSameVpcMap,\n+                mapGroupedByHostIp,\n+                subnetMap,\n+                vpcMap,\n+                portCounterL3,\n+                bindingHostIP,\n+                currentPortEntity,\n+                portStates,\n+                3);\n+      }\n+    }\n \n     // construct sb msg by ip\n-    Map<String, Goalstate.GoalState> goalStateHashMap = new HashMap<>();\n+    Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<>();\n     // TODO would opt this part when perf needed\n-    mapGroupedByHostIp.entrySet().stream()\n+    hostIpSubnetIdsMap\n+        .keySet()\n         .forEach(\n-            eachGSOnSingleIP -> {\n+            currentGroupHostIp -> {\n               Set<PortState> portStateHashSet = new HashSet<>();\n+              Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<>();\n               Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n               Set<Vpc.VpcState> vpcStateSet = new HashSet();\n-                List<DHCP.DHCPState> dhcpStateList = new ArrayList();\n-\n-                final List<InternalPortEntity> internalPortEntitySet = eachGSOnSingleIP.getValue();\n-              boolean m = false;\n-              internalPortEntitySet.stream()\n-                  .forEach(\n-                      portStateWithEverythingFilledNB -> {\n-                        Set<Port.PortConfiguration.HostInfo> neighborSB = new HashSet();\n-                        if (portStateWithEverythingFilledNB.getInternalNeighborInfo1() != null) {\n-                          neighborSB = new HashSet();\n-                          for (NeighborInfo neighborInfo :\n-                              portStateWithEverythingFilledNB.getInternalNeighborInfo1()) {\n-                            Port.PortConfiguration.HostInfo build =\n-                                Port.PortConfiguration.HostInfo.newBuilder()\n-                                    .setIpAddress(neighborInfo.getHostIp())\n-                                    .setMacAddress(neighborInfo.getPortId())\n-                                    .build();\n-                            neighborSB.add(build);\n+              Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+              final List<InternalPortEntity> internalPortEntitySet =\n+                  mapGroupedByHostIp.get(currentGroupHostIp);\n+              if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(\n+                    portStateWithEverythingFilledNB -> {\n+                      List<FixedIp> fixedIps = new ArrayList();\n+                      boolean isExistingPort = false;\n+                      final List<PortEntity.FixedIp> fixedIps1 =\n+                          portStateWithEverythingFilledNB.getFixedIps();\n+                      for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(\n+                            FixedIp.newBuilder()\n+                                .setSubnetId(fixedIp.getSubnetId())\n+                                .setIpAddress(fixedIp.getIpAddress())\n+                                .build());\n+                        for (NeighborInfo internalPortEntity : portIdNeighborInfoMap.values()) {\n+                          if (internalPortEntity\n+                              .getPortId()\n+                              .equals(ipPortIdMap.get(fixedIp.getIpAddress()))) {\n+                            isExistingPort = true;\n+                            break;\n                           }\n                         }\n-                        List<FixedIp> fixedIps = new ArrayList();\n-\n-                        for (PortEntity.FixedIp fixedIp :\n-                            portStateWithEverythingFilledNB.getFixedIps()) {\n-                          FixedIp fixedIp1 =\n-                              FixedIp.newBuilder()\n-                                  .setIpAddress(fixedIp.getIpAddress())\n+                        if (!isExistingPort) {\n+                          DHCP.DHCPConfiguration dhcpConfiguration =\n+                              DHCP.DHCPConfiguration.newBuilder()\n+                                  .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n                                   .setSubnetId(fixedIp.getSubnetId())\n+                                  .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                                  .setIpv4Address(fixedIp.getIpAddress())\n                                   .build();\n-                          fixedIps.add(fixedIp1);\n-                            DHCP.DHCPConfiguration dhcpConfiguration=DHCP.DHCPConfiguration.newBuilder()\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setSubnetId(fixedIp.getSubnetId())\n-                                    .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                    .setIpv4Address(fixedIp.getIpAddress())\n-                                    .build();\n-                            DHCP.DHCPState dhcpState= DHCP.DHCPState.newBuilder()\n-                                    .setConfiguration(dhcpConfiguration)\n-                                    .build();\n-                            dhcpStateList.add(dhcpState);\n-                        }\n-                        String name= portStateWithEverythingFilledNB.getName()==null\n-                                ?\"\":portStateWithEverythingFilledNB.getName();\n-\n-\n-                              Port.PortConfiguration portConfiguration =\n-                            Port.PortConfiguration.newBuilder()\n-                                .setName(name)\n-                                .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                .setVpcId(\n-                                    portStateWithEverythingFilledNB\n-                                        .getSubnetEntities()\n-                                        .iterator()\n-                                        .next()\n-                                        .getVpcId())\n-                                .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                .setAdminStateUp(true)\n-                                .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n-                                .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                .addAllFixedIps(fixedIps)\n-                                .buildPartial();\n-                        // since dpm has to do everything including neighbor in 1 shot\n-                        if (portStateHashSet.size() < neighborSB.size()) {\n-                          for (Port.PortConfiguration.HostInfo h : neighborSB) {\n-                            String pid = h.getMacAddress();\n-                            Port.PortConfiguration portConfiguration1 =\n-                                portConfiguration\n-                                    .toBuilder()\n-                                    .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                    .setId(pid)\n-                                    .setHostInfo(h)\n-                                    .setMessageTypeValue(Common.MessageType.DELTA_VALUE)\n-                                    .build();\n-                            final PortState portStateSB =\n-                                PortState.newBuilder()\n-                                    .setConfiguration(portConfiguration1)\n-                                    .setOperationType(Common.OperationType.NEIGHBOR_CREATE_UPDATE)\n-                                    .build();\n-                            portStateHashSet.add(portStateSB);\n-                          }\n-                        }\n-                        Port.PortConfiguration portConfiguration2 =\n-                            portConfiguration\n-                                .toBuilder()\n-                                .setId(portStateWithEverythingFilledNB.getId())\n-                                .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n-                                .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n-                                .build();\n-\n-                        final PortState portStateSB =\n-                            PortState.newBuilder()\n-                                .setConfiguration(portConfiguration2)\n-                                .setOperationType(Common.OperationType.CREATE)\n-                                .build();\n-\n-                        portStateHashSet.add(portStateSB);\n-\n-                        // lookup subnet entity\n-                        for (InternalSubnetEntity subnetEntity1 :\n-                            portStateWithEverythingFilledNB.getSubnetEntities()) {\n-                            if(subnetEntity1.getTunnelId()==null)\n-                            {\n-                                throw new ClientOfDPMFailureException(\"empty tunnelId in the subnet payload!\");\n-                            }\n-                          Subnet.SubnetConfiguration subnetConfiguration =\n-                              Subnet.SubnetConfiguration.newBuilder()\n-                                  .setId(subnetEntity1.getId())\n-                                  .setVpcId(subnetEntity1.getVpcId())\n-                                  .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n-                                  .setCidr(subnetEntity1.getCidr())\n-                                  .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                  .setTunnelId(subnetEntity1.getTunnelId())\n+                          DHCP.DHCPState dhcpState =\n+                              DHCP.DHCPState.newBuilder()\n+                                  .setConfiguration(dhcpConfiguration)\n                                   .build();\n-                          Subnet.SubnetState subnetState =\n-                              Subnet.SubnetState.newBuilder()\n-                                  .setConfiguration(subnetConfiguration)\n-                                  .buildPartial();\n-                          if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.INFO)\n-                                    .build();\n-                          else\n-                            subnetState =\n-                                subnetState\n-                                    .toBuilder()\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-\n-                          subnetStateSet.add(subnetState);\n-                          if (!(networkConfiguration.getOpType().equals(Common.OperationType.CREATE)\n-                              && networkConfiguration\n-                                  .getRsType()\n-                                  .equals(Common.ResourceType.PORT))) {\n-                            // lookup vpc entity\n-                            final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n-                            Vpc.VpcConfiguration vpcConfiguration =\n-                                Vpc.VpcConfiguration.newBuilder()\n-                                    .setId(vpcEntity.getId())\n-                                    .setCidr(vpcEntity.getCidr())\n-                                    .setFormatVersion(FORMAT_REVISION_NUMBER)\n-                                    .setRevisionNumber(FORMAT_REVISION_NUMBER)\n-                                    .build();\n-                            Vpc.VpcState vpcState =\n-                                Vpc.VpcState.newBuilder()\n-                                    .setConfiguration(vpcConfiguration)\n-                                    .setOperationTypeValue(Common.OperationType.CREATE_VALUE)\n-                                    .setOperationType(Common.OperationType.CREATE)\n-                                    .build();\n-                            vpcStateSet.add(vpcState);\n-                          }\n+                          dhcpStateList.add(dhcpState);\n+                          isExistingPort = true;\n+                        }\n+                      }\n+                      String name =\n+                          portStateWithEverythingFilledNB.getName() == null\n+                              ? \"\"\n+                              : portStateWithEverythingFilledNB.getName();\n+\n+                      Port.PortConfiguration portConfiguration =\n+                          Port.PortConfiguration.newBuilder()\n+                              .setName(name)\n+                              .setProjectId(portStateWithEverythingFilledNB.getProjectId())\n+                              .setVpcId(\n+                                  portStateWithEverythingFilledNB\n+                                      .getSubnetEntities()\n+                                      .iterator()\n+                                      .next()\n+                                      .getVpcId())\n+                              .setFormatVersion(FORMAT_REVISION_NUMBER)\n+                              .setAdminStateUp(true)\n+                              .setMacAddress(portStateWithEverythingFilledNB.getMacAddress())\n+                              .setRevisionNumber(FORMAT_REVISION_NUMBER)\n+                              .addAllFixedIps(fixedIps)\n+                              .setId(portStateWithEverythingFilledNB.getId())\n+                              .setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE)\n+                              .setMessageTypeValue(Common.MessageType.FULL_VALUE)\n+                              .build();\n+\n+                      final PortState portStateSB =\n+                          PortState.newBuilder()\n+                              .setConfiguration(portConfiguration)\n+                              .setOperationType(Common.OperationType.CREATE)\n+                              .build();\n+\n+                      portStateHashSet.add(portStateSB);\n+                    });\n+              }\n \n+              // avoid duplicate\n+\n+              if (networkConfiguration.getNeighborTable() != null\n+                  && neighborStates.size() == 0\n+                  && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                  for (String ip :\n+                      hostIpFixedIpsMap.values().stream()\n+                          .flatMap(alist -> alist.stream())\n+                          .collect(Collectors.toList())) {\n+                    {\n+                      Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                      Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                      if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                        if (!hostIpSubnetIdsMap\n+                            .get(currentGroupHostIp)\n+                            .iterator()\n+                            .next()\n+                            .equals(ipSubnetIdMap.get(ip))) {\n+                          l2 = Neighbor.NeighborType.L3;\n+                          l3 = Neighbor.NeighborType.L2;\n                         }\n-                      });\n+                      }\n+\n+                      if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l3,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } // if contains ip in neighbor info\n+                    }\n+                  }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                  for (String ip :\n+                      hostIpFixedIpsMap.values().stream()\n+                          .flatMap(alist -> alist.stream())\n+                          .collect(Collectors.toList())) {\n+                    Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                    Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                    if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                      if (!hostIpSubnetIdsMap\n+                          .get(currentGroupHostIp)\n+                          .iterator()\n+                          .next()\n+                          .equals(ipSubnetIdMap.get(ip))) {\n+                        l2 = Neighbor.NeighborType.L3;\n+                        l3 = Neighbor.NeighborType.L2;\n+                      }\n+                    }\n+\n+                    final InternalPortEntity portStateWithEverythingFilledNB =\n+                        portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                    if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                      Set<InternalSubnetEntity> ss =\n+                          portStateWithEverythingFilledNB.getSubnetEntities();\n+                      final InternalSubnetEntity next = ss.iterator().next();\n+                      if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l2,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } else {\n+                        createNeighborState(\n+                            networkConfiguration,\n+                            neighborStates,\n+                            brandNewIps,\n+                            ip,\n+                            currentGroupHostIp,\n+                            l3,\n+                            ipPortIdMap,\n+                            ipMacMap,\n+                            ipSubnetIdMap,\n+                            ipHostIpMap,\n+                            hostIpFixedIpsMap,\n+                            hostIpSubnetIdsMap,\n+                            subnetIdSubnetsMap,\n+                            portIdPortMap,\n+                            portIdNeighborInfoMap);\n+                      } // end if internal size==1 sn>2\n+                      brandNewIps.add(ip);\n+                    }\n+                  }\n+                  // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                  if (!ipHostIpMap.get(nip).equals(currentGroupHostIp)) continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 699}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beb09dee2292cd2ddca5e88f6898352bd91eb951", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/beb09dee2292cd2ddca5e88f6898352bd91eb951", "committedDate": "2020-11-05T05:30:15Z", "message": "Merge branch 'master' into feature/add-route-to-nc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/7ccbc912c6107d84c9b3820d897b556b41991bd7", "committedDate": "2020-11-05T06:27:33Z", "message": "refactor code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzOTY5MjA4", "url": "https://github.com/futurewei-cloud/alcor/pull/418#pullrequestreview-523969208", "createdAt": "2020-11-05T06:59:23Z", "commit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNjo1OToyM1rOHt1uqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNzoxNzo1NlrOHt2KiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyODI2NA==", "bodyText": "We will need a license statement on new file.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517828264", "createdAt": "2020-11-05T06:59:23Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/DataPlanePrinter.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.futurewei.alcor.dataplane.utils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyOTM5Mg==", "bodyText": "Can op = null? This is another potential NPE when trying to setOperationType(op) in next line.", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517829392", "createdAt": "2020-11-05T07:02:30Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateTransformer.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.schema.*;\n+import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n+import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n+import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n+import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n+\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n+\n+\n+public class GoalStateTransformer {\n+    private final GoalStateManager goalStateManager;\n+\n+    public GoalStateTransformer(GoalStateManager goalStateManager) {\n+        this.goalStateManager = goalStateManager;\n+    }\n+\n+    /**\n+     * transform client of dpm msg to aca protobuf format\n+     *\n+     * @param networkConfiguration msg to be transformmed\n+     * @return Map<String, Goalstate.GoalState>\n+     * @throws RuntimeException Various exceptions that may occur during the\n+     * send process\n+     */\n+    @Async\n+    public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(NetworkConfiguration networkConfiguration) throws RuntimeException {\n+\n+        Map<String, String> ipPortIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipMacMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipSubnetIdMap = new ConcurrentHashMap<String, String>();\n+        Map<String, String> ipHostIpMap = new ConcurrentHashMap<String, String>();\n+        Map<String, Set<String>> hostIpFixedIpsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, Set<String>> hostIpSubnetIdsMap = new ConcurrentHashMap<String, Set<String>>();\n+        Map<String, InternalSubnetEntity> subnetIdSubnetsMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portIdPortMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, NeighborInfo> portIdNeighborInfoMap = new ConcurrentHashMap<String, NeighborInfo>();\n+\n+        // print entry input for debug usage\n+        goalStateManager.printNetworkConfiguration(networkConfiguration);\n+        goalStateManager.getDPMPreparer().convert(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap);\n+\n+        Map<String, Set<String>> portsInSameSubnetMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameSubenetMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+        // L3\n+        Map<String, Set<String>> portsInSameVpcMap = new ConcurrentHashMap<String, Set<String>>();\n+\n+        Map<String, Set<NeighborInfo>> neighborInfoInSameVpcMap = new ConcurrentHashMap<String, Set<NeighborInfo>>();\n+\n+        InternalPortEntity[] portStatesArr = networkConfiguration.getPortEntities().toArray(new InternalPortEntity[0]);\n+        InternalSubnetEntity[] subnetArr = networkConfiguration.getSubnets().toArray(new InternalSubnetEntity[0]);\n+        VpcEntity[] vpcArr = networkConfiguration.getVpcs().toArray(new VpcEntity[0]);\n+\n+        // TODO need to v2 subnet and vpc part when logic is\n+        //  clear and integration done\n+        Map<String, List<InternalPortEntity>> mapGroupedByHostIp = new ConcurrentHashMap();\n+        Map<String, InternalSubnetEntity> subnetMap = new ConcurrentHashMap<String, InternalSubnetEntity>();\n+        Map<String, InternalPortEntity> portMap = new ConcurrentHashMap<String, InternalPortEntity>();\n+        Map<String, VpcEntity> vpcMap = new ConcurrentHashMap<String, VpcEntity>();\n+        // construct map from list\n+        for (InternalSubnetEntity s : subnetArr) {\n+            subnetMap.put(s.getId(), s);\n+        }\n+\n+        for (VpcEntity vpc : vpcArr) {\n+            vpcMap.put(vpc.getId(), vpc);\n+        }\n+        // group nb msg by ip\n+        int portCounter = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounter];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounter = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameSubnetMap, neighborInfoInSameSubenetMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounter, bindingHostIP, currentPortEntity, portStates, 2);\n+            }\n+        }\n+\n+        int portCounterL3 = 0;\n+        for (InternalPortEntity portEntityNB : portStatesArr) {\n+            portMap.put(portEntityNB.getId(), portEntityNB);\n+            String bindingHostIP = portEntityNB.getBindingHostIP();\n+            InternalPortEntity currentPortEntity = portStatesArr[portCounterL3];\n+            if (!mapGroupedByHostIp.containsKey(bindingHostIP)) {\n+                List<InternalPortEntity> portStates = new ArrayList<InternalPortEntity>();\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            } else {\n+                List<InternalPortEntity> portStates = mapGroupedByHostIp.get(bindingHostIP);\n+                portCounterL3 = goalStateManager.getGoalStateHelper().bindHostWithPorts(portsInSameVpcMap, neighborInfoInSameVpcMap, mapGroupedByHostIp, subnetMap, vpcMap, portCounterL3, bindingHostIP, currentPortEntity, portStates, 3);\n+            }\n+        }\n+\n+        // construct sb msg by ip\n+        Map<String, Goalstate.GoalState> goalStateConcurrentHashMap = new ConcurrentHashMap<String, Goalstate.GoalState>();\n+        // TODO would opt this part when perf needed\n+        hostIpSubnetIdsMap.keySet().forEach(currentGroupHostIp -> {\n+            Set<Port.PortState> portStateHashSet = new HashSet<Port.PortState>();\n+            Map<String, Neighbor.NeighborState> neighborStates = new ConcurrentHashMap<String, Neighbor.NeighborState>();\n+            Set<Subnet.SubnetState> subnetStateSet = new HashSet();\n+            Set<Vpc.VpcState> vpcStateSet = new HashSet();\n+            Set<DHCP.DHCPState> dhcpStateList = new HashSet();\n+            final List<InternalPortEntity> internalPortEntitySet = mapGroupedByHostIp.get(currentGroupHostIp);\n+            if (internalPortEntitySet != null) {\n+                internalPortEntitySet.forEach(portStateWithEverythingFilledNB -> {\n+                    List<Port.PortConfiguration.FixedIp> fixedIps = new ArrayList();\n+                    boolean isExistingPort = false;\n+                    final List<PortEntity.FixedIp> fixedIps1 = portStateWithEverythingFilledNB.getFixedIps();\n+                    for (PortEntity.FixedIp fixedIp : fixedIps1) {\n+                        fixedIps.add(Port.PortConfiguration.FixedIp.newBuilder().setSubnetId(fixedIp.getSubnetId()).setIpAddress(fixedIp.getIpAddress()).build());\n+                        if (portIdNeighborInfoMap.values().stream().filter(e -> e.getPortId().equals(ipPortIdMap.get(fixedIp.getIpAddress()))).count() == 0) {\n+                            DHCP.DHCPConfiguration dhcpConfiguration = DHCP.DHCPConfiguration.newBuilder().setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setSubnetId(fixedIp.getSubnetId()).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setIpv4Address(fixedIp.getIpAddress()).build();\n+                            DHCP.DHCPState dhcpState = DHCP.DHCPState.newBuilder().setConfiguration(dhcpConfiguration).build();\n+                            dhcpStateList.add(dhcpState);\n+                        }\n+                    }\n+                    String name = portStateWithEverythingFilledNB.getName() == null ? \"\" : portStateWithEverythingFilledNB.getName();\n+\n+                    Port.PortConfiguration portConfiguration = Port.PortConfiguration.newBuilder().setName(name).setProjectId(portStateWithEverythingFilledNB.getProjectId()).setVpcId(portStateWithEverythingFilledNB.getVpcEntities().iterator().next().getId()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setAdminStateUp(true).setMacAddress(portStateWithEverythingFilledNB.getMacAddress()).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).addAllFixedIps(fixedIps).setId(portStateWithEverythingFilledNB.getId()).setNetworkTypeValue(Common.NetworkType.VXLAN_VALUE).setMessageTypeValue(Common.MessageType.FULL_VALUE).build();\n+\n+                    final Port.PortState portStateSB = Port.PortState.newBuilder().setConfiguration(portConfiguration).setOperationType(Common.OperationType.CREATE).build();\n+\n+                    portStateHashSet.add(portStateSB);\n+                });\n+            }\n+\n+            // avoid duplicate\n+\n+            if (networkConfiguration.getNeighborTable() != null && neighborStates.size() == 0 && networkConfiguration.getNeighborTable().size() > 0) {\n+\n+                Set<String> brandNewIps = new ConcurrentSkipListSet();\n+                if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() > 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        {\n+                            Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                            Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                            if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                                if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                    l2 = Neighbor.NeighborType.L3;\n+                                    l3 = Neighbor.NeighborType.L2;\n+                                }\n+                            }\n+\n+                            if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // if contains ip in neighbor info\n+                        }\n+                    }\n+                } else if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                    for (String ip : hostIpFixedIpsMap.values().stream().flatMap(alist -> alist.stream()).collect(Collectors.toList())) {\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(ip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        final InternalPortEntity portStateWithEverythingFilledNB = portIdPortMap.get(ipPortIdMap.get(ip));\n+\n+                        if (!portIdNeighborInfoMap.containsKey(ip)) {\n+                            Set<InternalSubnetEntity> ss = portStateWithEverythingFilledNB.getSubnetEntities();\n+                            final InternalSubnetEntity next = ss.iterator().next();\n+                            if (ss.size() == 1 && ipSubnetIdMap.get(ip).equals(next.getId())) {\n+\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l2);\n+                            } else {\n+                                goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, ip, l3);\n+                            } // end if internal size==1 sn>2\n+                            brandNewIps.add(ip);\n+                        }\n+                    }\n+                    // start new loop for adding new ip to existing port\n+\n+                } // size ==1\n+                for (String nip : brandNewIps) {\n+                    if (!ipHostIpMap.get(nip).equals(currentGroupHostIp))\n+                        continue;\n+                    for (String eip : portIdNeighborInfoMap.keySet()) {\n+\n+                        Neighbor.NeighborType l3 = Neighbor.NeighborType.L3;\n+                        Neighbor.NeighborType l2 = Neighbor.NeighborType.L2;\n+\n+                        if (hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1) {\n+                            if (!hostIpSubnetIdsMap.get(currentGroupHostIp).iterator().next().equals(ipSubnetIdMap.get(nip))) {\n+                                l2 = Neighbor.NeighborType.L3;\n+                                l3 = Neighbor.NeighborType.L2;\n+                            }\n+                        }\n+\n+                        if (ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) { // ip 2.2\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (!ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l3);\n+                        } else if (!ipHostIpMap.get(eip).equals(currentGroupHostIp) && (ipSubnetIdMap.get(eip).equals(ipSubnetIdMap.get(nip)))) {\n+\n+                            goalStateManager.getGoalStateHelper().createNeighborHelper(networkConfiguration, ipPortIdMap, ipMacMap, ipSubnetIdMap, ipHostIpMap, hostIpFixedIpsMap, hostIpSubnetIdsMap, subnetIdSubnetsMap, portIdPortMap, portIdNeighborInfoMap, currentGroupHostIp, neighborStates, brandNewIps, eip, l2);\n+                        } // inner if end\n+                    } // 2nd loop end\n+                } // current nip end\n+            } // if size==0\n+\n+            // lookup subnet entity\n+            for (String sid : ipSubnetIdMap.values()) {\n+                InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(sid);\n+                if (subnetEntity1 == null) {\n+                    GoalStateManager.LOG.log(Level.SEVERE, sid +\n+                            \"subnet is MISSING\");\n+                    continue;\n+                }\n+                goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                // lookup vpc entity\n+                final VpcEntity vpcEntity = vpcMap.get(subnetEntity1.getVpcId());\n+                Vpc.VpcConfiguration vpcConfiguration = Vpc.VpcConfiguration.newBuilder().setId(vpcEntity.getId()).setCidr(vpcEntity.getCidr()).setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER).setRevisionNumber(GoalStateManager.FORMAT_REVISION_NUMBER).build();\n+                Vpc.VpcState vpcState = Vpc.VpcState.newBuilder().setConfiguration(vpcConfiguration).setOperationTypeValue(Common.OperationType.CREATE_VALUE).setOperationType(Common.OperationType.CREATE).build();\n+                vpcStateSet.add(vpcState);\n+            }\n+\n+            List<Router.RouterState> routerStateList = new ArrayList<Router.RouterState>();\n+            if (networkConfiguration.getInternalRouterInfos() != null && neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                for (InternalRouterInfo internalRouterInfo : networkConfiguration.getInternalRouterInfos()) {\n+                    final List<InternalSubnetRoutingTable> subnetRoutingTables = internalRouterInfo.getRouterConfiguration().getSubnetRoutingTables();\n+                    final List<Router.RouterConfiguration.SubnetRoutingTable> subnetRoutingTables2 = new ArrayList<Router.RouterConfiguration.SubnetRoutingTable>();\n+                    for (InternalSubnetRoutingTable internalSubnetRoutingTable : subnetRoutingTables) {\n+                        if (neighborStates.keySet().stream().filter(e -> e.indexOf(\"#L3\") != -1).count() > 0) {\n+                            final InternalSubnetEntity subnetEntity1 = subnetIdSubnetsMap.get(internalSubnetRoutingTable.getSubnetId());\n+\n+                            goalStateManager.getGoalStateHelper().add2SubnetStates(networkConfiguration, subnetStateSet, subnetEntity1);\n+                        }\n+\n+                        Router.RouterConfiguration.SubnetRoutingTable subnetRoutingTable = Router.RouterConfiguration.SubnetRoutingTable.newBuilder().setSubnetId(internalSubnetRoutingTable.getSubnetId()).buildPartial();\n+                        List<Router.RouterConfiguration.RoutingRule> routingRuleList = new ArrayList<Router.RouterConfiguration.RoutingRule>();\n+                        for (InternalRoutingRule internalRoutingRule : internalSubnetRoutingTable.getRoutingRules()) {\n+                            Router.DestinationType destinationType =\n+                                    Router.DestinationType.INTERNET;\n+                            Router.RouterConfiguration.RoutingRuleExtraInfo routingRuleExtraInfo = Router.RouterConfiguration.RoutingRuleExtraInfo.newBuilder().setDestinationType(destinationType).setNextHopMac(internalRoutingRule.getRoutingRuleExtraInfo().getNextHopMac()).build();\n+                            Common.OperationType op = goalStateManager.getGoalStateHelper().getOperationType(internalRoutingRule.getOperationType().equals(OperationType.CREATE), internalRoutingRule.getOperationType().equals(OperationType.INFO), Common.OperationType.INFO, internalRoutingRule.getOperationType().equals(OperationType.DELETE), Common.OperationType.DELETE, internalRoutingRule.getOperationType().equals(OperationType.UPDATE), Common.OperationType.UPDATE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjEyNw==", "bodyText": "What is this method for? It looks like a very customized \"getOperationType\".", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517832127", "createdAt": "2020-11-05T07:09:41Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzMjQ1OA==", "bodyText": "Does the parameter Common.Opeartion delete always means \"resource deletion\" or has different meaning in different usage?", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517832458", "createdAt": "2020-11-05T07:10:38Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateHelper.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.futurewei.alcor.dataplane.utils;\n+\n+import com.futurewei.alcor.schema.Common;\n+import com.futurewei.alcor.schema.Neighbor;\n+import com.futurewei.alcor.schema.Port;\n+import com.futurewei.alcor.schema.Subnet;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n+import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n+import org.jetbrains.annotations.Nullable;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GoalStateHelper {\n+  public GoalStateHelper() {}\n+\n+  void createNeighborHelper(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap,\n+      String currentGroupHostIp,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      Neighbor.NeighborType l2) {\n+    createNeighborState(\n+        networkConfiguration,\n+        neighborStates,\n+        brandNewIps,\n+        ip,\n+        currentGroupHostIp,\n+        l2,\n+        ipPortIdMap,\n+        ipMacMap,\n+        ipSubnetIdMap,\n+        ipHostIpMap,\n+        hostIpFixedIpsMap,\n+        hostIpSubnetIdsMap,\n+        subnetIdSubnetsMap,\n+        portIdPortMap,\n+        portIdNeighborInfoMap);\n+  }\n+\n+  void add2SubnetStates(\n+      NetworkConfiguration networkConfiguration,\n+      Set<Subnet.SubnetState> subnetStateSet,\n+      InternalSubnetEntity subnetEntity1) {\n+    Subnet.SubnetConfiguration.Gateway gateway =\n+        Subnet.SubnetConfiguration.Gateway.newBuilder()\n+            .setIpAddress(subnetEntity1.getGatewayIp())\n+            .setMacAddress(subnetEntity1.getGatewayMacAddress())\n+            .build();\n+    Subnet.SubnetConfiguration subnetConfiguration =\n+        Subnet.SubnetConfiguration.newBuilder()\n+            .setId(subnetEntity1.getId())\n+            .setVpcId(subnetEntity1.getVpcId())\n+            .setProjectId(subnetEntity1.getProjectId())\n+            .setCidr(subnetEntity1.getCidr())\n+            .setTunnelId(subnetEntity1.getTunnelId())\n+            .setGateway(gateway)\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .build();\n+    Subnet.SubnetState subnetState =\n+        Subnet.SubnetState.newBuilder().setConfiguration(subnetConfiguration).buildPartial();\n+    if (networkConfiguration.getRsType().equals(Common.ResourceType.PORT))\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.INFO).build();\n+    else\n+      subnetState = subnetState.toBuilder().setOperationType(Common.OperationType.CREATE).build();\n+\n+    subnetStateSet.add(subnetState);\n+  }\n+\n+  @Async\n+  /**\n+   * create L3/L2 neighbors\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  void createNeighborState(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, Neighbor.NeighborState> neighborStates,\n+      Set<String> brandNewIps,\n+      String ip,\n+      String currentGroupHostIp,\n+      Neighbor.NeighborType neighborType,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    // corner case check\n+    if (ipHostIpMap.get(ip).equals(currentGroupHostIp)) {\n+      for (InternalPortEntity it : networkConfiguration.getPortEntities()) {\n+        for (PortEntity.FixedIp f : it.getFixedIps()) {\n+          if (f.getIpAddress().equals(ip) && hostIpSubnetIdsMap.get(currentGroupHostIp).size() == 1)\n+            return;\n+        }\n+      }\n+    }\n+    // corner case check\n+    if (networkConfiguration.getNeighborTable() == null\n+        && networkConfiguration.getNeighborInfos() == null) return;\n+    if (currentGroupHostIp.equals(ipHostIpMap.get(ip))\n+        && networkConfiguration.getNeighborInfos().size()\n+            == networkConfiguration.getNeighborTable().size()\n+        && networkConfiguration.getNeighborTable().size() > 1) {\n+      Set<String> hostIps = new HashSet();\n+      for (NeighborEntry n : networkConfiguration.getNeighborTable()) {\n+        hostIps.add(ipHostIpMap.get(n.getNeighborIp()));\n+      }\n+      if (hostIps.size() == 1)\n+        for (InternalPortEntity i : portIdPortMap.values()) {\n+          for (PortEntity.FixedIp fixedIp : i.getFixedIps()) {\n+            if (fixedIp.getIpAddress().equals(ip)) return;\n+          }\n+        }\n+    }\n+    // construct the L3/L2 neighbor\n+    if (neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L3)) return;\n+    else if ((neighborStates.containsKey(ip + \"#\" + Neighbor.NeighborType.L2))\n+        && (neighborType.equals(Neighbor.NeighborType.L3)))\n+      neighborStates.remove(ip + \"#\" + Neighbor.NeighborType.L2);\n+    Neighbor.NeighborConfiguration.FixedIp fixedIp =\n+        Neighbor.NeighborConfiguration.FixedIp.newBuilder()\n+            .setIpAddress(ip)\n+            .setSubnetId(ipSubnetIdMap.get(ip))\n+            .setNeighborType(neighborType)\n+            .build();\n+    Neighbor.NeighborConfiguration neighborConfiguration =\n+        Neighbor.NeighborConfiguration.newBuilder()\n+            .addFixedIps(fixedIp)\n+            .setHostIpAddress(ipHostIpMap.get(ip))\n+            .setMacAddress(ipMacMap.get(ip))\n+            .setFormatVersion(GoalStateManager.FORMAT_REVISION_NUMBER)\n+            .setRevisionNumber(Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER)\n+            .setId(ipPortIdMap.get(ip))\n+            .setProjectId(networkConfiguration.getVpcs().get(0).getProjectId())\n+            .setVpcId(networkConfiguration.getVpcs().get(0).getId())\n+            .build();\n+    Common.OperationType target =\n+        getOperationType(\n+            networkConfiguration.getOpType().equals(Common.OperationType.CREATE),\n+            networkConfiguration.getOpType().equals(Common.OperationType.DELETE),\n+            Common.OperationType.DELETE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.UPDATE),\n+            Common.OperationType.UPDATE,\n+            networkConfiguration.getOpType().equals(Common.OperationType.INFO),\n+            Common.OperationType.INFO);\n+    Neighbor.NeighborState neighborState =\n+        Neighbor.NeighborState.newBuilder()\n+            .setConfiguration(neighborConfiguration)\n+            .setOperationType(target)\n+            .build();\n+    neighborStates.put(ip + \"#\" + neighborType, neighborState);\n+    brandNewIps.add(ip);\n+  }\n+\n+  @Nullable\n+  Common.OperationType getOperationType(\n+      boolean equals,\n+      boolean equals2,\n+      Common.OperationType delete,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ccbc912c6107d84c9b3820d897b556b41991bd7"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgzNTQwMA==", "bodyText": "The major logic of transformNorthToSouth method has been moved to GoalStateTransformer, and with some logics pulled out, which is a positive move.\nHowever, I have to point out that the major complexity remains in GoalStateTransformer, and the code remains long and prone to error or NPE (see a potential issue in line 258 of GoalStateTransformer as pointed out there).", "url": "https://github.com/futurewei-cloud/alcor/pull/418#discussion_r517835400", "createdAt": "2020-11-05T07:17:56Z", "author": {"login": "xieus"}, "path": "services/data_plane_manager/src/main/java/com/futurewei/alcor/dataplane/utils/GoalStateManager.java", "diffHunk": "@@ -16,73 +16,173 @@\n \n package com.futurewei.alcor.dataplane.utils;\n \n-import com.futurewei.alcor.dataplane.exception.ClientOfDPMFailureException;\n-import com.futurewei.alcor.dataplane.exception.DPMFailureException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.futurewei.alcor.common.enumClass.OperationType;\n+import com.futurewei.alcor.common.logging.Logger;\n+import com.futurewei.alcor.common.logging.LoggerFactory;\n import com.futurewei.alcor.dataplane.service.GoalStateService;\n import com.futurewei.alcor.schema.*;\n import com.futurewei.alcor.schema.Port.PortState;\n-import com.futurewei.alcor.web.entity.dataplane.InternalPortEntity;\n-import com.futurewei.alcor.web.entity.dataplane.InternalSubnetEntity;\n-import com.futurewei.alcor.web.entity.dataplane.NeighborInfo;\n-import com.futurewei.alcor.web.entity.dataplane.NetworkConfiguration;\n+import com.futurewei.alcor.web.entity.dataplane.*;\n import com.futurewei.alcor.web.entity.port.PortEntity;\n+import com.futurewei.alcor.web.entity.route.InternalRouterInfo;\n+import com.futurewei.alcor.web.entity.route.InternalRoutingRule;\n+import com.futurewei.alcor.web.entity.route.InternalSubnetRoutingTable;\n import com.futurewei.alcor.web.entity.vpc.VpcEntity;\n-import com.google.gson.ExclusionStrategy;\n-import com.google.gson.FieldAttributes;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n+import org.jetbrains.annotations.Nullable;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.scheduling.annotation.Async;\n+import org.springframework.scheduling.annotation.AsyncResult;\n import org.springframework.stereotype.Component;\n-import com.futurewei.alcor.common.logging.Logger;\n-import com.futurewei.alcor.common.logging.LoggerFactory;\n-\n \n import java.util.*;\n-import java.util.logging.Level;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.Future;\n+import java.util.logging.*;\n+import java.util.stream.Collectors;\n \n import static com.futurewei.alcor.schema.Port.PortConfiguration.FixedIp;\n+import static com.futurewei.alcor.schema.Port.PortConfiguration.REVISION_NUMBER_FIELD_NUMBER;\n \n @Component\n public class GoalStateManager {\n-    public static final int FORMAT_REVISION_NUMBER = 1;\n-    @Autowired private GoalStateService goalStateService;\n+  public static final int FORMAT_REVISION_NUMBER = 1;\n+  @Autowired private GoalStateService goalStateService;\n   private static final Logger LOG = LoggerFactory.getLogger();\n \n-  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration)\n-  {\n-    LOG.log(Level.INFO,\n-            \"### networkConf str: \"+networkConfiguration.toString());\n-    ExclusionStrategy myExclusionStrategy =\n-            new ExclusionStrategy() {\n-              @Override\n-              public boolean shouldSkipField(FieldAttributes fa) {\n-                return fa.getName().equals(\"tenantId\");\n-              }\n-\n-              @Override\n-              public boolean shouldSkipClass(Class<?> clazz) {\n-                return false;\n-              }\n-            };\n-    Gson gson = new GsonBuilder().setExclusionStrategies(myExclusionStrategy).create();\n-    LOG.log(Level.INFO,\"###############\");\n-    LOG.log(Level.INFO,gson.toJson(networkConfiguration));\n+  /**\n+   * convert and parse dpm input to dpm internal data structure\n+   *\n+   * @param networkConfiguration msg to be parsed\n+   * @param ipPortIdMap map of ip --> portId\n+   * @param ipMacMap map of ip --> Mac\n+   * @param ipSubnetIdMap map of ip --> SubnetId\n+   * @param ipHostIpMap map of ip --> HostIp\n+   * @param hostIpFixedIpsMap map of hostIp --> FixedIp\n+   * @param hostIpSubnetIdsMap map of hostIp --> SubnetId\n+   * @param subnetIdSubnetsMap map of subnetId --> Subnet\n+   * @param portIdPortMap map of portId --> Port\n+   * @param portIdNeighborInfoMap map of portId --> NeighborInfo\n+   */\n+  private void convert(\n+      NetworkConfiguration networkConfiguration,\n+      Map<String, String> ipPortIdMap,\n+      Map<String, String> ipMacMap,\n+      Map<String, String> ipSubnetIdMap,\n+      Map<String, String> ipHostIpMap,\n+      Map<String, Set<String>> hostIpFixedIpsMap,\n+      Map<String, Set<String>> hostIpSubnetIdsMap,\n+      Map<String, InternalSubnetEntity> subnetIdSubnetsMap,\n+      Map<String, InternalPortEntity> portIdPortMap,\n+      Map<String, NeighborInfo> portIdNeighborInfoMap) {\n+\n+    final List<NeighborInfo> neighborInfos = networkConfiguration.getNeighborInfos();\n+\n+    final List<InternalPortEntity> portEntities = networkConfiguration.getPortEntities();\n+    for (InternalSubnetEntity internalSubnetEntity : networkConfiguration.getSubnets())\n+      subnetIdSubnetsMap.put(internalSubnetEntity.getId(), internalSubnetEntity);\n+\n+    // for newly created ports\n+    for (InternalPortEntity internalPortEntity : portEntities) {\n+      portIdPortMap.put(internalPortEntity.getId(), internalPortEntity);\n+\n+      for (PortEntity.FixedIp ip : internalPortEntity.getFixedIps()) {\n+        Set<String> fixedIpsSet = hostIpFixedIpsMap.get(internalPortEntity.getBindingHostIP());\n+        if (fixedIpsSet == null) fixedIpsSet = new TreeSet<>();\n+        Set<String> subnetIdsSet = hostIpSubnetIdsMap.get(internalPortEntity.getBindingHostIP());\n+        if (subnetIdsSet == null) subnetIdsSet = new TreeSet<>();\n+        fixedIpsSet.add(ip.getIpAddress());\n+        subnetIdsSet.add(ip.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getBindingHostIP(), fixedIpsSet);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getBindingHostIP(), subnetIdsSet);\n+\n+        ipPortIdMap.put(ip.getIpAddress(), internalPortEntity.getId());\n+        ipHostIpMap.put(ip.getIpAddress(), internalPortEntity.getBindingHostIP());\n+        ipSubnetIdMap.put(ip.getIpAddress(), ip.getSubnetId());\n+        ipMacMap.put(ip.getIpAddress(), internalPortEntity.getMacAddress());\n+      }\n+    }\n+    // for neighbor infos\n+    if (neighborInfos != null) {\n+      for (NeighborInfo internalPortEntity : neighborInfos) {\n+        ipPortIdMap.put(internalPortEntity.getPortIp(), internalPortEntity.getPortId());\n+        ipHostIpMap.put(internalPortEntity.getPortIp(), internalPortEntity.getHostIp());\n+        portIdNeighborInfoMap.put(internalPortEntity.getPortIp(), internalPortEntity);\n+        String portIp = internalPortEntity.getPortIp();\n+        Set<String> fixedIps = hostIpFixedIpsMap.get(internalPortEntity.getHostIp());\n+        if (fixedIps == null) fixedIps = new TreeSet<>();\n+        Set<String> subnetIds = hostIpSubnetIdsMap.get(internalPortEntity.getHostIp());\n+        if (subnetIds == null) subnetIds = new TreeSet<>();\n+        fixedIps.add(portIp);\n+        subnetIds.add(internalPortEntity.getSubnetId());\n+        hostIpFixedIpsMap.put(internalPortEntity.getHostIp(), fixedIps);\n+        hostIpSubnetIdsMap.put(internalPortEntity.getHostIp(), subnetIds);\n+        ipPortIdMap.put(portIp, internalPortEntity.getPortId());\n+        ipHostIpMap.put(portIp, internalPortEntity.getHostIp());\n+        ipSubnetIdMap.put(portIp, internalPortEntity.getSubnetId());\n+        ipMacMap.put(portIp, internalPortEntity.getPortMac());\n+      }\n+    }\n+  }\n+  /**\n+   * print dpm input msg\n+   *\n+   * @param networkConfiguration msg\n+   */\n+  private void printNetworkConfiguration(NetworkConfiguration networkConfiguration) {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    try {\n+      String json = objectMapper.writeValueAsString(networkConfiguration);\n+      LOG.log(Level.INFO, \"@@@input json str: \" + json);\n+\n+    } catch (JsonProcessingException e) {\n+      LOG.log(Level.SEVERE, e.getMessage());\n+    }\n   }\n   /**\n    * transform client of dpm msg to aca protobuf format\n    *\n-   * @param networkConfiguration  msg to be transformmed\n+   * @param networkConfiguration msg to be transformmed\n    * @return Map<String, Goalstate.GoalState>\n    * @throws RuntimeException Various exceptions that may occur during the send process\n    */\n-  public Map<String, Goalstate.GoalState> transformNorthToSouth(\n+  @Async\n+  public Future<Map<String, Goalstate.GoalState>> transformNorthToSouth(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDgwOA=="}, "originalCommit": {"oid": "1da6acb24b06f8a18cb677337909797b87719fb7"}, "originalPosition": 174}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0408f93078e3d461afba8110ff2ce48fffae1c5", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/e0408f93078e3d461afba8110ff2ce48fffae1c5", "committedDate": "2020-11-05T23:00:57Z", "message": "address points in #pr 418"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3ab1c2b48906e83cc53bdf6bac2883902bb8593", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/d3ab1c2b48906e83cc53bdf6bac2883902bb8593", "committedDate": "2020-11-05T23:04:31Z", "message": "fix build break for test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3acad5336cc16f1138203d5c88c9fb7fb85e3661", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/3acad5336cc16f1138203d5c88c9fb7fb85e3661", "committedDate": "2020-11-05T23:14:09Z", "message": "remove build break tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e1bd064a70c51c99d8ac7ad2ccd6bd7cc937ab", "author": {"user": {"login": "haboy52581", "name": null}}, "url": "https://github.com/futurewei-cloud/alcor/commit/63e1bd064a70c51c99d8ac7ad2ccd6bd7cc937ab", "committedDate": "2020-11-06T00:39:42Z", "message": "fix test build failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2168695a1ce9ccb8fe90cfa5b58024acd640a8b", "author": {"user": {"login": "xieus", "name": "Liguang Xie"}}, "url": "https://github.com/futurewei-cloud/alcor/commit/d2168695a1ce9ccb8fe90cfa5b58024acd640a8b", "committedDate": "2020-11-06T01:34:34Z", "message": "Fix compile issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTAzMTkw", "url": "https://github.com/futurewei-cloud/alcor/pull/418#pullrequestreview-526503190", "createdAt": "2020-11-09T17:47:16Z", "commit": {"oid": "d2168695a1ce9ccb8fe90cfa5b58024acd640a8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1985, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}