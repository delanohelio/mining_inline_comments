{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MDcwMzkw", "number": 1773, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoxMTozN1rOETci_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoxMjozMlrOETcj7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODI2MTA5OnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/LambdaAndTerminalTaskSpec.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoxMTozN1rOG5MD7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoxMTozN1rOG5MD7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxOTYzMA==", "bodyText": "Instead of checking for negation, can we explicitly check for expected state? In this case SKIPPED.", "url": "https://github.com/Netflix/conductor/pull/1773#discussion_r462619630", "createdAt": "2020-07-29T22:11:37Z", "author": {"login": "kishorebanala"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/LambdaAndTerminalTaskSpec.groovy", "diffHunk": "@@ -110,6 +119,62 @@ class LambdaAndTerminalTaskSpec extends Specification {\n         }\n     }\n \n+    def \"Test workflow with a terminate task when the workflow has a subworkflow\"() {\n+        given: \"workflow input\"\n+        def workflowInput = new HashMap()\n+        workflowInput['a'] = 1\n+\n+        when: \"Start the workflow which has the terminate task\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(PARENT_WORKFLOW_WITH_TERMINATE_TASK, 1,\n+                '', workflowInput, null, null, null)\n+\n+        then: \"verify that the workflow has started and the tasks are as expected\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 6\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'LAMBDA'\n+            tasks[1].referenceTaskName == 'lambdaTask1'\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'LAMBDA'\n+            tasks[2].referenceTaskName == 'lambdaTask2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].taskType == 'SUB_WORKFLOW'\n+            tasks[5].status == Task.Status.IN_PROGRESS\n+            tasks[5].taskType == 'WAIT'\n+        }\n+\n+        when: \"Complete the WAIT task that should cause the TERMINATE task to execute\"\n+        def waitTask = workflowExecutionService.getExecutionStatus(workflowInstanceId, true).tasks[5]\n+        waitTask.status = Task.Status.COMPLETED\n+        workflowExecutor.updateTask(new TaskResult(waitTask))\n+\n+        then:\"Verify that the workflow has completed and the SUB_WORKFLOW is not still IN_PROGRESS (should be SKIPPED)\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.COMPLETED\n+            tasks.size() == 7\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'LAMBDA'\n+            tasks[1].referenceTaskName == 'lambdaTask1'\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'LAMBDA'\n+            tasks[2].referenceTaskName == 'lambdaTask2'\n+            tasks[3].status != Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status != Task.Status.IN_PROGRESS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0126592a1381b3596b78168576d92dca8d49c999"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODI2MzUwOnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/LambdaAndTerminalTaskSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoxMjozMlrOG5MFWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMToxMDoxNVrOG5ekAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxOTk5NA==", "bodyText": "Shall we also verify that the Subworkflow is not IN_PROGRESS as mentioned in the test method name, to close the verifications loop.", "url": "https://github.com/Netflix/conductor/pull/1773#discussion_r462619994", "createdAt": "2020-07-29T22:12:32Z", "author": {"login": "kishorebanala"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/LambdaAndTerminalTaskSpec.groovy", "diffHunk": "@@ -110,6 +119,62 @@ class LambdaAndTerminalTaskSpec extends Specification {\n         }\n     }\n \n+    def \"Test workflow with a terminate task when the workflow has a subworkflow\"() {\n+        given: \"workflow input\"\n+        def workflowInput = new HashMap()\n+        workflowInput['a'] = 1\n+\n+        when: \"Start the workflow which has the terminate task\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(PARENT_WORKFLOW_WITH_TERMINATE_TASK, 1,\n+                '', workflowInput, null, null, null)\n+\n+        then: \"verify that the workflow has started and the tasks are as expected\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 6\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'LAMBDA'\n+            tasks[1].referenceTaskName == 'lambdaTask1'\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'LAMBDA'\n+            tasks[2].referenceTaskName == 'lambdaTask2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].taskType == 'SUB_WORKFLOW'\n+            tasks[5].status == Task.Status.IN_PROGRESS\n+            tasks[5].taskType == 'WAIT'\n+        }\n+\n+        when: \"Complete the WAIT task that should cause the TERMINATE task to execute\"\n+        def waitTask = workflowExecutionService.getExecutionStatus(workflowInstanceId, true).tasks[5]\n+        waitTask.status = Task.Status.COMPLETED\n+        workflowExecutor.updateTask(new TaskResult(waitTask))\n+\n+        then:\"Verify that the workflow has completed and the SUB_WORKFLOW is not still IN_PROGRESS (should be SKIPPED)\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.COMPLETED\n+            tasks.size() == 7\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'LAMBDA'\n+            tasks[1].referenceTaskName == 'lambdaTask1'\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'LAMBDA'\n+            tasks[2].referenceTaskName == 'lambdaTask2'\n+            tasks[3].status != Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status != Task.Status.IN_PROGRESS\n+            tasks[4].taskType == 'SUB_WORKFLOW'\n+            tasks[5].status == Task.Status.COMPLETED\n+            tasks[5].taskType == 'WAIT'\n+            tasks[6].status == Task.Status.COMPLETED\n+            tasks[6].taskType == 'TERMINATE'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0126592a1381b3596b78168576d92dca8d49c999"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMjc1Mw==", "bodyText": "@kishorebanala I made the changes  you recommended. In the case of SUB_WORKFLOW before the WAIT task is COMPLETED, I had to put an 'either SCHEDULED or IN_PROGRESS' because it depends on the timing of when it gets changed to IN_PROGRESS. If I do it locally in Swagger it is in IN_PROGRESS status but in the spock test it is SCHEDULED. I don't want to make the test case unreliable so I used the OR condition.", "url": "https://github.com/Netflix/conductor/pull/1773#discussion_r462922753", "createdAt": "2020-07-30T11:10:15Z", "author": {"login": "rickfish"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/LambdaAndTerminalTaskSpec.groovy", "diffHunk": "@@ -110,6 +119,62 @@ class LambdaAndTerminalTaskSpec extends Specification {\n         }\n     }\n \n+    def \"Test workflow with a terminate task when the workflow has a subworkflow\"() {\n+        given: \"workflow input\"\n+        def workflowInput = new HashMap()\n+        workflowInput['a'] = 1\n+\n+        when: \"Start the workflow which has the terminate task\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(PARENT_WORKFLOW_WITH_TERMINATE_TASK, 1,\n+                '', workflowInput, null, null, null)\n+\n+        then: \"verify that the workflow has started and the tasks are as expected\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 6\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'LAMBDA'\n+            tasks[1].referenceTaskName == 'lambdaTask1'\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'LAMBDA'\n+            tasks[2].referenceTaskName == 'lambdaTask2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].taskType == 'SUB_WORKFLOW'\n+            tasks[5].status == Task.Status.IN_PROGRESS\n+            tasks[5].taskType == 'WAIT'\n+        }\n+\n+        when: \"Complete the WAIT task that should cause the TERMINATE task to execute\"\n+        def waitTask = workflowExecutionService.getExecutionStatus(workflowInstanceId, true).tasks[5]\n+        waitTask.status = Task.Status.COMPLETED\n+        workflowExecutor.updateTask(new TaskResult(waitTask))\n+\n+        then:\"Verify that the workflow has completed and the SUB_WORKFLOW is not still IN_PROGRESS (should be SKIPPED)\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.COMPLETED\n+            tasks.size() == 7\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'LAMBDA'\n+            tasks[1].referenceTaskName == 'lambdaTask1'\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'LAMBDA'\n+            tasks[2].referenceTaskName == 'lambdaTask2'\n+            tasks[3].status != Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status != Task.Status.IN_PROGRESS\n+            tasks[4].taskType == 'SUB_WORKFLOW'\n+            tasks[5].status == Task.Status.COMPLETED\n+            tasks[5].taskType == 'WAIT'\n+            tasks[6].status == Task.Status.COMPLETED\n+            tasks[6].taskType == 'TERMINATE'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxOTk5NA=="}, "originalCommit": {"oid": "0126592a1381b3596b78168576d92dca8d49c999"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4221, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}