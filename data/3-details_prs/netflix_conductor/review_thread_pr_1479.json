{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDc5NjYw", "number": 1479, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMjoxMVrODYTbRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzoyOToxOVrODaAvlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODEwNjkzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowDef.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMjoxMVrOFeFikA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMjoxMVrOFeFikA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjM2OA==", "bodyText": "@apanicker-nflx , We need to return null in case all loopOver task execution completed. The issue was, it was returning the next task which was LAMBDA as per definition. Since we are returning null it won't change task reference name. LAMBDA task will be return when DO_WHILE task will get completed. And we have added safe guard not to change taskReferenceName in such case.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r367092368", "createdAt": "2020-01-15T20:32:11Z", "author": {"login": "manan164"}, "path": "common/src/main/java/com/netflix/conductor/common/metadata/workflow/WorkflowDef.java", "diffHunk": "@@ -241,6 +241,9 @@ public WorkflowTask getNextTask(String taskReferenceName){\n \t\t\t WorkflowTask nextTask = task.next(taskReferenceName, null);\n \t\t\t if(nextTask != null){\n \t\t\t\t return nextTask;\n+\t\t\t } else if (TaskType.DO_WHILE.name().equals(task.getType()) && !task.getTaskReferenceName().equals(taskReferenceName) && task.has(taskReferenceName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODExMDg0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMzo0M1rOFeFlBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMzo0M1rOFeFlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5Mjk5Ng==", "bodyText": "Since we have changed the way next task will be returned for last loopOver task we just need to check that in case of two sequential DO_WHILE task we should not change the task reference name of second DO_WHILE task when the first one gets completed.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r367092996", "createdAt": "2020-01-15T20:33:43Z", "author": {"login": "manan164"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/DeciderService.java", "diffHunk": "@@ -190,7 +190,7 @@ private DeciderOutcome decide(final Workflow workflow, List<Task> preScheduledTa\n             if (!pendingTask.isExecuted() && !pendingTask.isRetried() && pendingTask.getStatus().isTerminal()) {\n                 pendingTask.setExecuted(true);\n                 List<Task> nextTasks = getNextTask(workflow, pendingTask);\n-                if (pendingTask.isLoopOverTask() && !nextTasks.isEmpty()) {\n+                if (pendingTask.isLoopOverTask() && !TaskType.DO_WHILE.name().equals(pendingTask.getTaskType()) && !nextTasks.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODExMzk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/DoWhile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozNDo1NlrOFeFnCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozNDo1NlrOFeFnCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MzUxNA==", "bodyText": "In case of workflow having two DO_WHILE task we should not check for all workflow task which matches the current iteration. We should only wait for all children task to get completed.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r367093514", "createdAt": "2020-01-15T20:34:56Z", "author": {"login": "manan164"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/DoWhile.java", "diffHunk": "@@ -65,15 +66,15 @@ public boolean execute(Workflow workflow, Task task, WorkflowExecutor workflowEx\n \t\tStringBuilder failureReason = new StringBuilder();\n \t\tMap<String, Object> output = new HashMap<>();\n \t\ttask.getOutputData().put(\"iteration\", task.getIteration());\n-\t\tList<Task> loopOver = workflow.getTasks().stream().filter(t -> (t.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))) && t.isLoopOverTask()).collect(Collectors.toList());\n+\t\tList<Task> loopOver = workflow.getTasks().stream().filter(t -> (task.getWorkflowTask().has(TaskUtils.removeIterationFromTaskRefName(t.getReferenceTaskName())) && !task.getReferenceTaskName().equals(t.getReferenceTaskName()))).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODExNTk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/DoWhile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozNTozOFrOFeFoQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozNTozOFrOFeFoQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MzgyNA==", "bodyText": "This is just code refactoring to fill DO_WHILE task output map to preserver original taskReferneceName.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r367093824", "createdAt": "2020-01-15T20:35:38Z", "author": {"login": "manan164"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/DoWhile.java", "diffHunk": "@@ -65,15 +66,15 @@ public boolean execute(Workflow workflow, Task task, WorkflowExecutor workflowEx\n \t\tStringBuilder failureReason = new StringBuilder();\n \t\tMap<String, Object> output = new HashMap<>();\n \t\ttask.getOutputData().put(\"iteration\", task.getIteration());\n-\t\tList<Task> loopOver = workflow.getTasks().stream().filter(t -> (t.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))) && t.isLoopOverTask()).collect(Collectors.toList());\n+\t\tList<Task> loopOver = workflow.getTasks().stream().filter(t -> (task.getWorkflowTask().has(TaskUtils.removeIterationFromTaskRefName(t.getReferenceTaskName())) && !task.getReferenceTaskName().equals(t.getReferenceTaskName()))).collect(Collectors.toList());\n \n \t\tfor (Task loopOverTask : loopOver) {\n \t\t\tStatus taskStatus = loopOverTask.getStatus();\n \t\t\thasFailures = !taskStatus.isSuccessful();\n \t\t\tif (hasFailures) {\n \t\t\t\tfailureReason.append(loopOverTask.getReasonForIncompletion()).append(\" \");\n \t\t\t}\n-\t\t\toutput.put(loopOverTask.getReferenceTaskName(), loopOverTask.getOutputData());\n+\t\t\toutput.put(TaskUtils.removeIterationFromTaskRefName(loopOverTask.getReferenceTaskName()), loopOverTask.getOutputData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODExODE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/DoWhile.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozNjoyNVrOFeFpjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozNjoyNVrOFeFpjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5NDE1OA==", "bodyText": "Same as https://github.com/Netflix/conductor/pull/1479/files#r367092996. No need to fill the taskInput Map unnecessarily.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r367094158", "createdAt": "2020-01-15T20:36:25Z", "author": {"login": "manan164"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/DoWhile.java", "diffHunk": "@@ -129,10 +130,10 @@ boolean getEvaluatedCondition(Workflow workflow, Task task, WorkflowExecutor wor\n \t\tTaskDef taskDefinition = workflowExecutor.getTaskDefinition(task);\n \t\tMap<String, Object> taskInput = parametersUtils.getTaskInputV2(task.getWorkflowTask().getInputParameters(), workflow, task.getTaskId(), taskDefinition);\n \t\ttaskInput.put(task.getReferenceTaskName(), task.getOutputData());\n-\t\tList<Task> loopOver = workflow.getTasks().stream().filter(t -> (t.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))) && t.isLoopOverTask()).collect(Collectors.toList());\n+\t\tList<Task> loopOver = workflow.getTasks().stream().filter(t -> (task.getWorkflowTask().has(TaskUtils.removeIterationFromTaskRefName(t.getReferenceTaskName())) && !task.getReferenceTaskName().equals(t.getReferenceTaskName()))).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NjAxNDI3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/netflix/conductor/core/execution/tasks/DoWhileTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzoyNzo0NFrOFgukkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMDoyOToyN1rOFsyaWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MTc3OA==", "bodyText": "why was the task type removed?", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r369861778", "createdAt": "2020-01-22T23:27:44Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/test/java/com/netflix/conductor/core/execution/tasks/DoWhileTest.java", "diffHunk": "@@ -107,6 +107,7 @@ public void setup() {\n         loopTask.setIteration(1);\n         loopWorkflowTask = new WorkflowTask();\n         loopWorkflowTask.setTaskReferenceName(\"loopTask\");\n+        loopWorkflowTask.setType(TaskType.DO_WHILE.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjUwNzYwOQ==", "bodyText": "It was never added. The tests were running fine earlier because I was directly using DoWhile class. Now we need because I have changed the way loopOvertask is being calculated. Earlier the approach was find all the task which has taskReferenceName as ___iteration but now approach is the DO_WHILE task must has() that task.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r382507609", "createdAt": "2020-02-21T10:29:27Z", "author": {"login": "manan164"}, "path": "core/src/test/java/com/netflix/conductor/core/execution/tasks/DoWhileTest.java", "diffHunk": "@@ -107,6 +107,7 @@ public void setup() {\n         loopTask.setIteration(1);\n         loopWorkflowTask = new WorkflowTask();\n         loopWorkflowTask.setTaskReferenceName(\"loopTask\");\n+        loopWorkflowTask.setType(TaskType.DO_WHILE.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MTc3OA=="}, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NjAxNzQ5OnYy", "diffSide": "RIGHT", "path": "docs/docs/configuration/systask.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzoyOToxOVrOFgumbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMDoyMjo0MVrOFsyNvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MjI1Mg==", "bodyText": "Loopover task must not be reused in neither workflow nor another DO_WHILE task.\n\nPlease provide more details about this. Does this mean that if a task is used as a loopover task, it can be used again within the same workflow?", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r369862252", "createdAt": "2020-01-22T23:29:19Z", "author": {"login": "apanicker-nflx"}, "path": "docs/docs/configuration/systask.md", "diffHunk": "@@ -569,7 +569,7 @@ Each iteration of loop over task will be scheduled as taskRefname__iteration. It\n Do while task output number of iterations with iteration as key and value as number of iterations. Each iteration's output will be stored as, iteration as key and loopover task's output as value\n Taskname which contains arithmetic operator must not be used in loopCondition. Any of loopOver task can be reference outside do while task same way other tasks are referenced.\n To reference specific iteration's output, ```$.LoopTask['iteration]['first_task']```\n-Do while task does NOT support domain or isolation group execution.\n+Do while task does NOT support domain or isolation group execution. Nesting of DO_WHILE task is not supported. Loopover task must not be reused in neither workflow nor another DO_WHILE task.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjUwNDM4Mg==", "bodyText": "No. It must not be reused within the same workflow once the task is used as loopOver task.", "url": "https://github.com/Netflix/conductor/pull/1479#discussion_r382504382", "createdAt": "2020-02-21T10:22:41Z", "author": {"login": "manan164"}, "path": "docs/docs/configuration/systask.md", "diffHunk": "@@ -569,7 +569,7 @@ Each iteration of loop over task will be scheduled as taskRefname__iteration. It\n Do while task output number of iterations with iteration as key and value as number of iterations. Each iteration's output will be stored as, iteration as key and loopover task's output as value\n Taskname which contains arithmetic operator must not be used in loopCondition. Any of loopOver task can be reference outside do while task same way other tasks are referenced.\n To reference specific iteration's output, ```$.LoopTask['iteration]['first_task']```\n-Do while task does NOT support domain or isolation group execution.\n+Do while task does NOT support domain or isolation group execution. Nesting of DO_WHILE task is not supported. Loopover task must not be reused in neither workflow nor another DO_WHILE task.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MjI1Mg=="}, "originalCommit": {"oid": "d26e25d1efba6a42f543ec8603db46c2145d729c"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4236, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}