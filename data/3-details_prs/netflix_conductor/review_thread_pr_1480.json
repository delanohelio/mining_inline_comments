{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMTE0ODY1", "number": 1480, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxOToxODowOVrODWV9yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxOToxODowOVrODWV9yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NzU1MTQ2OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/com/netflix/conductor/client/automator/TaskPollExecutorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxOToxODowOVrOFbDJYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxOToyNzoyOVrOFbDYpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkwNzQyNw==", "bodyText": "Is it intentional to have two thenReturn statements?", "url": "https://github.com/Netflix/conductor/pull/1480#discussion_r363907427", "createdAt": "2020-01-07T19:18:09Z", "author": {"login": "kishorebanala"}, "path": "client/src/test/java/com/netflix/conductor/client/automator/TaskPollExecutorTest.java", "diffHunk": "@@ -166,14 +164,45 @@ public void testTaskPollException() {\n         Worker worker = mock(Worker.class);\n         when(worker.getPollingInterval()).thenReturn(3000);\n         when(worker.getTaskDefName()).thenReturn(\"test\");\n-        when(worker.preAck(any())).thenReturn(true);\n         when(worker.execute(any())).thenReturn(new TaskResult(task));\n \n         TaskClient taskClient = Mockito.mock(TaskClient.class);\n         when(taskClient.pollTask(any(), any(), any()))\n             .thenThrow(ConductorClientException.class)\n             .thenReturn(task);\n-        when(taskClient.ack(any(), any())).thenReturn(true);\n+\n+        TaskPollExecutor taskPollExecutor = new TaskPollExecutor(null, taskClient, 1, 1, \"test-worker-\");\n+        CountDownLatch latch = new CountDownLatch(1);\n+        doAnswer(invocation -> {\n+                Object[] args = invocation.getArguments();\n+                TaskResult result = (TaskResult) args[0];\n+                assertEquals(IN_PROGRESS, result.getStatus());\n+                assertEquals(task.getTaskId(), result.getTaskId());\n+                latch.countDown();\n+                return null;\n+            }\n+        ).when(taskClient).updateTask(any());\n+\n+        Executors.newSingleThreadScheduledExecutor()\n+            .scheduleAtFixedRate(() -> taskPollExecutor.pollAndExecute(worker), 0, 1, TimeUnit.SECONDS);\n+\n+        Uninterruptibles.awaitUninterruptibly(latch);\n+        verify(taskClient).updateTask(any());\n+    }\n+\n+    @Test\n+    public void testTaskPoll() {\n+        Task task = testTask();\n+\n+        Worker worker = mock(Worker.class);\n+        when(worker.getPollingInterval()).thenReturn(3000);\n+        when(worker.getTaskDefName()).thenReturn(\"test\");\n+        when(worker.execute(any())).thenReturn(new TaskResult(task));\n+\n+        TaskClient taskClient = Mockito.mock(TaskClient.class);\n+        when(taskClient.pollTask(any(), any(), any()))\n+            .thenReturn(new Task())\n+            .thenReturn(task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1ccb8cd28ee38c8110b7e7648be7d77e76de9b4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkxMTMzNQ==", "bodyText": "yes, these will be the values returned by this method on 2 consecutive invocations.", "url": "https://github.com/Netflix/conductor/pull/1480#discussion_r363911335", "createdAt": "2020-01-07T19:27:29Z", "author": {"login": "apanicker-nflx"}, "path": "client/src/test/java/com/netflix/conductor/client/automator/TaskPollExecutorTest.java", "diffHunk": "@@ -166,14 +164,45 @@ public void testTaskPollException() {\n         Worker worker = mock(Worker.class);\n         when(worker.getPollingInterval()).thenReturn(3000);\n         when(worker.getTaskDefName()).thenReturn(\"test\");\n-        when(worker.preAck(any())).thenReturn(true);\n         when(worker.execute(any())).thenReturn(new TaskResult(task));\n \n         TaskClient taskClient = Mockito.mock(TaskClient.class);\n         when(taskClient.pollTask(any(), any(), any()))\n             .thenThrow(ConductorClientException.class)\n             .thenReturn(task);\n-        when(taskClient.ack(any(), any())).thenReturn(true);\n+\n+        TaskPollExecutor taskPollExecutor = new TaskPollExecutor(null, taskClient, 1, 1, \"test-worker-\");\n+        CountDownLatch latch = new CountDownLatch(1);\n+        doAnswer(invocation -> {\n+                Object[] args = invocation.getArguments();\n+                TaskResult result = (TaskResult) args[0];\n+                assertEquals(IN_PROGRESS, result.getStatus());\n+                assertEquals(task.getTaskId(), result.getTaskId());\n+                latch.countDown();\n+                return null;\n+            }\n+        ).when(taskClient).updateTask(any());\n+\n+        Executors.newSingleThreadScheduledExecutor()\n+            .scheduleAtFixedRate(() -> taskPollExecutor.pollAndExecute(worker), 0, 1, TimeUnit.SECONDS);\n+\n+        Uninterruptibles.awaitUninterruptibly(latch);\n+        verify(taskClient).updateTask(any());\n+    }\n+\n+    @Test\n+    public void testTaskPoll() {\n+        Task task = testTask();\n+\n+        Worker worker = mock(Worker.class);\n+        when(worker.getPollingInterval()).thenReturn(3000);\n+        when(worker.getTaskDefName()).thenReturn(\"test\");\n+        when(worker.execute(any())).thenReturn(new TaskResult(task));\n+\n+        TaskClient taskClient = Mockito.mock(TaskClient.class);\n+        when(taskClient.pollTask(any(), any(), any()))\n+            .thenReturn(new Task())\n+            .thenReturn(task);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkwNzQyNw=="}, "originalCommit": {"oid": "b1ccb8cd28ee38c8110b7e7648be7d77e76de9b4"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4238, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}