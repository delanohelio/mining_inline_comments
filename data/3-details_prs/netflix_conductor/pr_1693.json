{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDc4MTYx", "number": 1693, "title": "added scenario based integration tests for DO_WHILE task", "bodyText": "", "createdAt": "2020-05-20T03:07:02Z", "url": "https://github.com/Netflix/conductor/pull/1693", "merged": true, "mergeCommit": {"oid": "91bb4df30755b393f0cb9806e9e1b9e8b2410723"}, "closed": true, "closedAt": "2020-05-21T13:42:47Z", "author": {"login": "apanicker-nflx"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjANsFgBqjMzNTQ1MTIzMTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjXfX7gBqjMzNTkzOTY5MjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9a2470ce750584a6788145d8cc5b8b30cef8901", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/b9a2470ce750584a6788145d8cc5b8b30cef8901", "committedDate": "2020-05-20T03:06:12Z", "message": "added scenario based integration tests for DO_WHILE task"}, "afterCommit": {"oid": "abbeca270b3f01c76e0441c3c36fcb690e392456", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/abbeca270b3f01c76e0441c3c36fcb690e392456", "committedDate": "2020-05-20T03:08:11Z", "message": "added scenario based integration tests for DO_WHILE task"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abbeca270b3f01c76e0441c3c36fcb690e392456", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/abbeca270b3f01c76e0441c3c36fcb690e392456", "committedDate": "2020-05-20T03:08:11Z", "message": "added scenario based integration tests for DO_WHILE task"}, "afterCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/a6bd8c2323da2475e12e40417bb268ec1847cd85", "committedDate": "2020-05-20T07:02:20Z", "message": "added scenario based integration tests for DO_WHILE task"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDAwNTg2", "url": "https://github.com/Netflix/conductor/pull/1693#pullrequestreview-415400586", "createdAt": "2020-05-20T14:33:30Z", "commit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozMzozMFrOGYO2QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo1Mjo0MlrOGYPxVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2MjI3Mg==", "bodyText": "nit: use intuitive variable names. Instead of using generic variable name task, something like task0 or integrationTask0 will be me more readable", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428062272", "createdAt": "2020-05-20T14:33:30Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2NjYzOA==", "bodyText": "There are couple of methods in the WorkflowTestUtil which take care of repetitive steps during the test:\n\nPoll and Complete Task : Tuple pollAndCompleteTask(String taskName, String workerId, Map<String, String> outputParams, int waitAtEndSeconds) {\nPoll and Fail Task  : Tuple pollAndFailTask(String taskName, String workerId, String failureReason, int waitAtEndSeconds) {\nVerify weather a Task was polled and acknowledged: static void verifyPolledAndAcknowledgedTask(Map<String, String> expectedTaskInputParams, Tuple completedTaskAndAck) {\n\ntry to reuse them wherever possible, this helps reuse and makes test code readable.", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428066638", "createdAt": "2020-05-20T14:39:13Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MDYwNw==", "bodyText": "Define new variables instead reassigning new values to existing variables, in this case task. Defining new variables is cheap and improves readability in each given -  when -then", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428070607", "createdAt": "2020-05-20T14:44:18Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MzQ3OQ==", "bodyText": "nit: Validate the contents of the task[] to to verify that previous performed task completion has an affect and as a result the next task in schedule state.", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428073479", "createdAt": "2020-05-20T14:47:53Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3NzM5Ng==", "bodyText": "nit: getting the workflow state in the when can be moved to then and assigning of the variable can be skipped by leveraging the with:\nthen:\nwith(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)){\n  status == Workflow.WorkflowStatus.RUNNING\n  tasks.size() == 6\n  tasks[1].taskType == 'integration_task_0'\n  tasks[1].status == Task.Status.COMPLETED\n}", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428077396", "createdAt": "2020-05-20T14:52:42Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for third task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_2\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is completed\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.COMPLETED\n+        workflow.tasks.size() == 6\n+    }\n+\n+    def \"Test workflow with multiple Do While tasks with multiple iterations\"() {\n+        given: \"Number of iterations of the first loop is set to 2 and second loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 2\n+        workflowInput['loop2'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Multiple\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 158}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/a6bd8c2323da2475e12e40417bb268ec1847cd85", "committedDate": "2020-05-20T07:02:20Z", "message": "added scenario based integration tests for DO_WHILE task"}, "afterCommit": {"oid": "1225556b1af44ef6a54a757b444bfb8a41ef0c98", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/1225556b1af44ef6a54a757b444bfb8a41ef0c98", "committedDate": "2020-05-21T06:01:18Z", "message": "added scenario based integration tests for DO_WHILE task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acd91fd4838d09042506c2063923bb465a034472", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/acd91fd4838d09042506c2063923bb465a034472", "committedDate": "2020-05-21T06:15:20Z", "message": "added scenario based integration tests for DO_WHILE task"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1225556b1af44ef6a54a757b444bfb8a41ef0c98", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/1225556b1af44ef6a54a757b444bfb8a41ef0c98", "committedDate": "2020-05-21T06:01:18Z", "message": "added scenario based integration tests for DO_WHILE task"}, "afterCommit": {"oid": "acd91fd4838d09042506c2063923bb465a034472", "author": {"user": {"login": "rickfish", "name": null}}, "url": "https://github.com/Netflix/conductor/commit/acd91fd4838d09042506c2063923bb465a034472", "committedDate": "2020-05-21T06:15:20Z", "message": "added scenario based integration tests for DO_WHILE task"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 794, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}