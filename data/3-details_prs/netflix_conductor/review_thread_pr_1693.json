{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDc4MTYx", "number": 1693, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozMzozMFrOD-P6Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo1Mjo0MlrOD-Qdqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NTk4OTQzOnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozMzozMFrOGYO2QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjowMjo0OFrOGYnOZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2MjI3Mg==", "bodyText": "nit: use intuitive variable names. Instead of using generic variable name task, something like task0 or integrationTask0 will be me more readable", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428062272", "createdAt": "2020-05-20T14:33:30Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTY3MA==", "bodyText": "fixed", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461670", "createdAt": "2020-05-21T06:02:48Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2MjI3Mg=="}, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjAxNjY3OnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDozOToxM1rOGYPHTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjowMjo1OVrOGYnOlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2NjYzOA==", "bodyText": "There are couple of methods in the WorkflowTestUtil which take care of repetitive steps during the test:\n\nPoll and Complete Task : Tuple pollAndCompleteTask(String taskName, String workerId, Map<String, String> outputParams, int waitAtEndSeconds) {\nPoll and Fail Task  : Tuple pollAndFailTask(String taskName, String workerId, String failureReason, int waitAtEndSeconds) {\nVerify weather a Task was polled and acknowledged: static void verifyPolledAndAcknowledgedTask(Map<String, String> expectedTaskInputParams, Tuple completedTaskAndAck) {\n\ntry to reuse them wherever possible, this helps reuse and makes test code readable.", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428066638", "createdAt": "2020-05-20T14:39:13Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTcxNg==", "bodyText": "refactored", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461716", "createdAt": "2020-05-21T06:02:59Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2NjYzOA=="}, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjA0MDU0OnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0NDoxOFrOGYPWzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjowMzowOVrOGYnOvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MDYwNw==", "bodyText": "Define new variables instead reassigning new values to existing variables, in this case task. Defining new variables is cheap and improves readability in each given -  when -then", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428070607", "createdAt": "2020-05-20T14:44:18Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTc1OA==", "bodyText": "fixed", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461758", "createdAt": "2020-05-21T06:03:09Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MDYwNw=="}, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjA1Nzg0OnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo0Nzo1M1rOGYPiBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjowMzoxNlrOGYnO6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MzQ3OQ==", "bodyText": "nit: Validate the contents of the task[] to to verify that previous performed task completion has an affect and as a result the next task in schedule state.", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428073479", "createdAt": "2020-05-20T14:47:53Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTgwMA==", "bodyText": "validated", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461800", "createdAt": "2020-05-21T06:03:16Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MzQ3OQ=="}, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjA4MDQzOnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNDo1Mjo0MlrOGYPxVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNjowMjoxOFrOGYnN1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3NzM5Ng==", "bodyText": "nit: getting the workflow state in the when can be moved to then and assigning of the variable can be skipped by leveraging the with:\nthen:\nwith(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)){\n  status == Workflow.WorkflowStatus.RUNNING\n  tasks.size() == 6\n  tasks[1].taskType == 'integration_task_0'\n  tasks[1].status == Task.Status.COMPLETED\n}", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428077396", "createdAt": "2020-05-20T14:52:42Z", "author": {"login": "pctreddy"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for third task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_2\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is completed\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.COMPLETED\n+        workflow.tasks.size() == 6\n+    }\n+\n+    def \"Test workflow with multiple Do While tasks with multiple iterations\"() {\n+        given: \"Number of iterations of the first loop is set to 2 and second loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 2\n+        workflowInput['loop2'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Multiple\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTUyNQ==", "bodyText": "refactored", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461525", "createdAt": "2020-05-21T06:02:18Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for third task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_2\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is completed\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.COMPLETED\n+        workflow.tasks.size() == 6\n+    }\n+\n+    def \"Test workflow with multiple Do While tasks with multiple iterations\"() {\n+        given: \"Number of iterations of the first loop is set to 2 and second loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 2\n+        workflowInput['loop2'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Multiple\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3NzM5Ng=="}, "originalCommit": {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85"}, "originalPosition": 158}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4199, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}