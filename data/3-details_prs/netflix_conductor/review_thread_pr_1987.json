{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5MDM1NTgy", "number": 1987, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMDo0OToxNlrOE-5ycQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMDo0OToxNlrOE-5ycQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzkzOTY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/events/queue/EventPollSchedulerProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMDo0OToxNlrOH8Tu3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMTozMjo0MlrOH9AmTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk5OTkwMQ==", "bodyText": "@mdepak Based on the documentation here, http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html#computation--\n\nDo not perform IO-bound work on this scheduler. Use io() instead.\n\nand the fact that IO needs to be performed as seen here\nDoes it make sense to use io() instead here?", "url": "https://github.com/Netflix/conductor/pull/1987#discussion_r532999901", "createdAt": "2020-12-01T00:49:16Z", "author": {"login": "aravindanr"}, "path": "core/src/main/java/com/netflix/conductor/core/events/queue/EventPollSchedulerProvider.java", "diffHunk": "@@ -37,11 +37,14 @@ public EventPollSchedulerProvider(Configuration configuration) {\n \n     @Override\n     public Scheduler get() {\n-        ThreadFactory threadFactory = new ThreadFactoryBuilder()\n-                .setNameFormat(\"event-queue-poll-scheduler-thread-%d\")\n-                .build();\n-        Executor executorService = Executors.newFixedThreadPool(configuration.getEventSchedulerPollThreadCount(), threadFactory);\n-\n-        return Schedulers.from(executorService);\n+        if (configuration.getEventSchedulerPollThreadCount() != null) {\n+            ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"event-queue-poll-scheduler-thread-%d\")\n+                    .build();\n+            Executor executorService = Executors.newFixedThreadPool(configuration.getEventSchedulerPollThreadCount(), threadFactory);\n+            return Schedulers.from(executorService);\n+        } else {\n+            return Schedulers.computation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eb149f0317a36cc2260754009405fc751625d8b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczNDk5MA==", "bodyText": "@aravindanr  io() is a good candidate but the potential problem with this is it can grow the thread pool exponentially in case the IO wait is taking too long because of a problem with the Queue system and could cause OOM. RxJava 2.x doc has a more detailed explanation regarding the same http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/schedulers/Schedulers.html#io--\nThe objective of this fix is to ensure that the event processing functionality works as expected by default without tuning up the thread pool size. Meanwhile, I plan to debug why Executor scheduler is not working as expected, and its behavior in the later versions of RxJava. Please let me know your feedback.", "url": "https://github.com/Netflix/conductor/pull/1987#discussion_r533734990", "createdAt": "2020-12-01T21:32:42Z", "author": {"login": "mdepak"}, "path": "core/src/main/java/com/netflix/conductor/core/events/queue/EventPollSchedulerProvider.java", "diffHunk": "@@ -37,11 +37,14 @@ public EventPollSchedulerProvider(Configuration configuration) {\n \n     @Override\n     public Scheduler get() {\n-        ThreadFactory threadFactory = new ThreadFactoryBuilder()\n-                .setNameFormat(\"event-queue-poll-scheduler-thread-%d\")\n-                .build();\n-        Executor executorService = Executors.newFixedThreadPool(configuration.getEventSchedulerPollThreadCount(), threadFactory);\n-\n-        return Schedulers.from(executorService);\n+        if (configuration.getEventSchedulerPollThreadCount() != null) {\n+            ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+                    .setNameFormat(\"event-queue-poll-scheduler-thread-%d\")\n+                    .build();\n+            Executor executorService = Executors.newFixedThreadPool(configuration.getEventSchedulerPollThreadCount(), threadFactory);\n+            return Schedulers.from(executorService);\n+        } else {\n+            return Schedulers.computation();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk5OTkwMQ=="}, "originalCommit": {"oid": "7eb149f0317a36cc2260754009405fc751625d8b"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4146, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}