{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1ODY1NTQw", "number": 1900, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDoyOTo0M1rOEpQJaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNDoxNjoyNVrOEs29Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjkxNjI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SubWorkflow.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDoyOTo0M1rOHa0C4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDoyOTo0M1rOHa0C4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg3NzczMQ==", "bodyText": "do you also want to set the failure reason on the task here?", "url": "https://github.com/Netflix/conductor/pull/1900#discussion_r497877731", "createdAt": "2020-10-01T00:29:43Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SubWorkflow.java", "diffHunk": "@@ -185,9 +185,11 @@ private void updateTaskStatus(WorkflowStatus status, Task task) {\n \t\t\t\ttask.setStatus(Status.COMPLETED);\n \t\t\t\tbreak;\n \t\t\tcase FAILED:\n-\t\t\tcase TERMINATED:\n \t\t\t\ttask.setStatus(Status.FAILED);\n \t\t\t\tbreak;\n+\t\t\tcase TERMINATED:\n+\t\t\t\ttask.setStatus(Status.CANCELED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89ee5710bd486001943e3d1bf2b6b72c6514a4c8"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjk1OTY0OnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/groovy/com/netflix/conductor/test/integration/SubWorkflowSpec.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwMDo0MTowMlrOHa0fpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQxNDozMjozMFrOHfn_5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg4NTA5NQ==", "bodyText": "For consistency, use the with(...) semantics across the test. Lot of the boilerplate code in the then: sections below can be cleaned up with this usage.", "url": "https://github.com/Netflix/conductor/pull/1900#discussion_r497885095", "createdAt": "2020-10-01T00:41:02Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/groovy/com/netflix/conductor/test/integration/SubWorkflowSpec.groovy", "diffHunk": "@@ -228,4 +228,90 @@ class SubWorkflowSpec extends Specification {\n         cleanup: \"Ensure that the changes to the workflow def are reverted\"\n         metadataService.updateWorkflowDef([persistedWorkflowDefinition])\n     }\n+\n+    def \"Test terminating a subworkflow terminates parent workflow\"() {\n+        given: \"Existing workflow and subworkflow definitions\"\n+        metadataService.getWorkflowDef(SUB_WORKFLOW, 1)\n+        metadataService.getWorkflowDef(WORKFLOW_WITH_SUBWORKFLOW, 1)\n+\n+        and: \"input required to start the workflow execution\"\n+        String correlationId = 'wf_with_subwf_test_1'\n+        def input = new HashMap()\n+        String inputParam1 = 'p1 value'\n+        input['param1'] = inputParam1\n+        input['param2'] = 'p2 value'\n+\n+        when: \"Start a workflow with subworkflow based on the registered definition\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(WORKFLOW_WITH_SUBWORKFLOW, 1,\n+                correlationId, input,\n+                null, null, null)\n+\n+        then: \"verify that the workflow is in a running state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Polled for integration_task_1 task\"\n+        def pollAndCompleteTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_1', 'task1.integration.worker', ['op': 'task1.done'])\n+\n+        then: \"verify that the 'integration_task_1' was polled and acknowledged\"\n+        verifyPolledAndAcknowledgedTask(pollAndCompleteTask1Try1)\n+\n+        and: \"verify that the 'integration_task1' is complete and the next task (subworkflow) is in scheduled state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 2\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'SUB_WORKFLOW'\n+            tasks[1].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Polled for and executed subworkflow task\"\n+        List<String> polledTaskIds = queueDAO.pop(\"SUB_WORKFLOW\", 1, 200);\n+        WorkflowSystemTask systemTask = SystemTaskWorkerCoordinator.taskNameWorkflowTaskMapping.get(\"SUB_WORKFLOW\")\n+        workflowExecutor.executeSystemTask(systemTask, polledTaskIds.get(0), 30)\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"verify that the 'sub_workflow_task' is polled and IN_PROGRESS\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89ee5710bd486001943e3d1bf2b6b72c6514a4c8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkyMzIzNg==", "bodyText": "done.", "url": "https://github.com/Netflix/conductor/pull/1900#discussion_r502923236", "createdAt": "2020-10-11T14:32:30Z", "author": {"login": "kishorebanala"}, "path": "test-harness/src/test/groovy/com/netflix/conductor/test/integration/SubWorkflowSpec.groovy", "diffHunk": "@@ -228,4 +228,90 @@ class SubWorkflowSpec extends Specification {\n         cleanup: \"Ensure that the changes to the workflow def are reverted\"\n         metadataService.updateWorkflowDef([persistedWorkflowDefinition])\n     }\n+\n+    def \"Test terminating a subworkflow terminates parent workflow\"() {\n+        given: \"Existing workflow and subworkflow definitions\"\n+        metadataService.getWorkflowDef(SUB_WORKFLOW, 1)\n+        metadataService.getWorkflowDef(WORKFLOW_WITH_SUBWORKFLOW, 1)\n+\n+        and: \"input required to start the workflow execution\"\n+        String correlationId = 'wf_with_subwf_test_1'\n+        def input = new HashMap()\n+        String inputParam1 = 'p1 value'\n+        input['param1'] = inputParam1\n+        input['param2'] = 'p2 value'\n+\n+        when: \"Start a workflow with subworkflow based on the registered definition\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(WORKFLOW_WITH_SUBWORKFLOW, 1,\n+                correlationId, input,\n+                null, null, null)\n+\n+        then: \"verify that the workflow is in a running state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Polled for integration_task_1 task\"\n+        def pollAndCompleteTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_1', 'task1.integration.worker', ['op': 'task1.done'])\n+\n+        then: \"verify that the 'integration_task_1' was polled and acknowledged\"\n+        verifyPolledAndAcknowledgedTask(pollAndCompleteTask1Try1)\n+\n+        and: \"verify that the 'integration_task1' is complete and the next task (subworkflow) is in scheduled state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 2\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'SUB_WORKFLOW'\n+            tasks[1].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Polled for and executed subworkflow task\"\n+        List<String> polledTaskIds = queueDAO.pop(\"SUB_WORKFLOW\", 1, 200);\n+        WorkflowSystemTask systemTask = SystemTaskWorkerCoordinator.taskNameWorkflowTaskMapping.get(\"SUB_WORKFLOW\")\n+        workflowExecutor.executeSystemTask(systemTask, polledTaskIds.get(0), 30)\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"verify that the 'sub_workflow_task' is polled and IN_PROGRESS\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg4NTA5NQ=="}, "originalCommit": {"oid": "89ee5710bd486001943e3d1bf2b6b72c6514a4c8"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDczMjQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SubWorkflow.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNDoxNjoyNVrOHgUzOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODo0NTo1MVrOHg0uZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY1NzI3NA==", "bodyText": "This seems redundant to lines 188 and 192 above.", "url": "https://github.com/Netflix/conductor/pull/1900#discussion_r503657274", "createdAt": "2020-10-13T04:16:25Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SubWorkflow.java", "diffHunk": "@@ -185,14 +184,22 @@ private void updateTaskStatus(WorkflowStatus status, Task task) {\n \t\t\t\ttask.setStatus(Status.COMPLETED);\n \t\t\t\tbreak;\n \t\t\tcase FAILED:\n-\t\t\tcase TERMINATED:\n \t\t\t\ttask.setStatus(Status.FAILED);\n+\t\t\t\ttask.setReasonForIncompletion(subworkflow.getReasonForIncompletion());\n+\t\t\t\tbreak;\n+\t\t\tcase TERMINATED:\n+\t\t\t\ttask.setStatus(Status.CANCELED);\n+\t\t\t\ttask.setReasonForIncompletion(subworkflow.getReasonForIncompletion());\n \t\t\t\tbreak;\n \t\t\tcase TIMED_OUT:\n \t\t\t\ttask.setStatus(Status.TIMED_OUT);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tthrow new ApplicationException(ApplicationException.Code.INTERNAL_ERROR, \"Subworkflow status does not conform to relevant task status.\");\n \t\t}\n+\n+\t\tif (status.isTerminal() && !status.isSuccessful()) {\n+\t\t\ttask.setReasonForIncompletion(subworkflow.getReasonForIncompletion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0896f69d151d00f04fc3113807207a30a089cfa1"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE4MDMyNw==", "bodyText": "You're right, thanks for pointing. Cleaned up.", "url": "https://github.com/Netflix/conductor/pull/1900#discussion_r504180327", "createdAt": "2020-10-13T18:45:51Z", "author": {"login": "kishorebanala"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SubWorkflow.java", "diffHunk": "@@ -185,14 +184,22 @@ private void updateTaskStatus(WorkflowStatus status, Task task) {\n \t\t\t\ttask.setStatus(Status.COMPLETED);\n \t\t\t\tbreak;\n \t\t\tcase FAILED:\n-\t\t\tcase TERMINATED:\n \t\t\t\ttask.setStatus(Status.FAILED);\n+\t\t\t\ttask.setReasonForIncompletion(subworkflow.getReasonForIncompletion());\n+\t\t\t\tbreak;\n+\t\t\tcase TERMINATED:\n+\t\t\t\ttask.setStatus(Status.CANCELED);\n+\t\t\t\ttask.setReasonForIncompletion(subworkflow.getReasonForIncompletion());\n \t\t\t\tbreak;\n \t\t\tcase TIMED_OUT:\n \t\t\t\ttask.setStatus(Status.TIMED_OUT);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tthrow new ApplicationException(ApplicationException.Code.INTERNAL_ERROR, \"Subworkflow status does not conform to relevant task status.\");\n \t\t}\n+\n+\t\tif (status.isTerminal() && !status.isSuccessful()) {\n+\t\t\ttask.setReasonForIncompletion(subworkflow.getReasonForIncompletion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY1NzI3NA=="}, "originalCommit": {"oid": "0896f69d151d00f04fc3113807207a30a089cfa1"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4129, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}