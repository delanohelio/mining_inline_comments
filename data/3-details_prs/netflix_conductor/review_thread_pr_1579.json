{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTUzMDQz", "number": 1579, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMDozNToxOFrODn99fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMDo0MDo0NFrODn-GlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjM2MjIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMDozNToxOFrOF2RvXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMToxNTozNVrOF2TNXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ1ODA3Ng==", "bodyText": "It'd be nice to have a metric for this too, which helps in tracing poll failures due to db operations and find out before the clients notice poll delays.", "url": "https://github.com/Netflix/conductor/pull/1579#discussion_r392458076", "createdAt": "2020-03-13T20:35:18Z", "author": {"login": "kishorebanala"}, "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "diffHunk": "@@ -151,13 +159,14 @@ public Task poll(String taskType, String workerId, String domain) {\n \t\t\t\ttask.setPollCount(task.getPollCount() + 1);\n \t\t\t\texecutionDAOFacade.updateTask(task);\n \t\t\t\ttasks.add(task);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// db operation failed for dequeued message, re-enqueue with a delay\n+\t\t\t\tlogger.warn(\"DB operation failed for task: {}, postponing task in queue\", taskId, e);\n+\t\t\t\tqueueDAO.postpone(queueName, taskId, 0, queueTaskMessagePostponeSeconds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58061df3b9c5232238ed2041b5a2e12e08a79ff"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ4MjE0Mg==", "bodyText": "Good idea on the metric, will add.", "url": "https://github.com/Netflix/conductor/pull/1579#discussion_r392482142", "createdAt": "2020-03-13T21:15:35Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "diffHunk": "@@ -151,13 +159,14 @@ public Task poll(String taskType, String workerId, String domain) {\n \t\t\t\ttask.setPollCount(task.getPollCount() + 1);\n \t\t\t\texecutionDAOFacade.updateTask(task);\n \t\t\t\ttasks.add(task);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// db operation failed for dequeued message, re-enqueue with a delay\n+\t\t\t\tlogger.warn(\"DB operation failed for task: {}, postponing task in queue\", taskId, e);\n+\t\t\t\tqueueDAO.postpone(queueName, taskId, 0, queueTaskMessagePostponeSeconds);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ1ODA3Ng=="}, "originalCommit": {"oid": "a58061df3b9c5232238ed2041b5a2e12e08a79ff"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjM4NTQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMDo0MDo0NFrOF2R9cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMToxMDo0NFrOF2TB2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2MTY4Mg==", "bodyText": "How about surfacing this exception to client? Also, should we update updateTaskLastPoll if the pop fails?", "url": "https://github.com/Netflix/conductor/pull/1579#discussion_r392461682", "createdAt": "2020-03-13T20:40:44Z", "author": {"login": "kishorebanala"}, "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "diffHunk": "@@ -123,10 +123,18 @@ public Task poll(String taskType, String workerId, String domain) {\n \t\t}\n \t\tString queueName = QueueUtils.getQueueName(taskType, domain, null,null);\n \n+\t\tList<String> taskIds = new LinkedList<>();\n \t\tList<Task> tasks = new LinkedList<>();\n \t\ttry {\n-\t\t\tList<String> taskIds = queueDAO.pop(queueName, count, timeoutInMilliSecond);\n-\t\t\tfor (String taskId : taskIds) {\n+\t\t\ttaskIds = queueDAO.pop(queueName, count, timeoutInMilliSecond);\n+\t\t} catch (Exception e) {\n+\t\t\tlogger.error(\"Error polling for task: {} from worker: {} in domain: {}, count: {}\", taskType, workerId,\n+\t\t\t\tdomain, count, e);\n+\t\t\tMonitors.error(this.getClass().getCanonicalName(), \"taskPoll\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58061df3b9c5232238ed2041b5a2e12e08a79ff"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ3ODMxNg==", "bodyText": "Yes, this helps to track polling from workers irrespective of whether a task was returned in the poll.", "url": "https://github.com/Netflix/conductor/pull/1579#discussion_r392478316", "createdAt": "2020-03-13T21:09:14Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "diffHunk": "@@ -123,10 +123,18 @@ public Task poll(String taskType, String workerId, String domain) {\n \t\t}\n \t\tString queueName = QueueUtils.getQueueName(taskType, domain, null,null);\n \n+\t\tList<String> taskIds = new LinkedList<>();\n \t\tList<Task> tasks = new LinkedList<>();\n \t\ttry {\n-\t\t\tList<String> taskIds = queueDAO.pop(queueName, count, timeoutInMilliSecond);\n-\t\t\tfor (String taskId : taskIds) {\n+\t\t\ttaskIds = queueDAO.pop(queueName, count, timeoutInMilliSecond);\n+\t\t} catch (Exception e) {\n+\t\t\tlogger.error(\"Error polling for task: {} from worker: {} in domain: {}, count: {}\", taskType, workerId,\n+\t\t\t\tdomain, count, e);\n+\t\t\tMonitors.error(this.getClass().getCanonicalName(), \"taskPoll\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2MTY4Mg=="}, "originalCommit": {"oid": "a58061df3b9c5232238ed2041b5a2e12e08a79ff"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ3OTE5NA==", "bodyText": "This exception was not surfaced to the client in the previous implementation either. Since polling is a highly-frequent activity, it would clutter up client-side logs in case of a temporary dependency glitch on server-side.", "url": "https://github.com/Netflix/conductor/pull/1579#discussion_r392479194", "createdAt": "2020-03-13T21:10:44Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/service/ExecutionService.java", "diffHunk": "@@ -123,10 +123,18 @@ public Task poll(String taskType, String workerId, String domain) {\n \t\t}\n \t\tString queueName = QueueUtils.getQueueName(taskType, domain, null,null);\n \n+\t\tList<String> taskIds = new LinkedList<>();\n \t\tList<Task> tasks = new LinkedList<>();\n \t\ttry {\n-\t\t\tList<String> taskIds = queueDAO.pop(queueName, count, timeoutInMilliSecond);\n-\t\t\tfor (String taskId : taskIds) {\n+\t\t\ttaskIds = queueDAO.pop(queueName, count, timeoutInMilliSecond);\n+\t\t} catch (Exception e) {\n+\t\t\tlogger.error(\"Error polling for task: {} from worker: {} in domain: {}, count: {}\", taskType, workerId,\n+\t\t\t\tdomain, count, e);\n+\t\t\tMonitors.error(this.getClass().getCanonicalName(), \"taskPoll\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2MTY4Mg=="}, "originalCommit": {"oid": "a58061df3b9c5232238ed2041b5a2e12e08a79ff"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4258, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}