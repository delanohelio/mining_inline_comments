{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NzUxMzY3", "number": 1608, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMTo1NTozMFrODuLjGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozOTozMVrOEM0fXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzUwMjk2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMTo1NTozMFrOGACf-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDo0ODoxOFrOGFl73g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA==", "bodyText": "In the case of sub workflows, would it be better to terminate the sub workflow instead? The reason could be that the parent workflow was terminated using TERMINATE task.", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r402694138", "createdAt": "2020-04-03T01:55:30Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,6 +987,26 @@ public boolean decide(String workflowId) {\n                                 workflow.setStatus(workflowInstance.getStatus());\n                                 workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a180038382566254439838054500c1a9439d63f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2Njk4OA==", "bodyText": "There are a couple of issues that make terminating the subworkflows problematic (I think). Firstly, I think if the terminate task specifies COMPLETED as the terminationStatus and the subworkflow is terminated, the termination of the subworkflow would actually cause the ultimate status of the parent workflow to be FAILED which wouldn't honor the contract of the terminate task.\nAlso, I tried the below code and there is a StackOverflowError because WorkflowExecutor.decide() would call terminateWorkflow() which would call decide() to terminate the parent workflow, etc.\nif (TERMINATE.name().equals(task.getTaskType())) {\n\tworkflow.setStatus(workflowInstance.getStatus());\n\tworkflow.setOutput(workflowInstance.getOutput());\n\tdeciderService.externalizeWorkflowData(workflow);\n\t/*\n\t * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n\t */\n\tfor(Task workflowTask : workflow.getTasks()) {\n\t\tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n\t\t\tworkflowTask.setStatus(SKIPPED);\n\t\t\ttasksToBeUpdated.add(workflowTask);\n\t\t}\n\t}\n\t/*\n\t * Now find nested subworkflows that also need to have their tasks skipped\n\t */\n\tfor(Task workflowTask : workflow.getTasks()) {\n\t\tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n\t\t\tterminateWorkflow(workflowTask.getSubWorkflowId(), \"Parent workflow was terminated with a TERMINATE task\");\n\t\t/*                                \t\t\n\t\t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n\t\t\tif(subWorkflow != null) {\n\t\t\t\tskipTasksAffectedByTerminateTask(subWorkflow);                                \t\t\n\t\t\t}\n\t\t*/                                \t\t\n\t\t}\n\t}\n}\n\n\nThat said, I could probably make it work but that would involve a lot of changes that might create unforeseen problems elsewhere.\nWhat are your thoughts?", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r402966988", "createdAt": "2020-04-03T12:24:02Z", "author": {"login": "rickfish"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,6 +987,26 @@ public boolean decide(String workflowId) {\n                                 workflow.setStatus(workflowInstance.getStatus());\n                                 workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA=="}, "originalCommit": {"oid": "7a180038382566254439838054500c1a9439d63f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNzU5OA==", "bodyText": "f the terminate task specifies COMPLETED as the terminationStatus and the subworkflow is terminated, the termination of the subworkflow would actually cause the ultimate status of the parent workflow to be FAILED\n\nThis observation is correct. Agreed with the reasoning and implementation.", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408517598", "createdAt": "2020-04-15T00:48:18Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,6 +987,26 @@ public boolean decide(String workflowId) {\n                                 workflow.setStatus(workflowInstance.getStatus());\n                                 workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA=="}, "originalCommit": {"oid": "7a180038382566254439838054500c1a9439d63f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjIxNzEyOnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDo0MTo1OFrOGFl1OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNToyMjozMVrOGF_AEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng==", "bodyText": "Since this is a workflow with wait task, this method can be named createWorkflowWithWaitTask() for better clarity.", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408515896", "createdAt": "2020-04-15T00:41:58Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5272,64 +5274,43 @@ public void testLambda() {\n \n     @Test\n     public void testTerminateTaskWithCompletedStatus() {\n-        WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_terminate_task_wf\");\n-        workflowDef.setSchemaVersion(2);\n-\n-        Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n-        lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n-        lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n+    \ttestTerminateTask(WorkflowStatus.COMPLETED);\n+    }\n \n-        WorkflowTask lambdaWorkflowTask = new WorkflowTask();\n-        lambdaWorkflowTask.setWorkflowTaskType(TaskType.LAMBDA);\n-        lambdaWorkflowTask.setName(\"lambda\");\n-        lambdaWorkflowTask.setInputParameters(lambdaTaskInputParams);\n-        lambdaWorkflowTask.setTaskReferenceName(\"lambda0\");\n+    @Test\n+    public void testTerminateTaskWithFailedStatus() {\n+    \ttestTerminateTask(WorkflowStatus.FAILED);\n+    }\n \n-        Map<String, Object> terminateTaskInputParams = new HashMap<>();\n-        terminateTaskInputParams.put(Terminate.getTerminationStatusParameter(), \"COMPLETED\");\n-        terminateTaskInputParams.put(Terminate.getTerminationWorkflowOutputParameter(), \"${lambda0.output}\");\n+    private WorkflowDef createSubworkflowDefWithWaitTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxODE0NQ==", "bodyText": "Also, please add another task after the wait task in this workflow, and check that this task is not scheduled when parent workflow is completed using terminate.", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408518145", "createdAt": "2020-04-15T00:50:11Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5272,64 +5274,43 @@ public void testLambda() {\n \n     @Test\n     public void testTerminateTaskWithCompletedStatus() {\n-        WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_terminate_task_wf\");\n-        workflowDef.setSchemaVersion(2);\n-\n-        Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n-        lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n-        lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n+    \ttestTerminateTask(WorkflowStatus.COMPLETED);\n+    }\n \n-        WorkflowTask lambdaWorkflowTask = new WorkflowTask();\n-        lambdaWorkflowTask.setWorkflowTaskType(TaskType.LAMBDA);\n-        lambdaWorkflowTask.setName(\"lambda\");\n-        lambdaWorkflowTask.setInputParameters(lambdaTaskInputParams);\n-        lambdaWorkflowTask.setTaskReferenceName(\"lambda0\");\n+    @Test\n+    public void testTerminateTaskWithFailedStatus() {\n+    \ttestTerminateTask(WorkflowStatus.FAILED);\n+    }\n \n-        Map<String, Object> terminateTaskInputParams = new HashMap<>();\n-        terminateTaskInputParams.put(Terminate.getTerminationStatusParameter(), \"COMPLETED\");\n-        terminateTaskInputParams.put(Terminate.getTerminationWorkflowOutputParameter(), \"${lambda0.output}\");\n+    private WorkflowDef createSubworkflowDefWithWaitTask() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng=="}, "originalCommit": {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODI3NQ==", "bodyText": "made the requested changes", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408928275", "createdAt": "2020-04-15T15:22:31Z", "author": {"login": "rickfish"}, "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5272,64 +5274,43 @@ public void testLambda() {\n \n     @Test\n     public void testTerminateTaskWithCompletedStatus() {\n-        WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_terminate_task_wf\");\n-        workflowDef.setSchemaVersion(2);\n-\n-        Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n-        lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n-        lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n+    \ttestTerminateTask(WorkflowStatus.COMPLETED);\n+    }\n \n-        WorkflowTask lambdaWorkflowTask = new WorkflowTask();\n-        lambdaWorkflowTask.setWorkflowTaskType(TaskType.LAMBDA);\n-        lambdaWorkflowTask.setName(\"lambda\");\n-        lambdaWorkflowTask.setInputParameters(lambdaTaskInputParams);\n-        lambdaWorkflowTask.setTaskReferenceName(\"lambda0\");\n+    @Test\n+    public void testTerminateTaskWithFailedStatus() {\n+    \ttestTerminateTask(WorkflowStatus.FAILED);\n+    }\n \n-        Map<String, Object> terminateTaskInputParams = new HashMap<>();\n-        terminateTaskInputParams.put(Terminate.getTerminationStatusParameter(), \"COMPLETED\");\n-        terminateTaskInputParams.put(Terminate.getTerminationWorkflowOutputParameter(), \"${lambda0.output}\");\n+    private WorkflowDef createSubworkflowDefWithWaitTask() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng=="}, "originalCommit": {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjIyMjc2OnYy", "diffSide": "RIGHT", "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDo0NTowMVrOGFl4fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNToyMjo0N1rOGF_AuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjczMw==", "bodyText": "The last task in the left fork is the terminate task, however, the join is set to an intermediate task (wait). This looks incorrect.", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408516733", "createdAt": "2020-04-15T00:45:01Z", "author": {"login": "apanicker-nflx"}, "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5350,11 +5337,28 @@ public void testTerminateTaskWithFailedStatus() {\n         terminateWorkflowTask.setInputParameters(terminateTaskInputParams);\n         terminateWorkflowTask.setTaskReferenceName(\"terminate0\");\n \n-        WorkflowTask workflowTask2 = new WorkflowTask();\n-        workflowTask2.setName(\"junit_task_2\");\n-        workflowTask2.setTaskReferenceName(\"t2\");\n+        // right fork\n+        WorkflowTask subWorkflow = new WorkflowTask();\n+        subWorkflow.setType(SUB_WORKFLOW.name());\n+        SubWorkflowParams sw = new SubWorkflowParams();\n+        sw.setName(subworkflowDef.getName());\n+        subWorkflow.setSubWorkflowParam(sw);\n+        subWorkflow.setTaskReferenceName(\"sw1\");\n+\n+        fanoutTask.getForkTasks().add(Arrays.asList(subWorkflow));\n+        fanoutTask.getForkTasks().add(Arrays.asList(lambdaWorkflowTask, waitWorkflowTask, terminateWorkflowTask));\n+\n+        // join task\n+        WorkflowTask joinTask = new WorkflowTask();\n+        joinTask.setType(TaskType.JOIN.name());\n+        joinTask.setTaskReferenceName(\"fanouttask_join\");\n+        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"leftfork-wait0\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODQ0MQ==", "bodyText": "made the requested change", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408928441", "createdAt": "2020-04-15T15:22:47Z", "author": {"login": "rickfish"}, "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5350,11 +5337,28 @@ public void testTerminateTaskWithFailedStatus() {\n         terminateWorkflowTask.setInputParameters(terminateTaskInputParams);\n         terminateWorkflowTask.setTaskReferenceName(\"terminate0\");\n \n-        WorkflowTask workflowTask2 = new WorkflowTask();\n-        workflowTask2.setName(\"junit_task_2\");\n-        workflowTask2.setTaskReferenceName(\"t2\");\n+        // right fork\n+        WorkflowTask subWorkflow = new WorkflowTask();\n+        subWorkflow.setType(SUB_WORKFLOW.name());\n+        SubWorkflowParams sw = new SubWorkflowParams();\n+        sw.setName(subworkflowDef.getName());\n+        subWorkflow.setSubWorkflowParam(sw);\n+        subWorkflow.setTaskReferenceName(\"sw1\");\n+\n+        fanoutTask.getForkTasks().add(Arrays.asList(subWorkflow));\n+        fanoutTask.getForkTasks().add(Arrays.asList(lambdaWorkflowTask, waitWorkflowTask, terminateWorkflowTask));\n+\n+        // join task\n+        WorkflowTask joinTask = new WorkflowTask();\n+        joinTask.setType(TaskType.JOIN.name());\n+        joinTask.setTaskReferenceName(\"fanouttask_join\");\n+        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"leftfork-wait0\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjczMw=="}, "originalCommit": {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODc4MzY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozOTozMVrOGvJlgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwOTozOTozMVrOGvJlgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MzMxMw==", "bodyText": "This exception message: Unable to start system task: is not relevant, as we're not starting any system tasks here.", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r452093313", "createdAt": "2020-07-09T09:39:31Z", "author": {"login": "kishorebanala"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,29 +986,56 @@ public boolean decide(String workflowId) {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                        // FIXME: temporary hack to workaround TERMINATE task\n-                        if (TERMINATE.name().equals(task.getTaskType())) {\n-                            deciderService.externalizeTaskData(task);\n-                            executionDAOFacade.updateTask(task);\n-                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                completeWorkflow(workflow);\n-                            } else {\n-                                workflow.setStatus(workflowInstance.getStatus());\n-                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                    try {\n+                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                            // FIXME: temporary hack to workaround TERMINATE task\n+                            if (TERMINATE.name().equals(task.getTaskType())) {\n+                                deciderService.externalizeTaskData(task);\n+                                executionDAOFacade.updateTask(task);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n+                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n+                                \t\tif(subWorkflow != null) {\n+                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n+                                \t\t}\n+                                \t}\n+                                }\n+                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n+                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                \tcompleteWorkflow(workflow);\n+                                } else {\n+                                    workflow.setStatus(workflowInstance.getStatus());\n+                                \tterminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                                }\n+                                return true;\n                             }\n-                            return true;\n-                        }\n-                        deciderService.externalizeTaskData(task);\n-                        tasksToBeUpdated.add(task);\n-                        stateChanged = true;\n-                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                        // and continues with the current decide.\n-                        if (updateParentWorkflow(task, workflow)) {\n+                            deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n+                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                            // and continues with the current decide.\n+                            if (updateParentWorkflow(task, workflow)) {\n+                                tasksToBeUpdated.add(task);\n+                                stateChanged = true;\n+                            }\n                         }\n+                    } catch (Exception e) {\n+                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4155, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}