{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MjM1OTMz", "number": 1649, "title": "Refactored Subworkflow processing to leverage asyncComplete, and othe\u2026", "bodyText": "These changes complement the existing async processing of Subworkflow changes introduced in #1438.\nWith Subworkflow task being async, it is polled for and executed by System task workers every 30 seconds (Default call back after seconds for System tasks). This introduced a bottleneck on Subworkflow task queue, especially when there are large number of long running Subworkflows.\nWe can further optimize this by making Subworkflow task asyncComplete, meaning the task will only be polled for and executed twice overall in it's lifecycle, keeping the task in IN_PROGRESS state, until Subworkflow's completion. asyncComplete detaches the task from task queue, and expects the task to be completed by external trigger.\nIn Subworkflow task's case, the Subworkflow terminal state would be the external trigger that updates the Subworkflow task on completion with result.\nOther improvements like checking the Subworkflow's validity for restarts and retries are incorporated in this PR.", "createdAt": "2020-04-20T18:47:35Z", "url": "https://github.com/Netflix/conductor/pull/1649", "merged": true, "mergeCommit": {"oid": "bf3ae59372cc245dc791fcf9355248b7c111d6b1"}, "closed": true, "closedAt": "2020-04-23T18:58:39Z", "author": {"login": "kishorebanala"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZkNvngBqjMyNTMyMzYwMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcahLoUgBqjMyNjYyOTczMTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61f4591cd037f2d39701c2746246a743bd674c8e", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/61f4591cd037f2d39701c2746246a743bd674c8e", "committedDate": "2020-04-20T18:44:43Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}, "afterCommit": {"oid": "0940444b39399f592dcd992ef12f1efe85d2c696", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/0940444b39399f592dcd992ef12f1efe85d2c696", "committedDate": "2020-04-20T19:25:29Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzY0MTYz", "url": "https://github.com/Netflix/conductor/pull/1649#pullrequestreview-397764163", "createdAt": "2020-04-22T00:28:37Z", "commit": {"oid": "0940444b39399f592dcd992ef12f1efe85d2c696"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyODozOFrOGJeCcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNTo1MFrOGJeL6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MjUxNA==", "bodyText": "Does this need to be a public method? Please add a unit test for this method.", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r412582514", "createdAt": "2020-04-22T00:28:38Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1538,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    /**\n+     * Update parent Workflow status based on Subworkflow state.\n+     * @param subWorkflow\n+     */\n+    public void updateParentWorkflow(Workflow subWorkflow) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0940444b39399f592dcd992ef12f1efe85d2c696"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MjY4NQ==", "bodyText": "Does this need to be a public method? Please add a unit test for this method.", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r412582685", "createdAt": "2020-04-22T00:29:04Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1538,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    /**\n+     * Update parent Workflow status based on Subworkflow state.\n+     * @param subWorkflow\n+     */\n+    public void updateParentWorkflow(Workflow subWorkflow) {\n+        Workflow parent = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        WorkflowDef parentDef = Optional.ofNullable(parent.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parent.getWorkflowName(), parent.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parent.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        Task parentWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        // On workflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (subWorkflow.getStatus().isSuccessful() && StringUtils.isBlank(parentDef.getFailureWorkflow()) && parent.getStatus() == WorkflowStatus.FAILED && parentWorkflowTask.getStatus() == FAILED) {\n+                LOGGER.debug(\"Subworkflow: {} is successful, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), parent.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                parentWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(parentWorkflowTask);\n+                parent.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parent);\n+                decide(parent.getWorkflowId());\n+            } else if (parentWorkflowTask.getStatus() == IN_PROGRESS) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parent.getWorkflowId());\n+                SubWorkflow subWorkflowTask = new SubWorkflow();\n+                subWorkflowTask.execute(subWorkflow, parentWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (parentWorkflowTask.getExternalOutputPayloadStoragePath() != null && !parentWorkflowTask.getOutputData().isEmpty()) {\n+                    Map<String, Object> parentWorkflowTaskOutputData = parentWorkflowTask.getOutputData();\n+                    deciderService.populateTaskData(parentWorkflowTask);\n+                    parentWorkflowTask.getOutputData().putAll(parentWorkflowTaskOutputData);\n+                    deciderService.externalizeTaskData(parentWorkflowTask);\n+                }\n+                updateTask(new TaskResult(parentWorkflowTask));\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow\");\n+            }\n+        } else {\n+            // On workflow retry or restart..\n+            if (StringUtils.isBlank(parentDef.getFailureWorkflow()) && parent.getStatus() == WorkflowStatus.FAILED && parentWorkflowTask.getStatus() == FAILED) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parent.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                parentWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(parentWorkflowTask);\n+                parent.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parent);\n+                decide(parent.getWorkflowId());\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verify that the Subworkflow is still operational for a given parent workflow.\n+     * For eg., if parent workflow's Subworkflow task is retried, the previous workflow is no longer associated with parent,\n+     * and any operations on it shouldn't impact the current running Subworkflow and Parent.\n+     * Future improvements: Check if this flow is part of other System task like Decide, Join etc.\n+     * @param workflow\n+     * @return\n+     */\n+    public boolean isViolatingParentWorkflowConsistency(Workflow workflow) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0940444b39399f592dcd992ef12f1efe85d2c696"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDkzOA==", "bodyText": "What is the case where the parent workflow task is expected to have output data in external storage while remaining in progress? Shouldn't the output data only get populated when the sub workflow task completes?", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r412584938", "createdAt": "2020-04-22T00:35:50Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1538,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    /**\n+     * Update parent Workflow status based on Subworkflow state.\n+     * @param subWorkflow\n+     */\n+    public void updateParentWorkflow(Workflow subWorkflow) {\n+        Workflow parent = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        WorkflowDef parentDef = Optional.ofNullable(parent.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parent.getWorkflowName(), parent.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parent.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        Task parentWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        // On workflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (subWorkflow.getStatus().isSuccessful() && StringUtils.isBlank(parentDef.getFailureWorkflow()) && parent.getStatus() == WorkflowStatus.FAILED && parentWorkflowTask.getStatus() == FAILED) {\n+                LOGGER.debug(\"Subworkflow: {} is successful, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), parent.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                parentWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(parentWorkflowTask);\n+                parent.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parent);\n+                decide(parent.getWorkflowId());\n+            } else if (parentWorkflowTask.getStatus() == IN_PROGRESS) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parent.getWorkflowId());\n+                SubWorkflow subWorkflowTask = new SubWorkflow();\n+                subWorkflowTask.execute(subWorkflow, parentWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (parentWorkflowTask.getExternalOutputPayloadStoragePath() != null && !parentWorkflowTask.getOutputData().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0940444b39399f592dcd992ef12f1efe85d2c696"}, "originalPosition": 112}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c793be31a266cac79a35ffccf3fd1c2e3d55c81e", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/c793be31a266cac79a35ffccf3fd1c2e3d55c81e", "committedDate": "2020-04-22T20:58:37Z", "message": "[WIP] Further refactoring and improvements."}, "afterCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "committedDate": "2020-04-22T22:32:46Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjQzOTA3", "url": "https://github.com/Netflix/conductor/pull/1649#pullrequestreview-398643907", "createdAt": "2020-04-22T22:49:25Z", "commit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjo0OToyNVrOGKPA9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjo0OToyNVrOGKPA9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NDk1MQ==", "bodyText": "Do not throw an exception.", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413384951", "createdAt": "2020-04-22T22:49:25Z", "author": {"login": "kishorebanala"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (parentWorkflow.getStatus().equals(WorkflowStatus.FAILED)) {\n+                String errorMsg = String.format(\"Subworkflow: %s is successful, but parent workflow: %s is in FAILED state.\",\n+                        subWorkflow.getWorkflowId(), parentWorkflow.getWorkflowId());\n+                LOGGER.warn(errorMsg);\n+                throw new IllegalStateException(errorMsg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjQzOTc2", "url": "https://github.com/Netflix/conductor/pull/1649#pullrequestreview-398643976", "createdAt": "2020-04-22T22:49:34Z", "commit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjo0OTozNFrOGKPBMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjo0OTozNFrOGKPBMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NTAxMQ==", "bodyText": "Update comments", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413385011", "createdAt": "2020-04-22T22:49:34Z", "author": {"login": "kishorebanala"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjU5NDQ2", "url": "https://github.com/Netflix/conductor/pull/1649#pullrequestreview-398659446", "createdAt": "2020-04-22T23:27:44Z", "commit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzoyNzo0NVrOGKP-YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzozMTowMVrOGKQDNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMDY3Mg==", "bodyText": "Unable to do something can be changed to Unable to evaluate parent workflow", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413400672", "createdAt": "2020-04-22T23:27:45Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (parentWorkflow.getStatus().equals(WorkflowStatus.FAILED)) {\n+                String errorMsg = String.format(\"Subworkflow: %s is successful, but parent workflow: %s is in FAILED state.\",\n+                        subWorkflow.getWorkflowId(), parentWorkflow.getWorkflowId());\n+                LOGGER.warn(errorMsg);\n+                throw new IllegalStateException(errorMsg);\n+            } else if (subWorkflowTask.getStatus().equals(IN_PROGRESS)) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId());\n+                SubWorkflow subWorkflowSystemTask = new SubWorkflow();\n+                subWorkflowSystemTask.execute(subWorkflow, subWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (subWorkflowTask.getStatus().isTerminal() && subWorkflowTask.getExternalOutputPayloadStoragePath() != null && !subWorkflowTask.getOutputData().isEmpty()) {\n+                    Map<String, Object> parentWorkflowTaskOutputData = subWorkflowTask.getOutputData();\n+                    deciderService.populateTaskData(subWorkflowTask);\n+                    subWorkflowTask.getOutputData().putAll(parentWorkflowTaskOutputData);\n+                    deciderService.externalizeTaskData(subWorkflowTask);\n+                }\n+                return true;\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow: {} in status: {}, and subworkflow: {} in status: {}\",\n+                        parentWorkflow.getWorkflowId(), parentWorkflow.getStatus().name(),\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name());\n+            }\n+        } else {\n+            // On workflow retry or restart..\n+            if (StringUtils.isBlank(parentDef.getFailureWorkflow()) && parentWorkflow.getStatus().isTerminal() && subWorkflowTask.getStatus().isTerminal()) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                subWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(subWorkflowTask);\n+                parentWorkflow.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parentWorkflow);\n+                return true;\n+            } else if (parentWorkflow.getStatus().equals(WorkflowStatus.RUNNING)) {\n+                if (subWorkflowTask.getStatus().isTerminal()) {\n+                    String errorMsg = String.format(\"Subworkflow: %s is in RUNNING state, but Subworkflow task: %s in parent workflow: %s is in FAILED state.\",\n+                            subWorkflow.getWorkflowId(),subWorkflowTask.getTaskId(), parentWorkflow.getWorkflowId());\n+                    LOGGER.warn(errorMsg);\n+                    throw new IllegalStateException(errorMsg);\n+                } else {\n+                    // parentWorkflow, subWorkflowTask and subWorkflow are in non-terminal state\n+                    return false;\n+                }\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow: {} in status: {}, and subworkflow: {} in status: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMTMzOA==", "bodyText": "Why was this status changed?", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413401338", "createdAt": "2020-04-22T23:29:24Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/test/java/com/netflix/conductor/core/execution/tasks/TestSubWorkflow.java", "diffHunk": "@@ -211,7 +211,7 @@ public void testExecuteWorkflowStatus() {\n         subWorkflowInstance.setStatus(Workflow.WorkflowStatus.TIMED_OUT);\n         subWorkflowInstance.setReasonForIncompletion(\"unit2\");\n         assertTrue(subWorkflow.execute(workflowInstance, task, workflowExecutor));\n-        assertEquals(Task.Status.FAILED, task.getStatus());\n+        assertEquals(Task.Status.TIMED_OUT, task.getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMTkxMA==", "bodyText": "What is the scenario when this would be invoked?", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413401910", "createdAt": "2020-04-22T23:31:01Z", "author": {"login": "apanicker-nflx"}, "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (parentWorkflow.getStatus().equals(WorkflowStatus.FAILED)) {\n+                String errorMsg = String.format(\"Subworkflow: %s is successful, but parent workflow: %s is in FAILED state.\",\n+                        subWorkflow.getWorkflowId(), parentWorkflow.getWorkflowId());\n+                LOGGER.warn(errorMsg);\n+                throw new IllegalStateException(errorMsg);\n+            } else if (subWorkflowTask.getStatus().equals(IN_PROGRESS)) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId());\n+                SubWorkflow subWorkflowSystemTask = new SubWorkflow();\n+                subWorkflowSystemTask.execute(subWorkflow, subWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (subWorkflowTask.getStatus().isTerminal() && subWorkflowTask.getExternalOutputPayloadStoragePath() != null && !subWorkflowTask.getOutputData().isEmpty()) {\n+                    Map<String, Object> parentWorkflowTaskOutputData = subWorkflowTask.getOutputData();\n+                    deciderService.populateTaskData(subWorkflowTask);\n+                    subWorkflowTask.getOutputData().putAll(parentWorkflowTaskOutputData);\n+                    deciderService.externalizeTaskData(subWorkflowTask);\n+                }\n+                return true;\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow: {} in status: {}, and subworkflow: {} in status: {}\",\n+                        parentWorkflow.getWorkflowId(), parentWorkflow.getStatus().name(),\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name());\n+            }\n+        } else {\n+            // On workflow retry or restart..\n+            if (StringUtils.isBlank(parentDef.getFailureWorkflow()) && parentWorkflow.getStatus().isTerminal() && subWorkflowTask.getStatus().isTerminal()) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                subWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(subWorkflowTask);\n+                parentWorkflow.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parentWorkflow);\n+                return true;\n+            } else if (parentWorkflow.getStatus().equals(WorkflowStatus.RUNNING)) {\n+                if (subWorkflowTask.getStatus().isTerminal()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580"}, "originalPosition": 141}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "committedDate": "2020-04-22T22:32:46Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}, "afterCommit": {"oid": "7f758c5af544d32a56b7e02ff468716089f6fe34", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/7f758c5af544d32a56b7e02ff468716089f6fe34", "committedDate": "2020-04-23T04:20:42Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Nzg2NjYw", "url": "https://github.com/Netflix/conductor/pull/1649#pullrequestreview-398786660", "createdAt": "2020-04-23T06:15:09Z", "commit": {"oid": "7f758c5af544d32a56b7e02ff468716089f6fe34"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afcffb3f7dce6b3277961be13572a1d33f35c1dc", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/afcffb3f7dce6b3277961be13572a1d33f35c1dc", "committedDate": "2020-04-23T18:27:16Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f758c5af544d32a56b7e02ff468716089f6fe34", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/7f758c5af544d32a56b7e02ff468716089f6fe34", "committedDate": "2020-04-23T04:20:42Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}, "afterCommit": {"oid": "afcffb3f7dce6b3277961be13572a1d33f35c1dc", "author": {"user": {"login": "kishorebanala", "name": "Kishore"}}, "url": "https://github.com/Netflix/conductor/commit/afcffb3f7dce6b3277961be13572a1d33f35c1dc", "committedDate": "2020-04-23T18:27:16Z", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 772, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}