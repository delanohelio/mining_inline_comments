{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NjEzMjQ2", "number": 1589, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1MjoxN1rODqmPvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDowNTowNlrODs5c1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTkzNDA3OnYy", "diffSide": "RIGHT", "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPConfigurations.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1MjoxN1rOF6camg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1MjoxN1rOF6camg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNzI5MA==", "bodyText": "Nit: Consider formatting this to one per line.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r396827290", "createdAt": "2020-03-23T23:52:17Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPConfigurations.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+package com.netflix.conductor.contribs.queue.amqp;\n+\n+public enum AMQPConfigurations {\n+\n+\tPROPERTY_CONTENT_TYPE(\"contentType\"), PROPERTY_CONTENT_ENCODING(\"contentEncoding\"), PROPERTY_IS_DURABLE(\"durable\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3cc4490e6e3b4f48063544313ece2dbbbcd51d3"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTk0MzI3OnYy", "diffSide": "RIGHT", "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1Njo0OFrOF6cgHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1Njo0OFrOF6cgHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyODcwMw==", "bodyText": "Please add short descriptions as docs to what these constants are being used for.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r396828703", "createdAt": "2020-03-23T23:56:48Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPConstants.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+package com.netflix.conductor.contribs.queue.amqp;\n+\n+public class AMQPConstants {\n+\n+\tpublic static String AMQP_QUEUE_TYPE = \"amqp_queue\";\n+\tpublic static String AMQP_EXCHANGE_TYPE = \"amqp_exchange\";\n+\n+\tpublic static String PROPERTY_KEY_TEMPLATE = \"workflow.event.queues.amqp.%s\";\n+\n+\tpublic static String DEFAULT_CONTENT_TYPE = \"application/json\";\n+\tpublic static String DEFAULT_CONTENT_ENCODING = \"UTF-8\";\n+\tpublic static String DEFAULT_EXCHANGE_TYPE = \"topic\";\n+\n+\tpublic static boolean DEFAULT_DURABLE = true;\n+\tpublic static boolean DEFAULT_EXCLUSIVE = false;\n+\tpublic static boolean DEFAULT_AUTO_DELETE = false;\n+\n+\tpublic static int DEFAULT_DELIVERY_MODE = 2; // Persistent messages", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3cc4490e6e3b4f48063544313ece2dbbbcd51d3"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTk0Njg5OnYy", "diffSide": "RIGHT", "path": "contribs/src/main/java/com/netflix/conductor/contribs/AMQPModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1ODo0NlrOF6cibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1ODo0NlrOF6cibg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyOTI5NA==", "bodyText": "Please clean this up before the PR is merged, as it would be conflicting in master.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r396829294", "createdAt": "2020-03-23T23:58:46Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/main/java/com/netflix/conductor/contribs/AMQPModule.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package com.netflix.conductor.contribs;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.inject.AbstractModule;\n+import com.google.inject.Provides;\n+import com.google.inject.Singleton;\n+import com.google.inject.multibindings.ProvidesIntoMap;\n+import com.google.inject.multibindings.StringMapKey;\n+import com.google.inject.name.Named;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.contribs.queue.amqp.AMQPEventQueueProvider;\n+import com.netflix.conductor.contribs.queue.amqp.AMQPObservableQueue;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.events.EventQueueProvider;\n+import com.netflix.conductor.core.events.queue.ObservableQueue;\n+import static com.netflix.conductor.core.events.EventQueues.EVENT_QUEUE_PROVIDERS_QUALIFIER;\n+\n+/**\n+ * Module for support of AMQP queues Do not forget to define into the\n+ * configuration file:\n+ * \n+ * <pre>\n+ * conductor.additional.modules = com.netflix.conductor.contribs.AMQPModule\n+ * </pre>\n+ * \n+ *\n+ * @author Ritu Parathody\n+ * @version $Id$ This code is based on the PR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3cc4490e6e3b4f48063544313ece2dbbbcd51d3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTk0ODQ2OnYy", "diffSide": "RIGHT", "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPEventQueueProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1OTo1M1rOF6cjiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMzo1OTo1M1rOF6cjiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyOTU3Ng==", "bodyText": "Please clean this up before the PR is merged, as it would be conflicting in master.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r396829576", "createdAt": "2020-03-23T23:59:53Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPEventQueueProvider.java", "diffHunk": "@@ -0,0 +1,64 @@\n+\n+/**\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+package com.netflix.conductor.contribs.queue.amqp;\n+\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.events.EventQueueProvider;\n+import com.netflix.conductor.core.events.queue.ObservableQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static com.netflix.conductor.contribs.queue.amqp.AMQPObservableQueue.Builder;\n+\n+/**\n+ * Created at 19/03/2019 16:29\n+ *\n+ * @author Ritu Parathody\n+ * @version $Id$ This code is based on the PR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3cc4490e6e3b4f48063544313ece2dbbbcd51d3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTk0OTIxOnYy", "diffSide": "RIGHT", "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPObservableQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMDowMDoyM1rOF6ckFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMDowMDoyM1rOF6ckFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyOTcxOQ==", "bodyText": "Please clean this up before the PR is merged, as it would be conflicting in master.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r396829719", "createdAt": "2020-03-24T00:00:23Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPObservableQueue.java", "diffHunk": "@@ -0,0 +1,583 @@\n+/**\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+package com.netflix.conductor.contribs.queue.amqp;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.events.queue.Message;\n+import com.netflix.conductor.core.events.queue.ObservableQueue;\n+import com.netflix.conductor.metrics.Monitors;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Address;\n+import com.rabbitmq.client.BasicProperties;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.DeliverCallback;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+\n+import rx.Observable;\n+\n+/**\n+ * Created at 19/03/2019 16:29\n+ *\n+ * @author Ritu Parathody\n+ * @version $Id$ This code is based on the PR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3cc4490e6e3b4f48063544313ece2dbbbcd51d3"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTk2Mzk3OnYy", "diffSide": "RIGHT", "path": "contribs/src/test/java/com/netflix/conductor/contribs/queue/amqp/AMQPSettingsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMDowODo0MFrOF6ctXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMDowODo0MFrOF6ctXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgzMjA5NQ==", "bodyText": "Please remove unused assertions.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r396832095", "createdAt": "2020-03-24T00:08:40Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/test/java/com/netflix/conductor/contribs/queue/amqp/AMQPSettingsTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.netflix.conductor.contribs.queue.amqp;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import com.netflix.conductor.core.config.Configuration;\n+\n+import junit.framework.Assert;\n+\n+public class AMQPSettingsTest {\n+\tprivate Configuration config;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tconfig = Mockito.mock(Configuration.class);\n+\t}\n+\n+\t@Test\n+\tpublic void testAMQPSettings_exchange_fromuri_defaultconfig() {\n+\t\tString exchangestring = \"amqp_exchange:myExchangeName?exchangeType=topic&routingKey=test&deliveryMode=2\";\n+\t\tMockito.when(config.getProperty(Mockito.anyString(), Mockito.anyString()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tMockito.when(config.getBooleanProperty(Mockito.anyString(), Mockito.anyBoolean()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tMockito.when(config.getIntProperty(Mockito.anyString(), Mockito.anyInt()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tAMQPSettings settings = new AMQPSettings(config);\n+\t\tsettings = settings.fromURI(exchangestring);\n+\t\tAssert.assertEquals(\"topic\", settings.getExchangeType());\n+\t\tAssert.assertEquals(\"test\", settings.getRoutingKey());\n+\t\tAssert.assertEquals(\"myExchangeName\", settings.getQueueOrExchangeName());\n+\t}\n+\n+\t@Test\n+\tpublic void testAMQPSettings_queue_fromuri_defaultconfig() {\n+\t\tString exchangestring = \"amqp_queue:myQueueName?deliveryMode=2&durable=false&autoDelete=true&exclusive=true\";\n+\t\tMockito.when(config.getProperty(Mockito.anyString(), Mockito.anyString()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tMockito.when(config.getBooleanProperty(Mockito.anyString(), Mockito.anyBoolean()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tMockito.when(config.getIntProperty(Mockito.anyString(), Mockito.anyInt()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tAMQPSettings settings = new AMQPSettings(config);\n+\t\tsettings = settings.fromURI(exchangestring);\n+\t\tAssert.assertEquals(false, settings.isDurable());\n+\t\tAssert.assertEquals(true, settings.isExclusive());\n+\t\tAssert.assertEquals(true, settings.autoDelete());\n+\t\tAssert.assertEquals(2, settings.getDeliveryMode());\n+\t\tAssert.assertEquals(\"myQueueName\", settings.getQueueOrExchangeName());\n+\t}\n+\t@Test(expected=IllegalArgumentException.class)\n+\tpublic void testAMQPSettings_exchange_fromuri_wrongdeliverymode() {\n+\t\tString exchangestring = \"amqp_exchange:myExchangeName?exchangeType=topic&routingKey=test&deliveryMode=3\";\n+\t\tMockito.when(config.getProperty(Mockito.anyString(), Mockito.anyString()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tMockito.when(config.getBooleanProperty(Mockito.anyString(), Mockito.anyBoolean()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tMockito.when(config.getIntProperty(Mockito.anyString(), Mockito.anyInt()))\n+\t\t\t\t.thenAnswer(invocation -> invocation.getArgument(1));\n+\t\tAMQPSettings settings = new AMQPSettings(config);\n+\t\tsettings = settings.fromURI(exchangestring);\n+\t\t//Assert.assertEquals(\"topic\", settings.getExchangeType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3cc4490e6e3b4f48063544313ece2dbbbcd51d3"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDA1MjA3OnYy", "diffSide": "RIGHT", "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPObservableQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDowNTowNlrOF-An2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDowNTowNlrOF-An2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjIzMw==", "bodyText": "Even though this method is not used at the moment, please provide an implementation or throw an UnsupportedOperationException to avoid gaps, if we have to use this method from ObservableQueue interface elsewhere in the future.", "url": "https://github.com/Netflix/conductor/pull/1589#discussion_r400566233", "createdAt": "2020-03-31T00:05:06Z", "author": {"login": "kishorebanala"}, "path": "contribs/src/main/java/com/netflix/conductor/contribs/queue/amqp/AMQPObservableQueue.java", "diffHunk": "@@ -0,0 +1,568 @@\n+/**\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+package com.netflix.conductor.contribs.queue.amqp;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.events.queue.Message;\n+import com.netflix.conductor.core.events.queue.ObservableQueue;\n+import com.netflix.conductor.metrics.Monitors;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Address;\n+import com.rabbitmq.client.BasicProperties;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.DeliverCallback;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+\n+import rx.Observable;\n+\n+/**\n+ * @author Ritu Parathody\n+ * \n+ */\n+public class AMQPObservableQueue implements ObservableQueue {\n+\tprivate static Logger logger = LoggerFactory.getLogger(AMQPObservableQueue.class);\n+\n+\tprivate final AMQPSettings settings;\n+\n+\tprivate final int batchSize;\n+\n+\tprivate boolean useExchange;\n+\tprivate int pollTimeInMS;\n+\tprivate boolean isConnOpened = false, isChanOpened = false;\n+\n+\tprivate ConnectionFactory factory;\n+\tprivate Connection connection;\n+\tprivate Channel channel;\n+\tprivate Address[] addresses;\n+\tprotected LinkedBlockingQueue<Message> messages = new LinkedBlockingQueue<>();\n+\n+\tAMQPObservableQueue(final ConnectionFactory factory, final Address[] addresses, final boolean useExchange,\n+\t\t\tfinal AMQPSettings settings, final int batchSize, final int pollTimeInMS) {\n+\t\tif (factory == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Connection factory is undefined\");\n+\t\t}\n+\t\tif (addresses == null || addresses.length == 0) {\n+\t\t\tthrow new IllegalArgumentException(\"Addresses are undefined\");\n+\t\t}\n+\t\tif (settings == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Settings are undefined\");\n+\t\t}\n+\t\tif (batchSize <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\"Batch size must be greater than 0\");\n+\t\t}\n+\t\tif (pollTimeInMS <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\"Poll time must be greater than 0 ms\");\n+\t\t}\n+\t\tthis.factory = factory;\n+\t\tthis.addresses = addresses;\n+\t\tthis.useExchange = useExchange;\n+\t\tthis.settings = settings;\n+\t\tthis.batchSize = batchSize;\n+\t\tthis.setPollTimeInMS(pollTimeInMS);\n+\t}\n+\n+\tprivate void connect() {\n+\t\tif (isConnOpened) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttry {\n+\t\t\tconnection = factory.newConnection(addresses);\n+\t\t\tisConnOpened = connection.isOpen();\n+\t\t\tif (!isConnOpened) {\n+\t\t\t\tthrow new RuntimeException(\"Failed to open connection\");\n+\t\t\t}\n+\t\t} catch (final IOException e) {\n+\t\t\tisConnOpened = false;\n+\t\t\tfinal String error = \"IO error while connecting to \"\n+\t\t\t\t\t+ Arrays.stream(addresses).map(address -> address.toString()).collect(Collectors.joining(\",\"));\n+\t\t\tlogger.error(error, e);\n+\t\t\tthrow new RuntimeException(error, e);\n+\t\t} catch (final TimeoutException e) {\n+\t\t\tisConnOpened = false;\n+\t\t\tfinal String error = \"Timeout while connecting to \"\n+\t\t\t\t\t+ Arrays.stream(addresses).map(address -> address.toString()).collect(Collectors.joining(\",\"));\n+\t\t\tlogger.error(error, e);\n+\t\t\tthrow new RuntimeException(error, e);\n+\t\t}\n+\t}\n+\n+\tprivate boolean isClosed() {\n+\t\treturn !isConnOpened && !isChanOpened;\n+\t}\n+\n+\tprivate void open() {\n+\t\tconnect();\n+\t}\n+\n+\t@Override\n+\tpublic Observable<Message> observe() {\n+\t\treceiveMessages();\n+\t\tObservable.OnSubscribe<Message> onSubscribe = subscriber -> {\n+\t\t\tObservable<Long> interval = Observable.interval(pollTimeInMS, TimeUnit.MILLISECONDS);\n+\t\t\tinterval.flatMap((Long x) -> {\n+\t\t\t\tList<Message> available = new LinkedList<>();\n+\t\t\t\tmessages.drainTo(available);\n+\n+\t\t\t\tif (!available.isEmpty()) {\n+\t\t\t\t\tAtomicInteger count = new AtomicInteger(0);\n+\t\t\t\t\tStringBuilder buffer = new StringBuilder();\n+\t\t\t\t\tavailable.forEach(msg -> {\n+\t\t\t\t\t\tbuffer.append(msg.getId()).append(\"=\").append(msg.getPayload());\n+\t\t\t\t\t\tcount.incrementAndGet();\n+\n+\t\t\t\t\t\tif (count.get() < available.size()) {\n+\t\t\t\t\t\t\tbuffer.append(\",\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tlogger.info(String.format(\"Batch from %s to conductor is %s\", settings.getQueueOrExchangeName(),\n+\t\t\t\t\t\t\tbuffer.toString()));\n+\t\t\t\t}\n+\n+\t\t\t\treturn Observable.from(available);\n+\t\t\t}).subscribe(subscriber::onNext, subscriber::onError);\n+\t\t};\n+\t\treturn Observable.create(onSubscribe);\n+\t}\n+\n+\t@Override\n+\tpublic String getType() {\n+\t\treturn useExchange ? AMQPConstants.AMQP_EXCHANGE_TYPE : AMQPConstants.AMQP_QUEUE_TYPE;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn settings.getEventName();\n+\t}\n+\n+\t@Override\n+\tpublic String getURI() {\n+\t\treturn settings.getQueueOrExchangeName();\n+\t}\n+\n+\tpublic int getBatchSize() {\n+\t\treturn batchSize;\n+\t}\n+\n+\tpublic AMQPSettings getSettings() {\n+\t\treturn settings;\n+\t}\n+\n+\tpublic Address[] getAddresses() {\n+\t\treturn addresses;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> ack(List<Message> messages) {\n+\t\tfinal List<String> processedDeliveryTags = new ArrayList<>();\n+\t\tfor (final Message message : messages) {\n+\t\t\ttry {\n+\t\t\t\tlogger.info(\"ACK message with delivery tag {}\", message.getReceipt());\n+\t\t\t\tgetOrCreateChannel().basicAck(Long.valueOf(message.getReceipt()), false);\n+\t\t\t\t// Message ACKed\n+\t\t\t\tprocessedDeliveryTags.add(message.getReceipt());\n+\t\t\t} catch (final IOException e) {\n+\t\t\t\tlogger.error(\"Cannot ACK message with delivery tag {}\", message.getReceipt(), e);\n+\t\t\t}\n+\t\t}\n+\t\treturn processedDeliveryTags;\n+\t}\n+\n+\tprivate static AMQP.BasicProperties buildBasicProperties(final Message message, final AMQPSettings settings) {\n+\t\treturn new AMQP.BasicProperties.Builder()\n+\t\t\t\t.messageId(StringUtils.isEmpty(message.getId()) ? UUID.randomUUID().toString() : message.getId())\n+\t\t\t\t.correlationId(\n+\t\t\t\t\t\tStringUtils.isEmpty(message.getReceipt()) ? UUID.randomUUID().toString() : message.getReceipt())\n+\t\t\t\t.contentType(settings.getContentType()).contentEncoding(settings.getContentEncoding())\n+\t\t\t\t.deliveryMode(settings.getDeliveryMode()).build();\n+\t}\n+\n+\tprivate void publishMessage(Message message, String exchange, String routingKey) {\n+\t\ttry {\n+\t\t\tfinal String payload = message.getPayload();\n+\t\t\tgetOrCreateChannel().basicPublish(exchange, routingKey, buildBasicProperties(message, settings),\n+\t\t\t\t\tpayload.getBytes(settings.getContentEncoding()));\n+\t\t\tlogger.info(String.format(\"Published message to %s: %s\", exchange, payload));\n+\t\t} catch (Exception ex) {\n+\t\t\tlogger.error(\"Failed to publish message {} to {}\", message.getPayload(), exchange, ex);\n+\t\t\tthrow new RuntimeException(ex);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void publish(List<Message> messages) {\n+\t\ttry {\n+\t\t\tfinal String exchange, routingKey;\n+\t\t\tif (useExchange) {\n+\t\t\t\t// Use exchange + routing key for publishing\n+\t\t\t\tgetOrCreateExchange(settings.getQueueOrExchangeName(), settings.getExchangeType(), settings.isDurable(),\n+\t\t\t\t\t\tsettings.autoDelete(), settings.getArguments());\n+\t\t\t\texchange = settings.getQueueOrExchangeName();\n+\t\t\t\troutingKey = settings.getRoutingKey();\n+\t\t\t} else {\n+\t\t\t\t// Use queue for publishing\n+\t\t\t\tfinal AMQP.Queue.DeclareOk declareOk = getOrCreateQueue(settings.getQueueOrExchangeName(),\n+\t\t\t\t\t\tsettings.isDurable(), settings.isExclusive(), settings.autoDelete(), settings.getArguments());\n+\t\t\t\texchange = StringUtils.EMPTY; // Empty exchange name for queue\n+\t\t\t\troutingKey = declareOk.getQueue(); // Routing name is the name of queue\n+\t\t\t}\n+\t\t\tmessages.forEach(message -> publishMessage(message, exchange, routingKey));\n+\t\t} catch (final RuntimeException ex) {\n+\t\t\tthrow ex;\n+\t\t} catch (final Exception ex) {\n+\t\t\tlogger.error(\"Failed to publish messages: {}\", ex.getMessage(), ex);\n+\t\t\tthrow new RuntimeException(ex);\n+\t\t}\n+\n+\t}\n+\n+\t@Override\n+\tpublic void setUnackTimeout(Message message, long unackTimeout) {\n+\t\t// TODO Auto-generated method stub", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e11286d846b85b55321bb6972a4b00afe5d9b5ee"}, "originalPosition": 255}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4264, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}