{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwOTY5NDM3", "number": 8996, "title": "Add AuthorizationManager", "bodyText": "Closes gh-8900", "createdAt": "2020-09-07T01:36:27Z", "url": "https://github.com/spring-projects/spring-security/pull/8996", "merged": true, "mergeCommit": {"oid": "34b4b1054fe11f43436dec9c93623db8338b3ac9"}, "closed": true, "closedAt": "2020-12-16T22:58:38Z", "author": {"login": "evgeniycheban"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdGZlf9ABqjM3MzQ5MzE5OTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmh_MdgBqjQxMTY5MTg5NTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2OTg1NDIz", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-486985423", "createdAt": "2020-09-11T17:18:22Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzoxODoyMlrOHQnPyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzo0NToyMFrOHQoFfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4MjI4MQ==", "bodyText": "Let's avoid the use of the Stream API.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r487182281", "createdAt": "2020-09-11T17:18:22Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/access/RequestMatcherDelegatingAuthorizationManager.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.web.access;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.springframework.security.authorization.AuthorizationDecision;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.web.util.matcher.RequestMatcher;\n+import org.springframework.security.web.util.matcher.RequestMatcherEntry;\n+\n+/**\n+ * An {@link AuthorizationManager} which delegates to a specific\n+ * {@link AuthorizationManager} based on a {@link RequestMatcher} evaluation.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public final class RequestMatcherDelegatingAuthorizationManager implements AuthorizationManager<HttpServletRequest> {\n+\n+\tprivate final List<RequestMatcherEntry<AuthorizationManager<HttpServletRequest>>> managers;\n+\n+\tpublic RequestMatcherDelegatingAuthorizationManager(\n+\t\t\tList<RequestMatcherEntry<AuthorizationManager<HttpServletRequest>>> managers) {\n+\t\tthis.managers = managers;\n+\t}\n+\n+\t@Override\n+\tpublic AuthorizationDecision check(Supplier<Authentication> authentication, HttpServletRequest request) {\n+\t\treturn this.managers.stream().filter((entry) -> entry.getMatcher().matches(request))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NjAyOA==", "bodyText": "I'm not entirely convinced that this class should be public as these days authorizing by IP address is quite fragile.\nIf necessary, I think the DSL's implementation of hasIpAddress() could use a private AuthorizationManager implementation or a lambda.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r487196028", "createdAt": "2020-09-11T17:45:20Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/access/IpAddressAuthorizationManager.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.web.access;\n+\n+import java.util.function.Supplier;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.springframework.security.authorization.AuthorizationDecision;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.web.util.matcher.IpAddressMatcher;\n+import org.springframework.security.web.util.matcher.RequestMatcher;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * An {@link AuthorizationManager} that determines if the current request is authorized\n+ * based on a {@link IpAddressMatcher} evaluation.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public class IpAddressAuthorizationManager implements AuthorizationManager<HttpServletRequest> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODc1MTI0", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-489875124", "createdAt": "2020-09-16T18:05:00Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxODowNTowMVrOHS8Twg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMjozOToyMlrOHdcX6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYyNDUxNA==", "bodyText": "Because this is part of the public API (being a public method), we won't be able to remove it right away. The first step is to use the @Deprecated annotation and add a @deprecated JavaDoc comment indicating what the application should do instead.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r489624514", "createdAt": "2020-09-16T18:05:01Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractInterceptUrlConfigurer.java", "diffHunk": "@@ -142,29 +103,21 @@ private FilterSecurityInterceptor createFilterSecurityInterceptor(H http,\n \t\t\tthrows Exception {\n \t\tFilterSecurityInterceptor securityInterceptor = new FilterSecurityInterceptor();\n \t\tsecurityInterceptor.setSecurityMetadataSource(metadataSource);\n-\t\tsecurityInterceptor.setAccessDecisionManager(getAccessDecisionManager(http));\n \t\tsecurityInterceptor.setAuthenticationManager(authenticationManager);\n-\t\tsecurityInterceptor.afterPropertiesSet();\n+\t\tconfigureFilterSecurityInterceptor(http, securityInterceptor);\n \t\treturn securityInterceptor;\n \t}\n \n+\tprotected void configureFilterSecurityInterceptor(H http, FilterSecurityInterceptor filterSecurityInterceptor) {\n+\n+\t}\n+\n \tpublic abstract class AbstractInterceptUrlRegistry<R extends AbstractInterceptUrlRegistry<R, T>, T>\n \t\t\textends AbstractConfigAttributeRequestMatcherRegistry<T> {\n \n \t\tAbstractInterceptUrlRegistry() {\n \t\t}\n \n-\t\t/**\n-\t\t * Allows setting the {@link AccessDecisionManager}. If none is provided, a\n-\t\t * default {@link AccessDecisionManager} is created.\n-\t\t * @param accessDecisionManager the {@link AccessDecisionManager} to use\n-\t\t * @return the {@link AbstractInterceptUrlConfigurer} for further customization\n-\t\t */\n-\t\tpublic R accessDecisionManager(AccessDecisionManager accessDecisionManager) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMzg1Mw==", "bodyText": "Let's remove this reference once it's not used anymore.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r499733853", "createdAt": "2020-10-05T16:44:07Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -115,6 +118,8 @@\n \n \tprivate AccessDecisionManager accessDecisionManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNDIxMw==", "bodyText": "Once AccessDecisionManager is removed from this class, I think this check is no longer necessary.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r499734213", "createdAt": "2020-10-05T16:44:44Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -134,14 +139,15 @@ public void afterPropertiesSet() {\n \t\tAssert.notNull(getSecureObjectClass(), \"Subclass must provide a non-null response to getSecureObjectClass()\");\n \t\tAssert.notNull(this.messages, \"A message source must be set\");\n \t\tAssert.notNull(this.authenticationManager, \"An AuthenticationManager is required\");\n-\t\tAssert.notNull(this.accessDecisionManager, \"An AccessDecisionManager is required\");\n+\t\tAssert.isTrue(this.accessDecisionManager != null || this.authorizationManager != null,\n+\t\t\t\t\"Either AccessDecisionManager or AuthorizationManager must present\");\n \t\tAssert.notNull(this.runAsManager, \"A RunAsManager is required\");\n \t\tAssert.notNull(this.obtainSecurityMetadataSource(), \"An SecurityMetadataSource is required\");\n \t\tAssert.isTrue(this.obtainSecurityMetadataSource().supports(getSecureObjectClass()),\n \t\t\t\t() -> \"SecurityMetadataSource does not support secure object class: \" + getSecureObjectClass());\n \t\tAssert.isTrue(this.runAsManager.supports(getSecureObjectClass()),\n \t\t\t\t() -> \"RunAsManager does not support secure object class: \" + getSecureObjectClass());\n-\t\tAssert.isTrue(this.accessDecisionManager.supports(getSecureObjectClass()),\n+\t\tAssert.isTrue(this.accessDecisionManager == null || this.accessDecisionManager.supports(getSecureObjectClass()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNTAzNA==", "bodyText": "This test against AccessDecisionManager might be better to do in the AuthorizationManagerAdapter's constructor.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r499735034", "createdAt": "2020-10-05T16:46:06Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -161,7 +167,8 @@ public void afterPropertiesSet() {\n \tprivate void validateAttributeDefs(Collection<ConfigAttribute> attributeDefs) {\n \t\tSet<ConfigAttribute> unsupportedAttrs = new HashSet<>();\n \t\tfor (ConfigAttribute attr : attributeDefs) {\n-\t\t\tif (!this.runAsManager.supports(attr) && !this.accessDecisionManager.supports(attr)\n+\t\t\tif (!this.runAsManager.supports(attr) && this.accessDecisionManager != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczOTM3Mg==", "bodyText": "This setter should probably create an instance of the adapter.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r499739372", "createdAt": "2020-10-05T16:53:33Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -375,10 +404,24 @@ public boolean isValidateConfigAttributes() {\n \n \tpublic abstract SecurityMetadataSource obtainSecurityMetadataSource();\n \n+\t/**\n+\t * Sets the {@link AccessDecisionManager} instance.\n+\t * @param accessDecisionManager the {@link AccessDecisionManager} instance\n+\t * @deprecated use {@link #setAuthorizationManager(AuthorizationManager)} instead\n+\t */\n+\t@Deprecated\n \tpublic void setAccessDecisionManager(AccessDecisionManager accessDecisionManager) {\n \t\tthis.accessDecisionManager = accessDecisionManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYzMzMwMg==", "bodyText": "I think the ideal would be to initialize instances of AuthorizationManager with the correct security metadata instead of retrieving the security metadata each time an authentication is being checked.\nInstead of routing the rules configured in the DSL through the ConfigAttribute API, have you already considered having the DSL construct a delegating AuthorizationManager that is composed of delegates that already have the security metadata?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r500633302", "createdAt": "2020-10-06T22:32:54Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/authorization/AffirmativeBasedAuthorizationManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.authorization;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.springframework.security.access.AccessDecisionVoter;\n+import org.springframework.security.access.ConfigAttribute;\n+import org.springframework.security.access.SecurityMetadataSource;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * Simple concrete implementation of {@link AuthorizationManager} that grants access if\n+ * any {@link AccessDecisionVoter} returns an affirmative response.\n+ *\n+ * @param <T> the type of object that the authorization check is being done one.\n+ * @author Evgeniy Cheban\n+ */\n+public final class AffirmativeBasedAuthorizationManager<T> implements AuthorizationManager<T> {\n+\n+\tprivate final List<AccessDecisionVoter<?>> decisionVoters;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYzNDM1Ng==", "bodyText": "I think it would be valuable to make the return type nullable here, to indicate an abstain vote.\nThis aligns with the JavaDoc from ReactiveAuthorizationManager:\n@return a decision or empty Mono if no decision could be made", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r500634356", "createdAt": "2020-10-06T22:35:47Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorizationManager.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.authorization;\n+\n+import java.util.function.Supplier;\n+\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.Authentication;\n+\n+/**\n+ * An Authorization manager which can determine if an {@link Authentication} has access to\n+ * a specific object.\n+ *\n+ * @param <T> the type of object that the authorization check is being done one.\n+ * @author Evgeniy Cheban\n+ */\n+@FunctionalInterface\n+public interface AuthorizationManager<T> {\n+\n+\t/**\n+\t * Determines if access is granted for a specific authentication and object.\n+\t * @param authentication the Authentication to check\n+\t * @param object the object to check\n+\t * @return a decision\n+\t */\n+\tAuthorizationDecision check(Supplier<Authentication> authentication, T object);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYzNTYyNw==", "bodyText": "I think this might not be necessary. A better place for this functionality is on the access method, similar to how its exposed in ServerHttpSecurity.\nFor an application that is overriding accessDecisionManager, they can replace:\nhttp\n    .authorizeRequests((authz) -> authz\n        .accessDecisionManager(myAccessDecisionManager)\n    )\nwith:\nhttp\n    .authorizeRequests((authz) -> authz\n        .anyRequest.access(myAuthorizationManager)\n    )", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r500635627", "createdAt": "2020-10-06T22:39:22Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractInterceptUrlConfigurer.java", "diffHunk": "@@ -165,6 +180,17 @@ public R accessDecisionManager(AccessDecisionManager accessDecisionManager) {\n \t\t\treturn getSelf();\n \t\t}\n \n+\t\t/**\n+\t\t * Allows setting the {@link AuthorizationManager}. If none is provided, a default\n+\t\t * {@link AuthorizationManager} is created.\n+\t\t * @param authorizationManager the {@link AuthorizationManager} to use\n+\t\t * @return the {@link AbstractInterceptUrlConfigurer} for further customization\n+\t\t */\n+\t\tpublic R authorizationManager(AuthorizationManager<FilterInvocation> authorizationManager) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjY1NzQy", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-510665742", "createdAt": "2020-10-16T17:25:51Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNzoyNTo1MVrOHjJiQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxODoyOToxOVrOHjLp6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODQzNQ==", "bodyText": "I believe it's too early to call getExpressionHandler at this point. The reason is that an application could call expressionHandler after configuring its authorization rules.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506618435", "createdAt": "2020-10-16T17:25:51Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/ExpressionUrlAuthorizationConfigurer.java", "diffHunk": "@@ -434,10 +424,28 @@ public ExpressionInterceptUrlRegistry access(String attribute) {\n \t\t\tif (this.not) {\n \t\t\t\tattribute = \"!\" + attribute;\n \t\t\t}\n+\n+\t\t\tExpressionUrlAuthorizationConfigurer.this.authorizationManagerBuilder\n+\t\t\t\t\t.add(new RequestMatcherEntry<>(this.requestMatchers,\n+\t\t\t\t\t\t\tnew WebExpressionAuthorizationManager(attribute, getExpressionHandler(getBuilder()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMDA2MQ==", "bodyText": "I'm also a bit queasy about the parallel configuration here -- the authorization manager builder and the registry.\nIt might be better to follow the same pattern as createMetadataSource, introducing a createAuthorizationManager in the parent and then creating each AuthorizationManager at that point from the ConfigAttribute. Then, you'd only need to call interceptUrl. Another nice thing about this approach is that you'd have the ExpressionHandler set at that point.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506620061", "createdAt": "2020-10-16T17:28:54Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/ExpressionUrlAuthorizationConfigurer.java", "diffHunk": "@@ -434,10 +424,28 @@ public ExpressionInterceptUrlRegistry access(String attribute) {\n \t\t\tif (this.not) {\n \t\t\t\tattribute = \"!\" + attribute;\n \t\t\t}\n+\n+\t\t\tExpressionUrlAuthorizationConfigurer.this.authorizationManagerBuilder\n+\t\t\t\t\t.add(new RequestMatcherEntry<>(this.requestMatchers,\n+\t\t\t\t\t\t\tnew WebExpressionAuthorizationManager(attribute, getExpressionHandler(getBuilder()))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYxODQzNQ=="}, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMTkyMg==", "bodyText": "If the AuthorizationManager is produced from the ConfigAttribute mappings, then this line can be removed.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506621922", "createdAt": "2020-10-16T17:32:03Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/PermitAllSupport.java", "diffHunk": "@@ -53,6 +56,8 @@ static void permitAll(HttpSecurityBuilder<? extends HttpSecurityBuilder<?>> http\n \t\t\tif (matcher != null) {\n \t\t\t\tconfigurer.getRegistry().addMapping(0, new UrlMapping(matcher,\n \t\t\t\t\t\tSecurityConfig.createList(ExpressionUrlAuthorizationConfigurer.permitAll)));\n+\t\t\t\tconfigurer.authorizationManagerBuilder.add(0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyMzE0Nw==", "bodyText": "We can't actually add a parameter to an existing public method as it breaks backward compatibility.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506623147", "createdAt": "2020-10-16T17:34:01Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/UrlAuthorizationConfigurer.java", "diffHunk": "@@ -329,14 +317,31 @@ public StandardInterceptUrlRegistry anonymous() {\n \n \t\t/**\n \t\t * Specifies that the user must have the specified {@link ConfigAttribute}'s\n+\t\t * @param authorizationManager the {@link AuthorizationManager} to use\n \t\t * @param attributes the {@link ConfigAttribute}'s that restrict access to a URL\n \t\t * @return the {@link UrlAuthorizationConfigurer} for further customization\n \t\t */\n-\t\tpublic StandardInterceptUrlRegistry access(String... attributes) {\n+\t\tpublic StandardInterceptUrlRegistry access(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNTAzNA==", "bodyText": "It's important to make sure this bug fix continues to work. Instead of removing the test, could you change Sec3011Config to configure an AccessDecisionManager?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506625034", "createdAt": "2020-10-16T17:36:46Z", "author": {"login": "jzheaux"}, "path": "config/src/test/java/org/springframework/security/config/annotation/web/configurers/ExpressionUrlAuthorizationConfigurerTests.java", "diffHunk": "@@ -453,13 +447,6 @@ public void getWhenCustomExpressionHandlerAndAuthenticationNameDoesNotMatchThenR\n \t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n \t}\n \n-\t// SEC-3011", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNjI3Ng==", "bodyText": "It seems like this test should change to configureWhenNoCustomAccessDecisionManagerThenUsesFilterInvocationAuthorizationManager.\nThis test is also valuable in confirming that a post-processor can be invoked on the authorization manager.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506626276", "createdAt": "2020-10-16T17:39:09Z", "author": {"login": "jzheaux"}, "path": "config/src/test/java/org/springframework/security/config/annotation/web/configurers/ExpressionUrlAuthorizationConfigurerTests.java", "diffHunk": "@@ -91,12 +91,6 @@ public void configureWhenHasRoleStartingWithStringRoleThenException() {\n \t\t\t\t\t\t\"role should not start with 'ROLE_' since it is automatically inserted. Got 'ROLE_USER'\");\n \t}\n \n-\t@Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyOTAzMg==", "bodyText": "This seems a little odd. Why would I need to register an AccessDecisionManager in order for the AuthorizedEvent to be fired?\nIt would likely be a breaking change if applications upgraded and then events stopped firing.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506629032", "createdAt": "2020-10-16T17:43:27Z", "author": {"login": "jzheaux"}, "path": "config/src/test/java/org/springframework/security/config/annotation/web/configurers/ExpressionUrlAuthorizationConfigurerTests.java", "diffHunk": "@@ -820,6 +807,7 @@ protected void configure(HttpSecurity http) throws Exception {\n \t\t\thttp\n \t\t\t\t.authorizeRequests()\n \t\t\t\t\t.anyRequest().permitAll()\n+\t\t\t\t\t.accessDecisionManager(new AffirmativeBased(Collections.singletonList(new WebExpressionVoter())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzMjc4Nw==", "bodyText": "It makes sense why this change is necessary -- now the expression is parsed by the metadata source as well as the authorization manager. However, I'd recommend using times instead of atLeastOnce since it would be unexpected if it were called more than twice.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506632787", "createdAt": "2020-10-16T17:49:10Z", "author": {"login": "jzheaux"}, "path": "config/src/test/java/org/springframework/security/config/annotation/web/configurers/NamespaceHttpExpressionHandlerTests.java", "diffHunk": "@@ -72,7 +74,7 @@ public void getWhenHasCustomExpressionHandlerThenMatchesNamespace() throws Excep\n \t}\n \n \tprivate <T> T verifyBean(String beanName, Class<T> beanClass) {\n-\t\treturn verify(this.spring.getContext().getBean(beanName, beanClass));\n+\t\treturn verify(this.spring.getContext().getBean(beanName, beanClass), atLeastOnce());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzOTc4OA==", "bodyText": "I see that you moved these to the adapter, which is understandable since they need the collection of config attributes.\nHave you considered adding equivalent logs to FilterInvocationAuthorizationManager? It's helpful to see logs that explain the authorization context, especially reasons for authorization success of failure.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506639788", "createdAt": "2020-10-16T18:02:10Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -201,17 +212,8 @@ protected InterceptorStatusToken beforeInvocation(Object object) {\n \t\t\t\t\t\"An Authentication object was not found in the SecurityContext\"), object, attributes);\n \t\t}\n \t\tAuthentication authenticated = authenticateIfRequired();\n-\t\tif (this.logger.isTraceEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0MTc3OQ==", "bodyText": "I wonder if FilterInvocationAuthorizationManager should fire an AuthorizedEvent. I'm thinking out loud here just a bit, but the important thing to remember is that upgrading to the latest shouldn't mean your events stop firing.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506641779", "createdAt": "2020-10-16T18:06:07Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -201,17 +212,8 @@ protected InterceptorStatusToken beforeInvocation(Object object) {\n \t\t\t\t\t\"An Authentication object was not found in the SecurityContext\"), object, attributes);\n \t\t}\n \t\tAuthentication authenticated = authenticateIfRequired();\n-\t\tif (this.logger.isTraceEnabled()) {\n-\t\t\tthis.logger.trace(LogMessage.format(\"Authorizing %s with attributes %s\", object, attributes));\n-\t\t}\n \t\t// Attempt authorization\n-\t\tattemptAuthorization(object, attributes, authenticated);\n-\t\tif (this.logger.isDebugEnabled()) {\n-\t\t\tthis.logger.debug(LogMessage.format(\"Authorized %s with attributes %s\", object, attributes));\n-\t\t}\n-\t\tif (this.publishAuthorizationSuccess) {\n-\t\t\tpublishEvent(new AuthorizedEvent(object, attributes, authenticated));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0NDY1Mg==", "bodyText": "In newer APIs Spring Security checks for null in the setter. Does that work here?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506644652", "createdAt": "2020-10-16T18:11:40Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java", "diffHunk": "@@ -375,8 +379,25 @@ public boolean isValidateConfigAttributes() {\n \n \tpublic abstract SecurityMetadataSource obtainSecurityMetadataSource();\n \n+\t/**\n+\t * Sets the {@link AccessDecisionManager} instance.\n+\t * @param accessDecisionManager the {@link AccessDecisionManager} instance\n+\t * @deprecated use {@link #setAuthorizationManager(AuthorizationManager)} instead\n+\t */\n+\t@Deprecated\n \tpublic void setAccessDecisionManager(AccessDecisionManager accessDecisionManager) {\n-\t\tthis.accessDecisionManager = accessDecisionManager;\n+\t\tthis.authorizationManager = new AuthorizationManagerAdapter<>(accessDecisionManager);\n+\t}\n+\n+\t/**\n+\t * Sets the {@link AuthorizationManager} instance.\n+\t * @param authorizationManager the {@link AuthorizationManager} instance\n+\t * @throws IllegalArgumentException if an {@link AccessDecisionManager} is already set\n+\t */\n+\tpublic void setAuthorizationManager(AuthorizationManager<?> authorizationManager) {\n+\t\tAssert.isTrue(!(this.authorizationManager instanceof AuthorizationManagerAdapter),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0OTIxMA==", "bodyText": "A bit more thinking out loud, here. I wonder if AuthorizationDecision would benefit from a collection of reasons. Similar to OAuth2TokenValidatorResult, it's nice to be able to see why validation succeeded or failed.\nThe reason I'm thinking about this is that AuthorizedEvent and AuthorizedFailureEvent are both capable, through the config attributes, of saying why it succeeded or failed. It might be reasonable to add the AuthorizationDecision to the event.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506649210", "createdAt": "2020-10-16T18:20:49Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorizationDecision.java", "diffHunk": "@@ -18,10 +18,21 @@\n \n /**\n  * @author Rob Winch\n+ * @author Evgeniy Cheban\n  * @since 5.0\n  */\n public class AuthorizationDecision {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0OTg1NA==", "bodyText": "Should the tests also verify that a null authorization manager is detected?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506649854", "createdAt": "2020-10-16T18:22:12Z", "author": {"login": "jzheaux"}, "path": "core/src/test/java/org/springframework/security/access/intercept/aopalliance/MethodSecurityInterceptorTests.java", "diffHunk": "@@ -126,9 +127,9 @@ public void gettersReturnExpectedData() {\n \t}\n \n \t@Test\n-\tpublic void missingAccessDecisionManagerIsDetected() throws Exception {\n-\t\tthis.interceptor.setAccessDecisionManager(null);\n-\t\tassertThatIllegalArgumentException().isThrownBy(() -> this.interceptor.afterPropertiesSet());\n+\tpublic void missingAccessDecisionManagerIsDetected() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1MDQxOQ==", "bodyText": "To better align with the team standard, would you mind renaming these methods to methodUnderTestWhenConditionThenResult?\nFor example, this method could be instead hasRoleWhenNullThenException.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506650419", "createdAt": "2020-10-16T18:23:26Z", "author": {"login": "jzheaux"}, "path": "core/src/test/java/org/springframework/security/authorization/AuthorityAuthorizationManagerTests.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.authorization;\n+\n+import java.util.function.Supplier;\n+\n+import org.junit.Test;\n+\n+import org.springframework.security.authentication.TestingAuthenticationToken;\n+import org.springframework.security.core.Authentication;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+\n+/**\n+ * Tests for {@link AuthorityAuthorizationManager}.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public class AuthorityAuthorizationManagerTests {\n+\n+\t@Test\n+\tpublic void testWhenRoleNull() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1MDg5OQ==", "bodyText": "Is it still possible to preserve the log here? Or, is there a reason that the log is no longer needed?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506650899", "createdAt": "2020-10-16T18:24:28Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/access/DefaultWebInvocationPrivilegeEvaluator.java", "diffHunk": "@@ -91,14 +90,8 @@ public boolean isAllowed(String contextPath, String uri, String method, Authenti\n \t\tif (authentication == null) {\n \t\t\treturn false;\n \t\t}\n-\t\ttry {\n-\t\t\tthis.securityInterceptor.getAccessDecisionManager().decide(authentication, filterInvocation, attributes);\n-\t\t\treturn true;\n-\t\t}\n-\t\tcatch (AccessDeniedException ex) {\n-\t\t\tlogger.debug(LogMessage.format(\"%s denied for %s\", filterInvocation, authentication), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1Mjc0Mg==", "bodyText": "Changing the semantics in a minor release worries me a bit. Why is a null matcher a match now instead of not a match?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506652742", "createdAt": "2020-10-16T18:28:26Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/util/matcher/AntPathRequestMatcher.java", "diffHunk": "@@ -159,9 +160,14 @@ public boolean matches(HttpServletRequest request) {\n \n \t@Override\n \tpublic MatchResult matcher(HttpServletRequest request) {\n-\t\tif (this.matcher == null || !matches(request)) {\n+\t\tif (!matches(request)) {\n \t\t\treturn MatchResult.notMatch();\n \t\t}\n+\n+\t\tif (this.matcher == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1MzE2Mg==", "bodyText": "I'd recommend trying to keep the matchers the same as they are today. It might mean registering more authorization manager instances in the configurer.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r506653162", "createdAt": "2020-10-16T18:29:19Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/util/matcher/OrRequestMatcher.java", "diffHunk": "@@ -28,17 +28,18 @@\n  * {@link RequestMatcher} instances match.\n  *\n  * @author Rob Winch\n+ * @author Evgeniy Cheban\n  * @since 3.2\n  */\n public final class OrRequestMatcher implements RequestMatcher {\n \n-\tprivate final List<RequestMatcher> requestMatchers;\n+\tprivate final List<? extends RequestMatcher> requestMatchers;\n \n \t/**\n \t * Creates a new instance\n \t * @param requestMatchers the {@link RequestMatcher} instances to try\n \t */\n-\tpublic OrRequestMatcher(List<RequestMatcher> requestMatchers) {\n+\tpublic OrRequestMatcher(List<? extends RequestMatcher> requestMatchers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDY1MDEz", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-521065013", "createdAt": "2020-10-30T22:16:06Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMjoxNjowNlrOHrh4wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxODo0NToxMVrOHtlJ6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwNjAxNw==", "bodyText": "I think this is closer to what's needed, though it's not quite correct since it's going to change the precedence order. The mappings need to be processed in the order in which they were stated by the application in the DSL.\nSo, if the application does:\n.antMatchers(\"/api/**\").hasAuthority(\"API\")\n.anyRequest().access(new MyAuthorizationManager())\nThen the authorization manager needs to process them in that order.\nWith the current setup, I believe the anyRequest() would get processed by the AuthorizationManager first.\n(See my related comment on another line for additional context.)", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r515406017", "createdAt": "2020-10-30T22:16:06Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/ExpressionUrlAuthorizationConfigurer.java", "diffHunk": "@@ -126,24 +128,28 @@ private void interceptUrl(Iterable<? extends RequestMatcher> requestMatchers,\n \t\t}\n \t}\n \n-\t@Override\n-\t@SuppressWarnings(\"rawtypes\")\n-\tList<AccessDecisionVoter<?>> getDecisionVoters(H http) {\n-\t\tList<AccessDecisionVoter<?>> decisionVoters = new ArrayList<>();\n-\t\tWebExpressionVoter expressionVoter = new WebExpressionVoter();\n-\t\texpressionVoter.setExpressionHandler(getExpressionHandler(http));\n-\t\tdecisionVoters.add(expressionVoter);\n-\t\treturn decisionVoters;\n-\t}\n-\n \t@Override\n \tExpressionBasedFilterInvocationSecurityMetadataSource createMetadataSource(H http) {\n \t\tLinkedHashMap<RequestMatcher, Collection<ConfigAttribute>> requestMap = this.REGISTRY.createRequestMap();\n-\t\tAssert.state(!requestMap.isEmpty(),\n-\t\t\t\t\"At least one mapping is required (i.e. authorizeRequests().anyRequest().authenticated())\");\n \t\treturn new ExpressionBasedFilterInvocationSecurityMetadataSource(requestMap, getExpressionHandler(http));\n \t}\n \n+\t@Override\n+\tAuthorizationManager<FilterInvocation> createAuthorizationManager() {\n+\t\tfor (UrlMapping mapping : this.REGISTRY.getUrlMappings()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwNzY3Nw==", "bodyText": "I think this is just moving the parallel registry problem. Now, this registry is storing UrlMappings and RequestMatcherEntrys. This will make it tricky to remember the order that the application registered the mappings.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r515407677", "createdAt": "2020-10-30T22:22:33Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractInterceptUrlConfigurer.java", "diffHunk": "@@ -98,62 +101,62 @@ public void configure(H http) throws Exception {\n \tabstract FilterInvocationSecurityMetadataSource createMetadataSource(H http);\n \n \t/**\n-\t * Subclasses should implement this method to provide the {@link AccessDecisionVoter}\n-\t * instances used to create the default {@link AccessDecisionManager}\n-\t * @param http the builder to use\n-\t * @return the {@link AccessDecisionVoter} instances used to create the default\n-\t * {@link AccessDecisionManager}\n-\t */\n-\tabstract List<AccessDecisionVoter<?>> getDecisionVoters(H http);\n-\n-\t/**\n-\t * Creates the default {@code AccessDecisionManager}\n-\t * @return the default {@code AccessDecisionManager}\n+\t * Subclasses should implement this method to provide an {@link AuthorizationManager}\n+\t * for the {@link FilterSecurityInterceptor}.\n+\t * @return the {@link AuthorizationManager} to set on the\n+\t * {@link FilterSecurityInterceptor}. Cannot be null.\n \t */\n-\tprivate AccessDecisionManager createDefaultAccessDecisionManager(H http) {\n-\t\tAffirmativeBased result = new AffirmativeBased(getDecisionVoters(http));\n-\t\treturn postProcess(result);\n-\t}\n-\n-\t/**\n-\t * If currently null, creates a default {@link AccessDecisionManager} using\n-\t * {@link #createDefaultAccessDecisionManager(HttpSecurityBuilder)}. Otherwise returns\n-\t * the {@link AccessDecisionManager}.\n-\t * @param http the builder to use\n-\t * @return the {@link AccessDecisionManager} to use\n-\t */\n-\tprivate AccessDecisionManager getAccessDecisionManager(H http) {\n-\t\tif (this.accessDecisionManager == null) {\n-\t\t\tthis.accessDecisionManager = createDefaultAccessDecisionManager(http);\n-\t\t}\n-\t\treturn this.accessDecisionManager;\n-\t}\n+\tabstract AuthorizationManager<FilterInvocation> createAuthorizationManager();\n \n \t/**\n \t * Creates the {@link FilterSecurityInterceptor}\n-\t * @param http the builder to use\n \t * @param metadataSource the {@link FilterInvocationSecurityMetadataSource} to use\n \t * @param authenticationManager the {@link AuthenticationManager} to use\n \t * @return the {@link FilterSecurityInterceptor}\n \t * @throws Exception\n \t */\n-\tprivate FilterSecurityInterceptor createFilterSecurityInterceptor(H http,\n+\tprivate FilterSecurityInterceptor createFilterSecurityInterceptor(\n \t\t\tFilterInvocationSecurityMetadataSource metadataSource, AuthenticationManager authenticationManager)\n \t\t\tthrows Exception {\n \t\tFilterSecurityInterceptor securityInterceptor = new FilterSecurityInterceptor();\n \t\tsecurityInterceptor.setSecurityMetadataSource(metadataSource);\n-\t\tsecurityInterceptor.setAccessDecisionManager(getAccessDecisionManager(http));\n \t\tsecurityInterceptor.setAuthenticationManager(authenticationManager);\n+\t\tif (this.accessDecisionManager != null) {\n+\t\t\tsecurityInterceptor.setAccessDecisionManager(this.accessDecisionManager);\n+\t\t}\n+\t\telse {\n+\t\t\tsecurityInterceptor.setAuthorizationManager(createAuthorizationManager());\n+\t\t}\n \t\tsecurityInterceptor.afterPropertiesSet();\n \t\treturn securityInterceptor;\n \t}\n \n \tpublic abstract class AbstractInterceptUrlRegistry<R extends AbstractInterceptUrlRegistry<R, T>, T>\n \t\t\textends AbstractConfigAttributeRequestMatcherRegistry<T> {\n \n+\t\tprivate final FilterInvocationAuthorizationManager.Builder managerBuilder = FilterInvocationAuthorizationManager\n+\t\t\t\t.builder();\n+\n \t\tAbstractInterceptUrlRegistry() {\n \t\t}\n \n+\t\tfinal void addMapping(Iterable<? extends RequestMatcher> requestMatchers,\n+\t\t\t\tAuthorizationManager<FilterInvocationAuthorizationContext> authorizationManager) {\n+\t\t\tfor (RequestMatcher requestMatcher : requestMatchers) {\n+\t\t\t\taddMapping(requestMatcher, authorizationManager);\n+\t\t\t}\n+\t\t\tresetUnmappedMatchers();\n+\t\t}\n+\n+\t\tfinal void addMapping(RequestMatcher requestMatcher,\n+\t\t\t\tAuthorizationManager<FilterInvocationAuthorizationContext> authorizationManager) {\n+\t\t\tthis.managerBuilder.add(new RequestMatcherEntry<>(requestMatcher, authorizationManager));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU1NDE0Mw==", "bodyText": "One option might be to change WebExpressionAuthorizationManager's ExpressionHandler into a setter so that it can be post-processed by createAuthorizationManager. WebExpressionAuthorizationManager would use DefaultWebSecurityExpressionHandler by default, but would be updated by createAuthorizationManager.\nThen, while there is still parallel registration, at least the user's expression handler configuration doesn't get missed and the authorization manager would get all the rules in the right order.\nAnother option feels pretty hacky, but it would be to introduce a private class called AuthorizationManagerConfigAttribute that holds onto both items. Then this registry could hold onto config attributes and authorization managers in the same map. This has one minor benefit of removing the resetUnmappedMatchers method.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r517554143", "createdAt": "2020-11-04T18:40:37Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractInterceptUrlConfigurer.java", "diffHunk": "@@ -98,62 +101,62 @@ public void configure(H http) throws Exception {\n \tabstract FilterInvocationSecurityMetadataSource createMetadataSource(H http);\n \n \t/**\n-\t * Subclasses should implement this method to provide the {@link AccessDecisionVoter}\n-\t * instances used to create the default {@link AccessDecisionManager}\n-\t * @param http the builder to use\n-\t * @return the {@link AccessDecisionVoter} instances used to create the default\n-\t * {@link AccessDecisionManager}\n-\t */\n-\tabstract List<AccessDecisionVoter<?>> getDecisionVoters(H http);\n-\n-\t/**\n-\t * Creates the default {@code AccessDecisionManager}\n-\t * @return the default {@code AccessDecisionManager}\n+\t * Subclasses should implement this method to provide an {@link AuthorizationManager}\n+\t * for the {@link FilterSecurityInterceptor}.\n+\t * @return the {@link AuthorizationManager} to set on the\n+\t * {@link FilterSecurityInterceptor}. Cannot be null.\n \t */\n-\tprivate AccessDecisionManager createDefaultAccessDecisionManager(H http) {\n-\t\tAffirmativeBased result = new AffirmativeBased(getDecisionVoters(http));\n-\t\treturn postProcess(result);\n-\t}\n-\n-\t/**\n-\t * If currently null, creates a default {@link AccessDecisionManager} using\n-\t * {@link #createDefaultAccessDecisionManager(HttpSecurityBuilder)}. Otherwise returns\n-\t * the {@link AccessDecisionManager}.\n-\t * @param http the builder to use\n-\t * @return the {@link AccessDecisionManager} to use\n-\t */\n-\tprivate AccessDecisionManager getAccessDecisionManager(H http) {\n-\t\tif (this.accessDecisionManager == null) {\n-\t\t\tthis.accessDecisionManager = createDefaultAccessDecisionManager(http);\n-\t\t}\n-\t\treturn this.accessDecisionManager;\n-\t}\n+\tabstract AuthorizationManager<FilterInvocation> createAuthorizationManager();\n \n \t/**\n \t * Creates the {@link FilterSecurityInterceptor}\n-\t * @param http the builder to use\n \t * @param metadataSource the {@link FilterInvocationSecurityMetadataSource} to use\n \t * @param authenticationManager the {@link AuthenticationManager} to use\n \t * @return the {@link FilterSecurityInterceptor}\n \t * @throws Exception\n \t */\n-\tprivate FilterSecurityInterceptor createFilterSecurityInterceptor(H http,\n+\tprivate FilterSecurityInterceptor createFilterSecurityInterceptor(\n \t\t\tFilterInvocationSecurityMetadataSource metadataSource, AuthenticationManager authenticationManager)\n \t\t\tthrows Exception {\n \t\tFilterSecurityInterceptor securityInterceptor = new FilterSecurityInterceptor();\n \t\tsecurityInterceptor.setSecurityMetadataSource(metadataSource);\n-\t\tsecurityInterceptor.setAccessDecisionManager(getAccessDecisionManager(http));\n \t\tsecurityInterceptor.setAuthenticationManager(authenticationManager);\n+\t\tif (this.accessDecisionManager != null) {\n+\t\t\tsecurityInterceptor.setAccessDecisionManager(this.accessDecisionManager);\n+\t\t}\n+\t\telse {\n+\t\t\tsecurityInterceptor.setAuthorizationManager(createAuthorizationManager());\n+\t\t}\n \t\tsecurityInterceptor.afterPropertiesSet();\n \t\treturn securityInterceptor;\n \t}\n \n \tpublic abstract class AbstractInterceptUrlRegistry<R extends AbstractInterceptUrlRegistry<R, T>, T>\n \t\t\textends AbstractConfigAttributeRequestMatcherRegistry<T> {\n \n+\t\tprivate final FilterInvocationAuthorizationManager.Builder managerBuilder = FilterInvocationAuthorizationManager\n+\t\t\t\t.builder();\n+\n \t\tAbstractInterceptUrlRegistry() {\n \t\t}\n \n+\t\tfinal void addMapping(Iterable<? extends RequestMatcher> requestMatchers,\n+\t\t\t\tAuthorizationManager<FilterInvocationAuthorizationContext> authorizationManager) {\n+\t\t\tfor (RequestMatcher requestMatcher : requestMatchers) {\n+\t\t\t\taddMapping(requestMatcher, authorizationManager);\n+\t\t\t}\n+\t\t\tresetUnmappedMatchers();\n+\t\t}\n+\n+\t\tfinal void addMapping(RequestMatcher requestMatcher,\n+\t\t\t\tAuthorizationManager<FilterInvocationAuthorizationContext> authorizationManager) {\n+\t\t\tthis.managerBuilder.add(new RequestMatcherEntry<>(requestMatcher, authorizationManager));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwNzY3Nw=="}, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU1NjcxMw==", "bodyText": "Yes, I like this idea of building ConfigAttributes from AuthorizationDecision reasons. For now, let's try and leave the changes to AuthorizedEvent, etc. out of this PR. Those things that are firing the events can produce a collection of ConfigAttributes instead.\nIf that works well, you might consider re-consolidating the logging and event-throwing logic back into AbstractSecurityInterceptor. One reason this would be nice is it would prevent having to have the publishAuthorizationSuccess configuration in multiple places.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r517556713", "createdAt": "2020-11-04T18:45:11Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorizationDecision.java", "diffHunk": "@@ -18,10 +18,21 @@\n \n /**\n  * @author Rob Winch\n+ * @author Evgeniy Cheban\n  * @since 5.0\n  */\n public class AuthorizationDecision {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0OTIxMA=="}, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MTAwMjAz", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-545100203", "createdAt": "2020-12-04T16:16:56Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjoxNjo1NlrOH_X59w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNzoyMzoxOFrOH_acOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNDAwNw==", "bodyText": "Since this is a new class, I think it would be better to publish the chain as a bean instead:\n@EnableWebSecurity\nstatic class IncompleteMappingConfig {\n    @Bean \n    public SecurityFilterChain filterChain(HttpSecurity http)  throws Exception {\n        // ...\n    }\n}", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536214007", "createdAt": "2020-12-04T16:16:56Z", "author": {"login": "jzheaux"}, "path": "config/src/test/java/org/springframework/security/config/annotation/web/configurers/AuthorizeHttpRequestsConfigurerTests.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.config.annotation.web.configurers;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.config.annotation.ObjectPostProcessor;\n+import org.springframework.security.config.annotation.web.AbstractRequestMatcherRegistry;\n+import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n+import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n+import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n+import org.springframework.security.config.test.SpringTestRule;\n+import org.springframework.security.core.authority.SimpleGrantedAuthority;\n+import org.springframework.security.web.access.intercept.AuthorizationFilter;\n+import org.springframework.security.web.access.intercept.DelegatingAuthorizationManager;\n+import org.springframework.security.web.access.intercept.RequestAuthorizationContext;\n+import org.springframework.test.web.servlet.MockMvc;\n+import org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+import org.springframework.web.servlet.config.annotation.EnableWebMvc;\n+\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.security.config.Customizer.withDefaults;\n+import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;\n+import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.user;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+/**\n+ * Tests for {@link AuthorizeHttpRequestsConfigurer}.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public class AuthorizeHttpRequestsConfigurerTests {\n+\n+\t@Rule\n+\tpublic final SpringTestRule spring = new SpringTestRule();\n+\n+\t@Autowired\n+\tMockMvc mvc;\n+\n+\t@Test\n+\tpublic void configureWhenAnyRequestIncompleteMappingThenException() {\n+\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\t\t\t.isThrownBy(() -> this.spring.register(IncompleteMappingConfig.class).autowire())\n+\t\t\t\t.withMessageContaining(\"An incomplete mapping was found for \");\n+\t}\n+\n+\t@Test\n+\tpublic void configureWhenMvcMatcherAfterAnyRequestThenException() {\n+\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\t\t\t.isThrownBy(() -> this.spring.register(AfterAnyRequestConfig.class).autowire())\n+\t\t\t\t.withMessageContaining(\"Can't configure mvcMatchers after anyRequest\");\n+\t}\n+\n+\t@Test\n+\tpublic void configureMvcMatcherAccessAuthorizationManagerWhenNotNullThenVerifyUse() throws Exception {\n+\t\tCustomAuthorizationManagerConfig.authorizationManager = mock(AuthorizationManager.class);\n+\t\tthis.spring.register(CustomAuthorizationManagerConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isOk());\n+\t\tverify(CustomAuthorizationManagerConfig.authorizationManager).check(any(), any());\n+\t}\n+\n+\t@Test\n+\tpublic void configureMvcMatcherAccessAuthorizationManagerWhenNullThenException() {\n+\t\tCustomAuthorizationManagerConfig.authorizationManager = null;\n+\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\t\t\t.isThrownBy(() -> this.spring.register(CustomAuthorizationManagerConfig.class).autowire())\n+\t\t\t\t.withMessageContaining(\"manager cannot be null\");\n+\t}\n+\n+\t@Test\n+\tpublic void configureWhenObjectPostProcessorRegisteredThenInvokedOnAuthorizationManagerAndAuthorizationFilter() {\n+\t\tthis.spring.register(ObjectPostProcessorConfig.class).autowire();\n+\t\tverify(ObjectPostProcessorConfig.objectPostProcessor).postProcess(any(DelegatingAuthorizationManager.class));\n+\t\tverify(ObjectPostProcessorConfig.objectPostProcessor).postProcess(any(AuthorizationFilter.class));\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyAuthorityRoleUserConfiguredAndAuthorityIsRoleUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserAnyAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_USER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyAuthorityRoleUserConfiguredAndAuthorityIsRoleAdminThenRespondsWithForbidden()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(RoleUserAnyAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_ADMIN\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyAuthorityRoleUserConfiguredAndNoAuthorityThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(RoleUserAnyAuthorityConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAuthorityRoleUserConfiguredAndAuthorityIsRoleUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_USER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAuthorityRoleUserConfiguredAndAuthorityIsRoleAdminThenRespondsWithForbidden()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(RoleUserAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_ADMIN\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAuthorityRoleUserConfiguredAndNoAuthorityThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(RoleUserAuthorityConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminRequiredAndAuthorityIsRoleUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_USER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminRequiredAndAuthorityIsRoleAdminThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_ADMIN\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminRequiredAndAuthorityIsRoleOtherThenRespondsWithForbidden()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_OTHER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminAuthRequiredAndNoUserThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyRoleUserConfiguredAndRoleIsUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyRoleUserConfiguredAndRoleIsAdminThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(RoleUserConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"ADMIN\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenRoleUserOrAdminConfiguredAndRoleIsUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrAdminConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenRoleUserOrAdminConfiguredAndRoleIsAdminThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrAdminConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"ADMIN\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenRoleUserOrAdminConfiguredAndRoleIsOtherThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(RoleUserOrAdminConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithRoleOther = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"OTHER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithRoleOther).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenDenyAllConfiguredAndNoUserThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(DenyAllConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWheDenyAllConfiguredAndUserLoggedInThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(DenyAllConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenPermitAllConfiguredAndNoUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(PermitAllConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhePermitAllConfiguredAndUserLoggedInThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(DenyAllConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void authorizeHttpRequestsWhenInvokedTwiceThenUsesOriginalConfiguration() throws Exception {\n+\t\tthis.spring.register(InvokeTwiceDoesNotResetConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(post(\"/\").with(csrf())).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenServletPathRoleAdminConfiguredAndRoleIsUserThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(ServletPathConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/spring/\")\n+\t\t\t\t.servletPath(\"/spring\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenServletPathRoleAdminConfiguredAndRoleIsUserAndWithoutServletPathThenRespondsWithOk()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(ServletPathConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenServletPathRoleAdminConfiguredAndRoleIsAdminThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(ServletPathConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/spring/\")\n+\t\t\t\t.servletPath(\"/spring\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"ADMIN\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAnyRequestAuthenticatedConfiguredAndNoUserThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(AuthenticatedConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAnyRequestAuthenticatedConfiguredAndUserLoggedInThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(AuthenticatedConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@EnableWebSecurity\n+\tstatic class IncompleteMappingConfig extends WebSecurityConfigurerAdapter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNTIzOA==", "bodyText": "As a team, we're moving the format towards:\nhttp\n    .authorizeHttpRequests((requests) -> requests\n        .anyRequest().authenticated()\n        .mvcMatchers(\"/path\").hasRole(\"USER\")\n    );\nSince this is a new class, would you please use this updated format?", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536215238", "createdAt": "2020-12-04T16:18:26Z", "author": {"login": "jzheaux"}, "path": "config/src/test/java/org/springframework/security/config/annotation/web/configurers/AuthorizeHttpRequestsConfigurerTests.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.config.annotation.web.configurers;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.springframework.beans.factory.BeanCreationException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.config.annotation.ObjectPostProcessor;\n+import org.springframework.security.config.annotation.web.AbstractRequestMatcherRegistry;\n+import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n+import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n+import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n+import org.springframework.security.config.test.SpringTestRule;\n+import org.springframework.security.core.authority.SimpleGrantedAuthority;\n+import org.springframework.security.web.access.intercept.AuthorizationFilter;\n+import org.springframework.security.web.access.intercept.DelegatingAuthorizationManager;\n+import org.springframework.security.web.access.intercept.RequestAuthorizationContext;\n+import org.springframework.test.web.servlet.MockMvc;\n+import org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+import org.springframework.web.servlet.config.annotation.EnableWebMvc;\n+\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.security.config.Customizer.withDefaults;\n+import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;\n+import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.user;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+/**\n+ * Tests for {@link AuthorizeHttpRequestsConfigurer}.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public class AuthorizeHttpRequestsConfigurerTests {\n+\n+\t@Rule\n+\tpublic final SpringTestRule spring = new SpringTestRule();\n+\n+\t@Autowired\n+\tMockMvc mvc;\n+\n+\t@Test\n+\tpublic void configureWhenAnyRequestIncompleteMappingThenException() {\n+\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\t\t\t.isThrownBy(() -> this.spring.register(IncompleteMappingConfig.class).autowire())\n+\t\t\t\t.withMessageContaining(\"An incomplete mapping was found for \");\n+\t}\n+\n+\t@Test\n+\tpublic void configureWhenMvcMatcherAfterAnyRequestThenException() {\n+\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\t\t\t.isThrownBy(() -> this.spring.register(AfterAnyRequestConfig.class).autowire())\n+\t\t\t\t.withMessageContaining(\"Can't configure mvcMatchers after anyRequest\");\n+\t}\n+\n+\t@Test\n+\tpublic void configureMvcMatcherAccessAuthorizationManagerWhenNotNullThenVerifyUse() throws Exception {\n+\t\tCustomAuthorizationManagerConfig.authorizationManager = mock(AuthorizationManager.class);\n+\t\tthis.spring.register(CustomAuthorizationManagerConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isOk());\n+\t\tverify(CustomAuthorizationManagerConfig.authorizationManager).check(any(), any());\n+\t}\n+\n+\t@Test\n+\tpublic void configureMvcMatcherAccessAuthorizationManagerWhenNullThenException() {\n+\t\tCustomAuthorizationManagerConfig.authorizationManager = null;\n+\t\tassertThatExceptionOfType(BeanCreationException.class)\n+\t\t\t\t.isThrownBy(() -> this.spring.register(CustomAuthorizationManagerConfig.class).autowire())\n+\t\t\t\t.withMessageContaining(\"manager cannot be null\");\n+\t}\n+\n+\t@Test\n+\tpublic void configureWhenObjectPostProcessorRegisteredThenInvokedOnAuthorizationManagerAndAuthorizationFilter() {\n+\t\tthis.spring.register(ObjectPostProcessorConfig.class).autowire();\n+\t\tverify(ObjectPostProcessorConfig.objectPostProcessor).postProcess(any(DelegatingAuthorizationManager.class));\n+\t\tverify(ObjectPostProcessorConfig.objectPostProcessor).postProcess(any(AuthorizationFilter.class));\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyAuthorityRoleUserConfiguredAndAuthorityIsRoleUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserAnyAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_USER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyAuthorityRoleUserConfiguredAndAuthorityIsRoleAdminThenRespondsWithForbidden()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(RoleUserAnyAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_ADMIN\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyAuthorityRoleUserConfiguredAndNoAuthorityThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(RoleUserAnyAuthorityConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAuthorityRoleUserConfiguredAndAuthorityIsRoleUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_USER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAuthorityRoleUserConfiguredAndAuthorityIsRoleAdminThenRespondsWithForbidden()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(RoleUserAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_ADMIN\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAuthorityRoleUserConfiguredAndNoAuthorityThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(RoleUserAuthorityConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminRequiredAndAuthorityIsRoleUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_USER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminRequiredAndAuthorityIsRoleAdminThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_ADMIN\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminRequiredAndAuthorityIsRoleOtherThenRespondsWithForbidden()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.authorities(new SimpleGrantedAuthority(\"ROLE_OTHER\")));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAuthorityRoleUserOrAdminAuthRequiredAndNoUserThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(RoleUserOrRoleAdminAuthorityConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyRoleUserConfiguredAndRoleIsUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenHasAnyRoleUserConfiguredAndRoleIsAdminThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(RoleUserConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"ADMIN\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenRoleUserOrAdminConfiguredAndRoleIsUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrAdminConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenRoleUserOrAdminConfiguredAndRoleIsAdminThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(RoleUserOrAdminConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithAdmin = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"ADMIN\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithAdmin).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenRoleUserOrAdminConfiguredAndRoleIsOtherThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(RoleUserOrAdminConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithRoleOther = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"OTHER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithRoleOther).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenDenyAllConfiguredAndNoUserThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(DenyAllConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWheDenyAllConfiguredAndUserLoggedInThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(DenyAllConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenPermitAllConfiguredAndNoUserThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(PermitAllConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhePermitAllConfiguredAndUserLoggedInThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(DenyAllConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void authorizeHttpRequestsWhenInvokedTwiceThenUsesOriginalConfiguration() throws Exception {\n+\t\tthis.spring.register(InvokeTwiceDoesNotResetConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(post(\"/\").with(csrf())).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenServletPathRoleAdminConfiguredAndRoleIsUserThenRespondsWithForbidden() throws Exception {\n+\t\tthis.spring.register(ServletPathConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/spring/\")\n+\t\t\t\t.servletPath(\"/spring\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isForbidden());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenServletPathRoleAdminConfiguredAndRoleIsUserAndWithoutServletPathThenRespondsWithOk()\n+\t\t\tthrows Exception {\n+\t\tthis.spring.register(ServletPathConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenServletPathRoleAdminConfiguredAndRoleIsAdminThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(ServletPathConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/spring/\")\n+\t\t\t\t.servletPath(\"/spring\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"ADMIN\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAnyRequestAuthenticatedConfiguredAndNoUserThenRespondsWithUnauthorized() throws Exception {\n+\t\tthis.spring.register(AuthenticatedConfig.class, BasicController.class).autowire();\n+\t\tthis.mvc.perform(get(\"/\")).andExpect(status().isUnauthorized());\n+\t}\n+\n+\t@Test\n+\tpublic void getWhenAnyRequestAuthenticatedConfiguredAndUserLoggedInThenRespondsWithOk() throws Exception {\n+\t\tthis.spring.register(AuthenticatedConfig.class, BasicController.class).autowire();\n+\t\t// @formatter:off\n+\t\tMockHttpServletRequestBuilder requestWithUser = get(\"/\")\n+\t\t\t\t.with(user(\"user\")\n+\t\t\t\t.roles(\"USER\"));\n+\t\t// @formatter:on\n+\t\tthis.mvc.perform(requestWithUser).andExpect(status().isOk());\n+\t}\n+\n+\t@EnableWebSecurity\n+\tstatic class IncompleteMappingConfig extends WebSecurityConfigurerAdapter {\n+\n+\t\t@Override\n+\t\tprotected void configure(HttpSecurity http) throws Exception {\n+\t\t\t// @formatter:off\n+\t\t\thttp\n+\t\t\t\t.authorizeHttpRequests(AbstractRequestMatcherRegistry::anyRequest);\n+\t\t\t// @formatter:on\n+\t\t}\n+\n+\t}\n+\n+\t@EnableWebSecurity\n+\tstatic class AfterAnyRequestConfig extends WebSecurityConfigurerAdapter {\n+\n+\t\t@Override\n+\t\tprotected void configure(HttpSecurity http) throws Exception {\n+\t\t\t// @formatter:off\n+\t\t\thttp\n+\t\t\t\t.authorizeHttpRequests((authorizeHttpRequests) ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxOTUzNQ==", "bodyText": "Let's try and leave these constants out for now. We'll have another ticket shortly to flesh out how to transmit failure reasons, and that may affect how these get exposed.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536219535", "createdAt": "2020-12-04T16:24:54Z", "author": {"login": "jzheaux"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorizationDecision.java", "diffHunk": "@@ -18,16 +18,35 @@\n \n /**\n  * @author Rob Winch\n+ * @author Evgeniy Cheban\n  * @since 5.0\n  */\n public class AuthorizationDecision {\n \n+\t/**\n+\t * Granted {@link AuthorizationDecision}.\n+\t */\n+\tpublic static final AuthorizationDecision GRANTED = new AuthorizationDecision(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIyMTcwMw==", "bodyText": "To reduce indentation, I wonder if something like this would be more readable:\nTestingAuthenticationToken authentication = new TestingAuthenticationToken(\"user\", \"password\",\n\t\t\"ROLE_ADMIN\", \"ROLE_USER\");\nauthentication.setAuthenticated(false);\nObject object = new Object();\nassertThat(manager.check(() -> authentication, object).isGranted()).isFalse();", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536221703", "createdAt": "2020-12-04T16:27:38Z", "author": {"login": "jzheaux"}, "path": "core/src/test/java/org/springframework/security/authorization/AuthenticatedAuthorizationManagerTests.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.authorization;\n+\n+import java.util.function.Supplier;\n+\n+import org.junit.Test;\n+\n+import org.springframework.security.authentication.AnonymousAuthenticationToken;\n+import org.springframework.security.authentication.TestingAuthenticationToken;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.authority.AuthorityUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * Tests for {@link AuthenticatedAuthorizationManager}.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public class AuthenticatedAuthorizationManagerTests {\n+\n+\t@Test\n+\tpublic void authenticatedWhenUserNotAnonymousAndAuthenticatedThenGrantedDecision() {\n+\t\tAuthenticatedAuthorizationManager<Object> manager = AuthenticatedAuthorizationManager.authenticated();\n+\t\tSupplier<Authentication> authentication = () -> new TestingAuthenticationToken(\"user\", \"password\", \"ROLE_ADMIN\",\n+\t\t\t\t\"ROLE_USER\");\n+\t\tObject object = new Object();\n+\n+\t\tassertThat(manager.check(authentication, object).isGranted()).isTrue();\n+\t}\n+\n+\t@Test\n+\tpublic void authenticatedWhenUserNullThenDeniedDecision() {\n+\t\tAuthenticatedAuthorizationManager<Object> manager = AuthenticatedAuthorizationManager.authenticated();\n+\t\tSupplier<Authentication> authentication = () -> null;\n+\t\tObject object = new Object();\n+\n+\t\tassertThat(manager.check(authentication, object).isGranted()).isFalse();\n+\t}\n+\n+\t@Test\n+\tpublic void authenticatedWhenUserAnonymousThenDeniedDecision() {\n+\t\tAuthenticatedAuthorizationManager<Object> manager = AuthenticatedAuthorizationManager.authenticated();\n+\t\tSupplier<Authentication> authentication = () -> new AnonymousAuthenticationToken(\"key\", \"principal\",\n+\t\t\t\tAuthorityUtils.createAuthorityList(\"ROLE_ANONYMOUS\"));\n+\t\tObject object = new Object();\n+\n+\t\tassertThat(manager.check(authentication, object).isGranted()).isFalse();\n+\t}\n+\n+\t@Test\n+\tpublic void authenticatedWhenUserNotAuthenticatedThenDeniedDecision() {\n+\t\tAuthenticatedAuthorizationManager<Object> manager = AuthenticatedAuthorizationManager.authenticated();\n+\t\tSupplier<Authentication> authentication = () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIzMTI5MA==", "bodyText": "I think this PR could be simplified by removing RequestMatcherEntry.\nWhile having a joint class on the reactive side is helpful, it doesn't end up simplifying the imperative side.\nThe result is that this class will use a LinkedHashMap and this method will take two parameters instead of one.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536231290", "createdAt": "2020-12-04T16:42:09Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/access/intercept/DelegatingAuthorizationManager.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.web.access.intercept;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import org.springframework.core.log.LogMessage;\n+import org.springframework.security.authorization.AuthorizationDecision;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.web.util.matcher.RequestMatcher;\n+import org.springframework.security.web.util.matcher.RequestMatcher.MatchResult;\n+import org.springframework.security.web.util.matcher.RequestMatcherEntry;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * An {@link AuthorizationManager} which delegates to a specific\n+ * {@link AuthorizationManager} based on a {@link RequestMatcher} evaluation.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public final class DelegatingAuthorizationManager implements AuthorizationManager<HttpServletRequest> {\n+\n+\tprivate final Log logger = LogFactory.getLog(getClass());\n+\n+\tprivate final List<RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>>> mappings;\n+\n+\tprivate DelegatingAuthorizationManager(\n+\t\t\tList<RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>>> mappings) {\n+\t\tAssert.notEmpty(mappings, \"mappings cannot be empty\");\n+\t\tAssert.noNullElements(mappings, \"mappings cannot contain null values\");\n+\t\tthis.mappings = mappings;\n+\t}\n+\n+\t/**\n+\t * Delegates to a specific {@link AuthorizationManager} based on a\n+\t * {@link RequestMatcher} evaluation.\n+\t * @param authentication the {@link Supplier} of the {@link Authentication} to check\n+\t * @param request the {@link HttpServletRequest} to check\n+\t * @return an {@link AuthorizationDecision}. If there is no {@link RequestMatcher}\n+\t * matching the request, or the {@link AuthorizationManager} could not decide, then\n+\t * null is returned\n+\t */\n+\t@Override\n+\tpublic AuthorizationDecision check(Supplier<Authentication> authentication, HttpServletRequest request) {\n+\t\tif (this.logger.isTraceEnabled()) {\n+\t\t\tthis.logger.trace(LogMessage.format(\"Authorizing %s\", request));\n+\t\t}\n+\t\tfor (RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>> mapping : this.mappings) {\n+\t\t\tRequestMatcher matcher = mapping.getMatcher();\n+\t\t\tMatchResult matchResult = matcher.matcher(request);\n+\t\t\tif (matchResult.isMatch()) {\n+\t\t\t\tAuthorizationManager<RequestAuthorizationContext> manager = mapping.getEntry();\n+\t\t\t\tif (this.logger.isTraceEnabled()) {\n+\t\t\t\t\tthis.logger.trace(LogMessage.format(\"Checking authorization on %s using %s\", request, manager));\n+\t\t\t\t}\n+\t\t\t\treturn manager.check(authentication,\n+\t\t\t\t\t\tnew RequestAuthorizationContext(request, matchResult.getVariables()));\n+\t\t\t}\n+\t\t}\n+\t\tthis.logger.trace(\"Did not find RequestMatcher that match the request returned null\");\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates a builder for {@link DelegatingAuthorizationManager}.\n+\t * @return the new {@link Builder} instance\n+\t */\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * A builder for {@link DelegatingAuthorizationManager}.\n+\t */\n+\tpublic static final class Builder {\n+\n+\t\tprivate final List<RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>>> mappings = new ArrayList<>();\n+\n+\t\t/**\n+\t\t * Adds a {@link RequestMatcherEntry}.\n+\t\t * @param entry the {@link RequestMatcher} to add\n+\t\t * @return the {@link Builder} for further customizations\n+\t\t */\n+\t\tpublic Builder add(RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>> entry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0NzM5NA==", "bodyText": "Let's rephrase to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tthis.logger.trace(\"Did not find RequestMatcher that match the request returned null\");\n          \n          \n            \n            \t\tthis.logger.trace(\"Abstaining since did not find matching RequestMatcher\")", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536247394", "createdAt": "2020-12-04T17:08:35Z", "author": {"login": "jzheaux"}, "path": "web/src/main/java/org/springframework/security/web/access/intercept/DelegatingAuthorizationManager.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.web.access.intercept;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import org.springframework.core.log.LogMessage;\n+import org.springframework.security.authorization.AuthorizationDecision;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.web.util.matcher.RequestMatcher;\n+import org.springframework.security.web.util.matcher.RequestMatcher.MatchResult;\n+import org.springframework.security.web.util.matcher.RequestMatcherEntry;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * An {@link AuthorizationManager} which delegates to a specific\n+ * {@link AuthorizationManager} based on a {@link RequestMatcher} evaluation.\n+ *\n+ * @author Evgeniy Cheban\n+ */\n+public final class DelegatingAuthorizationManager implements AuthorizationManager<HttpServletRequest> {\n+\n+\tprivate final Log logger = LogFactory.getLog(getClass());\n+\n+\tprivate final List<RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>>> mappings;\n+\n+\tprivate DelegatingAuthorizationManager(\n+\t\t\tList<RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>>> mappings) {\n+\t\tAssert.notEmpty(mappings, \"mappings cannot be empty\");\n+\t\tAssert.noNullElements(mappings, \"mappings cannot contain null values\");\n+\t\tthis.mappings = mappings;\n+\t}\n+\n+\t/**\n+\t * Delegates to a specific {@link AuthorizationManager} based on a\n+\t * {@link RequestMatcher} evaluation.\n+\t * @param authentication the {@link Supplier} of the {@link Authentication} to check\n+\t * @param request the {@link HttpServletRequest} to check\n+\t * @return an {@link AuthorizationDecision}. If there is no {@link RequestMatcher}\n+\t * matching the request, or the {@link AuthorizationManager} could not decide, then\n+\t * null is returned\n+\t */\n+\t@Override\n+\tpublic AuthorizationDecision check(Supplier<Authentication> authentication, HttpServletRequest request) {\n+\t\tif (this.logger.isTraceEnabled()) {\n+\t\t\tthis.logger.trace(LogMessage.format(\"Authorizing %s\", request));\n+\t\t}\n+\t\tfor (RequestMatcherEntry<AuthorizationManager<RequestAuthorizationContext>> mapping : this.mappings) {\n+\t\t\tRequestMatcher matcher = mapping.getMatcher();\n+\t\t\tMatchResult matchResult = matcher.matcher(request);\n+\t\t\tif (matchResult.isMatch()) {\n+\t\t\t\tAuthorizationManager<RequestAuthorizationContext> manager = mapping.getEntry();\n+\t\t\t\tif (this.logger.isTraceEnabled()) {\n+\t\t\t\t\tthis.logger.trace(LogMessage.format(\"Checking authorization on %s using %s\", request, manager));\n+\t\t\t\t}\n+\t\t\t\treturn manager.check(authentication,\n+\t\t\t\t\t\tnew RequestAuthorizationContext(request, matchResult.getVariables()));\n+\t\t\t}\n+\t\t}\n+\t\tthis.logger.trace(\"Did not find RequestMatcher that match the request returned null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI1NTU0Nw==", "bodyText": "While the DelegatingAuthorizationManager constructor will make sure there is at least one mapping, it might be helpful to the end user to see a more contextual error here like:\nAt least one mapping is required (for example, authorizeHttpRequests().anyRequest().authenticated())\n\nThis is similar to the error message thrown with authorizeRequests.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r536255547", "createdAt": "2020-12-04T17:23:18Z", "author": {"login": "jzheaux"}, "path": "config/src/main/java/org/springframework/security/config/annotation/web/configurers/AuthorizeHttpRequestsConfigurer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.config.annotation.web.configurers;\n+\n+import java.util.List;\n+\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.security.authorization.AuthenticatedAuthorizationManager;\n+import org.springframework.security.authorization.AuthorityAuthorizationManager;\n+import org.springframework.security.authorization.AuthorizationDecision;\n+import org.springframework.security.authorization.AuthorizationManager;\n+import org.springframework.security.config.annotation.ObjectPostProcessor;\n+import org.springframework.security.config.annotation.SecurityBuilder;\n+import org.springframework.security.config.annotation.web.AbstractRequestMatcherRegistry;\n+import org.springframework.security.config.annotation.web.HttpSecurityBuilder;\n+import org.springframework.security.web.access.intercept.AuthorizationFilter;\n+import org.springframework.security.web.access.intercept.DelegatingAuthorizationManager;\n+import org.springframework.security.web.access.intercept.RequestAuthorizationContext;\n+import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;\n+import org.springframework.security.web.util.matcher.RequestMatcher;\n+import org.springframework.security.web.util.matcher.RequestMatcherEntry;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * Adds a URL based authorization using {@link AuthorizationManager}.\n+ *\n+ * @param <H> the type of {@link HttpSecurityBuilder} that is being configured\n+ * @author Evgeniy Cheban\n+ */\n+public final class AuthorizeHttpRequestsConfigurer<H extends HttpSecurityBuilder<H>>\n+\t\textends AbstractHttpConfigurer<AuthorizeHttpRequestsConfigurer<H>, H> {\n+\n+\tprivate final AuthorizationManagerRequestMatcherRegistry registry;\n+\n+\t/**\n+\t * Creates an instance.\n+\t * @param context the {@link ApplicationContext} to use\n+\t */\n+\tpublic AuthorizeHttpRequestsConfigurer(ApplicationContext context) {\n+\t\tthis.registry = new AuthorizationManagerRequestMatcherRegistry(context);\n+\t}\n+\n+\t/**\n+\t * The {@link AuthorizationManagerRequestMatcherRegistry} is what users will interact\n+\t * with after applying the {@link AuthorizeHttpRequestsConfigurer}.\n+\t * @return the {@link AuthorizationManagerRequestMatcherRegistry} for further\n+\t * customizations\n+\t */\n+\tpublic AuthorizationManagerRequestMatcherRegistry getRegistry() {\n+\t\treturn this.registry;\n+\t}\n+\n+\t@Override\n+\tpublic void configure(H http) {\n+\t\tAuthorizationManager<HttpServletRequest> authorizationManager = this.registry.createAuthorizationManager();\n+\t\tAuthorizationFilter authorizationFilter = new AuthorizationFilter(authorizationManager);\n+\t\thttp.addFilter(postProcess(authorizationFilter));\n+\t}\n+\n+\tprivate AuthorizationManagerRequestMatcherRegistry addMapping(List<? extends RequestMatcher> matchers,\n+\t\t\tAuthorizationManager<RequestAuthorizationContext> manager) {\n+\t\tfor (RequestMatcher matcher : matchers) {\n+\t\t\tthis.registry.addMapping(matcher, manager);\n+\t\t}\n+\t\treturn this.registry;\n+\t}\n+\n+\t/**\n+\t * Registry for mapping a {@link RequestMatcher} to an {@link AuthorizationManager}.\n+\t *\n+\t * @author Evgeniy Cheban\n+\t */\n+\tpublic final class AuthorizationManagerRequestMatcherRegistry\n+\t\t\textends AbstractRequestMatcherRegistry<AuthorizedUrl> {\n+\n+\t\tprivate final DelegatingAuthorizationManager.Builder managerBuilder = DelegatingAuthorizationManager.builder();\n+\n+\t\tprivate List<RequestMatcher> unmappedMatchers;\n+\n+\t\tprivate AuthorizationManagerRequestMatcherRegistry(ApplicationContext context) {\n+\t\t\tsetApplicationContext(context);\n+\t\t}\n+\n+\t\tprivate void addMapping(RequestMatcher matcher, AuthorizationManager<RequestAuthorizationContext> manager) {\n+\t\t\tthis.unmappedMatchers = null;\n+\t\t\tthis.managerBuilder.add(new RequestMatcherEntry<>(matcher, manager));\n+\t\t}\n+\n+\t\tprivate AuthorizationManager<HttpServletRequest> createAuthorizationManager() {\n+\t\t\tAssert.state(this.unmappedMatchers == null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyODQ0NjU5", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-552844659", "createdAt": "2020-12-15T20:32:26Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MzU0MzIz", "url": "https://github.com/spring-projects/spring-security/pull/8996#pullrequestreview-528354323", "createdAt": "2020-11-11T16:51:59Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1MTo1OVrOHxVofg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNzoxMTozMlrOHxWa7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NjcwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/**\n          \n          \n            \n            \t * Determines if access should be granted for a specific authentication and object.\n          \n          \n            \n            \t * @param authentication the {@link Supplier} of the {@link Authentication} to check\n          \n          \n            \n            \t * @param object the {@link T} object to check\n          \n          \n            \n            \t * @return true if access is granted, false if denied\n          \n          \n            \n            \t */\n          \n          \n            \n            \tdefault boolean isGranted(Supplier<Authentication> authentication, T object) {\n          \n          \n            \n            \t\tAuthorizationDecision decision = check(authentication, object);\n          \n          \n            \n            \t\treturn decision == null || decision.isGranted();\n          \n          \n            \n            \t}\n          \n      \n    \n    \n  \n\nI'd prefer to leave this out to keep the interface as simple as possible and provide better symmetry to ReactiveAuthorizationManager. We can always add it later if necessary since it would be passive.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r521496702", "createdAt": "2020-11-11T16:51:59Z", "author": {"login": "rwinch"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorizationManager.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.authorization;\n+\n+import java.util.function.Supplier;\n+\n+import org.springframework.lang.Nullable;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.core.Authentication;\n+\n+/**\n+ * An Authorization manager which can determine if an {@link Authentication} has access to\n+ * a specific object.\n+ *\n+ * @param <T> the type of object that the authorization check is being done one.\n+ * @author Evgeniy Cheban\n+ */\n+@FunctionalInterface\n+public interface AuthorizationManager<T> {\n+\n+\t/**\n+\t * Determines if access should be granted for a specific authentication and object.\n+\t * @param authentication the {@link Supplier} of the {@link Authentication} to check\n+\t * @param object the {@link T} object to check\n+\t * @throws AccessDeniedException if access is not granted\n+\t */\n+\tdefault void verify(Supplier<Authentication> authentication, T object) {\n+\t\tif (!isGranted(authentication, object)) {\n+\t\t\tthrow new AccessDeniedException(\"Access Denied\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Determines if access should be granted for a specific authentication and object.\n+\t * @param authentication the {@link Supplier} of the {@link Authentication} to check\n+\t * @param object the {@link T} object to check\n+\t * @return true if access is granted, false if denied\n+\t */\n+\tdefault boolean isGranted(Supplier<Authentication> authentication, T object) {\n+\t\tAuthorizationDecision decision = check(authentication, object);\n+\t\treturn decision == null || decision.isGranted();\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwNTM2Mg==", "bodyText": "Is there a reason that we need this now? I'd prefer to keep these changes as minimal as possible. We can always consider making these changes in isolation.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r521505362", "createdAt": "2020-11-11T17:04:35Z", "author": {"login": "rwinch"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorizationDecision.java", "diffHunk": "@@ -18,10 +18,21 @@\n \n /**\n  * @author Rob Winch\n+ * @author Evgeniy Cheban\n  * @since 5.0\n  */\n public class AuthorizationDecision {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0OTIxMA=="}, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwOTYxNQ==", "bodyText": "I think it might be better to make the constructor package scope and add some static factory methods like AuthorityReactiveAuthorizationManager does.", "url": "https://github.com/spring-projects/spring-security/pull/8996#discussion_r521509615", "createdAt": "2020-11-11T17:11:32Z", "author": {"login": "rwinch"}, "path": "core/src/main/java/org/springframework/security/authorization/AuthorityAuthorizationManager.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.security.authorization;\n+\n+import java.util.Collection;\n+import java.util.function.Supplier;\n+\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.GrantedAuthority;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * An {@link AuthorizationManager} that determines if the current user is authorized by\n+ * evaluating if the {@link Authentication} contains a specified authority.\n+ *\n+ * @param <T> the type of object being authorized.\n+ * @author Evgeniy Cheban\n+ */\n+public final class AuthorityAuthorizationManager<T> implements AuthorizationManager<T> {\n+\n+\tprivate final Collection<String> authorities;\n+\n+\tpublic AuthorityAuthorizationManager(Collection<String> authorities) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a6f74f0d0b0f13df89fd18f27fab1f54399d9c5", "author": {"user": {"login": "evgeniycheban", "name": "Evgeniy Cheban"}}, "url": "https://github.com/spring-projects/spring-security/commit/5a6f74f0d0b0f13df89fd18f27fab1f54399d9c5", "committedDate": "2020-12-15T22:21:44Z", "message": "Add AuthorizationManager\n\nCloses gh-8900"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "5a6f74f0d0b0f13df89fd18f27fab1f54399d9c5", "author": {"user": {"login": "evgeniycheban", "name": "Evgeniy Cheban"}}, "url": "https://github.com/spring-projects/spring-security/commit/5a6f74f0d0b0f13df89fd18f27fab1f54399d9c5", "committedDate": "2020-12-15T22:21:44Z", "message": "Add AuthorizationManager\n\nCloses gh-8900"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4900, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}