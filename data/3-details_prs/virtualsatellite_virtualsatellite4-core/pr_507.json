{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNzMyODA0", "number": 507, "title": "Adjusting Expression Evaluator in Calculations for Set Functions", "bodyText": "Set-Functions can such as a summary usually summarize a parameter. How deep they should search in the trees can be restricted. So far the implementation was orienting on the levels of nesting regarding the SEIs and their children. Now it is the the level of occurrence of the property or category in question.\nReused the BeanTraverser for this implementation. Generalized it for the usage of SEIs as well.\nChange was needed due to the inconsistency between the summary views and the calculations in CEF.", "createdAt": "2020-02-27T09:36:36Z", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507", "merged": true, "mergeCommit": {"oid": "610e5eefc66660ca5daa2e372f599d3a8ee6548e"}, "closed": true, "closedAt": "2020-03-02T16:52:27Z", "author": {"login": "PhilMFischer"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHggNrAH2gAyMzgwNzMyODA0OjBhMTY5MmQwMDQ3Yjc3NmEyZTNkYWFlZGY2YTVhNDBhYmUyNWVlYTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJwpjjAFqTM2NzM1ODkzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0a1692d0047b776a2e3daaedf6a5a40abe25eea2", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/0a1692d0047b776a2e3daaedf6a5a40abe25eea2", "committedDate": "2020-02-24T16:55:42Z", "message": "Refactored BeanTreeTraverser - (Task #497)\n\n- generalized Traverser to work with any kind of object not just beans.\nThis is needed as preparation for making it work with pure SEIs as well.\n- Added new functionality to know level of nesting and level of matches.\nWill be needed for set functions in computations\n- Added new test cases\n- Added hamcrest lib to test fragment\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80dfe032193cc5781225cd7f94e92206e0a2228a", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/80dfe032193cc5781225cd7f94e92206e0a2228a", "committedDate": "2020-02-25T10:01:14Z", "message": "Added TreeTraverser to Expression Evaluation - (Task #497)\n\n- Now evaluating Set functions on semantic levels rather than technical\nlevels.\n- Fixed VirSatEcoreUtil to use resolve flag in method as intended\n- Added new static variable for infinite nesting\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c34314e9499c8df85204d311ac70f49121a11c1c", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/c34314e9499c8df85204d311ac70f49121a11c1c", "committedDate": "2020-02-25T13:02:40Z", "message": "Added test case for checking traverser in evaluator - (Task #497)\n\n- Added test case to check for correct semantic level detection\n- Minor fixes to code to react correctly on comparing matched vs.\nrequired levels of nesting.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de12f09fddb2e272bd21eb953c96ba2e10232940", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/de12f09fddb2e272bd21eb953c96ba2e10232940", "committedDate": "2020-02-26T13:48:19Z", "message": "Minor fixes to expression evaluator - (Task #497)\n\n- Fixed issue with cyclic dependencies when e.g. summarizing properties\nwhich are in the same category as the equation including the\nset-function.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59a03162bd96812e948e9fa406ed4c84eac6473d", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/59a03162bd96812e948e9fa406ed4c84eac6473d", "committedDate": "2020-02-27T12:01:13Z", "message": "Added missing test cases for the Sei Helper - (Task #497)\n\n- A test Case was missing for the get deep children method.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3", "committedDate": "2020-02-27T13:12:44Z", "message": "Adjusted documentation - (Task #497)\n\n- Gave a not ont he emaning of depth.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MjU1NjIw", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#pullrequestreview-366255620", "createdAt": "2020-02-28T09:20:26Z", "commit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOToyMDoyNlrOFvuSng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOToyMTozNVrOFvuUtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NTgyMg==", "bodyText": "Would it maybe be sufficient to just check\nif (obj instanceof Result) { Result other = (Result) obj; return matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei); } else { return false; }\nThat should cover all the cases.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385585822", "createdAt": "2020-02-28T09:20:26Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NjM1Ng==", "bodyText": "Can we move these to the top of the Result class so the reader directly knows whats encapsualted by it?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385586356", "createdAt": "2020-02-28T09:21:35Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Mjc2MjU2", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#pullrequestreview-366276256", "createdAt": "2020-02-28T09:54:16Z", "commit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1NDoxNlrOFvvR_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzozNjo0NlrOFv1KDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMjA0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\n          \n          \n            \n             * Interface for plugging different logic into {@link TreeTraverser}", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385602047", "createdAt": "2020-02-28T09:54:16Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjQ3Mg==", "bodyText": "Let's rename processedLevel to treeLevel", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385606472", "createdAt": "2020-02-28T10:02:42Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ==", "bodyText": "Let's also add javadoc for missing parameters", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385606669", "createdAt": "2020-02-28T10:03:06Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwODAxNw==", "bodyText": "Let's rename processedLevel to treeLevel", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385608017", "createdAt": "2020-02-28T10:05:48Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+/**\r\n+ * Class for traversing a tree of structural element instances and calling\r\n+ * callback functions of a given matcher for matching nodes\r\n+ * @param <TYPE> the type of object the traverser should act on\r\n+ */\r\n+public class TreeTraverser<TYPE> {\r\n+\t\r\n+\tprotected ITreeTraverserMatcher<TYPE> matcher;\r\n+\t\r\n+\t/**\r\n+\t * Traverses the tree starting from the given root\r\n+\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n+\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n+\t * on all found matches\r\n+\t * @param root traverse the subtree of this bean\r\n+\t * @param matcher matcher for callbacks\r\n+\t */\r\n+\tpublic void traverse(TYPE root, ITreeTraverserMatcher<TYPE> matcher) {\r\n+\t\tthis.matcher = matcher;\r\n+\t\ttraverseRecursive(root, null, 0, 0);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Traverse a subtree of a given node\r\n+\t * @param node the node from where to start traversing\r\n+\t * @param matchingParent the closest matching parent of node (or null)\r\n+\t */\r\n+\tprotected void traverseRecursive(TYPE node, TYPE matchingParent, int processedLevel, int matchingLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMTAwNg==", "bodyText": "Outdated javadoc", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385611006", "createdAt": "2020-02-28T10:12:02Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+/**\r\n+ * Class for traversing a tree of structural element instances and calling\r\n+ * callback functions of a given matcher for matching nodes\r\n+ * @param <TYPE> the type of object the traverser should act on\r\n+ */\r\n+public class TreeTraverser<TYPE> {\r\n+\t\r\n+\tprotected ITreeTraverserMatcher<TYPE> matcher;\r\n+\t\r\n+\t/**\r\n+\t * Traverses the tree starting from the given root\r\n+\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMjA0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\n          \n          \n            \n             * Interface for plugging different logic into {@link TreeTraverser}", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385612046", "createdAt": "2020-02-28T10:14:13Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/IStructuralElementInstanceTreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYyNzA3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\n          \n          \n            \n            \t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int treeLevel, int matchingLevel) {", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385627075", "createdAt": "2020-02-28T10:46:08Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.extension.tests.test/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverserTest.java", "diffHunk": "@@ -111,7 +111,7 @@ public void testSomeMatchWithLimitedRecusion() {\n \t\t\r\n \t\tMockMatcher matcher = new MockMatcher(node -> node.getName().endsWith(\"matches\")) {\r\n \t\t\t@Override\r\n-\t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching) {\r\n+\t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY5MQ==", "bodyText": "Do we even need this class now?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385657691", "createdAt": "2020-02-28T11:58:57Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverser.java", "diffHunk": "@@ -11,55 +11,11 @@\n package de.dlr.sc.virsat.model.concept.types.structural.tree;\r\n \r\n import de.dlr.sc.virsat.model.concept.types.structural.IBeanStructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.tree.TreeTraverser;\r\n \r\n /**\r\n  * Class for traversing a tree of structural element instances and calling\r\n  * callback functions of a given matcher for matching nodes\r\n  */\r\n-public class BeanStructuralTreeTraverser {\r\n-\t\r\n-\tprivate IBeanStructuralTreeTraverserMatcher matcher;\r\n-\t\r\n-\t/**\r\n-\t * Traverses the tree starting from the given root\r\n-\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n-\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n-\t * on all found matches\r\n-\t * @param root traverse the subtree of this bean\r\n-\t * @param matcher matcher for callbacks\r\n-\t */\r\n-\tpublic void traverse(IBeanStructuralElementInstance root, IBeanStructuralTreeTraverserMatcher matcher) {\r\n-\t\tthis.matcher = matcher;\r\n-\t\ttraverseRecursive(root, null);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Traverse a subtree of a given node\r\n-\t * @param node the node from where to start traversing\r\n-\t * @param matchingParent the closest matching parent of node (or null)\r\n-\t */\r\n-\tprivate void traverseRecursive(IBeanStructuralElementInstance node, IBeanStructuralElementInstance matchingParent) {\r\n-\t\t// Remember the parent of the previous recursion\r\n-\t\tIBeanStructuralElementInstance nextParent = matchingParent;\r\n-\t\t\r\n-\t\t// First check if the traverser found a match.\r\n-\t\t// if yes start processing it, by handing over the node as well as its parent.\r\n-\t\t// This is e.g. needed by the visualization to create the tree nodes for the\r\n-\t\t// protobuf data model which can be transmitted to another visualization client.\r\n-\t\t// then remember the current node as the next parent to hand over the correct parent\r\n-\t\t// when processing the children.\r\n-\t\tboolean isMatching = matcher.isMatching(node);\r\n-\t\tif (isMatching) {\r\n-\t\t\tmatcher.processMatch(node, matchingParent);\r\n-\t\t\tnextParent = node;\r\n-\t\t}\r\n-\t\t\r\n-\t\t// Now check if the children should be processed.\r\n-\t\t// if yes recursively loop over all of them.\r\n-\t\tif (matcher.continueTraverseChildren(node, isMatching)) {\r\n-\t\t\tfor (IBeanStructuralElementInstance child : node.getChildren(IBeanStructuralElementInstance.class)) {\r\n-\t\t\t\ttraverseRecursive(child, nextParent);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+public class BeanStructuralTreeTraverser extends TreeTraverser<IBeanStructuralElementInstance> {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODU3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\n          \n          \n            \n            \t\t\t\t// Processing is done in the isMatching method", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385678574", "createdAt": "2020-02-28T12:51:40Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "diffHunk": "@@ -293,67 +287,89 @@ public IExpressionResult caseAOpRightExpression(AOpRightExpression object) {\n \r\n \t/**\r\n \t * Gets a list of a all type instances that the passed set function would use as input\r\n-\t * @param object the set function\r\n+\t * @param setFunction the set function\r\n \t * @return  a list of all type instances the set function will use for its computation and is thus dependent on\r\n \t */\r\n-\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction object) {\r\n-\t\tATypeDefinition typeDefinition = object.getTypeDefinition();\r\n-\t\tString filterName = object.getFilterName();\r\n+\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction setFunction) {\r\n+\t\tATypeDefinition typeDefinition = setFunction.getTypeDefinition();\r\n+\t\tString filterName = setFunction.getFilterName();\r\n \t\tboolean filterForName = filterName != null && !filterName.equals(\"\");\r\n \r\n \t\t// Grab the structural element instance the set function belongs to\r\n-\t\tStructuralElementInstance sei = getStructuralElementInstance(object);\r\n+\t\tStructuralElementInstance sei = getStructuralElementInstance(setFunction);\r\n \t\tif (sei == null) {\r\n \t\t\treturn new ArrayList<>();\r\n \t\t}\r\n \r\n-\t\t// Find all applicable instances that are directly or indirectly contained by the sei\r\n-\t\tList<EObject> containers = new ArrayList<>();\r\n-\t\tcontainers.add(sei);\r\n-\t\tcontainers.addAll(StructuralElementInstanceHelper.getDeepChildren(sei, object.getDepth(), 0));\r\n-\r\n+\t\t// Store the inputs to the set function\r\n \t\tList<ATypeInstance> inputs = new ArrayList<>();\r\n-\t\t\r\n+\r\n \t\t// Find all child seis that also compute the set function\r\n-\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, object, inputs);\r\n-\r\n-\t\tTreeIterator<Object> treeIter = EcoreUtil.getAllProperContents(containers, true);\r\n-\t\twhile (treeIter.hasNext()) {\r\n-\t\t\tObject potentialATypeInstance = treeIter.next();\r\n-\t\t\tif (potentialATypeInstance instanceof ATypeInstance) {\r\n-\t\t\t\tATypeInstance aTypeInstance = (ATypeInstance) potentialATypeInstance;\r\n-\r\n-\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n-\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(getStructuralElementInstance(aTypeInstance));\r\n-\r\n-\t\t\t\tif (correctType && notComputedByChild) {\r\n-\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n-\t\t\t\t\t// to be able to work with them\r\n-\t\t\t\t\tif (aTypeInstance instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\t\taTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n-\t\t\t\t\t}\r\n+\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, setFunction, inputs);\r\n+\t\t\r\n+\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n+\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n+\t\t// from the Set's inputs\r\n+\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(setFunction, CategoryAssignment.class);\r\n+\t\t\r\n+\t\t// Find all applicable TypeInstances that are directly or indirectly contained by the sei\r\n+\t\tTreeTraverser<StructuralElementInstance> treeTraverser = new TreeTraverser<>();\r\n+\t\ttreeTraverser.traverse(sei, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeSei) {\r\n+\t\t\t\tboolean isMatching = false;\r\n+\t\t\t\t// Get all nested TypeInstances to the current treeSei and see if one\r\n+\t\t\t\t// is matching to the definition of what is referenced by the SET function\r\n+\t\t\t\tList<CategoryAssignment> currentCas = new LinkedList<>(treeSei.getCategoryAssignments());\r\n+\t\t\t\tcurrentCas.remove(currentCa);\r\n+\t\t\t\tCollection<ATypeInstance> typeInstances = VirSatEcoreUtil.getAllContentsOfType(currentCas, ATypeInstance.class, true);\r\n+\t\t\t\ttypeInstances.addAll(currentCas);\r\n+\t\t\t\t\r\n+\t\t\t\t// Loop over all identified ATypeInstances\r\n+\t\t\t\tfor (ATypeInstance aTypeInstance : typeInstances) {\r\n+\t\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n+\t\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(treeSei);\r\n+\t\t\t\t\tif (correctType && notComputedByChild) {\r\n+\t\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n+\t\t\t\t\t\t// to be able to work with them, thus try to decompose it\r\n+\t\t\t\t\t\tATypeInstance decomposedTypeInstance = aTypeInstance;\r\n+\t\t\t\t\t\tif (decomposedTypeInstance instanceof ComposedPropertyInstance) {\r\n+\t\t\t\t\t\t\tdecomposedTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n+\t\t\t\t\t\t}\r\n \r\n-\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(aTypeInstance, filterName);\r\n-\t\t\t\t\tif (correctName) {\r\n-\t\t\t\t\t\tinputs.add(aTypeInstance);\r\n+\t\t\t\t\t\t// In case a name filter is set for the Set function make sure to apply it.\r\n+\t\t\t\t\t\t// If all properties are correct, remember the decomposed Type Instance as an input\r\n+\t\t\t\t\t\t// remember that we definitely had a match and continue with all the other items and check\r\n+\t\t\t\t\t\t// if they are potential inputs. Saving the match is important, so that the tree traverser\r\n+\t\t\t\t\t\t// can count the levels of nesting and levels of matches correctly\t\t\t\t\t\t\r\n+\t\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(decomposedTypeInstance, filterName);\r\n+\t\t\t\t\t\tif (correctName) {\r\n+\t\t\t\t\t\t\tinputs.add(decomposedTypeInstance);\r\n+\t\t\t\t\t\t\tisMatching = true;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t// return the result to decide if the current node will be counted\r\n+\t\t\t\t// for the matching levels or not\r\n+\t\t\t\treturn isMatching;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r\n+\t\t\t\t// Compare the depth of found matches with the depth set by the set function\r\n+\t\t\t\tint targetDepth = setFunction.getDepth();\r\n+\t\t\t\tboolean isDepthInfinite = targetDepth == AAdvancedFunctionOp.DEPTH_INFINITE;\r\n+\t\t\t\tboolean isDepthNotReached =  matchedLevel <= targetDepth; \r\n+\t\t\t\treturn isDepthInfinite || isDepthNotReached;\r\n \t\t\t}\r\n-\t\t}\r\n \r\n-\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n-\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n-\t\t// from the Set's inputs\r\n-\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(object, CategoryAssignment.class);\r\n-\t\tif (currentCa != null) {\r\n-\t\t\tfor (APropertyInstance pi : currentCa.getPropertyInstances()) {\r\n-\t\t\t\tinputs.remove(pi);\r\n-\t\t\t\tif (pi instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\tComposedPropertyInstance cpi = (ComposedPropertyInstance) pi;\r\n-\t\t\t\t\tinputs.remove(cpi.getTypeInstance());\r\n-\t\t\t\t}\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTA3MA==", "bodyText": "Line 390, let's also change -1 to AAdvancedFunctionOp.DEPTH_INFINITE", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385681070", "createdAt": "2020-02-28T12:57:47Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "diffHunk": "@@ -293,67 +287,89 @@ public IExpressionResult caseAOpRightExpression(AOpRightExpression object) {\n \r\n \t/**\r\n \t * Gets a list of a all type instances that the passed set function would use as input\r\n-\t * @param object the set function\r\n+\t * @param setFunction the set function\r\n \t * @return  a list of all type instances the set function will use for its computation and is thus dependent on\r\n \t */\r\n-\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction object) {\r\n-\t\tATypeDefinition typeDefinition = object.getTypeDefinition();\r\n-\t\tString filterName = object.getFilterName();\r\n+\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction setFunction) {\r\n+\t\tATypeDefinition typeDefinition = setFunction.getTypeDefinition();\r\n+\t\tString filterName = setFunction.getFilterName();\r\n \t\tboolean filterForName = filterName != null && !filterName.equals(\"\");\r\n \r\n \t\t// Grab the structural element instance the set function belongs to\r\n-\t\tStructuralElementInstance sei = getStructuralElementInstance(object);\r\n+\t\tStructuralElementInstance sei = getStructuralElementInstance(setFunction);\r\n \t\tif (sei == null) {\r\n \t\t\treturn new ArrayList<>();\r\n \t\t}\r\n \r\n-\t\t// Find all applicable instances that are directly or indirectly contained by the sei\r\n-\t\tList<EObject> containers = new ArrayList<>();\r\n-\t\tcontainers.add(sei);\r\n-\t\tcontainers.addAll(StructuralElementInstanceHelper.getDeepChildren(sei, object.getDepth(), 0));\r\n-\r\n+\t\t// Store the inputs to the set function\r\n \t\tList<ATypeInstance> inputs = new ArrayList<>();\r\n-\t\t\r\n+\r\n \t\t// Find all child seis that also compute the set function\r\n-\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, object, inputs);\r\n-\r\n-\t\tTreeIterator<Object> treeIter = EcoreUtil.getAllProperContents(containers, true);\r\n-\t\twhile (treeIter.hasNext()) {\r\n-\t\t\tObject potentialATypeInstance = treeIter.next();\r\n-\t\t\tif (potentialATypeInstance instanceof ATypeInstance) {\r\n-\t\t\t\tATypeInstance aTypeInstance = (ATypeInstance) potentialATypeInstance;\r\n-\r\n-\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n-\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(getStructuralElementInstance(aTypeInstance));\r\n-\r\n-\t\t\t\tif (correctType && notComputedByChild) {\r\n-\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n-\t\t\t\t\t// to be able to work with them\r\n-\t\t\t\t\tif (aTypeInstance instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\t\taTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n-\t\t\t\t\t}\r\n+\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, setFunction, inputs);\r\n+\t\t\r\n+\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n+\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n+\t\t// from the Set's inputs\r\n+\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(setFunction, CategoryAssignment.class);\r\n+\t\t\r\n+\t\t// Find all applicable TypeInstances that are directly or indirectly contained by the sei\r\n+\t\tTreeTraverser<StructuralElementInstance> treeTraverser = new TreeTraverser<>();\r\n+\t\ttreeTraverser.traverse(sei, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeSei) {\r\n+\t\t\t\tboolean isMatching = false;\r\n+\t\t\t\t// Get all nested TypeInstances to the current treeSei and see if one\r\n+\t\t\t\t// is matching to the definition of what is referenced by the SET function\r\n+\t\t\t\tList<CategoryAssignment> currentCas = new LinkedList<>(treeSei.getCategoryAssignments());\r\n+\t\t\t\tcurrentCas.remove(currentCa);\r\n+\t\t\t\tCollection<ATypeInstance> typeInstances = VirSatEcoreUtil.getAllContentsOfType(currentCas, ATypeInstance.class, true);\r\n+\t\t\t\ttypeInstances.addAll(currentCas);\r\n+\t\t\t\t\r\n+\t\t\t\t// Loop over all identified ATypeInstances\r\n+\t\t\t\tfor (ATypeInstance aTypeInstance : typeInstances) {\r\n+\t\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n+\t\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(treeSei);\r\n+\t\t\t\t\tif (correctType && notComputedByChild) {\r\n+\t\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n+\t\t\t\t\t\t// to be able to work with them, thus try to decompose it\r\n+\t\t\t\t\t\tATypeInstance decomposedTypeInstance = aTypeInstance;\r\n+\t\t\t\t\t\tif (decomposedTypeInstance instanceof ComposedPropertyInstance) {\r\n+\t\t\t\t\t\t\tdecomposedTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n+\t\t\t\t\t\t}\r\n \r\n-\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(aTypeInstance, filterName);\r\n-\t\t\t\t\tif (correctName) {\r\n-\t\t\t\t\t\tinputs.add(aTypeInstance);\r\n+\t\t\t\t\t\t// In case a name filter is set for the Set function make sure to apply it.\r\n+\t\t\t\t\t\t// If all properties are correct, remember the decomposed Type Instance as an input\r\n+\t\t\t\t\t\t// remember that we definitely had a match and continue with all the other items and check\r\n+\t\t\t\t\t\t// if they are potential inputs. Saving the match is important, so that the tree traverser\r\n+\t\t\t\t\t\t// can count the levels of nesting and levels of matches correctly\t\t\t\t\t\t\r\n+\t\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(decomposedTypeInstance, filterName);\r\n+\t\t\t\t\t\tif (correctName) {\r\n+\t\t\t\t\t\t\tinputs.add(decomposedTypeInstance);\r\n+\t\t\t\t\t\t\tisMatching = true;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t// return the result to decide if the current node will be counted\r\n+\t\t\t\t// for the matching levels or not\r\n+\t\t\t\treturn isMatching;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r\n+\t\t\t\t// Compare the depth of found matches with the depth set by the set function\r\n+\t\t\t\tint targetDepth = setFunction.getDepth();\r\n+\t\t\t\tboolean isDepthInfinite = targetDepth == AAdvancedFunctionOp.DEPTH_INFINITE;\r\n+\t\t\t\tboolean isDepthNotReached =  matchedLevel <= targetDepth; \r\n+\t\t\t\treturn isDepthInfinite || isDepthNotReached;\r\n \t\t\t}\r\n-\t\t}\r\n \r\n-\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n-\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n-\t\t// from the Set's inputs\r\n-\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(object, CategoryAssignment.class);\r\n-\t\tif (currentCa != null) {\r\n-\t\t\tfor (APropertyInstance pi : currentCa.getPropertyInstances()) {\r\n-\t\t\t\tinputs.remove(pi);\r\n-\t\t\t\tif (pi instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\tComposedPropertyInstance cpi = (ComposedPropertyInstance) pi;\r\n-\t\t\t\t\tinputs.remove(cpi.getTypeInstance());\r\n-\t\t\t\t}\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\r\n \t\t\t}\r\n-\t\t}\r\n+\t\t});\r\n \r\n \t\treturn inputs;\r\n \t}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mjk0NA==", "bodyText": "Not immediately clear what it matches. I suggest we either check it explicitly like return treeNode != seiChild1 && treenode != seiChild2 or check a special name like \"MISMATCH\", and set it to mismatching elements.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385692944", "createdAt": "2020-02-28T13:25:05Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NDQ3OQ==", "bodyText": "Shall we also add tree level and match level as parameters here?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385694479", "createdAt": "2020-02-28T13:28:13Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5ODMxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\n          \n          \n            \n            \t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\n          \n          \n            \n            \t\t\t\treturn treeNode != seiChild2Child;", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385698318", "createdAt": "2020-02-28T13:36:46Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r\n+\t\t\t\ttraverseResults.add(new Result(treeNode, nestingLevel, matchingLevel));\r\n+\t\t\t\t\r\n+\t\t\t\t// Try to make sure that the seiChild2ChildChild which is theoretically correct, still does not get found\r\n+\t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\r\n+\t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 144}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3ad412e5af4ab271317d16264d679731c53cb70", "author": {"user": {"login": "PhilMFischer", "name": "Philipp M. Fischer"}}, "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/commit/b3ad412e5af4ab271317d16264d679731c53cb70", "committedDate": "2020-03-02T15:32:13Z", "message": "Changes due to review comments - (Task #497)\n\n- Adjusted some a java doc.\n- made some minor code modifications to improve readability.\n\n---\nTask #497: Adjust CEFX calculations to summarize masses and power across\nempty system elements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MzU4MjYx", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#pullrequestreview-367358261", "createdAt": "2020-03-02T16:51:25Z", "commit": {"oid": "b3ad412e5af4ab271317d16264d679731c53cb70"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MzU4OTMw", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#pullrequestreview-367358930", "createdAt": "2020-03-02T16:52:14Z", "commit": {"oid": "b3ad412e5af4ab271317d16264d679731c53cb70"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 602, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}