{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNzMyODA0", "number": 507, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOToyMDoyNlrODjvrlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzozNjo0NlrODj0K4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODA3OTU2OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOToyMDoyNlrOFvuSng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTowMjo0OFrOFwivVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NTgyMg==", "bodyText": "Would it maybe be sufficient to just check\nif (obj instanceof Result) { Result other = (Result) obj; return matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei); } else { return false; }\nThat should cover all the cases.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385585822", "createdAt": "2020-02-28T09:20:26Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0NTE0Mw==", "bodyText": "Well, the code present is auto coded by the eclipse ide.  The result is basically the same, but there is a difference in performance. Since performance is not an issue in this test case, and in particular not with this object i don't mind changing it.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386445143", "createdAt": "2020-03-02T15:02:48Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NTgyMg=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODA4MzA1OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOToyMTozNVrOFvuUtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTowMzoyMVrOFwiwrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NjM1Ng==", "bodyText": "Can we move these to the top of the Result class so the reader directly knows whats encapsualted by it?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385586356", "createdAt": "2020-02-28T09:21:35Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0NTQ4Nw==", "bodyText": "yes done.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386445487", "createdAt": "2020-03-02T15:03:21Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU4NjM1Ng=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODE4NTIyOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1NDoxNlrOFvvR_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1NDoxNlrOFvvR_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMjA0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\n          \n          \n            \n             * Interface for plugging different logic into {@link TreeTraverser}", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385602047", "createdAt": "2020-02-28T09:54:16Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODIxNDA5OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDowMjo0MlrOFvvjSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTowNDoyOFrOFwizWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjQ3Mg==", "bodyText": "Let's rename processedLevel to treeLevel", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385606472", "createdAt": "2020-02-28T10:02:42Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0NjE3MQ==", "bodyText": "Good suggestion.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386446171", "createdAt": "2020-03-02T15:04:28Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjQ3Mg=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODIxNTQ3OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDowMzowNlrOFvvkDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjo0OTozMVrOFwnAvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ==", "bodyText": "Let's also add javadoc for missing parameters", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385606669", "createdAt": "2020-02-28T10:03:06Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0Nzk2Nw==", "bodyText": "It is a bit strange checkstyle is not complaining. but probably since the method is that small, it does not expect a javadoc at all.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386447967", "createdAt": "2020-03-02T15:07:26Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUxNTEzMw==", "bodyText": "Yes, it's just one line, checkstyle doesn't require a javadoc. But since it's an interface method, it's good to have all parameters explained", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386515133", "createdAt": "2020-03-02T16:49:31Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r\n+\t\r\n+\t/**\r\n+\t * This method tells if the children of the current node should be processed or not.\r\n+\t * \r\n+\t * Default behavior is that all children are processed.\r\n+\t * @param treeNode the node of which the children should be processed or not.\r\n+\t * @param isMatching the matching result which the traverser evaluated before.\r\n+\t * @return true in case the children should be processed. false in case not.\r\n+\t */\r\n+\tdefault boolean continueTraverseChildren(TYPE treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNjY2OQ=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODIyNDAzOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDowNTo0OFrOFvvpUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDowNTo0OFrOFvvpUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwODAxNw==", "bodyText": "Let's rename processedLevel to treeLevel", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385608017", "createdAt": "2020-02-28T10:05:48Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+/**\r\n+ * Class for traversing a tree of structural element instances and calling\r\n+ * callback functions of a given matcher for matching nodes\r\n+ * @param <TYPE> the type of object the traverser should act on\r\n+ */\r\n+public class TreeTraverser<TYPE> {\r\n+\t\r\n+\tprotected ITreeTraverserMatcher<TYPE> matcher;\r\n+\t\r\n+\t/**\r\n+\t * Traverses the tree starting from the given root\r\n+\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n+\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n+\t * on all found matches\r\n+\t * @param root traverse the subtree of this bean\r\n+\t * @param matcher matcher for callbacks\r\n+\t */\r\n+\tpublic void traverse(TYPE root, ITreeTraverserMatcher<TYPE> matcher) {\r\n+\t\tthis.matcher = matcher;\r\n+\t\ttraverseRecursive(root, null, 0, 0);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Traverse a subtree of a given node\r\n+\t * @param node the node from where to start traversing\r\n+\t * @param matchingParent the closest matching parent of node (or null)\r\n+\t */\r\n+\tprotected void traverseRecursive(TYPE node, TYPE matchingParent, int processedLevel, int matchingLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODI0MzYzOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDoxMjowMlrOFvv0_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDoxMjowMlrOFvv0_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMTAwNg==", "bodyText": "Outdated javadoc", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385611006", "createdAt": "2020-02-28T10:12:02Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverser.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+/**\r\n+ * Class for traversing a tree of structural element instances and calling\r\n+ * callback functions of a given matcher for matching nodes\r\n+ * @param <TYPE> the type of object the traverser should act on\r\n+ */\r\n+public class TreeTraverser<TYPE> {\r\n+\t\r\n+\tprotected ITreeTraverserMatcher<TYPE> matcher;\r\n+\t\r\n+\t/**\r\n+\t * Traverses the tree starting from the given root\r\n+\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODI1MDYwOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/IStructuralElementInstanceTreeTraverserMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDoxNDoxM1rOFvv5Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDoxNDoxM1rOFvv5Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYxMjA0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\n          \n          \n            \n             * Interface for plugging different logic into {@link TreeTraverser}", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385612046", "createdAt": "2020-02-28T10:14:13Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/IStructuralElementInstanceTreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODM0ODA2OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.extension.tests.test/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDo0NjowOFrOFvwzww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDo0NjowOFrOFvwzww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYyNzA3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\n          \n          \n            \n            \t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int treeLevel, int matchingLevel) {", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385627075", "createdAt": "2020-02-28T10:46:08Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.extension.tests.test/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverserTest.java", "diffHunk": "@@ -111,7 +111,7 @@ public void testSomeMatchWithLimitedRecusion() {\n \t\t\r\n \t\tMockMatcher matcher = new MockMatcher(node -> node.getName().endsWith(\"matches\")) {\r\n \t\t\t@Override\r\n-\t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching) {\r\n+\t\t\tpublic boolean continueTraverseChildren(IBeanStructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODU0NzUwOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMTo1ODo1N1rOFvyrWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToxNDo1MVrOFwjMMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY5MQ==", "bodyText": "Do we even need this class now?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385657691", "createdAt": "2020-02-28T11:58:57Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverser.java", "diffHunk": "@@ -11,55 +11,11 @@\n package de.dlr.sc.virsat.model.concept.types.structural.tree;\r\n \r\n import de.dlr.sc.virsat.model.concept.types.structural.IBeanStructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.tree.TreeTraverser;\r\n \r\n /**\r\n  * Class for traversing a tree of structural element instances and calling\r\n  * callback functions of a given matcher for matching nodes\r\n  */\r\n-public class BeanStructuralTreeTraverser {\r\n-\t\r\n-\tprivate IBeanStructuralTreeTraverserMatcher matcher;\r\n-\t\r\n-\t/**\r\n-\t * Traverses the tree starting from the given root\r\n-\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n-\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n-\t * on all found matches\r\n-\t * @param root traverse the subtree of this bean\r\n-\t * @param matcher matcher for callbacks\r\n-\t */\r\n-\tpublic void traverse(IBeanStructuralElementInstance root, IBeanStructuralTreeTraverserMatcher matcher) {\r\n-\t\tthis.matcher = matcher;\r\n-\t\ttraverseRecursive(root, null);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Traverse a subtree of a given node\r\n-\t * @param node the node from where to start traversing\r\n-\t * @param matchingParent the closest matching parent of node (or null)\r\n-\t */\r\n-\tprivate void traverseRecursive(IBeanStructuralElementInstance node, IBeanStructuralElementInstance matchingParent) {\r\n-\t\t// Remember the parent of the previous recursion\r\n-\t\tIBeanStructuralElementInstance nextParent = matchingParent;\r\n-\t\t\r\n-\t\t// First check if the traverser found a match.\r\n-\t\t// if yes start processing it, by handing over the node as well as its parent.\r\n-\t\t// This is e.g. needed by the visualization to create the tree nodes for the\r\n-\t\t// protobuf data model which can be transmitted to another visualization client.\r\n-\t\t// then remember the current node as the next parent to hand over the correct parent\r\n-\t\t// when processing the children.\r\n-\t\tboolean isMatching = matcher.isMatching(node);\r\n-\t\tif (isMatching) {\r\n-\t\t\tmatcher.processMatch(node, matchingParent);\r\n-\t\t\tnextParent = node;\r\n-\t\t}\r\n-\t\t\r\n-\t\t// Now check if the children should be processed.\r\n-\t\t// if yes recursively loop over all of them.\r\n-\t\tif (matcher.continueTraverseChildren(node, isMatching)) {\r\n-\t\t\tfor (IBeanStructuralElementInstance child : node.getChildren(IBeanStructuralElementInstance.class)) {\r\n-\t\t\t\ttraverseRecursive(child, nextParent);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+public class BeanStructuralTreeTraverser extends TreeTraverser<IBeanStructuralElementInstance> {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1MjUyOQ==", "bodyText": "Only for backwards compatibility, because it has been exposed API, and i am not sure about all places where it has been used.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386452529", "createdAt": "2020-03-02T15:14:51Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/types/structural/tree/BeanStructuralTreeTraverser.java", "diffHunk": "@@ -11,55 +11,11 @@\n package de.dlr.sc.virsat.model.concept.types.structural.tree;\r\n \r\n import de.dlr.sc.virsat.model.concept.types.structural.IBeanStructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.tree.TreeTraverser;\r\n \r\n /**\r\n  * Class for traversing a tree of structural element instances and calling\r\n  * callback functions of a given matcher for matching nodes\r\n  */\r\n-public class BeanStructuralTreeTraverser {\r\n-\t\r\n-\tprivate IBeanStructuralTreeTraverserMatcher matcher;\r\n-\t\r\n-\t/**\r\n-\t * Traverses the tree starting from the given root\r\n-\t * calling {@link IBeanStructuralTreeTraverserMatcher#isMatching(IBeanStructuralElementInstance)}\r\n-\t * on all nodes and {@link IBeanStructuralTreeTraverserMatcher#processMatch(IBeanStructuralElementInstance, IBeanStructuralElementInstance)}\r\n-\t * on all found matches\r\n-\t * @param root traverse the subtree of this bean\r\n-\t * @param matcher matcher for callbacks\r\n-\t */\r\n-\tpublic void traverse(IBeanStructuralElementInstance root, IBeanStructuralTreeTraverserMatcher matcher) {\r\n-\t\tthis.matcher = matcher;\r\n-\t\ttraverseRecursive(root, null);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Traverse a subtree of a given node\r\n-\t * @param node the node from where to start traversing\r\n-\t * @param matchingParent the closest matching parent of node (or null)\r\n-\t */\r\n-\tprivate void traverseRecursive(IBeanStructuralElementInstance node, IBeanStructuralElementInstance matchingParent) {\r\n-\t\t// Remember the parent of the previous recursion\r\n-\t\tIBeanStructuralElementInstance nextParent = matchingParent;\r\n-\t\t\r\n-\t\t// First check if the traverser found a match.\r\n-\t\t// if yes start processing it, by handing over the node as well as its parent.\r\n-\t\t// This is e.g. needed by the visualization to create the tree nodes for the\r\n-\t\t// protobuf data model which can be transmitted to another visualization client.\r\n-\t\t// then remember the current node as the next parent to hand over the correct parent\r\n-\t\t// when processing the children.\r\n-\t\tboolean isMatching = matcher.isMatching(node);\r\n-\t\tif (isMatching) {\r\n-\t\t\tmatcher.processMatch(node, matchingParent);\r\n-\t\t\tnextParent = node;\r\n-\t\t}\r\n-\t\t\r\n-\t\t// Now check if the children should be processed.\r\n-\t\t// if yes recursively loop over all of them.\r\n-\t\tif (matcher.continueTraverseChildren(node, isMatching)) {\r\n-\t\t\tfor (IBeanStructuralElementInstance child : node.getChildren(IBeanStructuralElementInstance.class)) {\r\n-\t\t\t\ttraverseRecursive(child, nextParent);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+public class BeanStructuralTreeTraverser extends TreeTraverser<IBeanStructuralElementInstance> {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1NzY5MQ=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODY4Mzg4OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1MTo0MFrOFvz87g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1MTo0MFrOFvz87g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODU3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\n          \n          \n            \n            \t\t\t\t// Processing is done in the isMatching method", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385678574", "createdAt": "2020-02-28T12:51:40Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "diffHunk": "@@ -293,67 +287,89 @@ public IExpressionResult caseAOpRightExpression(AOpRightExpression object) {\n \r\n \t/**\r\n \t * Gets a list of a all type instances that the passed set function would use as input\r\n-\t * @param object the set function\r\n+\t * @param setFunction the set function\r\n \t * @return  a list of all type instances the set function will use for its computation and is thus dependent on\r\n \t */\r\n-\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction object) {\r\n-\t\tATypeDefinition typeDefinition = object.getTypeDefinition();\r\n-\t\tString filterName = object.getFilterName();\r\n+\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction setFunction) {\r\n+\t\tATypeDefinition typeDefinition = setFunction.getTypeDefinition();\r\n+\t\tString filterName = setFunction.getFilterName();\r\n \t\tboolean filterForName = filterName != null && !filterName.equals(\"\");\r\n \r\n \t\t// Grab the structural element instance the set function belongs to\r\n-\t\tStructuralElementInstance sei = getStructuralElementInstance(object);\r\n+\t\tStructuralElementInstance sei = getStructuralElementInstance(setFunction);\r\n \t\tif (sei == null) {\r\n \t\t\treturn new ArrayList<>();\r\n \t\t}\r\n \r\n-\t\t// Find all applicable instances that are directly or indirectly contained by the sei\r\n-\t\tList<EObject> containers = new ArrayList<>();\r\n-\t\tcontainers.add(sei);\r\n-\t\tcontainers.addAll(StructuralElementInstanceHelper.getDeepChildren(sei, object.getDepth(), 0));\r\n-\r\n+\t\t// Store the inputs to the set function\r\n \t\tList<ATypeInstance> inputs = new ArrayList<>();\r\n-\t\t\r\n+\r\n \t\t// Find all child seis that also compute the set function\r\n-\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, object, inputs);\r\n-\r\n-\t\tTreeIterator<Object> treeIter = EcoreUtil.getAllProperContents(containers, true);\r\n-\t\twhile (treeIter.hasNext()) {\r\n-\t\t\tObject potentialATypeInstance = treeIter.next();\r\n-\t\t\tif (potentialATypeInstance instanceof ATypeInstance) {\r\n-\t\t\t\tATypeInstance aTypeInstance = (ATypeInstance) potentialATypeInstance;\r\n-\r\n-\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n-\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(getStructuralElementInstance(aTypeInstance));\r\n-\r\n-\t\t\t\tif (correctType && notComputedByChild) {\r\n-\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n-\t\t\t\t\t// to be able to work with them\r\n-\t\t\t\t\tif (aTypeInstance instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\t\taTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n-\t\t\t\t\t}\r\n+\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, setFunction, inputs);\r\n+\t\t\r\n+\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n+\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n+\t\t// from the Set's inputs\r\n+\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(setFunction, CategoryAssignment.class);\r\n+\t\t\r\n+\t\t// Find all applicable TypeInstances that are directly or indirectly contained by the sei\r\n+\t\tTreeTraverser<StructuralElementInstance> treeTraverser = new TreeTraverser<>();\r\n+\t\ttreeTraverser.traverse(sei, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeSei) {\r\n+\t\t\t\tboolean isMatching = false;\r\n+\t\t\t\t// Get all nested TypeInstances to the current treeSei and see if one\r\n+\t\t\t\t// is matching to the definition of what is referenced by the SET function\r\n+\t\t\t\tList<CategoryAssignment> currentCas = new LinkedList<>(treeSei.getCategoryAssignments());\r\n+\t\t\t\tcurrentCas.remove(currentCa);\r\n+\t\t\t\tCollection<ATypeInstance> typeInstances = VirSatEcoreUtil.getAllContentsOfType(currentCas, ATypeInstance.class, true);\r\n+\t\t\t\ttypeInstances.addAll(currentCas);\r\n+\t\t\t\t\r\n+\t\t\t\t// Loop over all identified ATypeInstances\r\n+\t\t\t\tfor (ATypeInstance aTypeInstance : typeInstances) {\r\n+\t\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n+\t\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(treeSei);\r\n+\t\t\t\t\tif (correctType && notComputedByChild) {\r\n+\t\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n+\t\t\t\t\t\t// to be able to work with them, thus try to decompose it\r\n+\t\t\t\t\t\tATypeInstance decomposedTypeInstance = aTypeInstance;\r\n+\t\t\t\t\t\tif (decomposedTypeInstance instanceof ComposedPropertyInstance) {\r\n+\t\t\t\t\t\t\tdecomposedTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n+\t\t\t\t\t\t}\r\n \r\n-\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(aTypeInstance, filterName);\r\n-\t\t\t\t\tif (correctName) {\r\n-\t\t\t\t\t\tinputs.add(aTypeInstance);\r\n+\t\t\t\t\t\t// In case a name filter is set for the Set function make sure to apply it.\r\n+\t\t\t\t\t\t// If all properties are correct, remember the decomposed Type Instance as an input\r\n+\t\t\t\t\t\t// remember that we definitely had a match and continue with all the other items and check\r\n+\t\t\t\t\t\t// if they are potential inputs. Saving the match is important, so that the tree traverser\r\n+\t\t\t\t\t\t// can count the levels of nesting and levels of matches correctly\t\t\t\t\t\t\r\n+\t\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(decomposedTypeInstance, filterName);\r\n+\t\t\t\t\t\tif (correctName) {\r\n+\t\t\t\t\t\t\tinputs.add(decomposedTypeInstance);\r\n+\t\t\t\t\t\t\tisMatching = true;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t// return the result to decide if the current node will be counted\r\n+\t\t\t\t// for the matching levels or not\r\n+\t\t\t\treturn isMatching;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r\n+\t\t\t\t// Compare the depth of found matches with the depth set by the set function\r\n+\t\t\t\tint targetDepth = setFunction.getDepth();\r\n+\t\t\t\tboolean isDepthInfinite = targetDepth == AAdvancedFunctionOp.DEPTH_INFINITE;\r\n+\t\t\t\tboolean isDepthNotReached =  matchedLevel <= targetDepth; \r\n+\t\t\t\treturn isDepthInfinite || isDepthNotReached;\r\n \t\t\t}\r\n-\t\t}\r\n \r\n-\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n-\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n-\t\t// from the Set's inputs\r\n-\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(object, CategoryAssignment.class);\r\n-\t\tif (currentCa != null) {\r\n-\t\t\tfor (APropertyInstance pi : currentCa.getPropertyInstances()) {\r\n-\t\t\t\tinputs.remove(pi);\r\n-\t\t\t\tif (pi instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\tComposedPropertyInstance cpi = (ComposedPropertyInstance) pi;\r\n-\t\t\t\t\tinputs.remove(cpi.getTypeInstance());\r\n-\t\t\t\t}\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODcwMDQ1OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1Nzo0N1rOFv0Grg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMjo1Nzo0N1rOFv0Grg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTA3MA==", "bodyText": "Line 390, let's also change -1 to AAdvancedFunctionOp.DEPTH_INFINITE", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385681070", "createdAt": "2020-02-28T12:57:47Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.calculation/src/de/dlr/sc/virsat/model/calculation/compute/ExpressionHelper.java", "diffHunk": "@@ -293,67 +287,89 @@ public IExpressionResult caseAOpRightExpression(AOpRightExpression object) {\n \r\n \t/**\r\n \t * Gets a list of a all type instances that the passed set function would use as input\r\n-\t * @param object the set function\r\n+\t * @param setFunction the set function\r\n \t * @return  a list of all type instances the set function will use for its computation and is thus dependent on\r\n \t */\r\n-\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction object) {\r\n-\t\tATypeDefinition typeDefinition = object.getTypeDefinition();\r\n-\t\tString filterName = object.getFilterName();\r\n+\tprivate List<ATypeInstance> getSetFunctionInput(SetFunction setFunction) {\r\n+\t\tATypeDefinition typeDefinition = setFunction.getTypeDefinition();\r\n+\t\tString filterName = setFunction.getFilterName();\r\n \t\tboolean filterForName = filterName != null && !filterName.equals(\"\");\r\n \r\n \t\t// Grab the structural element instance the set function belongs to\r\n-\t\tStructuralElementInstance sei = getStructuralElementInstance(object);\r\n+\t\tStructuralElementInstance sei = getStructuralElementInstance(setFunction);\r\n \t\tif (sei == null) {\r\n \t\t\treturn new ArrayList<>();\r\n \t\t}\r\n \r\n-\t\t// Find all applicable instances that are directly or indirectly contained by the sei\r\n-\t\tList<EObject> containers = new ArrayList<>();\r\n-\t\tcontainers.add(sei);\r\n-\t\tcontainers.addAll(StructuralElementInstanceHelper.getDeepChildren(sei, object.getDepth(), 0));\r\n-\r\n+\t\t// Store the inputs to the set function\r\n \t\tList<ATypeInstance> inputs = new ArrayList<>();\r\n-\t\t\r\n+\r\n \t\t// Find all child seis that also compute the set function\r\n-\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, object, inputs);\r\n-\r\n-\t\tTreeIterator<Object> treeIter = EcoreUtil.getAllProperContents(containers, true);\r\n-\t\twhile (treeIter.hasNext()) {\r\n-\t\t\tObject potentialATypeInstance = treeIter.next();\r\n-\t\t\tif (potentialATypeInstance instanceof ATypeInstance) {\r\n-\t\t\t\tATypeInstance aTypeInstance = (ATypeInstance) potentialATypeInstance;\r\n-\r\n-\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n-\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(getStructuralElementInstance(aTypeInstance));\r\n-\r\n-\t\t\t\tif (correctType && notComputedByChild) {\r\n-\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n-\t\t\t\t\t// to be able to work with them\r\n-\t\t\t\t\tif (aTypeInstance instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\t\taTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n-\t\t\t\t\t}\r\n+\t\tSet<StructuralElementInstance> childrenWithSetFunction = getChildrenWithSetFunction(sei, setFunction, inputs);\r\n+\t\t\r\n+\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n+\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n+\t\t// from the Set's inputs\r\n+\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(setFunction, CategoryAssignment.class);\r\n+\t\t\r\n+\t\t// Find all applicable TypeInstances that are directly or indirectly contained by the sei\r\n+\t\tTreeTraverser<StructuralElementInstance> treeTraverser = new TreeTraverser<>();\r\n+\t\ttreeTraverser.traverse(sei, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeSei) {\r\n+\t\t\t\tboolean isMatching = false;\r\n+\t\t\t\t// Get all nested TypeInstances to the current treeSei and see if one\r\n+\t\t\t\t// is matching to the definition of what is referenced by the SET function\r\n+\t\t\t\tList<CategoryAssignment> currentCas = new LinkedList<>(treeSei.getCategoryAssignments());\r\n+\t\t\t\tcurrentCas.remove(currentCa);\r\n+\t\t\t\tCollection<ATypeInstance> typeInstances = VirSatEcoreUtil.getAllContentsOfType(currentCas, ATypeInstance.class, true);\r\n+\t\t\t\ttypeInstances.addAll(currentCas);\r\n+\t\t\t\t\r\n+\t\t\t\t// Loop over all identified ATypeInstances\r\n+\t\t\t\tfor (ATypeInstance aTypeInstance : typeInstances) {\r\n+\t\t\t\t\tboolean correctType = aTypeInstance.getType() == typeDefinition;\r\n+\t\t\t\t\tboolean notComputedByChild = !childrenWithSetFunction.contains(treeSei);\r\n+\t\t\t\t\tif (correctType && notComputedByChild) {\r\n+\t\t\t\t\t\t// For composed property instances we have to get the category assignment\r\n+\t\t\t\t\t\t// to be able to work with them, thus try to decompose it\r\n+\t\t\t\t\t\tATypeInstance decomposedTypeInstance = aTypeInstance;\r\n+\t\t\t\t\t\tif (decomposedTypeInstance instanceof ComposedPropertyInstance) {\r\n+\t\t\t\t\t\t\tdecomposedTypeInstance = ((ComposedPropertyInstance) aTypeInstance).getTypeInstance();\r\n+\t\t\t\t\t\t}\r\n \r\n-\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(aTypeInstance, filterName);\r\n-\t\t\t\t\tif (correctName) {\r\n-\t\t\t\t\t\tinputs.add(aTypeInstance);\r\n+\t\t\t\t\t\t// In case a name filter is set for the Set function make sure to apply it.\r\n+\t\t\t\t\t\t// If all properties are correct, remember the decomposed Type Instance as an input\r\n+\t\t\t\t\t\t// remember that we definitely had a match and continue with all the other items and check\r\n+\t\t\t\t\t\t// if they are potential inputs. Saving the match is important, so that the tree traverser\r\n+\t\t\t\t\t\t// can count the levels of nesting and levels of matches correctly\t\t\t\t\t\t\r\n+\t\t\t\t\t\tboolean correctName = !filterForName || hasCorrectName(decomposedTypeInstance, filterName);\r\n+\t\t\t\t\t\tif (correctName) {\r\n+\t\t\t\t\t\t\tinputs.add(decomposedTypeInstance);\r\n+\t\t\t\t\t\t\tisMatching = true;\r\n+\t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t// return the result to decide if the current node will be counted\r\n+\t\t\t\t// for the matching levels or not\r\n+\t\t\t\treturn isMatching;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int processedLevel, int matchedLevel) {\r\n+\t\t\t\t// Compare the depth of found matches with the depth set by the set function\r\n+\t\t\t\tint targetDepth = setFunction.getDepth();\r\n+\t\t\t\tboolean isDepthInfinite = targetDepth == AAdvancedFunctionOp.DEPTH_INFINITE;\r\n+\t\t\t\tboolean isDepthNotReached =  matchedLevel <= targetDepth; \r\n+\t\t\t\treturn isDepthInfinite || isDepthNotReached;\r\n \t\t\t}\r\n-\t\t}\r\n \r\n-\t\t// Get the CA in which the current Set resides. All TypeInstances of this category shall not be\r\n-\t\t// part of the inputs to be processed by this SetFunction. Accordingly they have to be removed\r\n-\t\t// from the Set's inputs\r\n-\t\tCategoryAssignment currentCa = VirSatEcoreUtil.getEContainerOfClass(object, CategoryAssignment.class);\r\n-\t\tif (currentCa != null) {\r\n-\t\t\tfor (APropertyInstance pi : currentCa.getPropertyInstances()) {\r\n-\t\t\t\tinputs.remove(pi);\r\n-\t\t\t\tif (pi instanceof ComposedPropertyInstance) {\r\n-\t\t\t\t\tComposedPropertyInstance cpi = (ComposedPropertyInstance) pi;\r\n-\t\t\t\t\tinputs.remove(cpi.getTypeInstance());\r\n-\t\t\t\t}\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\t// Nothing special has to be processed with the SEIs that have Set functions in their calculations\r\n \t\t\t}\r\n-\t\t}\r\n+\t\t});\r\n \r\n \t\treturn inputs;\r\n \t}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODc4MDQ0OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzoyNTowNVrOFv01EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzoyNTowNVrOFv01EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5Mjk0NA==", "bodyText": "Not immediately clear what it matches. I suggest we either check it explicitly like return treeNode != seiChild1 && treenode != seiChild2 or check a special name like \"MISMATCH\", and set it to mismatching elements.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385692944", "createdAt": "2020-02-28T13:25:05Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODc5MDY3OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzoyODoxM1rOFv07Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToyNjowM1rOFwjo-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NDQ3OQ==", "bodyText": "Shall we also add tree level and match level as parameters here?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385694479", "createdAt": "2020-02-28T13:28:13Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1OTg5Nw==", "bodyText": "I thought about that one as well, but wanted to keep it to as minimal change as needed. thus i would argues for no, for the moment.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386459897", "createdAt": "2020-03-02T15:26:03Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model/src/de/dlr/sc/virsat/model/dvlm/tree/ITreeTraverserMatcher.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+import java.util.Collection;\r\n+\r\n+\r\n+/**\r\n+ * Interface for plugging different logic into {@link BeanStructuralTreeTraverser}\r\n+ * For example for building a tree consisting only of nodes with a certain Category attached\r\n+ * @param <TYPE> The type for which the matcher should apply\r\n+ */\r\n+public interface ITreeTraverserMatcher<TYPE> {\r\n+\r\n+\t/**\r\n+\t * Checks if the passed treeNode bean matches the desired criteria\r\n+\t * @param treeNode node bean to check\r\n+\t * @return true if this node matches, false otherwise\r\n+\t */\r\n+\tboolean isMatching(TYPE treeNode);\r\n+\t\r\n+\t/**\r\n+\t * Processes the found match\r\n+\t * @param treeNode a matching tree node\r\n+\t * @param matchingParent the closest parent of the node that also matches the criteria.\r\n+\t *        Can be null if the node does not have a matching parent\r\n+\t */\r\n+\tvoid processMatch(TYPE treeNode, TYPE matchingParent);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NDQ3OQ=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODgxNTA3OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzozNjo0NlrOFv1KDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToyOTozOFrOFwjyjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5ODMxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\n          \n          \n            \n            \t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\n          \n          \n            \n            \t\t\t\treturn treeNode != seiChild2Child;", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r385698318", "createdAt": "2020-02-28T13:36:46Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r\n+\t\t\t\ttraverseResults.add(new Result(treeNode, nestingLevel, matchingLevel));\r\n+\t\t\t\t\r\n+\t\t\t\t// Try to make sure that the seiChild2ChildChild which is theoretically correct, still does not get found\r\n+\t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\r\n+\t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2MjM1MA==", "bodyText": "The former one, has the default implementation of the interface connected to the test. Thus a change to the default implementation would be captured here. I prefer leaving it as it is, but i added a comment, why the statement has to be that complex.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/507#discussion_r386462350", "createdAt": "2020-03-02T15:29:38Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model.test/src/de/dlr/sc/virsat/model/dvlm/tree/TreeTraverserTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.dvlm.tree;\r\n+\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Test;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElement;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralElementInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.structural.StructuralFactory;\r\n+\r\n+import static org.hamcrest.Matchers.contains;\r\n+import static org.junit.Assert.assertEquals;\r\n+import static org.junit.Assert.assertFalse;\r\n+import static org.junit.Assert.assertThat;\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+public class TreeTraverserTest {\r\n+\r\n+\tStructuralElement se;\r\n+\t\r\n+\tStructuralElementInstance seiRoot;\r\n+\tStructuralElementInstance seiChild1;\r\n+\tStructuralElementInstance seiChild1Child;\r\n+\tStructuralElementInstance seiChild1ChildChild;\r\n+\tStructuralElementInstance seiChild2;\r\n+\tStructuralElementInstance seiChild2Child;\r\n+\tStructuralElementInstance seiChild2ChildChild;\r\n+\t\r\n+\t@Before\r\n+\tpublic void setUp() throws Exception {\r\n+\t\tStructuralElement se = StructuralFactory.eINSTANCE.createStructuralElement();\r\n+\t\t\r\n+\t\tseiRoot = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild1ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2 = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2Child = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\tseiChild2ChildChild = StructuralFactory.eINSTANCE.createStructuralElementInstance();\r\n+\t\t\r\n+\t\tse.setIsApplicableForAll(true);\r\n+\t\t\r\n+\t\tseiRoot.setType(se);\r\n+\t\tseiChild1.setType(se);\r\n+\t\tseiChild1Child.setType(se);\r\n+\t\tseiChild1ChildChild.setType(se);\r\n+\t\tseiChild2.setType(se);\r\n+\t\tseiChild2Child.setType(se);\r\n+\t\tseiChild2ChildChild.setType(se);\r\n+\t\t\r\n+\t\tseiRoot.getChildren().add(seiChild1);\r\n+\t\tseiRoot.getChildren().add(seiChild2);\r\n+\t\tseiChild1.getChildren().add(seiChild1Child);\r\n+\t\tseiChild2.getChildren().add(seiChild2Child);\r\n+\t\tseiChild1Child.getChildren().add(seiChild1ChildChild);\r\n+\t\tseiChild2Child.getChildren().add(seiChild2ChildChild);\r\n+\t\t\r\n+\t\t// Now set names for the 2 level and for the 3 level,\r\n+\t\t// Try to find them and check if the traverser reacts as expected\r\n+\t\tseiRoot.setName(\"Root\");\r\n+\t\tseiChild1Child.setName(\"ChildOf1\");\r\n+\t\tseiChild2Child.setName(\"ChildOf2\");\r\n+\t\tseiChild1ChildChild.setName(\"DoubleChildOf1\");\r\n+\t\tseiChild2ChildChild.setName(\"DoubleChildOf2\");\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Class to capture the results from the tree traversing\r\n+\t */\r\n+\tclass Result {\r\n+\t\t\r\n+\t\t@Override\r\n+\t\tpublic int hashCode() {\r\n+\t\t\tfinal int prime = 31;\r\n+\t\t\tint result = 1;\r\n+\t\t\tresult = prime * result + Objects.hash(matchingLevel, nestingLevel, sei);\r\n+\t\t\treturn result;\r\n+\t\t}\r\n+\r\n+\t\t@Override\r\n+\t\tpublic boolean equals(Object obj) {\r\n+\t\t\tif (this == obj) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t} else if (obj == null) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else if (getClass() != obj.getClass()) {\r\n+\t\t\t\treturn false;\r\n+\t\t\t} else {\r\n+\t\t\t\tResult other = (Result) obj;\r\n+\t\t\t\treturn matchingLevel == other.matchingLevel && nestingLevel == other.nestingLevel && Objects.equals(sei, other.sei);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t\r\n+\t\tResult(StructuralElementInstance sei, int processedLevel, int matchedLevel) {\r\n+\t\t\tthis.sei = sei;\r\n+\t\t\tthis.nestingLevel = processedLevel;\r\n+\t\t\tthis.matchingLevel = matchedLevel;\r\n+\t\t}\r\n+\r\n+\t\tStructuralElementInstance sei;\r\n+\t\tint nestingLevel;\r\n+\t\tint matchingLevel;\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testTraverse() {\r\n+\t\tList<Result> traverseResults = new LinkedList<>();\r\n+\t\tMap<StructuralElementInstance, StructuralElementInstance> mapToParentResults = new HashMap<>();\r\n+\t\t\r\n+\t\tTreeTraverser<StructuralElementInstance> traverser = new TreeTraverser<>();\r\n+\t\t\r\n+\t\ttraverser.traverse(seiRoot, new IStructuralElementInstanceTreeTraverserMatcher() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic void processMatch(StructuralElementInstance treeNode, StructuralElementInstance matchingParent) {\r\n+\t\t\t\tmapToParentResults.put(treeNode, matchingParent);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean isMatching(StructuralElementInstance treeNode) {\r\n+\t\t\t\treturn treeNode.getName() != null;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic boolean continueTraverseChildren(StructuralElementInstance treeNode, boolean isMatching, int nestingLevel, int matchingLevel) {\r\n+\t\t\t\ttraverseResults.add(new Result(treeNode, nestingLevel, matchingLevel));\r\n+\t\t\t\t\r\n+\t\t\t\t// Try to make sure that the seiChild2ChildChild which is theoretically correct, still does not get found\r\n+\t\t\t\tboolean isChild2Child = treeNode == seiChild2Child;\r\n+\t\t\t\treturn !isChild2Child && IStructuralElementInstanceTreeTraverserMatcher.super.continueTraverseChildren(treeNode, isMatching, nestingLevel, matchingLevel);\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5ODMxOA=="}, "originalCommit": {"oid": "2d7cc76e9a4c094fdc50aa0d13501c2bed86ffa3"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 686, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}