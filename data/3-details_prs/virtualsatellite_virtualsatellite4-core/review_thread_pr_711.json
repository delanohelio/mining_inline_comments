{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1ODA4MDIz", "number": 711, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwODo0ODowNFrOERvuhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwODo0ODowNFrOERvuhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDQzMjA1OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.team/src/de/dlr/sc/virsat/team/git/VirSatGitVersionControlBackend.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwODo0ODowNFrOG2nxgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMTo0NDoxMVrOG2sXIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNzkzNw==", "bodyText": "Do we maybe want to notify the user about the replacement? Like with a simple dialog? I'm afraid people will not realize that the change was reverted...", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/711#discussion_r459927937", "createdAt": "2020-07-24T08:48:04Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.team/src/de/dlr/sc/virsat/team/git/VirSatGitVersionControlBackend.java", "diffHunk": "@@ -93,41 +121,87 @@ protected void doCommit(Repository gitRepository, String message, SubMonitor mon\n \r\n \t@Override\r\n \tpublic void update(IProject project,  IProgressMonitor monitor) throws Exception {\r\n-\t\tSubMonitor commitAndPullMonitor = SubMonitor.convert(monitor, \"Virtual Satellite git commit and pull\", PROGRESS_INDEX_COMMIT_UPDATE_STEPS);\r\n+\t\tSubMonitor commitAndPullMonitor = SubMonitor.convert(monitor, \"Virtual Satellite git commit and pull\", PROGRESS_INDEX_UPDATE_STEPS);\r\n \t\t\r\n \t\t// Get the repository mapped to the project\r\n \t\tRepository gitRepository = RepositoryMapping.getMapping(project).getRepository();\r\n \t\t// Stage and commit all changes\r\n \t\tdoCommit(gitRepository, BACKEND_REPOSITORY_COMMIT_PULL_MESSAGE  + project.getName(), commitAndPullMonitor.split(1));\r\n \r\n \t\tcommitAndPullMonitor.split(1).subTask(\"Check if remotes exist\");\r\n+\t\t\r\n \t\t// Get the remotes for the repository\r\n \t\tString remoteUrl = gitRepository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n \t\tCollection<Ref> refs = Git.lsRemoteRepository()\r\n \t\t\t.setRemote(remoteUrl)\r\n \t\t\t.call();\r\n \t\t\r\n \t\t// Only perform a pull of the remote exists\r\n-\t\tProgressMonitor gitMonitor = new EclipseGitProgressTransformer(commitAndPullMonitor.split(1));\r\n-\t\t\r\n \t\tif (!refs.isEmpty()) {\r\n-\t\t\t// Pull from origin\r\n-\t\t\tGit.wrap(gitRepository).pull()\r\n+\t\t\t\r\n+\t\t\t// Pull from origin and apply the Recursive Merge Strategy. It is the git standard merge strategy.\r\n+\t\t\t// In case there has been another commit on the remote in between, the pull will try to resolve it\r\n+\t\t\t// and store it as a new commit locally.\r\n+\t\t\tProgressMonitor gitPullMonitor = new EclipseGitProgressTransformer(commitAndPullMonitor.setWorkRemaining(1).split(1));\r\n+\t\t\tlastPullResult = Git.wrap(gitRepository).pull()\r\n \t\t\t\t.setCredentialsProvider(credentialsProvider)\r\n-\t\t\t\t.setProgressMonitor(gitMonitor)\r\n+\t\t\t\t.setProgressMonitor(gitPullMonitor)\r\n \t\t\t\t.setTimeout(GIT_REMOTE_TIMEOUT)\r\n-\t\t\t\t.setStrategy(MergeStrategy.THEIRS)\r\n+\t\t\t\t.setStrategy(MergeStrategy.RECURSIVE)\r\n \t\t\t\t.call();\r\n-\t\t}\r\n-\t\t\r\n+\t\t\t\r\n+\t\t\tcheckAndResolveConflicts(gitRepository, commitAndPullMonitor);\r\n+\t\t} \r\n+\t\t \r\n \t\tGit.wrap(gitRepository).close();\r\n \t\t\r\n \t\tproject.refreshLocal(Resource.DEPTH_INFINITE, commitAndPullMonitor.split(1));\r\n \t}\r\n+\t\r\n+\t/**\r\n+\t * In case not all files could be merged they need to be fixed.\r\n+\t * Conflicting files are fixed by replacing them with the version from the remote git repository.\r\n+\t * @param gitRepository the git repository\r\n+\t * @param monitor the progress monitor\r\n+\t * @throws Exception\r\n+\t */\r\n+\tprivate void checkAndResolveConflicts(Repository gitRepository, SubMonitor progressMonitor) throws Exception {\r\n+\t\t// Therefore lets see if files are in a conflicting state within the repository\r\n+\t\tSet<String> conflictingFiles = Git.wrap(gitRepository).status().call().getConflicting();\r\n+\t\t\r\n+\t\t// If there are any continue from here with resolving the conflicts.\r\n+\t\tif (!conflictingFiles.isEmpty()) {\r\n+\t\t\tprogressMonitor.setWorkRemaining(2);\r\n+\t\t\tProgressMonitor gitCheckoutMonitor = new EclipseGitProgressTransformer(progressMonitor.split(1));\r\n+\t\t\t\r\n+\t\t\t// Prepare a checkout command to get THEIRS on all conflicting files.\r\n+\t\t\t// This basically means that in case of concept the files in the repository\r\n+\t\t\t// are regarded as being correct. This happens on the cost of loosing local changes.\r\n+\t\t\tCheckoutCommand checkoutCommand = Git.wrap(gitRepository).checkout();\r\n+\t\t\tcheckoutCommand.setProgressMonitor(gitCheckoutMonitor);\r\n+\t\t\t\r\n+\t\t\tfor (String conflictingFile : conflictingFiles) {\r\n+\t\t\t\tcheckoutCommand.addPath(conflictingFile);\r\n+\t\t\t}\r\n+\t\t\tcheckoutCommand.setStage(Stage.THEIRS);\r\n+\t\t\tcheckoutCommand.call();\r\n+\t\t\t\r\n+\t\t\t// Finally close the still open merge commit\r\n+\t\t\tdoCommit(gitRepository, BACKEND_REPOSITORY_MERGE_COMMIT_MESSAGE, progressMonitor.split(1));\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6475447278cdd6333a5ab3f7a9390f51cf24c80f"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMzEwNQ==", "bodyText": "@franzTobiasDLR Its not much but in the EGit dialog you at least see the status notification that there were conflicts + you get the modified files.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/711#discussion_r460003105", "createdAt": "2020-07-24T11:44:11Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.team/src/de/dlr/sc/virsat/team/git/VirSatGitVersionControlBackend.java", "diffHunk": "@@ -93,41 +121,87 @@ protected void doCommit(Repository gitRepository, String message, SubMonitor mon\n \r\n \t@Override\r\n \tpublic void update(IProject project,  IProgressMonitor monitor) throws Exception {\r\n-\t\tSubMonitor commitAndPullMonitor = SubMonitor.convert(monitor, \"Virtual Satellite git commit and pull\", PROGRESS_INDEX_COMMIT_UPDATE_STEPS);\r\n+\t\tSubMonitor commitAndPullMonitor = SubMonitor.convert(monitor, \"Virtual Satellite git commit and pull\", PROGRESS_INDEX_UPDATE_STEPS);\r\n \t\t\r\n \t\t// Get the repository mapped to the project\r\n \t\tRepository gitRepository = RepositoryMapping.getMapping(project).getRepository();\r\n \t\t// Stage and commit all changes\r\n \t\tdoCommit(gitRepository, BACKEND_REPOSITORY_COMMIT_PULL_MESSAGE  + project.getName(), commitAndPullMonitor.split(1));\r\n \r\n \t\tcommitAndPullMonitor.split(1).subTask(\"Check if remotes exist\");\r\n+\t\t\r\n \t\t// Get the remotes for the repository\r\n \t\tString remoteUrl = gitRepository.getConfig().getString(\"remote\", \"origin\", \"url\");\r\n \t\tCollection<Ref> refs = Git.lsRemoteRepository()\r\n \t\t\t.setRemote(remoteUrl)\r\n \t\t\t.call();\r\n \t\t\r\n \t\t// Only perform a pull of the remote exists\r\n-\t\tProgressMonitor gitMonitor = new EclipseGitProgressTransformer(commitAndPullMonitor.split(1));\r\n-\t\t\r\n \t\tif (!refs.isEmpty()) {\r\n-\t\t\t// Pull from origin\r\n-\t\t\tGit.wrap(gitRepository).pull()\r\n+\t\t\t\r\n+\t\t\t// Pull from origin and apply the Recursive Merge Strategy. It is the git standard merge strategy.\r\n+\t\t\t// In case there has been another commit on the remote in between, the pull will try to resolve it\r\n+\t\t\t// and store it as a new commit locally.\r\n+\t\t\tProgressMonitor gitPullMonitor = new EclipseGitProgressTransformer(commitAndPullMonitor.setWorkRemaining(1).split(1));\r\n+\t\t\tlastPullResult = Git.wrap(gitRepository).pull()\r\n \t\t\t\t.setCredentialsProvider(credentialsProvider)\r\n-\t\t\t\t.setProgressMonitor(gitMonitor)\r\n+\t\t\t\t.setProgressMonitor(gitPullMonitor)\r\n \t\t\t\t.setTimeout(GIT_REMOTE_TIMEOUT)\r\n-\t\t\t\t.setStrategy(MergeStrategy.THEIRS)\r\n+\t\t\t\t.setStrategy(MergeStrategy.RECURSIVE)\r\n \t\t\t\t.call();\r\n-\t\t}\r\n-\t\t\r\n+\t\t\t\r\n+\t\t\tcheckAndResolveConflicts(gitRepository, commitAndPullMonitor);\r\n+\t\t} \r\n+\t\t \r\n \t\tGit.wrap(gitRepository).close();\r\n \t\t\r\n \t\tproject.refreshLocal(Resource.DEPTH_INFINITE, commitAndPullMonitor.split(1));\r\n \t}\r\n+\t\r\n+\t/**\r\n+\t * In case not all files could be merged they need to be fixed.\r\n+\t * Conflicting files are fixed by replacing them with the version from the remote git repository.\r\n+\t * @param gitRepository the git repository\r\n+\t * @param monitor the progress monitor\r\n+\t * @throws Exception\r\n+\t */\r\n+\tprivate void checkAndResolveConflicts(Repository gitRepository, SubMonitor progressMonitor) throws Exception {\r\n+\t\t// Therefore lets see if files are in a conflicting state within the repository\r\n+\t\tSet<String> conflictingFiles = Git.wrap(gitRepository).status().call().getConflicting();\r\n+\t\t\r\n+\t\t// If there are any continue from here with resolving the conflicts.\r\n+\t\tif (!conflictingFiles.isEmpty()) {\r\n+\t\t\tprogressMonitor.setWorkRemaining(2);\r\n+\t\t\tProgressMonitor gitCheckoutMonitor = new EclipseGitProgressTransformer(progressMonitor.split(1));\r\n+\t\t\t\r\n+\t\t\t// Prepare a checkout command to get THEIRS on all conflicting files.\r\n+\t\t\t// This basically means that in case of concept the files in the repository\r\n+\t\t\t// are regarded as being correct. This happens on the cost of loosing local changes.\r\n+\t\t\tCheckoutCommand checkoutCommand = Git.wrap(gitRepository).checkout();\r\n+\t\t\tcheckoutCommand.setProgressMonitor(gitCheckoutMonitor);\r\n+\t\t\t\r\n+\t\t\tfor (String conflictingFile : conflictingFiles) {\r\n+\t\t\t\tcheckoutCommand.addPath(conflictingFile);\r\n+\t\t\t}\r\n+\t\t\tcheckoutCommand.setStage(Stage.THEIRS);\r\n+\t\t\tcheckoutCommand.call();\r\n+\t\t\t\r\n+\t\t\t// Finally close the still open merge commit\r\n+\t\t\tdoCommit(gitRepository, BACKEND_REPOSITORY_MERGE_COMMIT_MESSAGE, progressMonitor.split(1));\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNzkzNw=="}, "originalCommit": {"oid": "6475447278cdd6333a5ab3f7a9390f51cf24c80f"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 600, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}