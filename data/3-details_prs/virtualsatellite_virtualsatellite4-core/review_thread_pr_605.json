{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NDYxNTgz", "number": 605, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMToyMjoxNVrOD_WiEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjoxMTo1MFrOD_XUlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzU2MDQ4OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMToyMjoxNVrOGZ959Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMToyMjoxNVrOGZ959Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4MTg0NQ==", "bodyText": "Either we should leave the class comment out or actually write something.\nEmpty comment blocks to evade check style dont make sense to me.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r429881845", "createdAt": "2020-05-25T11:22:15Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.celleditor;\r\n+\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.common.command.UnexecutableCommand;\r\n+import org.eclipse.emf.edit.command.SetCommand;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.jface.dialogs.Dialog;\r\n+import org.eclipse.jface.viewers.CellEditor;\r\n+import org.eclipse.jface.viewers.ColumnViewer;\r\n+import org.eclipse.jface.viewers.DialogCellEditor;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Control;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.forms.widgets.FormToolkit;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.ATypeInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.AProperty;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.APropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.PropertyinstancesPackage;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.snippet.dialog.RequirementsTraceEditingDialog;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.uiengine.ui.cellEditor.aproperties.APropertyCellEditingSupport;\r\n+\r\n+/**\r\n+ *\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzU2NDM3OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMToyMzo0OFrOGZ98Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MzoxOVrOGq64eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4MjQ2Ng==", "bodyText": "A small comment why we can oberride the parent canEdit and ignore the setCommand executability would be nice here.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r429882466", "createdAt": "2020-05-25T11:23:48Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.celleditor;\r\n+\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.common.command.UnexecutableCommand;\r\n+import org.eclipse.emf.edit.command.SetCommand;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.jface.dialogs.Dialog;\r\n+import org.eclipse.jface.viewers.CellEditor;\r\n+import org.eclipse.jface.viewers.ColumnViewer;\r\n+import org.eclipse.jface.viewers.DialogCellEditor;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Control;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.forms.widgets.FormToolkit;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.ATypeInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.AProperty;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.APropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.PropertyinstancesPackage;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.snippet.dialog.RequirementsTraceEditingDialog;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.uiengine.ui.cellEditor.aproperties.APropertyCellEditingSupport;\r\n+\r\n+/**\r\n+ *\r\n+ */\r\n+public class RequirementTraceEditingSupport extends APropertyCellEditingSupport {\r\n+\r\n+\tprotected FormToolkit toolkit;\r\n+\t\r\n+\t/**\r\n+\t * constructor of the value property cell editing support instantiate the editor\r\n+\t * @param editingDomain the editing domain\r\n+\t * @param viewer the table viewer\r\n+\t * @param property an aproperty\r\n+\t */\r\n+\tpublic RequirementTraceEditingSupport(EditingDomain editingDomain, ColumnViewer viewer, AProperty property, FormToolkit toolkit) {\r\n+\t\tsuper(editingDomain, viewer, property);\r\n+\t\tthis.toolkit = toolkit;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected CellEditor getCellEditor(Object element) {\r\n+\t\t\r\n+\t\tif (element instanceof ComposedPropertyInstance) {\r\n+\t\t\tRequirement req = new Requirement(((ComposedPropertyInstance) element).getTypeInstance());\r\n+\t\t\tfinal CategoryAssignment referencedTypeInstance = req.getTrace().getTypeInstance();\r\n+\t\t\teditor = new DialogCellEditor((Composite) viewer.getControl()) {\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Object openDialogBox(Control cellEditorWindow) {\r\n+\t\t\t\t\tEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE.getEd(referencedTypeInstance);\r\n+\t\t\t\t\tif (referencedTypeInstance != null) {\r\n+\t\t\t\t\t\tDialog dialog = new RequirementsTraceEditingDialog(\r\n+\t\t\t\t\t\t\t\tPlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(), toolkit, editingDomain,\r\n+\t\t\t\t\t\t\t\treferencedTypeInstance);\r\n+\t\t\t\t\t\tif (dialog.open() == Dialog.OK) {\r\n+\t\t\t\t\t\t\treturn referencedTypeInstance;\r\n+\t\t\t\t\t\t} \r\n+\t\t\t\t\t}\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Button createButton(final Composite parent) {\r\n+\t\t\t\t\t// This override is needed to the following eclipse bug\r\n+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193081\r\n+\t\t\t\t\tButton button = super.createButton(parent);\r\n+\r\n+\t\t\t\t\t// This listener hands back traversal control to the cell rather the button. \r\n+\t\t\t\t\t// This is important if TableEditor functionality is used. if the button handles the traverse \r\n+\t\t\t\t\t// signal, it will try to select the next button but not the next cell.\r\n+\t\t\t\t\tbutton.addListener(SWT.Traverse, (event) -> parent.notifyListeners(SWT.Traverse, event));\r\n+\t\t\t\t\treturn button;\r\n+\t\t\t\t}\r\n+\t\t\t};\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn editor;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected Object getValue(Object element) {\r\n+\t\tAPropertyInstance propertyInstance = getPropertyInstance(element);\r\n+\t\tATypeInstance value = ((ComposedPropertyInstance) propertyInstance).getTypeInstance();\r\n+\t\treturn value;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected boolean canEdit(Object element) {\r\n+\t\treturn true;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1ODEwNg==", "bodyText": "I added a comment... In short this editing support is not actually doing any change but rather forwarding it... It's not even executing a command... That's why we're not doing the check.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r447658106", "createdAt": "2020-06-30T12:53:19Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.celleditor;\r\n+\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.common.command.UnexecutableCommand;\r\n+import org.eclipse.emf.edit.command.SetCommand;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.jface.dialogs.Dialog;\r\n+import org.eclipse.jface.viewers.CellEditor;\r\n+import org.eclipse.jface.viewers.ColumnViewer;\r\n+import org.eclipse.jface.viewers.DialogCellEditor;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Control;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.forms.widgets.FormToolkit;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.ATypeInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.AProperty;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.APropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.PropertyinstancesPackage;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.snippet.dialog.RequirementsTraceEditingDialog;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.uiengine.ui.cellEditor.aproperties.APropertyCellEditingSupport;\r\n+\r\n+/**\r\n+ *\r\n+ */\r\n+public class RequirementTraceEditingSupport extends APropertyCellEditingSupport {\r\n+\r\n+\tprotected FormToolkit toolkit;\r\n+\t\r\n+\t/**\r\n+\t * constructor of the value property cell editing support instantiate the editor\r\n+\t * @param editingDomain the editing domain\r\n+\t * @param viewer the table viewer\r\n+\t * @param property an aproperty\r\n+\t */\r\n+\tpublic RequirementTraceEditingSupport(EditingDomain editingDomain, ColumnViewer viewer, AProperty property, FormToolkit toolkit) {\r\n+\t\tsuper(editingDomain, viewer, property);\r\n+\t\tthis.toolkit = toolkit;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected CellEditor getCellEditor(Object element) {\r\n+\t\t\r\n+\t\tif (element instanceof ComposedPropertyInstance) {\r\n+\t\t\tRequirement req = new Requirement(((ComposedPropertyInstance) element).getTypeInstance());\r\n+\t\t\tfinal CategoryAssignment referencedTypeInstance = req.getTrace().getTypeInstance();\r\n+\t\t\teditor = new DialogCellEditor((Composite) viewer.getControl()) {\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Object openDialogBox(Control cellEditorWindow) {\r\n+\t\t\t\t\tEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE.getEd(referencedTypeInstance);\r\n+\t\t\t\t\tif (referencedTypeInstance != null) {\r\n+\t\t\t\t\t\tDialog dialog = new RequirementsTraceEditingDialog(\r\n+\t\t\t\t\t\t\t\tPlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(), toolkit, editingDomain,\r\n+\t\t\t\t\t\t\t\treferencedTypeInstance);\r\n+\t\t\t\t\t\tif (dialog.open() == Dialog.OK) {\r\n+\t\t\t\t\t\t\treturn referencedTypeInstance;\r\n+\t\t\t\t\t\t} \r\n+\t\t\t\t\t}\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Button createButton(final Composite parent) {\r\n+\t\t\t\t\t// This override is needed to the following eclipse bug\r\n+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193081\r\n+\t\t\t\t\tButton button = super.createButton(parent);\r\n+\r\n+\t\t\t\t\t// This listener hands back traversal control to the cell rather the button. \r\n+\t\t\t\t\t// This is important if TableEditor functionality is used. if the button handles the traverse \r\n+\t\t\t\t\t// signal, it will try to select the next button but not the next cell.\r\n+\t\t\t\t\tbutton.addListener(SWT.Traverse, (event) -> parent.notifyListeners(SWT.Traverse, event));\r\n+\t\t\t\t\treturn button;\r\n+\t\t\t\t}\r\n+\t\t\t};\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn editor;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected Object getValue(Object element) {\r\n+\t\tAPropertyInstance propertyInstance = getPropertyInstance(element);\r\n+\t\tATypeInstance value = ((ComposedPropertyInstance) propertyInstance).getTypeInstance();\r\n+\t\treturn value;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected boolean canEdit(Object element) {\r\n+\t\treturn true;\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4MjQ2Ng=="}, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzY1NjEzOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMTo1ODo1M1rOGZ-0HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1NDoyNFrOGq67Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjczMw==", "bodyText": "Same as above. What is the reason we have to override the behavior since this looks like the parent class behavior with less checks.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r429896733", "createdAt": "2020-05-25T11:58:53Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.celleditor;\r\n+\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.common.command.UnexecutableCommand;\r\n+import org.eclipse.emf.edit.command.SetCommand;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.jface.dialogs.Dialog;\r\n+import org.eclipse.jface.viewers.CellEditor;\r\n+import org.eclipse.jface.viewers.ColumnViewer;\r\n+import org.eclipse.jface.viewers.DialogCellEditor;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Control;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.forms.widgets.FormToolkit;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.ATypeInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.AProperty;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.APropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.PropertyinstancesPackage;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.snippet.dialog.RequirementsTraceEditingDialog;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.uiengine.ui.cellEditor.aproperties.APropertyCellEditingSupport;\r\n+\r\n+/**\r\n+ *\r\n+ */\r\n+public class RequirementTraceEditingSupport extends APropertyCellEditingSupport {\r\n+\r\n+\tprotected FormToolkit toolkit;\r\n+\t\r\n+\t/**\r\n+\t * constructor of the value property cell editing support instantiate the editor\r\n+\t * @param editingDomain the editing domain\r\n+\t * @param viewer the table viewer\r\n+\t * @param property an aproperty\r\n+\t */\r\n+\tpublic RequirementTraceEditingSupport(EditingDomain editingDomain, ColumnViewer viewer, AProperty property, FormToolkit toolkit) {\r\n+\t\tsuper(editingDomain, viewer, property);\r\n+\t\tthis.toolkit = toolkit;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected CellEditor getCellEditor(Object element) {\r\n+\t\t\r\n+\t\tif (element instanceof ComposedPropertyInstance) {\r\n+\t\t\tRequirement req = new Requirement(((ComposedPropertyInstance) element).getTypeInstance());\r\n+\t\t\tfinal CategoryAssignment referencedTypeInstance = req.getTrace().getTypeInstance();\r\n+\t\t\teditor = new DialogCellEditor((Composite) viewer.getControl()) {\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Object openDialogBox(Control cellEditorWindow) {\r\n+\t\t\t\t\tEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE.getEd(referencedTypeInstance);\r\n+\t\t\t\t\tif (referencedTypeInstance != null) {\r\n+\t\t\t\t\t\tDialog dialog = new RequirementsTraceEditingDialog(\r\n+\t\t\t\t\t\t\t\tPlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(), toolkit, editingDomain,\r\n+\t\t\t\t\t\t\t\treferencedTypeInstance);\r\n+\t\t\t\t\t\tif (dialog.open() == Dialog.OK) {\r\n+\t\t\t\t\t\t\treturn referencedTypeInstance;\r\n+\t\t\t\t\t\t} \r\n+\t\t\t\t\t}\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Button createButton(final Composite parent) {\r\n+\t\t\t\t\t// This override is needed to the following eclipse bug\r\n+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193081\r\n+\t\t\t\t\tButton button = super.createButton(parent);\r\n+\r\n+\t\t\t\t\t// This listener hands back traversal control to the cell rather the button. \r\n+\t\t\t\t\t// This is important if TableEditor functionality is used. if the button handles the traverse \r\n+\t\t\t\t\t// signal, it will try to select the next button but not the next cell.\r\n+\t\t\t\t\tbutton.addListener(SWT.Traverse, (event) -> parent.notifyListeners(SWT.Traverse, event));\r\n+\t\t\t\t\treturn button;\r\n+\t\t\t\t}\r\n+\t\t\t};\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn editor;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected Object getValue(Object element) {\r\n+\t\tAPropertyInstance propertyInstance = getPropertyInstance(element);\r\n+\t\tATypeInstance value = ((ComposedPropertyInstance) propertyInstance).getTypeInstance();\r\n+\t\treturn value;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected boolean canEdit(Object element) {\r\n+\t\treturn true;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected Command createSetCommand(Object element, Object userInputValue) {\r\n+\t\tAPropertyInstance propertyInstance = getPropertyInstance(element);\r\n+\t\tif (propertyInstance != null) {\r\n+\t\t\tCommand cmd = SetCommand.create(editingDomain, propertyInstance, PropertyinstancesPackage.Literals.REFERENCE_PROPERTY_INSTANCE__REFERENCE, userInputValue); \r\n+\t\t\treturn cmd;\r\n+\t\t}\r\n+\t\treturn UnexecutableCommand.INSTANCE;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected void setValue(Object element, Object userInputValue) {\r\n+\t\tCommand cmd = createSetCommand(element, userInputValue);  \r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1ODc5NQ==", "bodyText": "I changed the method to only update the viewer... The getSetCommand was actually never doing anything... I also added a comment to this method why we need to overwrite it", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r447658795", "createdAt": "2020-06-30T12:54:24Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/celleditor/RequirementTraceEditingSupport.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.extension.requirements.ui.celleditor;\r\n+\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.common.command.UnexecutableCommand;\r\n+import org.eclipse.emf.edit.command.SetCommand;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.jface.dialogs.Dialog;\r\n+import org.eclipse.jface.viewers.CellEditor;\r\n+import org.eclipse.jface.viewers.ColumnViewer;\r\n+import org.eclipse.jface.viewers.DialogCellEditor;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Control;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.forms.widgets.FormToolkit;\r\n+\r\n+import de.dlr.sc.virsat.model.dvlm.categories.ATypeInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.CategoryAssignment;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.AProperty;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.APropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.ComposedPropertyInstance;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertyinstances.PropertyinstancesPackage;\r\n+import de.dlr.sc.virsat.model.extension.requirements.model.Requirement;\r\n+import de.dlr.sc.virsat.model.extension.requirements.ui.snippet.dialog.RequirementsTraceEditingDialog;\r\n+import de.dlr.sc.virsat.project.editingDomain.VirSatEditingDomainRegistry;\r\n+import de.dlr.sc.virsat.uiengine.ui.cellEditor.aproperties.APropertyCellEditingSupport;\r\n+\r\n+/**\r\n+ *\r\n+ */\r\n+public class RequirementTraceEditingSupport extends APropertyCellEditingSupport {\r\n+\r\n+\tprotected FormToolkit toolkit;\r\n+\t\r\n+\t/**\r\n+\t * constructor of the value property cell editing support instantiate the editor\r\n+\t * @param editingDomain the editing domain\r\n+\t * @param viewer the table viewer\r\n+\t * @param property an aproperty\r\n+\t */\r\n+\tpublic RequirementTraceEditingSupport(EditingDomain editingDomain, ColumnViewer viewer, AProperty property, FormToolkit toolkit) {\r\n+\t\tsuper(editingDomain, viewer, property);\r\n+\t\tthis.toolkit = toolkit;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tprotected CellEditor getCellEditor(Object element) {\r\n+\t\t\r\n+\t\tif (element instanceof ComposedPropertyInstance) {\r\n+\t\t\tRequirement req = new Requirement(((ComposedPropertyInstance) element).getTypeInstance());\r\n+\t\t\tfinal CategoryAssignment referencedTypeInstance = req.getTrace().getTypeInstance();\r\n+\t\t\teditor = new DialogCellEditor((Composite) viewer.getControl()) {\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Object openDialogBox(Control cellEditorWindow) {\r\n+\t\t\t\t\tEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE.getEd(referencedTypeInstance);\r\n+\t\t\t\t\tif (referencedTypeInstance != null) {\r\n+\t\t\t\t\t\tDialog dialog = new RequirementsTraceEditingDialog(\r\n+\t\t\t\t\t\t\t\tPlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(), toolkit, editingDomain,\r\n+\t\t\t\t\t\t\t\treferencedTypeInstance);\r\n+\t\t\t\t\t\tif (dialog.open() == Dialog.OK) {\r\n+\t\t\t\t\t\t\treturn referencedTypeInstance;\r\n+\t\t\t\t\t\t} \r\n+\t\t\t\t\t}\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\t@Override\r\n+\t\t\t\tprotected Button createButton(final Composite parent) {\r\n+\t\t\t\t\t// This override is needed to the following eclipse bug\r\n+\t\t\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=193081\r\n+\t\t\t\t\tButton button = super.createButton(parent);\r\n+\r\n+\t\t\t\t\t// This listener hands back traversal control to the cell rather the button. \r\n+\t\t\t\t\t// This is important if TableEditor functionality is used. if the button handles the traverse \r\n+\t\t\t\t\t// signal, it will try to select the next button but not the next cell.\r\n+\t\t\t\t\tbutton.addListener(SWT.Traverse, (event) -> parent.notifyListeners(SWT.Traverse, event));\r\n+\t\t\t\t\treturn button;\r\n+\t\t\t\t}\r\n+\t\t\t};\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn editor;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected Object getValue(Object element) {\r\n+\t\tAPropertyInstance propertyInstance = getPropertyInstance(element);\r\n+\t\tATypeInstance value = ((ComposedPropertyInstance) propertyInstance).getTypeInstance();\r\n+\t\treturn value;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected boolean canEdit(Object element) {\r\n+\t\treturn true;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected Command createSetCommand(Object element, Object userInputValue) {\r\n+\t\tAPropertyInstance propertyInstance = getPropertyInstance(element);\r\n+\t\tif (propertyInstance != null) {\r\n+\t\t\tCommand cmd = SetCommand.create(editingDomain, propertyInstance, PropertyinstancesPackage.Literals.REFERENCE_PROPERTY_INSTANCE__REFERENCE, userInputValue); \r\n+\t\t\treturn cmd;\r\n+\t\t}\r\n+\t\treturn UnexecutableCommand.INSTANCE;\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tprotected void setValue(Object element, Object userInputValue) {\r\n+\t\tCommand cmd = createSetCommand(element, userInputValue);  \r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjczMw=="}, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzY4OTgzOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/provider/RequirementsAttributeLabelProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjoxMTo1MFrOGZ_IxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MjowOFrOGq611Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMjAyMA==", "bodyText": "I only recently learned this one:\nIf you use a List instead of StringBuilder you can do \"{\" + String.join(\" ,\", myList) + \"}\" you can get java to do the delimiting for you without needing these nasty if logic blocks.", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r429902020", "createdAt": "2020-05-25T12:11:50Z", "author": {"login": "SaMuellerDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/provider/RequirementsAttributeLabelProvider.java", "diffHunk": "@@ -163,27 +174,60 @@ public Image getColumnImage(Object object, int columnIndex) {\n \r\n \t\treturn super.getColumnImage(object, columnIndex);\r\n \t}\r\n-\t\r\n+\r\n \t/**\r\n-\t * Clean up requirements if their type or a type of an attribute does not exist anymore\r\n+\t * Clean up requirements if their type or a type of an attribute does not exist\r\n+\t * anymore\r\n+\t * \r\n \t * @param att the attribute value\r\n \t */\r\n \tprotected void cleanUpAttribue(AttributeValue att) {\r\n \t\tRequirement containingRequirement = att.getCaBeanFromParentSei(Requirement.class);\r\n \t\tVirSatTransactionalEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE\r\n \t\t\t\t.getEd(att.getTypeInstance());\r\n-\t\t\r\n+\r\n \t\tif (containingRequirement != null && containingRequirement.getReqType() == null) {\r\n-\t\t\t//requirement does not have a type anymore... completely delete it\r\n-\t\t\t\r\n+\t\t\t// requirement does not have a type anymore... completely delete it\r\n+\r\n \t\t\teditingDomain.getVirSatCommandStack().execute(containingRequirement.delete(editingDomain));\r\n-\t\t\t\r\n+\r\n \t\t} else if (att.getAttType() == null) {\r\n-\t\t\t//Only the attribute does not have a type anymore... clean the attribute value\r\n-\t\t\t\r\n+\t\t\t// Only the attribute does not have a type anymore... clean the attribute value\r\n+\r\n \t\t\teditingDomain.getVirSatCommandStack().execute(att.delete(editingDomain));\r\n \t\t}\r\n-\t\t\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Create a label for requirements traces customized to this table \r\n+\t * \r\n+\t * @param req the requirement for which a trace label is created\r\n+\t * @return the trace label\r\n+\t */\r\n+\tprotected String getTraceLabel(Requirement req) {\r\n+\t\tif (req.getTrace().getTarget() == null || req.getTrace().getTarget().isEmpty()) {\r\n+\t\t\treturn EMPTY_TRACE_STRING;\r\n+\t\t} else {\r\n+\t\t\tStringBuilder traceString = new StringBuilder();\r\n+\t\t\ttraceString.append(\"{\");\r\n+\r\n+\t\t\t// Some heavy casting necessary because Bean GenericCategory is abstract\r\n+\t\t\tAPropertyInstance targetProperty = req.getTrace().getTypeInstance().getPropertyInstances()\r\n+\t\t\t\t\t.get(REQUIREMENT_TRACE_TARGET_PROPERTY_NUMBER);\r\n+\t\t\tfor (APropertyInstance targetRPI : ((ArrayInstance) targetProperty).getArrayInstances()) {\r\n+\t\t\t\tCategoryAssignment target = (CategoryAssignment) ((ReferencePropertyInstance) targetRPI)\r\n+\t\t\t\t\t\t.getReference();\r\n+\t\t\t\tif (target != null) {\r\n+\t\t\t\t\ttraceString.append(target.getName());\r\n+\t\t\t\t\tif (((ArrayInstance) targetProperty).getArrayInstances()\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NzQyOQ==", "bodyText": "Ah, that's cool! Didn't know that...", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/605#discussion_r447657429", "createdAt": "2020-06-30T12:52:08Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.extension.requirements.ui/src/de/dlr/sc/virsat/model/extension/requirements/ui/provider/RequirementsAttributeLabelProvider.java", "diffHunk": "@@ -163,27 +174,60 @@ public Image getColumnImage(Object object, int columnIndex) {\n \r\n \t\treturn super.getColumnImage(object, columnIndex);\r\n \t}\r\n-\t\r\n+\r\n \t/**\r\n-\t * Clean up requirements if their type or a type of an attribute does not exist anymore\r\n+\t * Clean up requirements if their type or a type of an attribute does not exist\r\n+\t * anymore\r\n+\t * \r\n \t * @param att the attribute value\r\n \t */\r\n \tprotected void cleanUpAttribue(AttributeValue att) {\r\n \t\tRequirement containingRequirement = att.getCaBeanFromParentSei(Requirement.class);\r\n \t\tVirSatTransactionalEditingDomain editingDomain = VirSatEditingDomainRegistry.INSTANCE\r\n \t\t\t\t.getEd(att.getTypeInstance());\r\n-\t\t\r\n+\r\n \t\tif (containingRequirement != null && containingRequirement.getReqType() == null) {\r\n-\t\t\t//requirement does not have a type anymore... completely delete it\r\n-\t\t\t\r\n+\t\t\t// requirement does not have a type anymore... completely delete it\r\n+\r\n \t\t\teditingDomain.getVirSatCommandStack().execute(containingRequirement.delete(editingDomain));\r\n-\t\t\t\r\n+\r\n \t\t} else if (att.getAttType() == null) {\r\n-\t\t\t//Only the attribute does not have a type anymore... clean the attribute value\r\n-\t\t\t\r\n+\t\t\t// Only the attribute does not have a type anymore... clean the attribute value\r\n+\r\n \t\t\teditingDomain.getVirSatCommandStack().execute(att.delete(editingDomain));\r\n \t\t}\r\n-\t\t\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Create a label for requirements traces customized to this table \r\n+\t * \r\n+\t * @param req the requirement for which a trace label is created\r\n+\t * @return the trace label\r\n+\t */\r\n+\tprotected String getTraceLabel(Requirement req) {\r\n+\t\tif (req.getTrace().getTarget() == null || req.getTrace().getTarget().isEmpty()) {\r\n+\t\t\treturn EMPTY_TRACE_STRING;\r\n+\t\t} else {\r\n+\t\t\tStringBuilder traceString = new StringBuilder();\r\n+\t\t\ttraceString.append(\"{\");\r\n+\r\n+\t\t\t// Some heavy casting necessary because Bean GenericCategory is abstract\r\n+\t\t\tAPropertyInstance targetProperty = req.getTrace().getTypeInstance().getPropertyInstances()\r\n+\t\t\t\t\t.get(REQUIREMENT_TRACE_TARGET_PROPERTY_NUMBER);\r\n+\t\t\tfor (APropertyInstance targetRPI : ((ArrayInstance) targetProperty).getArrayInstances()) {\r\n+\t\t\t\tCategoryAssignment target = (CategoryAssignment) ((ReferencePropertyInstance) targetRPI)\r\n+\t\t\t\t\t\t.getReference();\r\n+\t\t\t\tif (target != null) {\r\n+\t\t\t\t\ttraceString.append(target.getName());\r\n+\t\t\t\t\tif (((ArrayInstance) targetProperty).getArrayInstances()\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMjAyMA=="}, "originalCommit": {"oid": "53845a280dd2c781f370b20028105596096a135c"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 567, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}