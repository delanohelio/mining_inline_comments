{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNTEwODA0", "number": 518, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNTowNTo1OVrODldVtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoxNDo0MlrODotxVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjA0NTk4OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/IMigrator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNTowNTo1OVrOFyXLFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNTowNTo1OVrOFyXLFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM1Mjc5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return a list of new required concepts\n          \n          \n            \n            \t * @return a list of new required concept names", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388352790", "createdAt": "2020-03-05T15:05:59Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/IMigrator.java", "diffHunk": "@@ -21,6 +23,15 @@\n \t\r\n \tString EXTENSION_POINT_ID = \"de.dlr.sc.virsat.model.edit.ConceptMigrator\";\r\n \t\r\n+\t/**\r\n+\t * Returns new dependencies of the new concept version. These have to be activated\r\n+\t * before migration can be done\r\n+\t * @param concept the concept to be migrated\r\n+\t * @param previousMigrator the previously executed migrator, can be null if none was executed before\r\n+\t * @return a list of new required concepts\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjU4NjEzOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzoxNDowMVrOFycc2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODo1NDozN1rOFyxPuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQzOTI1OA==", "bodyText": "Else throw exception?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388439258", "createdAt": "2020-03-05T17:14:01Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.concept.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.resource.Resource;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.emf.transaction.TransactionalEditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.commons.datastructures.DependencyTree;\r\n+import de.dlr.sc.virsat.model.concept.migrator.ConceptMigrator;\r\n+import de.dlr.sc.virsat.model.concept.migrator.CreateMigrateConceptToLatestCommand;\r\n+import de.dlr.sc.virsat.model.concept.migrator.IMigrator;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.EReferencePropertyHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.IConceptTypeDefinition;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.registry.ActiveConceptConfigurationElement;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.provider.DVLMEditPlugin;\r\n+\r\n+/**\r\n+ * This class helps activating concepts. Concepts are copied into the \r\n+ * repository. Furthermore, this class redirects references so that these can be \r\n+ * resolved from a platform plugin. References to other concepts are redirected \r\n+ * to their active version within the repository\r\n+ *\r\n+ */\r\n+public class ConceptActivationHelper {\r\n+\t\r\n+\tprivate static final String CONCEPT_PATH = \"/concept/concept.xmi\";\r\n+\tprotected Repository repository;\r\n+\t\r\n+\tpublic ConceptActivationHelper(Repository repository) {\r\n+\t\tthis.repository = repository;\r\n+\t}\r\n+\t\r\n+\tpublic ConceptActivationHelper(Concept concept) {\r\n+\t\tif (concept.eContainer() != null && concept.eContainer() instanceof Repository) {\r\n+\t\t\tthis.repository = ((Repository) concept.eContainer());\r\n+\t\t}\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3OTk2MQ==", "bodyText": "Good idea \ud83d\udc4d", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388779961", "createdAt": "2020-03-06T08:54:37Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.concept.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.resource.Resource;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.emf.transaction.TransactionalEditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.commons.datastructures.DependencyTree;\r\n+import de.dlr.sc.virsat.model.concept.migrator.ConceptMigrator;\r\n+import de.dlr.sc.virsat.model.concept.migrator.CreateMigrateConceptToLatestCommand;\r\n+import de.dlr.sc.virsat.model.concept.migrator.IMigrator;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.EReferencePropertyHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.IConceptTypeDefinition;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.registry.ActiveConceptConfigurationElement;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.provider.DVLMEditPlugin;\r\n+\r\n+/**\r\n+ * This class helps activating concepts. Concepts are copied into the \r\n+ * repository. Furthermore, this class redirects references so that these can be \r\n+ * resolved from a platform plugin. References to other concepts are redirected \r\n+ * to their active version within the repository\r\n+ *\r\n+ */\r\n+public class ConceptActivationHelper {\r\n+\t\r\n+\tprivate static final String CONCEPT_PATH = \"/concept/concept.xmi\";\r\n+\tprotected Repository repository;\r\n+\t\r\n+\tpublic ConceptActivationHelper(Repository repository) {\r\n+\t\tthis.repository = repository;\r\n+\t}\r\n+\t\r\n+\tpublic ConceptActivationHelper(Concept concept) {\r\n+\t\tif (concept.eContainer() != null && concept.eContainer() instanceof Repository) {\r\n+\t\t\tthis.repository = ((Repository) concept.eContainer());\r\n+\t\t}\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQzOTI1OA=="}, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY2NjcyOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzozNjo0OVrOFydOng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzowOTo1MFrOF0OA8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTk5OA==", "bodyText": "Should we maybe also handle the situation when a dependency was removed in one of the concept versions?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388451998", "createdAt": "2020-03-05T17:36:49Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.concept.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.resource.Resource;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.emf.transaction.TransactionalEditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.commons.datastructures.DependencyTree;\r\n+import de.dlr.sc.virsat.model.concept.migrator.ConceptMigrator;\r\n+import de.dlr.sc.virsat.model.concept.migrator.CreateMigrateConceptToLatestCommand;\r\n+import de.dlr.sc.virsat.model.concept.migrator.IMigrator;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.EReferencePropertyHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.IConceptTypeDefinition;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.registry.ActiveConceptConfigurationElement;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.provider.DVLMEditPlugin;\r\n+\r\n+/**\r\n+ * This class helps activating concepts. Concepts are copied into the \r\n+ * repository. Furthermore, this class redirects references so that these can be \r\n+ * resolved from a platform plugin. References to other concepts are redirected \r\n+ * to their active version within the repository\r\n+ *\r\n+ */\r\n+public class ConceptActivationHelper {\r\n+\t\r\n+\tprivate static final String CONCEPT_PATH = \"/concept/concept.xmi\";\r\n+\tprotected Repository repository;\r\n+\t\r\n+\tpublic ConceptActivationHelper(Repository repository) {\r\n+\t\tthis.repository = repository;\r\n+\t}\r\n+\t\r\n+\tpublic ConceptActivationHelper(Concept concept) {\r\n+\t\tif (concept.eContainer() != null && concept.eContainer() instanceof Repository) {\r\n+\t\t\tthis.repository = ((Repository) concept.eContainer());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Activate type by redirecting it to type in the repository\r\n+\t * @param type the type to be activates\r\n+\t * @return the activated type\r\n+\t */\r\n+\tpublic EObject getActiveType(EObject type) {\r\n+\t\t\r\n+\t\t// For EReferences to external EClasses ignore concept \r\n+\t\t// activation and convert URIs instead. The URI needs to be\r\n+\t\t// transformed from a PluginResourceURI to a PlattformPluginURI so \r\n+\t\t// that it can be resolved from the VirSat project in the eclipse runtime\r\n+\t\t// instance.\r\n+\t\t// VirSat does not ensure external model's storage.\r\n+\t\t// We only enable non-containment references.\r\n+\t\tif (type instanceof EClass) {\r\n+\t\t\treturn new EReferencePropertyHelper().activateEClassType((EClass) type);\r\n+\t\t}\r\n+\r\n+\t\t// In case we try to create a reference to an object which was not copied\r\n+\t\t// we should try to redirect that reference to an already active and existing concept\r\n+\t\tif (repository != null && repository.eResource() != null && type instanceof IConceptTypeDefinition) {\r\n+\t\t\tIConceptTypeDefinition typeDefinition = (IConceptTypeDefinition) type;\r\n+\t\r\n+\t\t\t// Get the fragment URI of the concept we want to reference to\r\n+\t\t\tString uriFragment = EcoreUtil.getURI(typeDefinition).fragment();\r\n+\t\t\r\n+\t\t\t// ask the repository if there is such an object with the given URI fragment\r\n+\t\t\tResource repoResource = repository.eResource();\r\n+\t\t\tEObject repoTypeDefinition = repoResource.getEObject(uriFragment);\r\n+\r\n+\t\t\t// If not throw a warning that there is something missing\r\n+\t\t\tif (repoTypeDefinition == null) {\r\n+\t\t\t\tString fqId = ActiveConceptHelper.getFullQualifiedId(typeDefinition);\r\n+\t\t\t\r\n+\t\t\t\tthrow new RuntimeException(\"Install missing concept first! Missing concept: \" + fqId);\r\n+\t\t\t}\r\n+\t\t\treturn repoTypeDefinition;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn type;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Handle the activation of concepts from their configuration elements\r\n+\t * @param conceptConfigurationElements an array of concept configurations\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void activateConcepts(Object[] conceptConfigurationElements, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\t\t\r\n+\t\tList<Concept> concepts = new ArrayList<Concept>();\r\n+\t\tfor (Object acce : conceptConfigurationElements) {\r\n+\t\t\tif (acce instanceof ActiveConceptConfigurationElement) {\r\n+\t\t\t\tconcepts.add(((ActiveConceptConfigurationElement) acce).loadConceptFromPlugin());\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tactivateConcepts(concepts, editingDomain, progressMonitor);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Handle the activation of concepts. Resolves dependencies in correct order. \r\n+\t * @param conceptConfigurationElements a list of concept configurations\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void activateConcepts(List<Concept> concepts, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\t\t\r\n+\t\t// Correctly sort the selected concepts depending on their dependencies\r\n+\t\tDependencyTree<String> dependencyTree = new DependencyTree<String>();\r\n+\t\tMap<String, Concept> selectedConcepts = new HashMap<String, Concept>();\r\n+\t\t\r\n+\t\t// Create a map conceptName -> concept and add all concept names to the dependency tree\r\n+\t\tfor (Concept concept : concepts) {\r\n+\t\t\tselectedConcepts.put(concept.getName(), concept);\r\n+\t\t\tdependencyTree.addDependencies(concept.getName(), new String[] {});\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Now create the dependencies using the concept names as identifiers\r\n+\t\tfor (Concept concept : selectedConcepts.values()) {\r\n+\t\t\tList<String> conceptDependencyIds = new ArrayList<>(ActiveConceptHelper.getConceptDependencies(concept));\r\n+\t\t\tdependencyTree.addDependencies(concept.getName(), conceptDependencyIds);\r\n+\t\t}\r\n+\t\t\r\n+\t\tList<String> orderedConcepts = dependencyTree.getLinearOrder();\r\n+\t\t\r\n+\t\t// And then install them by using the ordered list of concept names\r\n+\t\t// and the map of concept names pointing to the already preloaded concepts\r\n+\t\tfor (String conceptName : orderedConcepts) {\r\n+\t\t\tif (selectedConcepts.containsKey(conceptName)) {\r\n+\t\t\t\tactivateConcept(selectedConcepts.get(conceptName), editingDomain, progressMonitor);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Prepare a selected concept for activation. Checks if an older version is already in the repository and if so\r\n+\t * migrates it to the latest version, otherwise the concept will be simply added to the active concepts\r\n+\t * @param concept the selected concept\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tprotected void activateConcept(Concept concept, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\r\n+\t\t// Check if we already have this concept but with a different version added to the repository\r\n+\t\tConcept activeConcept = new ActiveConceptHelper(repository).getConcept(concept.getName());\r\n+\r\n+\t\tboolean conceptIsInRepository = activeConcept != null;\r\n+\t\t\r\n+\t\t// There is a concept of a different version in the repository\r\n+\t\tif (conceptIsInRepository && !activeConcept.getVersion().equals(concept.getVersion())) {\r\n+\t\t\t\t\r\n+\t\t\t//Check if new dependencies have to be added before migration\r\n+\t\t\tif (activeConcept.eContainer() != null && activeConcept.eContainer() instanceof Repository) {\r\n+\t\t\t\tRepository repository = (Repository) activeConcept.eContainer();\r\n+\t\t\t\tnew ConceptActivationHelper(repository).handleNewDependencies(activeConcept, editingDomain, progressMonitor);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\ttry {\r\n+\t\t\t\tCommand migrateToLatestCommand = CreateMigrateConceptToLatestCommand.create(activeConcept, (TransactionalEditingDomain) editingDomain, progressMonitor);\r\n+\t\t\t\teditingDomain.getCommandStack().execute(migrateToLatestCommand);\r\n+\t\t\t} catch (CoreException e) {\r\n+\t\t\t\tDVLMEditPlugin.getPlugin().getLog().log(new Status(Status.ERROR, DVLMEditPlugin.PLUGIN_ID, \"Failed to do migration on active concept: \" + concept.getDisplayName(), e));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t}\r\n+\t\t\r\n+\t\tif (!conceptIsInRepository) {\r\n+\t\t\tCommand cmd = ActiveConceptConfigurationElement.createCopyConceptToRepository(editingDomain, concept, repository);\r\n+\t\t\teditingDomain.getCommandStack().execute(cmd);\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Activate new concept dependencies \r\n+\t * @param concept the concept to be prepared for migration\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void handleNewDependencies(Concept concept, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4MDc4Nw==", "bodyText": "How would you handle that? I mean we can add that to the migrator, but we currently do not forsee removing deactivating concepts... So any idea what that would do with the removed dependency?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388780787", "createdAt": "2020-03-06T08:56:35Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.concept.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.resource.Resource;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.emf.transaction.TransactionalEditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.commons.datastructures.DependencyTree;\r\n+import de.dlr.sc.virsat.model.concept.migrator.ConceptMigrator;\r\n+import de.dlr.sc.virsat.model.concept.migrator.CreateMigrateConceptToLatestCommand;\r\n+import de.dlr.sc.virsat.model.concept.migrator.IMigrator;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.EReferencePropertyHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.IConceptTypeDefinition;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.registry.ActiveConceptConfigurationElement;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.provider.DVLMEditPlugin;\r\n+\r\n+/**\r\n+ * This class helps activating concepts. Concepts are copied into the \r\n+ * repository. Furthermore, this class redirects references so that these can be \r\n+ * resolved from a platform plugin. References to other concepts are redirected \r\n+ * to their active version within the repository\r\n+ *\r\n+ */\r\n+public class ConceptActivationHelper {\r\n+\t\r\n+\tprivate static final String CONCEPT_PATH = \"/concept/concept.xmi\";\r\n+\tprotected Repository repository;\r\n+\t\r\n+\tpublic ConceptActivationHelper(Repository repository) {\r\n+\t\tthis.repository = repository;\r\n+\t}\r\n+\t\r\n+\tpublic ConceptActivationHelper(Concept concept) {\r\n+\t\tif (concept.eContainer() != null && concept.eContainer() instanceof Repository) {\r\n+\t\t\tthis.repository = ((Repository) concept.eContainer());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Activate type by redirecting it to type in the repository\r\n+\t * @param type the type to be activates\r\n+\t * @return the activated type\r\n+\t */\r\n+\tpublic EObject getActiveType(EObject type) {\r\n+\t\t\r\n+\t\t// For EReferences to external EClasses ignore concept \r\n+\t\t// activation and convert URIs instead. The URI needs to be\r\n+\t\t// transformed from a PluginResourceURI to a PlattformPluginURI so \r\n+\t\t// that it can be resolved from the VirSat project in the eclipse runtime\r\n+\t\t// instance.\r\n+\t\t// VirSat does not ensure external model's storage.\r\n+\t\t// We only enable non-containment references.\r\n+\t\tif (type instanceof EClass) {\r\n+\t\t\treturn new EReferencePropertyHelper().activateEClassType((EClass) type);\r\n+\t\t}\r\n+\r\n+\t\t// In case we try to create a reference to an object which was not copied\r\n+\t\t// we should try to redirect that reference to an already active and existing concept\r\n+\t\tif (repository != null && repository.eResource() != null && type instanceof IConceptTypeDefinition) {\r\n+\t\t\tIConceptTypeDefinition typeDefinition = (IConceptTypeDefinition) type;\r\n+\t\r\n+\t\t\t// Get the fragment URI of the concept we want to reference to\r\n+\t\t\tString uriFragment = EcoreUtil.getURI(typeDefinition).fragment();\r\n+\t\t\r\n+\t\t\t// ask the repository if there is such an object with the given URI fragment\r\n+\t\t\tResource repoResource = repository.eResource();\r\n+\t\t\tEObject repoTypeDefinition = repoResource.getEObject(uriFragment);\r\n+\r\n+\t\t\t// If not throw a warning that there is something missing\r\n+\t\t\tif (repoTypeDefinition == null) {\r\n+\t\t\t\tString fqId = ActiveConceptHelper.getFullQualifiedId(typeDefinition);\r\n+\t\t\t\r\n+\t\t\t\tthrow new RuntimeException(\"Install missing concept first! Missing concept: \" + fqId);\r\n+\t\t\t}\r\n+\t\t\treturn repoTypeDefinition;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn type;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Handle the activation of concepts from their configuration elements\r\n+\t * @param conceptConfigurationElements an array of concept configurations\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void activateConcepts(Object[] conceptConfigurationElements, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\t\t\r\n+\t\tList<Concept> concepts = new ArrayList<Concept>();\r\n+\t\tfor (Object acce : conceptConfigurationElements) {\r\n+\t\t\tif (acce instanceof ActiveConceptConfigurationElement) {\r\n+\t\t\t\tconcepts.add(((ActiveConceptConfigurationElement) acce).loadConceptFromPlugin());\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tactivateConcepts(concepts, editingDomain, progressMonitor);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Handle the activation of concepts. Resolves dependencies in correct order. \r\n+\t * @param conceptConfigurationElements a list of concept configurations\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void activateConcepts(List<Concept> concepts, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\t\t\r\n+\t\t// Correctly sort the selected concepts depending on their dependencies\r\n+\t\tDependencyTree<String> dependencyTree = new DependencyTree<String>();\r\n+\t\tMap<String, Concept> selectedConcepts = new HashMap<String, Concept>();\r\n+\t\t\r\n+\t\t// Create a map conceptName -> concept and add all concept names to the dependency tree\r\n+\t\tfor (Concept concept : concepts) {\r\n+\t\t\tselectedConcepts.put(concept.getName(), concept);\r\n+\t\t\tdependencyTree.addDependencies(concept.getName(), new String[] {});\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Now create the dependencies using the concept names as identifiers\r\n+\t\tfor (Concept concept : selectedConcepts.values()) {\r\n+\t\t\tList<String> conceptDependencyIds = new ArrayList<>(ActiveConceptHelper.getConceptDependencies(concept));\r\n+\t\t\tdependencyTree.addDependencies(concept.getName(), conceptDependencyIds);\r\n+\t\t}\r\n+\t\t\r\n+\t\tList<String> orderedConcepts = dependencyTree.getLinearOrder();\r\n+\t\t\r\n+\t\t// And then install them by using the ordered list of concept names\r\n+\t\t// and the map of concept names pointing to the already preloaded concepts\r\n+\t\tfor (String conceptName : orderedConcepts) {\r\n+\t\t\tif (selectedConcepts.containsKey(conceptName)) {\r\n+\t\t\t\tactivateConcept(selectedConcepts.get(conceptName), editingDomain, progressMonitor);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Prepare a selected concept for activation. Checks if an older version is already in the repository and if so\r\n+\t * migrates it to the latest version, otherwise the concept will be simply added to the active concepts\r\n+\t * @param concept the selected concept\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tprotected void activateConcept(Concept concept, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\r\n+\t\t// Check if we already have this concept but with a different version added to the repository\r\n+\t\tConcept activeConcept = new ActiveConceptHelper(repository).getConcept(concept.getName());\r\n+\r\n+\t\tboolean conceptIsInRepository = activeConcept != null;\r\n+\t\t\r\n+\t\t// There is a concept of a different version in the repository\r\n+\t\tif (conceptIsInRepository && !activeConcept.getVersion().equals(concept.getVersion())) {\r\n+\t\t\t\t\r\n+\t\t\t//Check if new dependencies have to be added before migration\r\n+\t\t\tif (activeConcept.eContainer() != null && activeConcept.eContainer() instanceof Repository) {\r\n+\t\t\t\tRepository repository = (Repository) activeConcept.eContainer();\r\n+\t\t\t\tnew ConceptActivationHelper(repository).handleNewDependencies(activeConcept, editingDomain, progressMonitor);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\ttry {\r\n+\t\t\t\tCommand migrateToLatestCommand = CreateMigrateConceptToLatestCommand.create(activeConcept, (TransactionalEditingDomain) editingDomain, progressMonitor);\r\n+\t\t\t\teditingDomain.getCommandStack().execute(migrateToLatestCommand);\r\n+\t\t\t} catch (CoreException e) {\r\n+\t\t\t\tDVLMEditPlugin.getPlugin().getLog().log(new Status(Status.ERROR, DVLMEditPlugin.PLUGIN_ID, \"Failed to do migration on active concept: \" + concept.getDisplayName(), e));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t}\r\n+\t\t\r\n+\t\tif (!conceptIsInRepository) {\r\n+\t\t\tCommand cmd = ActiveConceptConfigurationElement.createCopyConceptToRepository(editingDomain, concept, repository);\r\n+\t\t\teditingDomain.getCommandStack().execute(cmd);\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Activate new concept dependencies \r\n+\t * @param concept the concept to be prepared for migration\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void handleNewDependencies(Concept concept, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTk5OA=="}, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5OTg4OQ==", "bodyText": "Assume v1 has no dependency, v2 has a dependency, v3 has no dependency again. If I want to migrate from v1 to v3, I don't need to activate this dependency. But I guess it's not going to happen often, so we leave it", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r390299889", "createdAt": "2020-03-10T13:09:50Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/util/ConceptActivationHelper.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2008-2019 German Aerospace Center (DLR), Simulation and Software Technology, Germany.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0.\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ *******************************************************************************/\r\n+package de.dlr.sc.virsat.model.concept.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.emf.common.command.Command;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.resource.Resource;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.emf.edit.domain.EditingDomain;\r\n+import org.eclipse.emf.transaction.TransactionalEditingDomain;\r\n+\r\n+import de.dlr.sc.virsat.commons.datastructures.DependencyTree;\r\n+import de.dlr.sc.virsat.model.concept.migrator.ConceptMigrator;\r\n+import de.dlr.sc.virsat.model.concept.migrator.CreateMigrateConceptToLatestCommand;\r\n+import de.dlr.sc.virsat.model.concept.migrator.IMigrator;\r\n+import de.dlr.sc.virsat.model.dvlm.Repository;\r\n+import de.dlr.sc.virsat.model.dvlm.categories.propertydefinitions.EReferencePropertyHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.Concept;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.IConceptTypeDefinition;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.registry.ActiveConceptConfigurationElement;\r\n+import de.dlr.sc.virsat.model.dvlm.concepts.util.ActiveConceptHelper;\r\n+import de.dlr.sc.virsat.model.dvlm.provider.DVLMEditPlugin;\r\n+\r\n+/**\r\n+ * This class helps activating concepts. Concepts are copied into the \r\n+ * repository. Furthermore, this class redirects references so that these can be \r\n+ * resolved from a platform plugin. References to other concepts are redirected \r\n+ * to their active version within the repository\r\n+ *\r\n+ */\r\n+public class ConceptActivationHelper {\r\n+\t\r\n+\tprivate static final String CONCEPT_PATH = \"/concept/concept.xmi\";\r\n+\tprotected Repository repository;\r\n+\t\r\n+\tpublic ConceptActivationHelper(Repository repository) {\r\n+\t\tthis.repository = repository;\r\n+\t}\r\n+\t\r\n+\tpublic ConceptActivationHelper(Concept concept) {\r\n+\t\tif (concept.eContainer() != null && concept.eContainer() instanceof Repository) {\r\n+\t\t\tthis.repository = ((Repository) concept.eContainer());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Activate type by redirecting it to type in the repository\r\n+\t * @param type the type to be activates\r\n+\t * @return the activated type\r\n+\t */\r\n+\tpublic EObject getActiveType(EObject type) {\r\n+\t\t\r\n+\t\t// For EReferences to external EClasses ignore concept \r\n+\t\t// activation and convert URIs instead. The URI needs to be\r\n+\t\t// transformed from a PluginResourceURI to a PlattformPluginURI so \r\n+\t\t// that it can be resolved from the VirSat project in the eclipse runtime\r\n+\t\t// instance.\r\n+\t\t// VirSat does not ensure external model's storage.\r\n+\t\t// We only enable non-containment references.\r\n+\t\tif (type instanceof EClass) {\r\n+\t\t\treturn new EReferencePropertyHelper().activateEClassType((EClass) type);\r\n+\t\t}\r\n+\r\n+\t\t// In case we try to create a reference to an object which was not copied\r\n+\t\t// we should try to redirect that reference to an already active and existing concept\r\n+\t\tif (repository != null && repository.eResource() != null && type instanceof IConceptTypeDefinition) {\r\n+\t\t\tIConceptTypeDefinition typeDefinition = (IConceptTypeDefinition) type;\r\n+\t\r\n+\t\t\t// Get the fragment URI of the concept we want to reference to\r\n+\t\t\tString uriFragment = EcoreUtil.getURI(typeDefinition).fragment();\r\n+\t\t\r\n+\t\t\t// ask the repository if there is such an object with the given URI fragment\r\n+\t\t\tResource repoResource = repository.eResource();\r\n+\t\t\tEObject repoTypeDefinition = repoResource.getEObject(uriFragment);\r\n+\r\n+\t\t\t// If not throw a warning that there is something missing\r\n+\t\t\tif (repoTypeDefinition == null) {\r\n+\t\t\t\tString fqId = ActiveConceptHelper.getFullQualifiedId(typeDefinition);\r\n+\t\t\t\r\n+\t\t\t\tthrow new RuntimeException(\"Install missing concept first! Missing concept: \" + fqId);\r\n+\t\t\t}\r\n+\t\t\treturn repoTypeDefinition;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn type;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Handle the activation of concepts from their configuration elements\r\n+\t * @param conceptConfigurationElements an array of concept configurations\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void activateConcepts(Object[] conceptConfigurationElements, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\t\t\r\n+\t\tList<Concept> concepts = new ArrayList<Concept>();\r\n+\t\tfor (Object acce : conceptConfigurationElements) {\r\n+\t\t\tif (acce instanceof ActiveConceptConfigurationElement) {\r\n+\t\t\t\tconcepts.add(((ActiveConceptConfigurationElement) acce).loadConceptFromPlugin());\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tactivateConcepts(concepts, editingDomain, progressMonitor);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Handle the activation of concepts. Resolves dependencies in correct order. \r\n+\t * @param conceptConfigurationElements a list of concept configurations\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void activateConcepts(List<Concept> concepts, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\t\t\r\n+\t\t// Correctly sort the selected concepts depending on their dependencies\r\n+\t\tDependencyTree<String> dependencyTree = new DependencyTree<String>();\r\n+\t\tMap<String, Concept> selectedConcepts = new HashMap<String, Concept>();\r\n+\t\t\r\n+\t\t// Create a map conceptName -> concept and add all concept names to the dependency tree\r\n+\t\tfor (Concept concept : concepts) {\r\n+\t\t\tselectedConcepts.put(concept.getName(), concept);\r\n+\t\t\tdependencyTree.addDependencies(concept.getName(), new String[] {});\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Now create the dependencies using the concept names as identifiers\r\n+\t\tfor (Concept concept : selectedConcepts.values()) {\r\n+\t\t\tList<String> conceptDependencyIds = new ArrayList<>(ActiveConceptHelper.getConceptDependencies(concept));\r\n+\t\t\tdependencyTree.addDependencies(concept.getName(), conceptDependencyIds);\r\n+\t\t}\r\n+\t\t\r\n+\t\tList<String> orderedConcepts = dependencyTree.getLinearOrder();\r\n+\t\t\r\n+\t\t// And then install them by using the ordered list of concept names\r\n+\t\t// and the map of concept names pointing to the already preloaded concepts\r\n+\t\tfor (String conceptName : orderedConcepts) {\r\n+\t\t\tif (selectedConcepts.containsKey(conceptName)) {\r\n+\t\t\t\tactivateConcept(selectedConcepts.get(conceptName), editingDomain, progressMonitor);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Prepare a selected concept for activation. Checks if an older version is already in the repository and if so\r\n+\t * migrates it to the latest version, otherwise the concept will be simply added to the active concepts\r\n+\t * @param concept the selected concept\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tprotected void activateConcept(Concept concept, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r\n+\r\n+\t\t// Check if we already have this concept but with a different version added to the repository\r\n+\t\tConcept activeConcept = new ActiveConceptHelper(repository).getConcept(concept.getName());\r\n+\r\n+\t\tboolean conceptIsInRepository = activeConcept != null;\r\n+\t\t\r\n+\t\t// There is a concept of a different version in the repository\r\n+\t\tif (conceptIsInRepository && !activeConcept.getVersion().equals(concept.getVersion())) {\r\n+\t\t\t\t\r\n+\t\t\t//Check if new dependencies have to be added before migration\r\n+\t\t\tif (activeConcept.eContainer() != null && activeConcept.eContainer() instanceof Repository) {\r\n+\t\t\t\tRepository repository = (Repository) activeConcept.eContainer();\r\n+\t\t\t\tnew ConceptActivationHelper(repository).handleNewDependencies(activeConcept, editingDomain, progressMonitor);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\ttry {\r\n+\t\t\t\tCommand migrateToLatestCommand = CreateMigrateConceptToLatestCommand.create(activeConcept, (TransactionalEditingDomain) editingDomain, progressMonitor);\r\n+\t\t\t\teditingDomain.getCommandStack().execute(migrateToLatestCommand);\r\n+\t\t\t} catch (CoreException e) {\r\n+\t\t\t\tDVLMEditPlugin.getPlugin().getLog().log(new Status(Status.ERROR, DVLMEditPlugin.PLUGIN_ID, \"Failed to do migration on active concept: \" + concept.getDisplayName(), e));\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t}\r\n+\t\t\r\n+\t\tif (!conceptIsInRepository) {\r\n+\t\t\tCommand cmd = ActiveConceptConfigurationElement.createCopyConceptToRepository(editingDomain, concept, repository);\r\n+\t\t\teditingDomain.getCommandStack().execute(cmd);\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Activate new concept dependencies \r\n+\t * @param concept the concept to be prepared for migration\r\n+\t * @param editingDomain the editing domain\r\n+\t */\r\n+\tpublic void handleNewDependencies(Concept concept, EditingDomain editingDomain, IProgressMonitor progressMonitor) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTk5OA=="}, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY3OTUzOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzozOTo0OFrOFydVxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOTo1OTo1N1rOFyzNKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MzgzMQ==", "bodyText": "According to ther javadoc, previousMigrator can be null, which would result in NPE here", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388453831", "createdAt": "2020-03-05T17:39:48Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "diffHunk": "@@ -204,6 +222,34 @@ protected void removeFromTarget(ReferenceChange diff, boolean rightToLeft) {\n \tprotected void registerOldToNewIds() {\r\n \t}\r\n \t\r\n+\t@Override\r\n+\tpublic Set<String> getNewDependencies(Concept concept, IMigrator previousMigrator) {\r\n+\t\t\r\n+\t\tString conceptId = concept.getFullQualifiedName() + \"/\";\r\n+\t\tConcept conceptPrevious = loadConceptXmi(conceptId + previousMigrator.getResource());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjA3Mg==", "bodyText": "Oh true, and actually the same holds for the migration itself", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388812072", "createdAt": "2020-03-06T09:59:57Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "diffHunk": "@@ -204,6 +222,34 @@ protected void removeFromTarget(ReferenceChange diff, boolean rightToLeft) {\n \tprotected void registerOldToNewIds() {\r\n \t}\r\n \t\r\n+\t@Override\r\n+\tpublic Set<String> getNewDependencies(Concept concept, IMigrator previousMigrator) {\r\n+\t\t\r\n+\t\tString conceptId = concept.getFullQualifiedName() + \"/\";\r\n+\t\tConcept conceptPrevious = loadConceptXmi(conceptId + previousMigrator.getResource());\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MzgzMQ=="}, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY4ODY1OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzo0MjowMlrOFydbCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMDowMTozNFrOFyzQZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1NTE3OQ==", "bodyText": "Looks like we don't need conceptPrevious", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388455179", "createdAt": "2020-03-05T17:42:02Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "diffHunk": "@@ -204,6 +222,34 @@ protected void removeFromTarget(ReferenceChange diff, boolean rightToLeft) {\n \tprotected void registerOldToNewIds() {\r\n \t}\r\n \t\r\n+\t@Override\r\n+\tpublic Set<String> getNewDependencies(Concept concept, IMigrator previousMigrator) {\r\n+\t\t\r\n+\t\tString conceptId = concept.getFullQualifiedName() + \"/\";\r\n+\t\tConcept conceptPrevious = loadConceptXmi(conceptId + previousMigrator.getResource());\r\n+\t\tConcept conceptNext = loadConceptXmi(conceptId + getResource());\r\n+\t\t\r\n+\t\treturn getNewDependencies(conceptPrevious, concept, conceptNext);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Return new dependencies of new concept versions\r\n+\t * @param conceptPrevious the previous concept version. A comparison between conceptPrevious\r\n+\t * and the conceptCurrent should not yield any differences.\r\n+\t * @param conceptCurrent the current concept as it is in the repository\r\n+\t * @param conceptNext the next concept version\r\n+\t * @return A set of new concept names\r\n+\t */\r\n+\tpublic Set<String> getNewDependencies(Concept conceptPrevious, Concept conceptCurrent, Concept conceptNext) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjkwMw==", "bodyText": "Yes, I just wanted to keep the interface analog to the migration... But I guess that only overcomplicates thinks", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388812903", "createdAt": "2020-03-06T10:01:34Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "diffHunk": "@@ -204,6 +222,34 @@ protected void removeFromTarget(ReferenceChange diff, boolean rightToLeft) {\n \tprotected void registerOldToNewIds() {\r\n \t}\r\n \t\r\n+\t@Override\r\n+\tpublic Set<String> getNewDependencies(Concept concept, IMigrator previousMigrator) {\r\n+\t\t\r\n+\t\tString conceptId = concept.getFullQualifiedName() + \"/\";\r\n+\t\tConcept conceptPrevious = loadConceptXmi(conceptId + previousMigrator.getResource());\r\n+\t\tConcept conceptNext = loadConceptXmi(conceptId + getResource());\r\n+\t\t\r\n+\t\treturn getNewDependencies(conceptPrevious, concept, conceptNext);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Return new dependencies of new concept versions\r\n+\t * @param conceptPrevious the previous concept version. A comparison between conceptPrevious\r\n+\t * and the conceptCurrent should not yield any differences.\r\n+\t * @param conceptCurrent the current concept as it is in the repository\r\n+\t * @param conceptNext the next concept version\r\n+\t * @return A set of new concept names\r\n+\t */\r\n+\tpublic Set<String> getNewDependencies(Concept conceptPrevious, Concept conceptCurrent, Concept conceptNext) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1NTE3OQ=="}, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjcyMTc1OnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzo1MjoyN1rOFydwEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOTowMzo1OFrOFyxgGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2MDU2Mg==", "bodyText": "Could you please explain this fragment? When can the migrator be null, why are we returning a new resource set and what does it mean to the calling code?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388460562", "createdAt": "2020-03-05T17:52:27Z", "author": {"login": "andriikovalov-dlr"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "diffHunk": "@@ -608,6 +656,13 @@ public EObject getEObject(URI uri, boolean loadOnDemand) {\n \t\tString nsURI = ReleaseUtils.getNamespaceURI(conceptResourceUri);\r\n \t\tMigrator migrator = MigratorRegistry.getInstance().getMigrator(nsURI);\r\n \t\t\r\n+\t\tif (migrator == null) {\r\n+\t\t\tDVLMEditPlugin.getPlugin().getLog().log(new Status(Status.ERROR, DVLMEditPlugin.PLUGIN_ID, \r\n+\t\t\t\t\t\"Could not get DVLM migrator for concept resource: \" + conceptResourceUri));\r\n+\t\t\t//Check that all dependent concepts and their plugins are available in platform...  \r\n+\t\t\treturn new ResourceSetImpl();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc4NDE1NA==", "bodyText": "Well, I had the problem that a test case was failing in the maven build (only in the maven build!) because there the migrator was \"null\". I was debugging that for several hours until I tried returning a simple resource set in that case... The resource set then informed me that a required concepts of that cocept could not be found, because its plugin was not found... So I simply had to add the dependent concept's plugin as required plugin in the test fragement...\nIf you don't like that we can also remove this fragement... But I was that pissed of that the migrator was just \"null\" without any explonation that I added this pease of code. I had that pronblem some time ago and I think there that would have helped as well", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r388784154", "createdAt": "2020-03-06T09:03:58Z", "author": {"login": "franzTobiasDLR"}, "path": "de.dlr.sc.virsat.model.edit/src/de/dlr/sc/virsat/model/concept/migrator/AMigrator.java", "diffHunk": "@@ -608,6 +656,13 @@ public EObject getEObject(URI uri, boolean loadOnDemand) {\n \t\tString nsURI = ReleaseUtils.getNamespaceURI(conceptResourceUri);\r\n \t\tMigrator migrator = MigratorRegistry.getInstance().getMigrator(nsURI);\r\n \t\t\r\n+\t\tif (migrator == null) {\r\n+\t\t\tDVLMEditPlugin.getPlugin().getLog().log(new Status(Status.ERROR, DVLMEditPlugin.PLUGIN_ID, \r\n+\t\t\t\t\t\"Could not get DVLM migrator for concept resource: \" + conceptResourceUri));\r\n+\t\t\t//Check that all dependent concepts and their plugins are available in platform...  \r\n+\t\t\treturn new ResourceSetImpl();\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2MDU2Mg=="}, "originalCommit": {"oid": "d49057dee9bc8c230f2e6795181c122cb4863556"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDE5NTQyOnYy", "diffSide": "RIGHT", "path": "de.dlr.sc.virsat.model.edit.test/src/de/dlr/sc/virsat/model/concept/migrator/AMigratorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoxNDo0MlrOF3bpYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoxNDo0MlrOF3bpYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2ODk2MA==", "bodyText": "Maybe a little hint why the concept has to be placed into the repository?", "url": "https://github.com/virtualsatellite/VirtualSatellite4-Core/pull/518#discussion_r393668960", "createdAt": "2020-03-17T13:14:42Z", "author": {"login": "PhilMFischer"}, "path": "de.dlr.sc.virsat.model.edit.test/src/de/dlr/sc/virsat/model/concept/migrator/AMigratorTest.java", "diffHunk": "@@ -136,6 +139,8 @@ public void testMigrateAddStructuralElement() {\n \t\tConcept conceptPrevious = ConceptsFactory.eINSTANCE.createConcept();\r\n \t\tConcept conceptCurrent = ConceptsFactory.eINSTANCE.createConcept();\r\n \t\tConcept conceptNext = ConceptsFactory.eINSTANCE.createConcept();\r\n+\t\tRepository repository = DVLMFactory.eINSTANCE.createRepository();\r\n+\t\trepository.getActiveConcepts().add(conceptCurrent);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b97576cf5f34421692e31b9cbb02defd538920f"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 697, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}