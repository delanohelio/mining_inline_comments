{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNjIxOTYw", "number": 8522, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMDowMzo0NlrOFE5ptA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwODozOTo0OFrOFXCKdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjgzMTg4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMDowMzo0NlrOIFIz3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowNjowNlrOIMAGvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1ODE0MQ==", "bodyText": "could this be IgniteAppService method or property?", "url": "https://github.com/apache/ignite/pull/8522#discussion_r542258141", "createdAt": "2020-12-14T10:03:46Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -244,17 +250,18 @@ def _simulate_and_detect_failure(self, servers, failed_nodes, timeout):\n \n     def _check_failed_number(self, failed_nodes, survived_node):\n         \"\"\"Ensures number of failed nodes is correct.\"\"\"\n-        cmd = \"grep '%s' %s | wc -l\" % (node_failed_event_pattern(), IgniteAwareService.STDOUT_STDERR_CAPTURE)\n+        failed_cnt = int(exec_command(survived_node, \"grep '%s' %s | wc -l\" %\n+                                      (node_failed_event_pattern(), IgniteAwareService.STDOUT_STDERR_CAPTURE)))\n \n-        failed_cnt = int(str(survived_node.account.ssh_client.exec_command(cmd)[1].read(), sys.getdefaultencoding()))\n+        # Cache survivor id, do not read each time.\n+        surv_id = read_node_id(survived_node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NTU0OQ==", "bodyText": "Moved to the ignite utils", "url": "https://github.com/apache/ignite/pull/8522#discussion_r549455549", "createdAt": "2020-12-28T19:06:06Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -244,17 +250,18 @@ def _simulate_and_detect_failure(self, servers, failed_nodes, timeout):\n \n     def _check_failed_number(self, failed_nodes, survived_node):\n         \"\"\"Ensures number of failed nodes is correct.\"\"\"\n-        cmd = \"grep '%s' %s | wc -l\" % (node_failed_event_pattern(), IgniteAwareService.STDOUT_STDERR_CAPTURE)\n+        failed_cnt = int(exec_command(survived_node, \"grep '%s' %s | wc -l\" %\n+                                      (node_failed_event_pattern(), IgniteAwareService.STDOUT_STDERR_CAPTURE)))\n \n-        failed_cnt = int(str(survived_node.account.ssh_client.exec_command(cmd)[1].read(), sys.getdefaultencoding()))\n+        # Cache survivor id, do not read each time.\n+        surv_id = read_node_id(survived_node)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1ODE0MQ=="}, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjg0NTcyOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMDowNjozNFrOIFI7rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowNTo1MlrOIMAGew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2MDE0MQ==", "bodyText": "could this be the default behavior for any IgniteAwareService?", "url": "https://github.com/apache/ignite/pull/8522#discussion_r542260141", "createdAt": "2020-12-14T10:06:34Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (\n+            self.ZOOKEEPER_NODES if test_config.with_zk else 0), \\\n+            f\"Few required containers: {len(self.test_context.cluster)}. Check the params.\"\n \n-        self.logger.info(\"Starting on \" + str(max_containers) + \" maximal containers.\")\n+        self.logger.info(\"Starting on \" + str(len(self.test_context.cluster)) + \" maximal containers.\")\n+        self.logger.info(f\"{self.GLOBAL_DETECTION_TIMEOUT}: {failure_detection_timeout}\")\n \n         results = {}\n \n         modules = ['zookeeper'] if test_config.with_zk else None\n \n         if test_config.with_zk:\n-            zk_quorum = start_zookeeper(self.test_context, DiscoveryTest.ZOOKEEPER_NODES, test_config)\n+            zk_quorum = start_zookeeper(self.test_context, self.ZOOKEEPER_NODES, failure_detection_timeout)\n \n             discovery_spi = from_zookeeper_cluster(zk_quorum)\n         else:\n             discovery_spi = TcpDiscoverySpi()\n \n+            if LATEST_2_7 < test_config.version < V_2_9_1:\n+                discovery_spi.so_linger = 0\n+\n         ignite_config = IgniteConfiguration(\n             version=test_config.version,\n             discovery_spi=discovery_spi,\n-            failure_detection_timeout=test_config.failure_detection_timeout,\n+            failure_detection_timeout=failure_detection_timeout,\n             caches=[CacheConfiguration(\n                 name='test-cache',\n                 backups=1,\n                 atomicity_mode='TRANSACTIONAL' if test_config.load_type == ClusterLoad.TRANSACTIONAL else 'ATOMIC'\n             )]\n         )\n \n+        jvm_opts_str = jvm_settings(gc_dump_path=os.path.join(IgniteService.PERSISTENT_ROOT, \"ignite_gc.log\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NTQ4Mw==", "bodyText": "Moved to the spec", "url": "https://github.com/apache/ignite/pull/8522#discussion_r549455483", "createdAt": "2020-12-28T19:05:52Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (\n+            self.ZOOKEEPER_NODES if test_config.with_zk else 0), \\\n+            f\"Few required containers: {len(self.test_context.cluster)}. Check the params.\"\n \n-        self.logger.info(\"Starting on \" + str(max_containers) + \" maximal containers.\")\n+        self.logger.info(\"Starting on \" + str(len(self.test_context.cluster)) + \" maximal containers.\")\n+        self.logger.info(f\"{self.GLOBAL_DETECTION_TIMEOUT}: {failure_detection_timeout}\")\n \n         results = {}\n \n         modules = ['zookeeper'] if test_config.with_zk else None\n \n         if test_config.with_zk:\n-            zk_quorum = start_zookeeper(self.test_context, DiscoveryTest.ZOOKEEPER_NODES, test_config)\n+            zk_quorum = start_zookeeper(self.test_context, self.ZOOKEEPER_NODES, failure_detection_timeout)\n \n             discovery_spi = from_zookeeper_cluster(zk_quorum)\n         else:\n             discovery_spi = TcpDiscoverySpi()\n \n+            if LATEST_2_7 < test_config.version < V_2_9_1:\n+                discovery_spi.so_linger = 0\n+\n         ignite_config = IgniteConfiguration(\n             version=test_config.version,\n             discovery_spi=discovery_spi,\n-            failure_detection_timeout=test_config.failure_detection_timeout,\n+            failure_detection_timeout=failure_detection_timeout,\n             caches=[CacheConfiguration(\n                 name='test-cache',\n                 backups=1,\n                 atomicity_mode='TRANSACTIONAL' if test_config.load_type == ClusterLoad.TRANSACTIONAL else 'ATOMIC'\n             )]\n         )\n \n+        jvm_opts_str = jvm_settings(gc_dump_path=os.path.join(IgniteService.PERSISTENT_ROOT, \"ignite_gc.log\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2MDE0MQ=="}, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjg4NDczOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMDoxNToxOVrOIFJSCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOToxOTowMVrOIMAUIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2NTg2Nw==", "bodyText": "any reason to call len(self.test_context.cluster) so much time?", "url": "https://github.com/apache/ignite/pull/8522#discussion_r542265867", "createdAt": "2020-12-14T10:15:19Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwODUxNw==", "bodyText": "The reason is \"Too many local variables\".", "url": "https://github.com/apache/ignite/pull/8522#discussion_r542308517", "createdAt": "2020-12-14T11:21:31Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2NTg2Nw=="}, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQyNzMxMw==", "bodyText": "as for me, a better case is to reduce warning or perform refactoring/decomposition.", "url": "https://github.com/apache/ignite/pull/8522#discussion_r542427313", "createdAt": "2020-12-14T14:29:27Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2NTg2Nw=="}, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1ODk3OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8522#discussion_r549458979", "createdAt": "2020-12-28T19:19:01Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2NTg2Nw=="}, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjg5MDM5OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMDoxNjoyN1rOIFJVOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowNToyOVrOIMAGCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2NjY4Mw==", "bodyText": "let's assert it 0 at 2.9.1", "url": "https://github.com/apache/ignite/pull/8522#discussion_r542266683", "createdAt": "2020-12-14T10:16:27Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (\n+            self.ZOOKEEPER_NODES if test_config.with_zk else 0), \\\n+            f\"Few required containers: {len(self.test_context.cluster)}. Check the params.\"\n \n-        self.logger.info(\"Starting on \" + str(max_containers) + \" maximal containers.\")\n+        self.logger.info(\"Starting on \" + str(len(self.test_context.cluster)) + \" maximal containers.\")\n+        self.logger.info(f\"{self.GLOBAL_DETECTION_TIMEOUT}: {failure_detection_timeout}\")\n \n         results = {}\n \n         modules = ['zookeeper'] if test_config.with_zk else None\n \n         if test_config.with_zk:\n-            zk_quorum = start_zookeeper(self.test_context, DiscoveryTest.ZOOKEEPER_NODES, test_config)\n+            zk_quorum = start_zookeeper(self.test_context, self.ZOOKEEPER_NODES, failure_detection_timeout)\n \n             discovery_spi = from_zookeeper_cluster(zk_quorum)\n         else:\n             discovery_spi = TcpDiscoverySpi()\n \n+            if LATEST_2_7 < test_config.version < V_2_9_1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NTM2OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8522#discussion_r549455369", "createdAt": "2020-12-28T19:05:29Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -88,99 +93,100 @@ def __init__(self, test_context):\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_tcp(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test nodes failure scenario with TcpDiscoverySpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=False)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_tcp(self, ignite_version, load_type):\n         \"\"\"\n         Test 2 nodes sequential failure scenario with TcpDiscoverySpi.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n-                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          failure_detection_timeout=failure_detection_timeout)\n+                                          load_type=ClusterLoad.construct_from(load_type), sequential_failure=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(nodes_to_kill=[1, 2], failure_detection_timeout=[FAILURE_TIMEOUT],\n-            load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n-    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type, failure_detection_timeout):\n+    @matrix(nodes_to_kill=[1, 2], load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_nodes_fail_not_sequential_zk(self, ignite_version, nodes_to_kill, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing nodes to fail in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=nodes_to_kill,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=False,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     @cluster(num_nodes=MAX_CONTAINERS)\n     @version_if(lambda version: version != V_2_8_0)  # ignite-zookeeper package is broken in 2.8.0\n     @ignite_versions(str(DEV_BRANCH), str(LATEST))\n-    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL],\n-            failure_detection_timeout=[FAILURE_TIMEOUT])\n-    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type, failure_detection_timeout):\n+    @matrix(load_type=[ClusterLoad.NONE, ClusterLoad.ATOMIC, ClusterLoad.TRANSACTIONAL])\n+    def test_2_nodes_fail_sequential_zk(self, ignite_version, load_type):\n         \"\"\"\n         Test node failure scenario with ZooKeeperSpi not allowing to fail nodes in a row.\n         \"\"\"\n         test_config = DiscoveryTestConfig(version=IgniteVersion(ignite_version), nodes_to_kill=2,\n                                           load_type=ClusterLoad.construct_from(load_type), sequential_failure=True,\n-                                          with_zk=True, failure_detection_timeout=failure_detection_timeout)\n+                                          with_zk=True)\n \n         return self._perform_node_fail_scenario(test_config)\n \n     def _perform_node_fail_scenario(self, test_config):\n-        max_containers = len(self.test_context.cluster)\n+        failure_detection_timeout = self._global_int(self.GLOBAL_DETECTION_TIMEOUT, self.DEFAULT_DETECTION_TIMEOUT)\n \n         # One node is required to detect the failure.\n-        assert max_containers >= 1 + test_config.nodes_to_kill + (\n-            DiscoveryTest.ZOOKEEPER_NODES if test_config.with_zk else 0) + (\n-                   0 if test_config.load_type == ClusterLoad.NONE else 1), \"Few required containers: \" + \\\n-                                                                           str(max_containers) + \". Check the params.\"\n+        assert len(self.test_context.cluster) >= 1 + test_config.nodes_to_kill + (\n+            self.ZOOKEEPER_NODES if test_config.with_zk else 0), \\\n+            f\"Few required containers: {len(self.test_context.cluster)}. Check the params.\"\n \n-        self.logger.info(\"Starting on \" + str(max_containers) + \" maximal containers.\")\n+        self.logger.info(\"Starting on \" + str(len(self.test_context.cluster)) + \" maximal containers.\")\n+        self.logger.info(f\"{self.GLOBAL_DETECTION_TIMEOUT}: {failure_detection_timeout}\")\n \n         results = {}\n \n         modules = ['zookeeper'] if test_config.with_zk else None\n \n         if test_config.with_zk:\n-            zk_quorum = start_zookeeper(self.test_context, DiscoveryTest.ZOOKEEPER_NODES, test_config)\n+            zk_quorum = start_zookeeper(self.test_context, self.ZOOKEEPER_NODES, failure_detection_timeout)\n \n             discovery_spi = from_zookeeper_cluster(zk_quorum)\n         else:\n             discovery_spi = TcpDiscoverySpi()\n \n+            if LATEST_2_7 < test_config.version < V_2_9_1:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI2NjY4Mw=="}, "originalCommit": {"oid": "9e219df0c24fd7a7d7fece5b3fd60baa7a326eb3"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NjgyMzAwOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwNzo1Nzo1MFrOIgVvBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMToxNzozOFrOIgcyFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc4MTQ0NQ==", "bodyText": "Why located not at IgniteAwareService?", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570781445", "createdAt": "2021-02-05T07:57:50Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "diffHunk": "@@ -90,3 +91,19 @@ def get_event_time(service, log_node, log_pattern, from_the_beginning=True, time\n \n     return datetime.strptime(re.match(\"^\\\\[[^\\\\[]+\\\\]\", stdout.read().decode(\"utf-8\")).group(),\n                              \"[%Y-%m-%d %H:%M:%S,%f]\")\n+\n+\n+def exec_command(node, cmd):\n+    \"\"\"Executes the command passed on the given node and returns result as string.\"\"\"\n+    return str(node.account.ssh_client.exec_command(cmd)[1].read(), sys.getdefaultencoding())\n+\n+\n+def node_id(node):\n+    \"\"\"\n+    Returns node id from its log if started.\n+    This is a remote call. Reuse its results if possible.\n+    \"\"\"\n+    regexp = \"^>>> Local node \\\\[ID=([^,]+),.+$\"\n+    cmd = \"grep -E '%s' %s | sed -r 's/%s/\\\\1/'\" % (regexp, node.log_file, regexp)\n+\n+    return exec_command(node, cmd).strip().lower()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgwOTg1NQ==", "bodyText": "Because they are 'static' helpers not binded to any instanse. Is it ok?", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570809855", "createdAt": "2021-02-05T08:51:18Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "diffHunk": "@@ -90,3 +91,19 @@ def get_event_time(service, log_node, log_pattern, from_the_beginning=True, time\n \n     return datetime.strptime(re.match(\"^\\\\[[^\\\\[]+\\\\]\", stdout.read().decode(\"utf-8\")).group(),\n                              \"[%Y-%m-%d %H:%M:%S,%f]\")\n+\n+\n+def exec_command(node, cmd):\n+    \"\"\"Executes the command passed on the given node and returns result as string.\"\"\"\n+    return str(node.account.ssh_client.exec_command(cmd)[1].read(), sys.getdefaultencoding())\n+\n+\n+def node_id(node):\n+    \"\"\"\n+    Returns node id from its log if started.\n+    This is a remote call. Reuse its results if possible.\n+    \"\"\"\n+    regexp = \"^>>> Local node \\\\[ID=([^,]+),.+$\"\n+    cmd = \"grep -E '%s' %s | sed -r 's/%s/\\\\1/'\" % (regexp, node.log_file, regexp)\n+\n+    return exec_command(node, cmd).strip().lower()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc4MTQ0NQ=="}, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg3Mzg5NA==", "bodyText": "Why do we want to reduce this helper's scope only to IgniteService, not to all IgniteAwares?\nSeems, this will be a good case to have the same feature at IgniteApplicationService, especially considering the relocation price is 0?", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570873894", "createdAt": "2021-02-05T10:35:32Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "diffHunk": "@@ -90,3 +91,19 @@ def get_event_time(service, log_node, log_pattern, from_the_beginning=True, time\n \n     return datetime.strptime(re.match(\"^\\\\[[^\\\\[]+\\\\]\", stdout.read().decode(\"utf-8\")).group(),\n                              \"[%Y-%m-%d %H:%M:%S,%f]\")\n+\n+\n+def exec_command(node, cmd):\n+    \"\"\"Executes the command passed on the given node and returns result as string.\"\"\"\n+    return str(node.account.ssh_client.exec_command(cmd)[1].read(), sys.getdefaultencoding())\n+\n+\n+def node_id(node):\n+    \"\"\"\n+    Returns node id from its log if started.\n+    This is a remote call. Reuse its results if possible.\n+    \"\"\"\n+    regexp = \"^>>> Local node \\\\[ID=([^,]+),.+$\"\n+    cmd = \"grep -E '%s' %s | sed -r 's/%s/\\\\1/'\" % (regexp, node.log_file, regexp)\n+\n+    return exec_command(node, cmd).strip().lower()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc4MTQ0NQ=="}, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5NjkxOQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570896919", "createdAt": "2021-02-05T11:17:38Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "diffHunk": "@@ -90,3 +91,19 @@ def get_event_time(service, log_node, log_pattern, from_the_beginning=True, time\n \n     return datetime.strptime(re.match(\"^\\\\[[^\\\\[]+\\\\]\", stdout.read().decode(\"utf-8\")).group(),\n                              \"[%Y-%m-%d %H:%M:%S,%f]\")\n+\n+\n+def exec_command(node, cmd):\n+    \"\"\"Executes the command passed on the given node and returns result as string.\"\"\"\n+    return str(node.account.ssh_client.exec_command(cmd)[1].read(), sys.getdefaultencoding())\n+\n+\n+def node_id(node):\n+    \"\"\"\n+    Returns node id from its log if started.\n+    This is a remote call. Reuse its results if possible.\n+    \"\"\"\n+    regexp = \"^>>> Local node \\\\[ID=([^,]+),.+$\"\n+    cmd = \"grep -E '%s' %s | sed -r 's/%s/\\\\1/'\" % (regexp, node.log_file, regexp)\n+\n+    return exec_command(node, cmd).strip().lower()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc4MTQ0NQ=="}, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5Njk2MTY2OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwODozNzozNVrOIgXALA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwOToxMDo1MFrOIgYLTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgwMjIyMA==", "bodyText": "let's define what is 0.004 properly.", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570802220", "createdAt": "2021-02-05T08:37:35Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -213,36 +215,37 @@ def _perform_node_fail_scenario(self, test_config):\n                       \"targetNodes\": tran_nodes,\n                       \"transactional\": bool(tran_nodes)}\n \n-            start_load_app(self.test_context, ignite_config=load_config, params=params, modules=modules)\n+            start_load_app(self.test_context, load_config, params, modules)\n \n+        # Minimal detection timeout is failure_detection_timeout * 2. Let's more to capture also 'bad' results.\n         results.update(self._simulate_and_detect_failure(servers, failed_nodes,\n-                                                         test_config.failure_detection_timeout * 4,\n+                                                         0.004 * ignite_config.failure_detection_timeout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgyMTQ1NQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570821455", "createdAt": "2021-02-05T09:10:50Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -213,36 +215,37 @@ def _perform_node_fail_scenario(self, test_config):\n                       \"targetNodes\": tran_nodes,\n                       \"transactional\": bool(tran_nodes)}\n \n-            start_load_app(self.test_context, ignite_config=load_config, params=params, modules=modules)\n+            start_load_app(self.test_context, load_config, params, modules)\n \n+        # Minimal detection timeout is failure_detection_timeout * 2. Let's more to capture also 'bad' results.\n         results.update(self._simulate_and_detect_failure(servers, failed_nodes,\n-                                                         test_config.failure_detection_timeout * 4,\n+                                                         0.004 * ignite_config.failure_detection_timeout,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgwMjIyMA=="}, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5Njk3MDEzOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/utils/ignite_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwODozOTo0OFrOIgXFIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwOToxMDozOVrOIgYK0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgwMzQ5MA==", "bodyText": "any reason to start a name with \"_\"?\n\"default=None\" or \"int = None\", please format the code.", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570803490", "createdAt": "2021-02-05T08:39:48Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/utils/ignite_test.py", "diffHunk": "@@ -55,3 +55,11 @@ def tearDown(self):\n         self.logger.debug(\"All services killed.\")\n \n         super().tearDown()\n+\n+    def _global_param(self, param_name, default=None):\n+        \"\"\"Reads global parameter passed to the test suite.\"\"\"\n+        return self.test_context.globals.get(param_name, default)\n+\n+    def _global_int(self, param_name, default: int = None):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgyMTMyOQ==", "bodyText": "Hm. The autoformat says current typing is correct where as supposed fixes are not:\nFor 'default = None' - PEP 8: E251 unexpected staces...\nFor 'int=None' - PEP 8: E252: Missing whitespace aroung parameters.\nSame from pylint.\nThe reason for _global_param is that it's like 'private' method. Not intended to call it outside", "url": "https://github.com/apache/ignite/pull/8522#discussion_r570821329", "createdAt": "2021-02-05T09:10:39Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/utils/ignite_test.py", "diffHunk": "@@ -55,3 +55,11 @@ def tearDown(self):\n         self.logger.debug(\"All services killed.\")\n \n         super().tearDown()\n+\n+    def _global_param(self, param_name, default=None):\n+        \"\"\"Reads global parameter passed to the test suite.\"\"\"\n+        return self.test_context.globals.get(param_name, default)\n+\n+    def _global_int(self, param_name, default: int = None):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgwMzQ5MA=="}, "originalCommit": {"oid": "db0d455830111c5196c847aeb32e3fde315e9568"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2630, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}