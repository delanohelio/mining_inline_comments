{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MTM1MTYw", "number": 8142, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1MjoxMlrOEXP8Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNDoyOTo0NVrOEXp0DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODEzOTIyOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/utils/concurrent.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1MjoxMlrOG-7sew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo1MDoxNVrOG_aJLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MjkzOQ==", "bodyText": "This is mutex or lock, not cond_var.", "url": "https://github.com/apache/ignite/pull/8142#discussion_r468642939", "createdAt": "2020-08-11T14:52:12Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/services/utils/concurrent.py", "diffHunk": "@@ -0,0 +1,74 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains concurrent utils.\n+\"\"\"\n+\n+import threading\n+\n+\n+class CountDownLatch(object):\n+    \"\"\"\n+    A count-down latch.\n+    \"\"\"\n+    def __init__(self, count=1):\n+        self.count = count\n+        self.cond_var = threading.Condition()\n+\n+    def count_down(self):\n+        \"\"\"\n+        Decreases the latch counter.\n+        \"\"\"\n+        with self.cond_var:\n+            if self.count > 0:\n+                self.count -= 1\n+            if self.count == 0:\n+                self.cond_var.notifyAll()\n+\n+    def wait(self):\n+        \"\"\"\n+        Blocks current thread if the latch is not free.\n+        \"\"\"\n+        with self.cond_var:\n+            while self.count > 0:\n+                self.cond_var.wait()\n+\n+\n+# pylint: disable=C0116\n+class AtomicValue:\n+    \"\"\"\n+    An atomic reference holder.\n+    \"\"\"\n+    def __init__(self, value=None):\n+        self.value = value\n+        self.cond_var = threading.Lock()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTgwNA==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469141804", "createdAt": "2020-08-12T09:50:15Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/services/utils/concurrent.py", "diffHunk": "@@ -0,0 +1,74 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains concurrent utils.\n+\"\"\"\n+\n+import threading\n+\n+\n+class CountDownLatch(object):\n+    \"\"\"\n+    A count-down latch.\n+    \"\"\"\n+    def __init__(self, count=1):\n+        self.count = count\n+        self.cond_var = threading.Condition()\n+\n+    def count_down(self):\n+        \"\"\"\n+        Decreases the latch counter.\n+        \"\"\"\n+        with self.cond_var:\n+            if self.count > 0:\n+                self.count -= 1\n+            if self.count == 0:\n+                self.cond_var.notifyAll()\n+\n+    def wait(self):\n+        \"\"\"\n+        Blocks current thread if the latch is not free.\n+        \"\"\"\n+        with self.cond_var:\n+            while self.count > 0:\n+                self.cond_var.wait()\n+\n+\n+# pylint: disable=C0116\n+class AtomicValue:\n+    \"\"\"\n+    An atomic reference holder.\n+    \"\"\"\n+    def __init__(self, value=None):\n+        self.value = value\n+        self.cond_var = threading.Lock()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MjkzOQ=="}, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE1OTQ4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1Njo1NVrOG-752Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0OTo0MFrOG_aH0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NjM2MQ==", "bodyText": "May be try to pass a regexp to grep?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r468646361", "createdAt": "2020-08-11T14:56:55Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -117,46 +163,81 @@ def __basic_test__(self, version, with_zk=False):\n \n         start = self.monotonic()\n         self.servers.start()\n-        data = {'Ignite cluster start time (s)': self.monotonic() - start}\n+        data = {'Ignite cluster start time (s)': round(self.monotonic() - start, 1)}\n         self.stage(\"Topology is ready\")\n \n-        # Node failure detection\n-        fail_node, survived_node = self.choose_random_node_to_kill(self.servers)\n+        if nodes_to_kill > self.servers.num_nodes - 1 or coordinator and nodes_to_kill > 1:\n+            raise Exception(\"Too many nodes to kill: \" + str(nodes_to_kill))\n+\n+        if coordinator:\n+            node_chooser = lambda nodes: \\\n+                next(node for node in nodes if node.discovery_info().node_id == nodes[0].discovery_info().coordinator)\n+        else:\n+            node_chooser = lambda nodes: \\\n+                random.sample([n for n in self.servers.nodes if n.discovery_info().node_id !=\n+                               self.servers.nodes[0].discovery_info().coordinator], nodes_to_kill)\n \n-        data[\"nodes\"] = [node.node_id() for node in self.servers.nodes]\n+        failed_nodes, survived_node = self.choose_node_to_kill(self.servers.nodes, node_chooser)\n \n-        disco_infos = []\n-        for node in self.servers.nodes:\n-            disco_info = node.discovery_info()\n-            disco_infos.append({\n-                \"id\": disco_info.node_id,\n-                \"consistent_id\": disco_info.consistent_id,\n-                \"coordinator\": disco_info.coordinator,\n-                \"order\": disco_info.order,\n-                \"int_order\": disco_info.int_order,\n-                \"is_client\": disco_info.is_client\n-            })\n+        ids_to_wait = [node.discovery_info().node_id for node in failed_nodes]\n \n-        data[\"node_disco_info\"] = disco_infos\n+        self.stage(\"Stopping \" + str(len(failed_nodes)) + \" nodes.\")\n \n-        self.servers.stop_node(fail_node, clean_shutdown=False)\n+        first_terminated = self.servers.stop_nodes_async(failed_nodes, clean_shutdown=False, wait_for_stop=False)\n \n-        start = self.monotonic()\n-        self.servers.await_event_on_node(\"Node FAILED\", random.choice(survived_node), 60, True)\n+        self.stage(\"Waiting for failure detection of \" + str(len(failed_nodes)) + \" nodes.\")\n+\n+        # Keeps dates of logged node failures.\n+        last_failure_detected = 0\n+        logged_timestamps = []\n+\n+        for failed_id in ids_to_wait:\n+            pattern = \"Node FAILED: \" + (\"ZookeeperClusterNode\" if with_zk else \"TcpDiscoveryNode\") + \" \\\\[id=\" \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTQ1OA==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469141458", "createdAt": "2020-08-12T09:49:40Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -117,46 +163,81 @@ def __basic_test__(self, version, with_zk=False):\n \n         start = self.monotonic()\n         self.servers.start()\n-        data = {'Ignite cluster start time (s)': self.monotonic() - start}\n+        data = {'Ignite cluster start time (s)': round(self.monotonic() - start, 1)}\n         self.stage(\"Topology is ready\")\n \n-        # Node failure detection\n-        fail_node, survived_node = self.choose_random_node_to_kill(self.servers)\n+        if nodes_to_kill > self.servers.num_nodes - 1 or coordinator and nodes_to_kill > 1:\n+            raise Exception(\"Too many nodes to kill: \" + str(nodes_to_kill))\n+\n+        if coordinator:\n+            node_chooser = lambda nodes: \\\n+                next(node for node in nodes if node.discovery_info().node_id == nodes[0].discovery_info().coordinator)\n+        else:\n+            node_chooser = lambda nodes: \\\n+                random.sample([n for n in self.servers.nodes if n.discovery_info().node_id !=\n+                               self.servers.nodes[0].discovery_info().coordinator], nodes_to_kill)\n \n-        data[\"nodes\"] = [node.node_id() for node in self.servers.nodes]\n+        failed_nodes, survived_node = self.choose_node_to_kill(self.servers.nodes, node_chooser)\n \n-        disco_infos = []\n-        for node in self.servers.nodes:\n-            disco_info = node.discovery_info()\n-            disco_infos.append({\n-                \"id\": disco_info.node_id,\n-                \"consistent_id\": disco_info.consistent_id,\n-                \"coordinator\": disco_info.coordinator,\n-                \"order\": disco_info.order,\n-                \"int_order\": disco_info.int_order,\n-                \"is_client\": disco_info.is_client\n-            })\n+        ids_to_wait = [node.discovery_info().node_id for node in failed_nodes]\n \n-        data[\"node_disco_info\"] = disco_infos\n+        self.stage(\"Stopping \" + str(len(failed_nodes)) + \" nodes.\")\n \n-        self.servers.stop_node(fail_node, clean_shutdown=False)\n+        first_terminated = self.servers.stop_nodes_async(failed_nodes, clean_shutdown=False, wait_for_stop=False)\n \n-        start = self.monotonic()\n-        self.servers.await_event_on_node(\"Node FAILED\", random.choice(survived_node), 60, True)\n+        self.stage(\"Waiting for failure detection of \" + str(len(failed_nodes)) + \" nodes.\")\n+\n+        # Keeps dates of logged node failures.\n+        last_failure_detected = 0\n+        logged_timestamps = []\n+\n+        for failed_id in ids_to_wait:\n+            pattern = \"Node FAILED: \" + (\"ZookeeperClusterNode\" if with_zk else \"TcpDiscoveryNode\") + \" \\\\[id=\" \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NjM2MQ=="}, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE2NDE1OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1Nzo0OVrOG-78wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0OTo0OVrOG_aIJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NzEwNQ==", "bodyText": "I suppose, that we can rewrite a little bit test, it's really overcomplicated a little bit.\nMay be it is not a good idea to turn off linter warnings here?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r468647105", "createdAt": "2020-08-11T14:57:49Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,28 +90,65 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_not_coordinator_two(self, version):\n+        \"\"\"\n+        Test two-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, True)\n+\n+    @cluster(num_nodes=NUM_NODES + 3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_not_coordinator_single(self, version):\n         \"\"\"\n-        Test basic discovery scenario with TcpDiscoverySpi.\n+        Test single node failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, False)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1, coordinator=False, with_zk=True)\n \n     @cluster(num_nodes=NUM_NODES + 3)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_zk(self, version):\n+    def test_zk_not_coordinator_two(self, version):\n         \"\"\"\n-        Test basic discovery scenario with ZookeeperDiscoverySpi.\n+        Test two-node-failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, True)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2, coordinator=False, with_zk=True)\n \n-    def __basic_test__(self, version, with_zk=False):\n+    @cluster(num_nodes=NUM_NODES+3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with ZooKeeper.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, coordinator=True, with_zk=True)\n+\n+    # pylint: disable=R0913,R0914", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTU0MA==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469141540", "createdAt": "2020-08-12T09:49:49Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,28 +90,65 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_not_coordinator_two(self, version):\n+        \"\"\"\n+        Test two-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, True)\n+\n+    @cluster(num_nodes=NUM_NODES + 3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_not_coordinator_single(self, version):\n         \"\"\"\n-        Test basic discovery scenario with TcpDiscoverySpi.\n+        Test single node failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, False)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1, coordinator=False, with_zk=True)\n \n     @cluster(num_nodes=NUM_NODES + 3)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_zk(self, version):\n+    def test_zk_not_coordinator_two(self, version):\n         \"\"\"\n-        Test basic discovery scenario with ZookeeperDiscoverySpi.\n+        Test two-node-failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, True)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2, coordinator=False, with_zk=True)\n \n-    def __basic_test__(self, version, with_zk=False):\n+    @cluster(num_nodes=NUM_NODES+3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with ZooKeeper.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, coordinator=True, with_zk=True)\n+\n+    # pylint: disable=R0913,R0914", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NzEwNQ=="}, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE2ODc2OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1ODo1M1rOG-7_qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo1MDowNFrOG_aIxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0Nzg0OQ==", "bodyText": "We can move this part to additional function and call it in each zk steps.", "url": "https://github.com/apache/ignite/pull/8142#discussion_r468647849", "createdAt": "2020-08-11T14:58:53Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,28 +90,65 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_not_coordinator_two(self, version):\n+        \"\"\"\n+        Test two-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, True)\n+\n+    @cluster(num_nodes=NUM_NODES + 3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_not_coordinator_single(self, version):\n         \"\"\"\n-        Test basic discovery scenario with TcpDiscoverySpi.\n+        Test single node failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, False)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1, coordinator=False, with_zk=True)\n \n     @cluster(num_nodes=NUM_NODES + 3)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_zk(self, version):\n+    def test_zk_not_coordinator_two(self, version):\n         \"\"\"\n-        Test basic discovery scenario with ZookeeperDiscoverySpi.\n+        Test two-node-failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, True)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2, coordinator=False, with_zk=True)\n \n-    def __basic_test__(self, version, with_zk=False):\n+    @cluster(num_nodes=NUM_NODES+3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with ZooKeeper.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, coordinator=True, with_zk=True)\n+\n+    # pylint: disable=R0913,R0914\n+    def __simulate_nodes_failure(self, version, coordinator=False, with_zk=False, nodes_to_kill=1):\n         if with_zk:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTcwMA==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469141700", "createdAt": "2020-08-12T09:50:04Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,28 +90,65 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_not_coordinator_two(self, version):\n+        \"\"\"\n+        Test two-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_tcp_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, True)\n+\n+    @cluster(num_nodes=NUM_NODES + 3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_not_coordinator_single(self, version):\n         \"\"\"\n-        Test basic discovery scenario with TcpDiscoverySpi.\n+        Test single node failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, False)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=1, coordinator=False, with_zk=True)\n \n     @cluster(num_nodes=NUM_NODES + 3)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_zk(self, version):\n+    def test_zk_not_coordinator_two(self, version):\n         \"\"\"\n-        Test basic discovery scenario with ZookeeperDiscoverySpi.\n+        Test two-node-failure scenario (not the coordinator) with ZooKeeper.\n         \"\"\"\n-        return self.__basic_test__(version, True)\n+        return self.__simulate_nodes_failure(version, nodes_to_kill=2, coordinator=False, with_zk=True)\n \n-    def __basic_test__(self, version, with_zk=False):\n+    @cluster(num_nodes=NUM_NODES+3)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_zk_coordinator(self, version):\n+        \"\"\"\n+        Test coordinator-failure scenario with ZooKeeper.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, coordinator=True, with_zk=True)\n+\n+    # pylint: disable=R0913,R0914\n+    def __simulate_nodes_failure(self, version, coordinator=False, with_zk=False, nodes_to_kill=1):\n         if with_zk:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0Nzg0OQ=="}, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE4NzUwOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMjozOFrOG-8LJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0OTo1NVrOG_aIYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MDc4OA==", "bodyText": "Same as above. Seems that it is a good candidate to separate function, isn't it?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r468650788", "createdAt": "2020-08-11T15:02:38Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -117,46 +163,81 @@ def __basic_test__(self, version, with_zk=False):\n \n         start = self.monotonic()\n         self.servers.start()\n-        data = {'Ignite cluster start time (s)': self.monotonic() - start}\n+        data = {'Ignite cluster start time (s)': round(self.monotonic() - start, 1)}\n         self.stage(\"Topology is ready\")\n \n-        # Node failure detection\n-        fail_node, survived_node = self.choose_random_node_to_kill(self.servers)\n+        if nodes_to_kill > self.servers.num_nodes - 1 or coordinator and nodes_to_kill > 1:\n+            raise Exception(\"Too many nodes to kill: \" + str(nodes_to_kill))\n+\n+        if coordinator:\n+            node_chooser = lambda nodes: \\\n+                next(node for node in nodes if node.discovery_info().node_id == nodes[0].discovery_info().coordinator)\n+        else:\n+            node_chooser = lambda nodes: \\\n+                random.sample([n for n in self.servers.nodes if n.discovery_info().node_id !=\n+                               self.servers.nodes[0].discovery_info().coordinator], nodes_to_kill)\n \n-        data[\"nodes\"] = [node.node_id() for node in self.servers.nodes]\n+        failed_nodes, survived_node = self.choose_node_to_kill(self.servers.nodes, node_chooser)\n \n-        disco_infos = []\n-        for node in self.servers.nodes:\n-            disco_info = node.discovery_info()\n-            disco_infos.append({\n-                \"id\": disco_info.node_id,\n-                \"consistent_id\": disco_info.consistent_id,\n-                \"coordinator\": disco_info.coordinator,\n-                \"order\": disco_info.order,\n-                \"int_order\": disco_info.int_order,\n-                \"is_client\": disco_info.is_client\n-            })\n+        ids_to_wait = [node.discovery_info().node_id for node in failed_nodes]\n \n-        data[\"node_disco_info\"] = disco_infos\n+        self.stage(\"Stopping \" + str(len(failed_nodes)) + \" nodes.\")\n \n-        self.servers.stop_node(fail_node, clean_shutdown=False)\n+        first_terminated = self.servers.stop_nodes_async(failed_nodes, clean_shutdown=False, wait_for_stop=False)\n \n-        start = self.monotonic()\n-        self.servers.await_event_on_node(\"Node FAILED\", random.choice(survived_node), 60, True)\n+        self.stage(\"Waiting for failure detection of \" + str(len(failed_nodes)) + \" nodes.\")\n+\n+        # Keeps dates of logged node failures.\n+        last_failure_detected = 0\n+        logged_timestamps = []\n+\n+        for failed_id in ids_to_wait:\n+            pattern = \"Node FAILED: \" + (\"ZookeeperClusterNode\" if with_zk else \"TcpDiscoveryNode\") + \" \\\\[id=\" \\\n+                      + failed_id\n+\n+            self.servers.await_event_on_node(pattern, survived_node, 10, from_the_beginning=True, backoff_sec=0.01)\n \n-        data['Failure of node detected in time (s)'] = self.monotonic() - start\n+            last_failure_detected = self.monotonic()\n+\n+            self.stage(\"Failure detection measured.\")\n+\n+        for failed_id in ids_to_wait:\n+            pattern = \"Node FAILED: \" + (\"ZookeeperClusterNode\" if with_zk else \"TcpDiscoveryNode\") + \" \\\\[id=\" \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MTYwMg==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469141602", "createdAt": "2020-08-12T09:49:55Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -117,46 +163,81 @@ def __basic_test__(self, version, with_zk=False):\n \n         start = self.monotonic()\n         self.servers.start()\n-        data = {'Ignite cluster start time (s)': self.monotonic() - start}\n+        data = {'Ignite cluster start time (s)': round(self.monotonic() - start, 1)}\n         self.stage(\"Topology is ready\")\n \n-        # Node failure detection\n-        fail_node, survived_node = self.choose_random_node_to_kill(self.servers)\n+        if nodes_to_kill > self.servers.num_nodes - 1 or coordinator and nodes_to_kill > 1:\n+            raise Exception(\"Too many nodes to kill: \" + str(nodes_to_kill))\n+\n+        if coordinator:\n+            node_chooser = lambda nodes: \\\n+                next(node for node in nodes if node.discovery_info().node_id == nodes[0].discovery_info().coordinator)\n+        else:\n+            node_chooser = lambda nodes: \\\n+                random.sample([n for n in self.servers.nodes if n.discovery_info().node_id !=\n+                               self.servers.nodes[0].discovery_info().coordinator], nodes_to_kill)\n \n-        data[\"nodes\"] = [node.node_id() for node in self.servers.nodes]\n+        failed_nodes, survived_node = self.choose_node_to_kill(self.servers.nodes, node_chooser)\n \n-        disco_infos = []\n-        for node in self.servers.nodes:\n-            disco_info = node.discovery_info()\n-            disco_infos.append({\n-                \"id\": disco_info.node_id,\n-                \"consistent_id\": disco_info.consistent_id,\n-                \"coordinator\": disco_info.coordinator,\n-                \"order\": disco_info.order,\n-                \"int_order\": disco_info.int_order,\n-                \"is_client\": disco_info.is_client\n-            })\n+        ids_to_wait = [node.discovery_info().node_id for node in failed_nodes]\n \n-        data[\"node_disco_info\"] = disco_infos\n+        self.stage(\"Stopping \" + str(len(failed_nodes)) + \" nodes.\")\n \n-        self.servers.stop_node(fail_node, clean_shutdown=False)\n+        first_terminated = self.servers.stop_nodes_async(failed_nodes, clean_shutdown=False, wait_for_stop=False)\n \n-        start = self.monotonic()\n-        self.servers.await_event_on_node(\"Node FAILED\", random.choice(survived_node), 60, True)\n+        self.stage(\"Waiting for failure detection of \" + str(len(failed_nodes)) + \" nodes.\")\n+\n+        # Keeps dates of logged node failures.\n+        last_failure_detected = 0\n+        logged_timestamps = []\n+\n+        for failed_id in ids_to_wait:\n+            pattern = \"Node FAILED: \" + (\"ZookeeperClusterNode\" if with_zk else \"TcpDiscoveryNode\") + \" \\\\[id=\" \\\n+                      + failed_id\n+\n+            self.servers.await_event_on_node(pattern, survived_node, 10, from_the_beginning=True, backoff_sec=0.01)\n \n-        data['Failure of node detected in time (s)'] = self.monotonic() - start\n+            last_failure_detected = self.monotonic()\n+\n+            self.stage(\"Failure detection measured.\")\n+\n+        for failed_id in ids_to_wait:\n+            pattern = \"Node FAILED: \" + (\"ZookeeperClusterNode\" if with_zk else \"TcpDiscoveryNode\") + \" \\\\[id=\" \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MDc4OA=="}, "originalCommit": {"oid": "b0559ef38f7d17753702a22235af9c17dc2738b4"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTM1NjQ1OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/utils/concurrent.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo1MjoxMlrOG_aNnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDowNDoxMFrOG_am7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0Mjk0Mw==", "bodyText": "I suppose it's better to write some docs, isn't it?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469142943", "createdAt": "2020-08-12T09:52:12Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/services/utils/concurrent.py", "diffHunk": "@@ -0,0 +1,74 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains concurrent utils.\n+\"\"\"\n+\n+import threading\n+\n+\n+class CountDownLatch(object):\n+    \"\"\"\n+    A count-down latch.\n+    \"\"\"\n+    def __init__(self, count=1):\n+        self.count = count\n+        self.cond_var = threading.Condition()\n+\n+    def count_down(self):\n+        \"\"\"\n+        Decreases the latch counter.\n+        \"\"\"\n+        with self.cond_var:\n+            if self.count > 0:\n+                self.count -= 1\n+            if self.count == 0:\n+                self.cond_var.notifyAll()\n+\n+    def wait(self):\n+        \"\"\"\n+        Blocks current thread if the latch is not free.\n+        \"\"\"\n+        with self.cond_var:\n+            while self.count > 0:\n+                self.cond_var.wait()\n+\n+\n+# pylint: disable=C0116", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79970cd92392d3fd0e160a75cf1374a660eb44a6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0OTQyMQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469149421", "createdAt": "2020-08-12T10:04:10Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/services/utils/concurrent.py", "diffHunk": "@@ -0,0 +1,74 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains concurrent utils.\n+\"\"\"\n+\n+import threading\n+\n+\n+class CountDownLatch(object):\n+    \"\"\"\n+    A count-down latch.\n+    \"\"\"\n+    def __init__(self, count=1):\n+        self.count = count\n+        self.cond_var = threading.Condition()\n+\n+    def count_down(self):\n+        \"\"\"\n+        Decreases the latch counter.\n+        \"\"\"\n+        with self.cond_var:\n+            if self.count > 0:\n+                self.count -= 1\n+            if self.count == 0:\n+                self.cond_var.notifyAll()\n+\n+    def wait(self):\n+        \"\"\"\n+        Blocks current thread if the latch is not free.\n+        \"\"\"\n+        with self.cond_var:\n+            while self.count > 0:\n+                self.cond_var.wait()\n+\n+\n+# pylint: disable=C0116", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0Mjk0Mw=="}, "originalCommit": {"oid": "79970cd92392d3fd0e160a75cf1374a660eb44a6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTY3MDI2OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMTozMjo0MFrOG_dNgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMTo0ODowNlrOG_dp7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE5MjA2NA==", "bodyText": "why not gain from IgniteAwareService?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469192064", "createdAt": "2020-08-12T11:32:40Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -32,41 +37,58 @@\n # pylint: disable=W0223\n class DiscoveryTest(IgniteTest):\n     \"\"\"\n-    Test basic discovery scenarious (TCP and Zookeeper).\n+    Test various node failure scenarios (TCP and ZooKeeper).\n     1. Start of ignite cluster.\n     2. Kill random node.\n     3. Wait that survived node detects node failure.\n     \"\"\"\n     NUM_NODES = 7\n \n+    FAILURE_DETECTION_TIMEOUT = 2000\n+\n+    __LOG_PATH = os.path.join(IgniteAwareService.PERSISTENT_ROOT, \"console.log\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE5OTM0Mg==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469199342", "createdAt": "2020-08-12T11:48:06Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -32,41 +37,58 @@\n # pylint: disable=W0223\n class DiscoveryTest(IgniteTest):\n     \"\"\"\n-    Test basic discovery scenarious (TCP and Zookeeper).\n+    Test various node failure scenarios (TCP and ZooKeeper).\n     1. Start of ignite cluster.\n     2. Kill random node.\n     3. Wait that survived node detects node failure.\n     \"\"\"\n     NUM_NODES = 7\n \n+    FAILURE_DETECTION_TIMEOUT = 2000\n+\n+    __LOG_PATH = os.path.join(IgniteAwareService.PERSISTENT_ROOT, \"console.log\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE5MjA2NA=="}, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTc0NDk3OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMTo1NzoxMFrOG_d6zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMjo1MzozNVrOG_f6gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIwMzY2MA==", "bodyText": "can we pass how many nodes to kill via @matrix to reduce methods amount?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469203660", "createdAt": "2020-08-12T11:57:10Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,31 +103,68 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, self.__properties(), 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIwODQ1Mg==", "bodyText": "@matrix\n\nWe won't distinguish easily which test failed because, for example, 0 nodes to kill means to kill coordinator in internal routines. This reduces parameters count. Now we clearly  see it by test name. There is a lot of parametrization to me. We got 6 test functions. They look not so many. Makes sense?", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469208452", "createdAt": "2020-08-12T12:07:02Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,31 +103,68 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, self.__properties(), 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIwMzY2MA=="}, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIyMDU2OQ==", "bodyText": "I see code duplication and we have to reduce it if possible.\n@matrix made for this.\n0 to stop coordinator looks counter-intuitive to me, what about the case when we have kill coordinator and some node?\nHow to kill node after coordinator in one case and before at another?\nmatrix with a list of nodes to kill will be more clear? eg. [0, 3, 7], [5, 0, 2], [0, 5, 2].", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469220569", "createdAt": "2020-08-12T12:27:34Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,31 +103,68 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, self.__properties(), 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIwMzY2MA=="}, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIyNTM2NQ==", "bodyText": "Yes, counter-intuitive. But you don't see it now. Now we have intuitive test names. It will become counter-inuitive with @matrix. This parametrization requires extra test organization. This PR do not include case for failing coordinator with some othe node. This could be done with some small changes and parameter. But looks like anohter ticket and PR to me.", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469225365", "createdAt": "2020-08-12T12:33:43Z", "author": {"login": "Vladsz83"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,31 +103,68 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, self.__properties(), 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIwMzY2MA=="}, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIzNjM1Mw==", "bodyText": "Ok for now.", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469236353", "createdAt": "2020-08-12T12:53:35Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/discovery_test.py", "diffHunk": "@@ -81,31 +103,68 @@ def teardown(self):\n     @cluster(num_nodes=NUM_NODES)\n     @parametrize(version=str(DEV_BRANCH))\n     @parametrize(version=str(LATEST_2_7))\n-    def test_tcp(self, version):\n+    def test_tcp_not_coordinator_single(self, version):\n+        \"\"\"\n+        Test single-node-failure scenario (not the coordinator) with TcpDiscoverySpi.\n+        \"\"\"\n+        return self.__simulate_nodes_failure(version, self.__properties(), 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIwMzY2MA=="}, "originalCommit": {"oid": "67facb6335517c9f59022712070352977570e2be"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjM3NzcyOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNDoyOTo0NVrOG_j9ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNDoyOTo0NVrOG_j9ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMwMjY4Ng==", "bodyText": "Actually, you can use simple dict here, it is thread-safe (GIL)", "url": "https://github.com/apache/ignite/pull/8142#discussion_r469302686", "createdAt": "2020-08-12T14:29:45Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/services/ignite.py", "diffHunk": "@@ -100,6 +107,59 @@ def stop_node(self, node, clean_shutdown=True, timeout_sec=60):\n             self.thread_dump(node)\n             raise\n \n+    def stop_nodes_async(self, nodes, delay_ms=0, clean_shutdown=True, timeout_sec=20, wait_for_stop=False):\n+        \"\"\"\n+        Stops the nodes asynchronously.\n+        \"\"\"\n+        sig = signal.SIGTERM if clean_shutdown else signal.SIGKILL\n+\n+        sem = CountDownLatch(len(nodes))\n+        time_holder = AtomicValue()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53ecc85137ce7596ab1774f11e4277e5c2a0fc78"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2708, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}