{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3ODA5Njgx", "number": 7531, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNToyMVrODos6bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNToyMzoyNVrODoxImQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDA1NDg1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNToyMVrOF3aQmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzozMzoxNVrOF3cZxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjIzNQ==", "bodyText": "I suggest leaving this method only in the bean.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393646235", "createdAt": "2020-03-17T12:35:21Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -3586,6 +3305,26 @@ private void checkNearCacheStarted(IgniteCacheProxy<?, ?> cache) throws IgniteCh\n                 \"(a cache with the same name without near cache is already started)\");\n     }\n \n+    /**\n+     * This method allows manually remove the checkpoint with given {@code key}.\n+     *\n+     * @param key Checkpoint key.\n+     * @return {@code true} if specified checkpoint was indeed removed, {@code false}\n+     *      otherwise.\n+     */\n+    boolean removeCheckpoint(String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2MDM3Nw==", "bodyText": "I suggest leaving this method only in the bean.\n\n@NSAmelchev, what do you suggest to do with IgniteKernal.checkClusterState() ?", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393660377", "createdAt": "2020-03-17T13:00:29Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -3586,6 +3305,26 @@ private void checkNearCacheStarted(IgniteCacheProxy<?, ?> cache) throws IgniteCh\n                 \"(a cache with the same name without near cache is already started)\");\n     }\n \n+    /**\n+     * This method allows manually remove the checkpoint with given {@code key}.\n+     *\n+     * @param key Checkpoint key.\n+     * @return {@code true} if specified checkpoint was indeed removed, {@code false}\n+     *      otherwise.\n+     */\n+    boolean removeCheckpoint(String key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjIzNQ=="}, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MTM1MA==", "bodyText": "Ok, let's leave it here. And do not move it down in the code.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393681350", "createdAt": "2020-03-17T13:33:15Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -3586,6 +3305,26 @@ private void checkNearCacheStarted(IgniteCacheProxy<?, ?> cache) throws IgniteCh\n                 \"(a cache with the same name without near cache is already started)\");\n     }\n \n+    /**\n+     * This method allows manually remove the checkpoint with given {@code key}.\n+     *\n+     * @param key Checkpoint key.\n+     * @return {@code true} if specified checkpoint was indeed removed, {@code false}\n+     *      otherwise.\n+     */\n+    boolean removeCheckpoint(String key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjIzNQ=="}, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDA1NjQyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNTo0OFrOF3aRhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoyNzo0OVrOF3cL4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjQ3MQ==", "bodyText": "name -> instanceName", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393646471", "createdAt": "2020-03-17T12:35:48Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -4618,32 +4357,32 @@ private void registerMetrics() {\n \n         MetricRegistry reg = ctx.metric().registry(GridMetricManager.IGNITE_METRICS);\n \n-        reg.register(\"fullVersion\", this::getFullVersion, String.class, FULL_VER_DESC);\n-        reg.register(\"copyright\", this::getCopyright, String.class, COPYRIGHT_DESC);\n+        reg.register(\"fullVersion\", this::fullVersion, String.class, FULL_VER_DESC);\n+        reg.register(\"copyright\", () -> COPYRIGHT, String.class, COPYRIGHT_DESC);\n \n-        reg.register(\"startTimestampFormatted\", this::getStartTimestampFormatted, String.class,\n+        reg.register(\"startTimestampFormatted\", this::startTimeFormatted, String.class,\n             START_TIMESTAMP_FORMATTED_DESC);\n \n         reg.register(\"isRebalanceEnabled\", this::isRebalanceEnabled, IS_REBALANCE_ENABLED_DESC);\n-        reg.register(\"uptimeFormatted\", this::getUpTimeFormatted, String.class, UPTIME_FORMATTED_DESC);\n-        reg.register(\"startTimestamp\", this::getStartTimestamp, START_TIMESTAMP_DESC);\n-        reg.register(\"uptime\", this::getUpTime, UPTIME_DESC);\n-        reg.register(\"osInformation\", this::getOsInformation, String.class, OS_INFO_DESC);\n-        reg.register(\"jdkInformation\", this::getJdkInformation, String.class, JDK_INFO_DESC);\n-        reg.register(\"osUser\", this::getOsUser, String.class, OS_USER_DESC);\n-        reg.register(\"vmName\", this::getVmName, String.class, VM_NAME_DESC);\n-        reg.register(\"instanceName\", this::getInstanceName, String.class, INSTANCE_NAME_DESC);\n-\n-        reg.register(\"currentCoordinatorFormatted\", this::getCurrentCoordinatorFormatted, String.class,\n+        reg.register(\"uptimeFormatted\", this::upTimeFormatted, String.class, UPTIME_FORMATTED_DESC);\n+        reg.register(\"startTimestamp\", this::startTimestamp, START_TIMESTAMP_DESC);\n+        reg.register(\"uptime\", this::upTime, UPTIME_DESC);\n+        reg.register(\"osInformation\", this::osInformation, String.class, OS_INFO_DESC);\n+        reg.register(\"jdkInformation\", this::jdkInformation, String.class, JDK_INFO_DESC);\n+        reg.register(\"osUser\", this::osUser, String.class, OS_USER_DESC);\n+        reg.register(\"vmName\", this::vmName, String.class, VM_NAME_DESC);\n+        reg.register(\"instanceName\", this::name, String.class, INSTANCE_NAME_DESC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2MzQ4OA==", "bodyText": "name -> instanceName\n\nWe should not change public api Ignite.name(). And I don't like adding one more function for the same. Makes sense?", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393663488", "createdAt": "2020-03-17T13:05:48Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -4618,32 +4357,32 @@ private void registerMetrics() {\n \n         MetricRegistry reg = ctx.metric().registry(GridMetricManager.IGNITE_METRICS);\n \n-        reg.register(\"fullVersion\", this::getFullVersion, String.class, FULL_VER_DESC);\n-        reg.register(\"copyright\", this::getCopyright, String.class, COPYRIGHT_DESC);\n+        reg.register(\"fullVersion\", this::fullVersion, String.class, FULL_VER_DESC);\n+        reg.register(\"copyright\", () -> COPYRIGHT, String.class, COPYRIGHT_DESC);\n \n-        reg.register(\"startTimestampFormatted\", this::getStartTimestampFormatted, String.class,\n+        reg.register(\"startTimestampFormatted\", this::startTimeFormatted, String.class,\n             START_TIMESTAMP_FORMATTED_DESC);\n \n         reg.register(\"isRebalanceEnabled\", this::isRebalanceEnabled, IS_REBALANCE_ENABLED_DESC);\n-        reg.register(\"uptimeFormatted\", this::getUpTimeFormatted, String.class, UPTIME_FORMATTED_DESC);\n-        reg.register(\"startTimestamp\", this::getStartTimestamp, START_TIMESTAMP_DESC);\n-        reg.register(\"uptime\", this::getUpTime, UPTIME_DESC);\n-        reg.register(\"osInformation\", this::getOsInformation, String.class, OS_INFO_DESC);\n-        reg.register(\"jdkInformation\", this::getJdkInformation, String.class, JDK_INFO_DESC);\n-        reg.register(\"osUser\", this::getOsUser, String.class, OS_USER_DESC);\n-        reg.register(\"vmName\", this::getVmName, String.class, VM_NAME_DESC);\n-        reg.register(\"instanceName\", this::getInstanceName, String.class, INSTANCE_NAME_DESC);\n-\n-        reg.register(\"currentCoordinatorFormatted\", this::getCurrentCoordinatorFormatted, String.class,\n+        reg.register(\"uptimeFormatted\", this::upTimeFormatted, String.class, UPTIME_FORMATTED_DESC);\n+        reg.register(\"startTimestamp\", this::startTimestamp, START_TIMESTAMP_DESC);\n+        reg.register(\"uptime\", this::upTime, UPTIME_DESC);\n+        reg.register(\"osInformation\", this::osInformation, String.class, OS_INFO_DESC);\n+        reg.register(\"jdkInformation\", this::jdkInformation, String.class, JDK_INFO_DESC);\n+        reg.register(\"osUser\", this::osUser, String.class, OS_USER_DESC);\n+        reg.register(\"vmName\", this::vmName, String.class, VM_NAME_DESC);\n+        reg.register(\"instanceName\", this::name, String.class, INSTANCE_NAME_DESC);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjQ3MQ=="}, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3Nzc5Mg==", "bodyText": "Ok, lets use name()", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393677792", "createdAt": "2020-03-17T13:27:49Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -4618,32 +4357,32 @@ private void registerMetrics() {\n \n         MetricRegistry reg = ctx.metric().registry(GridMetricManager.IGNITE_METRICS);\n \n-        reg.register(\"fullVersion\", this::getFullVersion, String.class, FULL_VER_DESC);\n-        reg.register(\"copyright\", this::getCopyright, String.class, COPYRIGHT_DESC);\n+        reg.register(\"fullVersion\", this::fullVersion, String.class, FULL_VER_DESC);\n+        reg.register(\"copyright\", () -> COPYRIGHT, String.class, COPYRIGHT_DESC);\n \n-        reg.register(\"startTimestampFormatted\", this::getStartTimestampFormatted, String.class,\n+        reg.register(\"startTimestampFormatted\", this::startTimeFormatted, String.class,\n             START_TIMESTAMP_FORMATTED_DESC);\n \n         reg.register(\"isRebalanceEnabled\", this::isRebalanceEnabled, IS_REBALANCE_ENABLED_DESC);\n-        reg.register(\"uptimeFormatted\", this::getUpTimeFormatted, String.class, UPTIME_FORMATTED_DESC);\n-        reg.register(\"startTimestamp\", this::getStartTimestamp, START_TIMESTAMP_DESC);\n-        reg.register(\"uptime\", this::getUpTime, UPTIME_DESC);\n-        reg.register(\"osInformation\", this::getOsInformation, String.class, OS_INFO_DESC);\n-        reg.register(\"jdkInformation\", this::getJdkInformation, String.class, JDK_INFO_DESC);\n-        reg.register(\"osUser\", this::getOsUser, String.class, OS_USER_DESC);\n-        reg.register(\"vmName\", this::getVmName, String.class, VM_NAME_DESC);\n-        reg.register(\"instanceName\", this::getInstanceName, String.class, INSTANCE_NAME_DESC);\n-\n-        reg.register(\"currentCoordinatorFormatted\", this::getCurrentCoordinatorFormatted, String.class,\n+        reg.register(\"uptimeFormatted\", this::upTimeFormatted, String.class, UPTIME_FORMATTED_DESC);\n+        reg.register(\"startTimestamp\", this::startTimestamp, START_TIMESTAMP_DESC);\n+        reg.register(\"uptime\", this::upTime, UPTIME_DESC);\n+        reg.register(\"osInformation\", this::osInformation, String.class, OS_INFO_DESC);\n+        reg.register(\"jdkInformation\", this::jdkInformation, String.class, JDK_INFO_DESC);\n+        reg.register(\"osUser\", this::osUser, String.class, OS_USER_DESC);\n+        reg.register(\"vmName\", this::vmName, String.class, VM_NAME_DESC);\n+        reg.register(\"instanceName\", this::name, String.class, INSTANCE_NAME_DESC);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NjQ3MQ=="}, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 489}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDA2MjI2OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozNzo0MlrOF3aVcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzowNzo0OVrOF3bY_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzQ3NA==", "bodyText": "Can be inlined", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393647474", "createdAt": "2020-03-17T12:37:42Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -4652,53 +4391,353 @@ private void registerMetrics() {\n         reg.register(\"clusterState\", this::clusterState, String.class, CLUSTER_STATE_DESC);\n         reg.register(\"lastClusterStateChangeTime\", this::lastClusterStateChangeTime, LAST_CLUSTER_STATE_CHANGE_TIME_DESC);\n \n-        reg.register(\"userAttributesFormatted\", this::getUserAttributesFormatted, List.class,\n+        reg.register(\"userAttributesFormatted\", this::userAttributesFormatted, List.class,\n             USER_ATTRS_FORMATTED_DESC);\n \n-        reg.register(\"gridLoggerFormatted\", this::getGridLoggerFormatted, String.class,\n+        reg.register(\"gridLoggerFormatted\", this::gridLoggerFormatted, String.class,\n             GRID_LOG_FORMATTED_DESC);\n \n-        reg.register(\"executorServiceFormatted\", this::getExecutorServiceFormatted, String.class,\n+        reg.register(\"executorServiceFormatted\", this::executorServiceFormatted, String.class,\n             EXECUTOR_SRVC_FORMATTED_DESC);\n \n-        reg.register(\"igniteHome\", this::getIgniteHome, String.class, IGNITE_HOME_DESC);\n+        reg.register(\"igniteHome\", this::igniteHome, String.class, IGNITE_HOME_DESC);\n \n-        reg.register(\"mBeanServerFormatted\", this::getMBeanServerFormatted, String.class,\n+        reg.register(\"mBeanServerFormatted\", this::mbeanServerFormatted, String.class,\n             MBEAN_SERVER_FORMATTED_DESC);\n \n         reg.register(\"localNodeId\", this::getLocalNodeId, UUID.class, LOC_NODE_ID_DESC);\n \n-        reg.register(\"isPeerClassLoadingEnabled\", this::isPeerClassLoadingEnabled, Boolean.class,\n+        reg.register(\"isPeerClassLoadingEnabled\", this::peerClassLoadingEnabled, Boolean.class,\n             IS_PEER_CLS_LOADING_ENABLED_DESC);\n \n-        reg.register(\"lifecycleBeansFormatted\", this::getLifecycleBeansFormatted, List.class,\n+        reg.register(\"lifecycleBeansFormatted\", this::lifecycleBeansFormatted, List.class,\n             LIFECYCLE_BEANS_FORMATTED_DESC);\n \n-        reg.register(\"discoverySpiFormatted\", this::getDiscoverySpiFormatted, String.class,\n+        reg.register(\"discoverySpiFormatted\", this::discoverySpiFormatted, String.class,\n             DISCOVERY_SPI_FORMATTED_DESC);\n \n-        reg.register(\"communicationSpiFormatted\", this::getCommunicationSpiFormatted, String.class,\n+        reg.register(\"communicationSpiFormatted\", this::communicationSpiFormatted, String.class,\n             COMMUNICATION_SPI_FORMATTED_DESC);\n \n-        reg.register(\"deploymentSpiFormatted\", this::getDeploymentSpiFormatted, String.class,\n+        reg.register(\"deploymentSpiFormatted\", this::deploymentSpiFormatted, String.class,\n             DEPLOYMENT_SPI_FORMATTED_DESC);\n \n-        reg.register(\"checkpointSpiFormatted\", this::getCheckpointSpiFormatted, String.class,\n+        reg.register(\"checkpointSpiFormatted\", this::checkpointSpiFormatted, String.class,\n             CHECKPOINT_SPI_FORMATTED_DESC);\n \n-        reg.register(\"collisionSpiFormatted\", this::getCollisionSpiFormatted, String.class,\n+        reg.register(\"collisionSpiFormatted\", this::collisionSpiFormatted, String.class,\n             COLLISION_SPI_FORMATTED_DESC);\n \n-        reg.register(\"eventStorageSpiFormatted\", this::getEventStorageSpiFormatted, String.class,\n+        reg.register(\"eventStorageSpiFormatted\", this::eventStorageSpiFormatted, String.class,\n             EVT_STORAGE_SPI_FORMATTED_DESC);\n \n-        reg.register(\"failoverSpiFormatted\", this::getFailoverSpiFormatted, String.class,\n+        reg.register(\"failoverSpiFormatted\", this::failoverSpiFormatted, String.class,\n             FAILOVER_SPI_FORMATTED_DESC);\n \n-        reg.register(\"loadBalancingSpiFormatted\", this::getLoadBalancingSpiFormatted, String.class,\n+        reg.register(\"loadBalancingSpiFormatted\", this::loadBalancingSpiFormatted, String.class,\n             LOAD_BALANCING_SPI_FORMATTED_DESC);\n     }\n \n+    /**\n+     * @return String representation of version of current Ignite instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 575}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2NDc2Nw==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393664767", "createdAt": "2020-03-17T13:07:49Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteKernal.java", "diffHunk": "@@ -4652,53 +4391,353 @@ private void registerMetrics() {\n         reg.register(\"clusterState\", this::clusterState, String.class, CLUSTER_STATE_DESC);\n         reg.register(\"lastClusterStateChangeTime\", this::lastClusterStateChangeTime, LAST_CLUSTER_STATE_CHANGE_TIME_DESC);\n \n-        reg.register(\"userAttributesFormatted\", this::getUserAttributesFormatted, List.class,\n+        reg.register(\"userAttributesFormatted\", this::userAttributesFormatted, List.class,\n             USER_ATTRS_FORMATTED_DESC);\n \n-        reg.register(\"gridLoggerFormatted\", this::getGridLoggerFormatted, String.class,\n+        reg.register(\"gridLoggerFormatted\", this::gridLoggerFormatted, String.class,\n             GRID_LOG_FORMATTED_DESC);\n \n-        reg.register(\"executorServiceFormatted\", this::getExecutorServiceFormatted, String.class,\n+        reg.register(\"executorServiceFormatted\", this::executorServiceFormatted, String.class,\n             EXECUTOR_SRVC_FORMATTED_DESC);\n \n-        reg.register(\"igniteHome\", this::getIgniteHome, String.class, IGNITE_HOME_DESC);\n+        reg.register(\"igniteHome\", this::igniteHome, String.class, IGNITE_HOME_DESC);\n \n-        reg.register(\"mBeanServerFormatted\", this::getMBeanServerFormatted, String.class,\n+        reg.register(\"mBeanServerFormatted\", this::mbeanServerFormatted, String.class,\n             MBEAN_SERVER_FORMATTED_DESC);\n \n         reg.register(\"localNodeId\", this::getLocalNodeId, UUID.class, LOC_NODE_ID_DESC);\n \n-        reg.register(\"isPeerClassLoadingEnabled\", this::isPeerClassLoadingEnabled, Boolean.class,\n+        reg.register(\"isPeerClassLoadingEnabled\", this::peerClassLoadingEnabled, Boolean.class,\n             IS_PEER_CLS_LOADING_ENABLED_DESC);\n \n-        reg.register(\"lifecycleBeansFormatted\", this::getLifecycleBeansFormatted, List.class,\n+        reg.register(\"lifecycleBeansFormatted\", this::lifecycleBeansFormatted, List.class,\n             LIFECYCLE_BEANS_FORMATTED_DESC);\n \n-        reg.register(\"discoverySpiFormatted\", this::getDiscoverySpiFormatted, String.class,\n+        reg.register(\"discoverySpiFormatted\", this::discoverySpiFormatted, String.class,\n             DISCOVERY_SPI_FORMATTED_DESC);\n \n-        reg.register(\"communicationSpiFormatted\", this::getCommunicationSpiFormatted, String.class,\n+        reg.register(\"communicationSpiFormatted\", this::communicationSpiFormatted, String.class,\n             COMMUNICATION_SPI_FORMATTED_DESC);\n \n-        reg.register(\"deploymentSpiFormatted\", this::getDeploymentSpiFormatted, String.class,\n+        reg.register(\"deploymentSpiFormatted\", this::deploymentSpiFormatted, String.class,\n             DEPLOYMENT_SPI_FORMATTED_DESC);\n \n-        reg.register(\"checkpointSpiFormatted\", this::getCheckpointSpiFormatted, String.class,\n+        reg.register(\"checkpointSpiFormatted\", this::checkpointSpiFormatted, String.class,\n             CHECKPOINT_SPI_FORMATTED_DESC);\n \n-        reg.register(\"collisionSpiFormatted\", this::getCollisionSpiFormatted, String.class,\n+        reg.register(\"collisionSpiFormatted\", this::collisionSpiFormatted, String.class,\n             COLLISION_SPI_FORMATTED_DESC);\n \n-        reg.register(\"eventStorageSpiFormatted\", this::getEventStorageSpiFormatted, String.class,\n+        reg.register(\"eventStorageSpiFormatted\", this::eventStorageSpiFormatted, String.class,\n             EVT_STORAGE_SPI_FORMATTED_DESC);\n \n-        reg.register(\"failoverSpiFormatted\", this::getFailoverSpiFormatted, String.class,\n+        reg.register(\"failoverSpiFormatted\", this::failoverSpiFormatted, String.class,\n             FAILOVER_SPI_FORMATTED_DESC);\n \n-        reg.register(\"loadBalancingSpiFormatted\", this::getLoadBalancingSpiFormatted, String.class,\n+        reg.register(\"loadBalancingSpiFormatted\", this::loadBalancingSpiFormatted, String.class,\n             LOAD_BALANCING_SPI_FORMATTED_DESC);\n     }\n \n+    /**\n+     * @return String representation of version of current Ignite instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0NzQ3NA=="}, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 575}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDA2ODAwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/managers/IgniteMBeansManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjozOTozMVrOF3aZFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoyMDozOVrOF3b4iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0ODQwNw==", "bodyText": "Create mbean var, please", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393648407", "createdAt": "2020-03-17T12:39:31Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/managers/IgniteMBeansManager.java", "diffHunk": "@@ -131,7 +132,7 @@ public void registerAllMBeans(\n             return;\n \n         // Kernal\n-        registerMBean(\"Kernal\", IgniteKernal.class.getSimpleName(), kernal, IgniteMXBean.class);\n+        registerMBean(\"Kernal\", IgniteKernal.class.getSimpleName(), new IgniteMXBeanImpl(kernal), IgniteMXBean.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3Mjg0MQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393672841", "createdAt": "2020-03-17T13:20:39Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/managers/IgniteMBeansManager.java", "diffHunk": "@@ -131,7 +132,7 @@ public void registerAllMBeans(\n             return;\n \n         // Kernal\n-        registerMBean(\"Kernal\", IgniteKernal.class.getSimpleName(), kernal, IgniteMXBean.class);\n+        registerMBean(\"Kernal\", IgniteKernal.class.getSimpleName(), new IgniteMXBeanImpl(kernal), IgniteMXBean.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0ODQwNw=="}, "originalCommit": {"oid": "a000843c62d74798b96f50f1d7ec8f0880b036af"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDA3NTYyOnYy", "diffSide": "LEFT", "path": "modules/core/src/main/java/org/apache/ignite/IgniteCluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjo0MTozMlrOF3adsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoxMzoxNFrOF3bl4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0OTU4NA==", "bodyText": "Why this changed?", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393649584", "createdAt": "2020-03-17T12:41:32Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/IgniteCluster.java", "diffHunk": "@@ -455,9 +455,6 @@\n \n     /**\n      * Changes Ignite grid state to active or inactive.\n-     * <p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2ODA2Ng==", "bodyText": "Miss-puss. Fixed.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393668066", "createdAt": "2020-03-17T13:13:14Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/IgniteCluster.java", "diffHunk": "@@ -455,9 +455,6 @@\n \n     /**\n      * Changes Ignite grid state to active or inactive.\n-     * <p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0OTU4NA=="}, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDE1OTM1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzowNTowMVrOF3bSOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzowNTowMVrOF3bSOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2MzAzNA==", "bodyText": "Lets create printLastErrors in the kerrnal like osUser methods. Log will not be needed.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393663034", "createdAt": "2020-03-17T13:05:01Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,341 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /** Logger, same as for IgniteKernal. */\n+    private final IgniteLogger log;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+\n+        this.log = kernal.context().log(IgniteKernal.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            return kernal.context().state().publicApiActiveState(true);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void active(boolean active) {\n+        clusterState(active ? ACTIVE.toString() : INACTIVE.toString(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCopyright() {\n+        return COPYRIGHT;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getStartTimestamp() {\n+        return kernal.startTimestamp();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getStartTimestampFormatted() {\n+        return kernal.startTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getUpTime() {\n+        return kernal.upTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesCount() {\n+        return kernal.longJVMPausesCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesTotalDuration() {\n+        return kernal.longJVMPausesTotalDuration();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Map<Long, Long> getLongJVMPauseLastEvents() {\n+        return kernal.longJVMPauseLastEvents();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getUpTimeFormatted() {\n+        return kernal.upTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFullVersion() {\n+        return kernal.fullVersion();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCheckpointSpiFormatted() {\n+        return kernal.checkpointSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCurrentCoordinatorFormatted() {\n+        return kernal.currentCoordinatorFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isNodeInBaseline() {\n+       return kernal.nodeInBaseline();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCommunicationSpiFormatted() {\n+        return kernal.communicationSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDeploymentSpiFormatted() {\n+        return kernal.deploymentSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDiscoverySpiFormatted() {\n+        return kernal.discoverySpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getEventStorageSpiFormatted() {\n+        return kernal.eventStorageSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCollisionSpiFormatted() {\n+        return kernal.collisionSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFailoverSpiFormatted() {\n+        return kernal.failoverSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getLoadBalancingSpiFormatted() {\n+        return kernal.loadBalancingSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsInformation() {\n+        return kernal.osInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getJdkInformation() {\n+        return kernal.jdkInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsUser() {\n+        return kernal.osUser();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void printLastErrors() {\n+        kernal.context().exceptionRegistry().printErrors(log);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDE5NzMxOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoxNToxNFrOF3bqnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoxODozMFrOF3bzBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2OTI3OQ==", "bodyText": "Lets use isRebalanceEnabled from kernal", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393669279", "createdAt": "2020-03-17T13:15:14Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,341 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /** Logger, same as for IgniteKernal. */\n+    private final IgniteLogger log;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+\n+        this.log = kernal.context().log(IgniteKernal.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            return kernal.context().state().publicApiActiveState(true);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void active(boolean active) {\n+        clusterState(active ? ACTIVE.toString() : INACTIVE.toString(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCopyright() {\n+        return COPYRIGHT;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getStartTimestamp() {\n+        return kernal.startTimestamp();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getStartTimestampFormatted() {\n+        return kernal.startTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getUpTime() {\n+        return kernal.upTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesCount() {\n+        return kernal.longJVMPausesCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesTotalDuration() {\n+        return kernal.longJVMPausesTotalDuration();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Map<Long, Long> getLongJVMPauseLastEvents() {\n+        return kernal.longJVMPauseLastEvents();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getUpTimeFormatted() {\n+        return kernal.upTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFullVersion() {\n+        return kernal.fullVersion();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCheckpointSpiFormatted() {\n+        return kernal.checkpointSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCurrentCoordinatorFormatted() {\n+        return kernal.currentCoordinatorFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isNodeInBaseline() {\n+       return kernal.nodeInBaseline();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCommunicationSpiFormatted() {\n+        return kernal.communicationSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDeploymentSpiFormatted() {\n+        return kernal.deploymentSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDiscoverySpiFormatted() {\n+        return kernal.discoverySpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getEventStorageSpiFormatted() {\n+        return kernal.eventStorageSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCollisionSpiFormatted() {\n+        return kernal.collisionSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFailoverSpiFormatted() {\n+        return kernal.failoverSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getLoadBalancingSpiFormatted() {\n+        return kernal.loadBalancingSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsInformation() {\n+        return kernal.osInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getJdkInformation() {\n+        return kernal.jdkInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsUser() {\n+        return kernal.osUser();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void printLastErrors() {\n+        kernal.context().exceptionRegistry().printErrors(log);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getVmName() {\n+        return kernal.vmName();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getInstanceName() {\n+        return kernal.name();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getExecutorServiceFormatted() {\n+        return kernal.executorServiceFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getIgniteHome() {\n+        return kernal.igniteHome();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getGridLoggerFormatted() {\n+        return kernal.gridLoggerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getMBeanServerFormatted() {\n+        return kernal.mbeanServerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public UUID getLocalNodeId() {\n+        return kernal.getLocalNodeId();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getUserAttributesFormatted() {\n+        return kernal.userAttributesFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isPeerClassLoadingEnabled() {\n+        return kernal.peerClassLoadingEnabled();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getLifecycleBeansFormatted() {\n+        return kernal.lifecycleBeansFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String clusterState() {\n+        return kernal.clusterState();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long lastClusterStateChangeTime() {\n+        return kernal.lastClusterStateChangeTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean removeCheckpoint(String key) {\n+        A.notNull(key, \"key\");\n+\n+        return kernal.removeCheckpoint(key);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNode(String nodeId) {\n+        A.notNull(nodeId, \"nodeId\");\n+\n+        return kernal.cluster().pingNode(UUID.fromString(nodeId));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void undeployTaskFromGrid(String taskName) throws JMException {\n+        A.notNull(taskName, \"taskName\");\n+\n+        try {\n+            kernal.compute().undeployTask(taskName);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String executeTask(String taskName, String arg) throws JMException {\n+        try {\n+            return kernal.compute().execute(taskName, arg);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNodeByAddress(String host) {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            for (ClusterNode n : kernal.cluster().nodes())\n+                if (n.addresses().contains(host))\n+                    return kernal.context().discovery().pingNode(n.id());\n+\n+            return false;\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void dumpDebugInfo() {\n+        kernal.dumpDebugInfo();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void runIoTest(\n+        long warmup,\n+        long duration,\n+        int threads,\n+        long maxLatency,\n+        int rangesCnt,\n+        int payLoadSize,\n+        boolean procFromNioThread\n+    ) {\n+        kernal.context().io().runIoTest(warmup, duration, threads, maxLatency, rangesCnt, payLoadSize,\n+            procFromNioThread, new ArrayList(kernal.context().cluster().get().forServers().forRemotes().nodes()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearNodeLocalMap() {\n+        kernal.context().cluster().get().clearNodeMap();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state) {\n+        clusterState(state, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state, boolean forceDeactivation) {\n+        ClusterState newState = ClusterState.valueOf(state);\n+\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            kernal.context().state().changeGlobalState(newState, forceDeactivation, kernal.context().cluster().get()\n+                .forServers().nodes(), false).get();\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isRebalanceEnabled() {\n+        return kernal.context().cache().context().isRebalanceEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3MTQzMQ==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393671431", "createdAt": "2020-03-17T13:18:30Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,341 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /** Logger, same as for IgniteKernal. */\n+    private final IgniteLogger log;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+\n+        this.log = kernal.context().log(IgniteKernal.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            return kernal.context().state().publicApiActiveState(true);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void active(boolean active) {\n+        clusterState(active ? ACTIVE.toString() : INACTIVE.toString(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCopyright() {\n+        return COPYRIGHT;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getStartTimestamp() {\n+        return kernal.startTimestamp();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getStartTimestampFormatted() {\n+        return kernal.startTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getUpTime() {\n+        return kernal.upTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesCount() {\n+        return kernal.longJVMPausesCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesTotalDuration() {\n+        return kernal.longJVMPausesTotalDuration();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Map<Long, Long> getLongJVMPauseLastEvents() {\n+        return kernal.longJVMPauseLastEvents();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getUpTimeFormatted() {\n+        return kernal.upTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFullVersion() {\n+        return kernal.fullVersion();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCheckpointSpiFormatted() {\n+        return kernal.checkpointSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCurrentCoordinatorFormatted() {\n+        return kernal.currentCoordinatorFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isNodeInBaseline() {\n+       return kernal.nodeInBaseline();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCommunicationSpiFormatted() {\n+        return kernal.communicationSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDeploymentSpiFormatted() {\n+        return kernal.deploymentSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDiscoverySpiFormatted() {\n+        return kernal.discoverySpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getEventStorageSpiFormatted() {\n+        return kernal.eventStorageSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCollisionSpiFormatted() {\n+        return kernal.collisionSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFailoverSpiFormatted() {\n+        return kernal.failoverSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getLoadBalancingSpiFormatted() {\n+        return kernal.loadBalancingSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsInformation() {\n+        return kernal.osInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getJdkInformation() {\n+        return kernal.jdkInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsUser() {\n+        return kernal.osUser();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void printLastErrors() {\n+        kernal.context().exceptionRegistry().printErrors(log);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getVmName() {\n+        return kernal.vmName();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getInstanceName() {\n+        return kernal.name();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getExecutorServiceFormatted() {\n+        return kernal.executorServiceFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getIgniteHome() {\n+        return kernal.igniteHome();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getGridLoggerFormatted() {\n+        return kernal.gridLoggerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getMBeanServerFormatted() {\n+        return kernal.mbeanServerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public UUID getLocalNodeId() {\n+        return kernal.getLocalNodeId();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getUserAttributesFormatted() {\n+        return kernal.userAttributesFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isPeerClassLoadingEnabled() {\n+        return kernal.peerClassLoadingEnabled();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getLifecycleBeansFormatted() {\n+        return kernal.lifecycleBeansFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String clusterState() {\n+        return kernal.clusterState();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long lastClusterStateChangeTime() {\n+        return kernal.lastClusterStateChangeTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean removeCheckpoint(String key) {\n+        A.notNull(key, \"key\");\n+\n+        return kernal.removeCheckpoint(key);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNode(String nodeId) {\n+        A.notNull(nodeId, \"nodeId\");\n+\n+        return kernal.cluster().pingNode(UUID.fromString(nodeId));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void undeployTaskFromGrid(String taskName) throws JMException {\n+        A.notNull(taskName, \"taskName\");\n+\n+        try {\n+            kernal.compute().undeployTask(taskName);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String executeTask(String taskName, String arg) throws JMException {\n+        try {\n+            return kernal.compute().execute(taskName, arg);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNodeByAddress(String host) {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            for (ClusterNode n : kernal.cluster().nodes())\n+                if (n.addresses().contains(host))\n+                    return kernal.context().discovery().pingNode(n.id());\n+\n+            return false;\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void dumpDebugInfo() {\n+        kernal.dumpDebugInfo();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void runIoTest(\n+        long warmup,\n+        long duration,\n+        int threads,\n+        long maxLatency,\n+        int rangesCnt,\n+        int payLoadSize,\n+        boolean procFromNioThread\n+    ) {\n+        kernal.context().io().runIoTest(warmup, duration, threads, maxLatency, rangesCnt, payLoadSize,\n+            procFromNioThread, new ArrayList(kernal.context().cluster().get().forServers().forRemotes().nodes()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearNodeLocalMap() {\n+        kernal.context().cluster().get().clearNodeMap();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state) {\n+        clusterState(state, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state, boolean forceDeactivation) {\n+        ClusterState newState = ClusterState.valueOf(state);\n+\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            kernal.context().state().changeGlobalState(newState, forceDeactivation, kernal.context().cluster().get()\n+                .forServers().nodes(), false).get();\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isRebalanceEnabled() {\n+        return kernal.context().cache().context().isRebalanceEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2OTI3OQ=="}, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDIyMjMzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoyMTozN1rOF3b6_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzoyNTozMFrOF3cFkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3MzQ2OA==", "bodyText": "Lets use kernal.active()", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393673468", "createdAt": "2020-03-17T13:21:37Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,341 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /** Logger, same as for IgniteKernal. */\n+    private final IgniteLogger log;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+\n+        this.log = kernal.context().log(IgniteKernal.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            return kernal.context().state().publicApiActiveState(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3NjE3Ng==", "bodyText": "fixed.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393676176", "createdAt": "2020-03-17T13:25:30Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,341 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /** Logger, same as for IgniteKernal. */\n+    private final IgniteLogger log;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+\n+        this.log = kernal.context().log(IgniteKernal.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            return kernal.context().state().publicApiActiveState(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3MzQ2OA=="}, "originalCommit": {"oid": "993a9efe7635f6bd7cfb230b45f51935e0f6c319"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDc0NjQ5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNToyMzoyNVrOF3hPIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNToyNToyM1rOF3hU3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2MDU0NQ==", "bodyText": "Lets use kernal.rebalanceEnabled(rebalanceEnabled);", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393760545", "createdAt": "2020-03-17T15:23:25Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        return kernal.active();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void active(boolean active) {\n+        clusterState(active ? ACTIVE.toString() : INACTIVE.toString(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCopyright() {\n+        return COPYRIGHT;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getStartTimestamp() {\n+        return kernal.startTimestamp();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getStartTimestampFormatted() {\n+        return kernal.startTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getUpTime() {\n+        return kernal.upTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesCount() {\n+        return kernal.longJVMPausesCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesTotalDuration() {\n+        return kernal.longJVMPausesTotalDuration();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Map<Long, Long> getLongJVMPauseLastEvents() {\n+        return kernal.longJVMPauseLastEvents();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getUpTimeFormatted() {\n+        return kernal.upTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFullVersion() {\n+        return kernal.fullVersion();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCheckpointSpiFormatted() {\n+        return kernal.checkpointSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCurrentCoordinatorFormatted() {\n+        return kernal.currentCoordinatorFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isNodeInBaseline() {\n+       return kernal.nodeInBaseline();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCommunicationSpiFormatted() {\n+        return kernal.communicationSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDeploymentSpiFormatted() {\n+        return kernal.deploymentSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDiscoverySpiFormatted() {\n+        return kernal.discoverySpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getEventStorageSpiFormatted() {\n+        return kernal.eventStorageSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCollisionSpiFormatted() {\n+        return kernal.collisionSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFailoverSpiFormatted() {\n+        return kernal.failoverSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getLoadBalancingSpiFormatted() {\n+        return kernal.loadBalancingSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsInformation() {\n+        return kernal.osInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getJdkInformation() {\n+        return kernal.jdkInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsUser() {\n+        return kernal.osUser();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void printLastErrors() {\n+        kernal.printLastErrors();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getVmName() {\n+        return kernal.vmName();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getInstanceName() {\n+        return kernal.name();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getExecutorServiceFormatted() {\n+        return kernal.executorServiceFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getIgniteHome() {\n+        return kernal.igniteHome();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getGridLoggerFormatted() {\n+        return kernal.gridLoggerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getMBeanServerFormatted() {\n+        return kernal.mbeanServerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public UUID getLocalNodeId() {\n+        return kernal.getLocalNodeId();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getUserAttributesFormatted() {\n+        return kernal.userAttributesFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isPeerClassLoadingEnabled() {\n+        return kernal.peerClassLoadingEnabled();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getLifecycleBeansFormatted() {\n+        return kernal.lifecycleBeansFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String clusterState() {\n+        return kernal.clusterState();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long lastClusterStateChangeTime() {\n+        return kernal.lastClusterStateChangeTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean removeCheckpoint(String key) {\n+        A.notNull(key, \"key\");\n+\n+        return kernal.removeCheckpoint(key);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNode(String nodeId) {\n+        A.notNull(nodeId, \"nodeId\");\n+\n+        return kernal.cluster().pingNode(UUID.fromString(nodeId));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void undeployTaskFromGrid(String taskName) throws JMException {\n+        A.notNull(taskName, \"taskName\");\n+\n+        try {\n+            kernal.compute().undeployTask(taskName);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String executeTask(String taskName, String arg) throws JMException {\n+        try {\n+            return kernal.compute().execute(taskName, arg);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNodeByAddress(String host) {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            for (ClusterNode n : kernal.cluster().nodes())\n+                if (n.addresses().contains(host))\n+                    return kernal.context().discovery().pingNode(n.id());\n+\n+            return false;\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void dumpDebugInfo() {\n+        kernal.dumpDebugInfo();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void runIoTest(\n+        long warmup,\n+        long duration,\n+        int threads,\n+        long maxLatency,\n+        int rangesCnt,\n+        int payLoadSize,\n+        boolean procFromNioThread\n+    ) {\n+        kernal.context().io().runIoTest(warmup, duration, threads, maxLatency, rangesCnt, payLoadSize,\n+            procFromNioThread, new ArrayList(kernal.context().cluster().get().forServers().forRemotes().nodes()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearNodeLocalMap() {\n+        kernal.context().cluster().get().clearNodeMap();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state) {\n+        clusterState(state, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state, boolean forceDeactivation) {\n+        ClusterState newState = ClusterState.valueOf(state);\n+\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            kernal.context().state().changeGlobalState(newState, forceDeactivation, kernal.context().cluster().get()\n+                .forServers().nodes(), false).get();\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isRebalanceEnabled() {\n+        return kernal.isRebalanceEnabled();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void rebalanceEnabled(boolean rebalanceEnabled) {\n+        kernal.context().cache().context().rebalanceEnabled(rebalanceEnabled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79eb5be3c30e70a5391a55c2ae665e371ca94659"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2MjAxMg==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7531#discussion_r393762012", "createdAt": "2020-03-17T15:25:23Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/IgniteMXBeanImpl.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package org.apache.ignite.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import javax.management.JMException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.mxbean.IgniteMXBean;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.IgniteVersionUtils.COPYRIGHT;\n+\n+/** Implementation of Ignite mxBean. */\n+public class IgniteMXBeanImpl implements IgniteMXBean {\n+    /** Ignite core to work with. */\n+    private final IgniteKernal kernal;\n+\n+    /**\n+     * @param kernal Ignite kernel to work with.\n+     */\n+    public IgniteMXBeanImpl(IgniteKernal kernal) {\n+        this.kernal = kernal;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean active() {\n+        return kernal.active();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void active(boolean active) {\n+        clusterState(active ? ACTIVE.toString() : INACTIVE.toString(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCopyright() {\n+        return COPYRIGHT;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getStartTimestamp() {\n+        return kernal.startTimestamp();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getStartTimestampFormatted() {\n+        return kernal.startTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getUpTime() {\n+        return kernal.upTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesCount() {\n+        return kernal.longJVMPausesCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long getLongJVMPausesTotalDuration() {\n+        return kernal.longJVMPausesTotalDuration();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public Map<Long, Long> getLongJVMPauseLastEvents() {\n+        return kernal.longJVMPauseLastEvents();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getUpTimeFormatted() {\n+        return kernal.upTimeFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFullVersion() {\n+        return kernal.fullVersion();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCheckpointSpiFormatted() {\n+        return kernal.checkpointSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCurrentCoordinatorFormatted() {\n+        return kernal.currentCoordinatorFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isNodeInBaseline() {\n+       return kernal.nodeInBaseline();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCommunicationSpiFormatted() {\n+        return kernal.communicationSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDeploymentSpiFormatted() {\n+        return kernal.deploymentSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getDiscoverySpiFormatted() {\n+        return kernal.discoverySpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getEventStorageSpiFormatted() {\n+        return kernal.eventStorageSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getCollisionSpiFormatted() {\n+        return kernal.collisionSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getFailoverSpiFormatted() {\n+        return kernal.failoverSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getLoadBalancingSpiFormatted() {\n+        return kernal.loadBalancingSpiFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsInformation() {\n+        return kernal.osInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getJdkInformation() {\n+        return kernal.jdkInformation();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getOsUser() {\n+        return kernal.osUser();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void printLastErrors() {\n+        kernal.printLastErrors();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getVmName() {\n+        return kernal.vmName();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getInstanceName() {\n+        return kernal.name();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getExecutorServiceFormatted() {\n+        return kernal.executorServiceFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getIgniteHome() {\n+        return kernal.igniteHome();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getGridLoggerFormatted() {\n+        return kernal.gridLoggerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String getMBeanServerFormatted() {\n+        return kernal.mbeanServerFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public UUID getLocalNodeId() {\n+        return kernal.getLocalNodeId();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getUserAttributesFormatted() {\n+        return kernal.userAttributesFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isPeerClassLoadingEnabled() {\n+        return kernal.peerClassLoadingEnabled();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public List<String> getLifecycleBeansFormatted() {\n+        return kernal.lifecycleBeansFormatted();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String clusterState() {\n+        return kernal.clusterState();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public long lastClusterStateChangeTime() {\n+        return kernal.lastClusterStateChangeTime();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean removeCheckpoint(String key) {\n+        A.notNull(key, \"key\");\n+\n+        return kernal.removeCheckpoint(key);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNode(String nodeId) {\n+        A.notNull(nodeId, \"nodeId\");\n+\n+        return kernal.cluster().pingNode(UUID.fromString(nodeId));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void undeployTaskFromGrid(String taskName) throws JMException {\n+        A.notNull(taskName, \"taskName\");\n+\n+        try {\n+            kernal.compute().undeployTask(taskName);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String executeTask(String taskName, String arg) throws JMException {\n+        try {\n+            return kernal.compute().execute(taskName, arg);\n+        }\n+        catch (IgniteException e) {\n+            throw U.jmException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean pingNodeByAddress(String host) {\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            for (ClusterNode n : kernal.cluster().nodes())\n+                if (n.addresses().contains(host))\n+                    return kernal.context().discovery().pingNode(n.id());\n+\n+            return false;\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void dumpDebugInfo() {\n+        kernal.dumpDebugInfo();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void runIoTest(\n+        long warmup,\n+        long duration,\n+        int threads,\n+        long maxLatency,\n+        int rangesCnt,\n+        int payLoadSize,\n+        boolean procFromNioThread\n+    ) {\n+        kernal.context().io().runIoTest(warmup, duration, threads, maxLatency, rangesCnt, payLoadSize,\n+            procFromNioThread, new ArrayList(kernal.context().cluster().get().forServers().forRemotes().nodes()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearNodeLocalMap() {\n+        kernal.context().cluster().get().clearNodeMap();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state) {\n+        clusterState(state, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clusterState(String state, boolean forceDeactivation) {\n+        ClusterState newState = ClusterState.valueOf(state);\n+\n+        kernal.context().gateway().readLock();\n+\n+        try {\n+            kernal.context().state().changeGlobalState(newState, forceDeactivation, kernal.context().cluster().get()\n+                .forServers().nodes(), false).get();\n+        }\n+        catch (IgniteCheckedException e) {\n+            throw U.convertException(e);\n+        }\n+        finally {\n+            kernal.context().gateway().readUnlock();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean isRebalanceEnabled() {\n+        return kernal.isRebalanceEnabled();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void rebalanceEnabled(boolean rebalanceEnabled) {\n+        kernal.context().cache().context().rebalanceEnabled(rebalanceEnabled);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2MDU0NQ=="}, "originalCommit": {"oid": "79eb5be3c30e70a5391a55c2ae665e371ca94659"}, "originalPosition": 326}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2531, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}