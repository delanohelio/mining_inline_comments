{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1ODg2MjQ2", "number": 7693, "title": "IGNITE-12666 Provide cluster performance profiling tool", "bodyText": "Cluster profiling based on logging performance statistics to files.\nPerformanceStatisticsMBean is used for management.\nThe Ignite log some additional internal statistics to profiling files (FilePerformanceStatisticsWriter). The format is like WAL logging.\nOne disk-writer thread and off-heap memory buffer will be used to minimize affect on performance. Maximum file size and buffer size can be configured with system properties.\nThe tool to build the report placed in ignite-extensions. See apache/ignite-extensions#16\nThe report contains statistics:\n\ncache operations: get|getAll|put|putAll|remove|removeAll|getAndPut|getAndRemove|lock|invoke|invokeAll\ntransaction commit, rollback; histogram of transaction durations\nSQL, SCAN queries, top of slowest queries\nTasks and jobs. Top of slowest tasks\ncluster info", "createdAt": "2020-04-20T07:45:18Z", "url": "https://github.com/apache/ignite/pull/7693", "merged": true, "mergeCommit": {"oid": "c5c007f73359c1b3264e0e627afa9af9144017f4"}, "closed": true, "closedAt": "2020-12-15T17:49:42Z", "author": {"login": "NSAmelchev"}, "timelineItems": {"totalCount": 257, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1HOgfgFqTQ0ODc4Mzk5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmeFBuAFqTU1MjcxNTYyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NzgzOTky", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448783992", "createdAt": "2020-07-15T09:29:14Z", "commit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOToyOToxNFrOGx2AAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOToyOToxNFrOGx2AAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxODE0Nw==", "bodyText": "Let's make this class internal in the AbstractPerformanceStatisticsTest.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454918147", "createdAt": "2020-07-15T09:29:14Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/TestHandler.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Test performance statistics handler.\n+ */\n+public class TestHandler implements PerformanceStatisticsHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4Nzg0MjA5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448784209", "createdAt": "2020-07-15T09:29:32Z", "commit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOToyOTozMlrOGx2Aqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOToyOTozMlrOGx2Aqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxODMxNA==", "bodyText": "Typo: javadoc required.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454918314", "createdAt": "2020-07-15T09:29:32Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/TestHandler.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Test performance statistics handler.\n+ */\n+public class TestHandler implements PerformanceStatisticsHandler {\n+    @Override public void cacheOperation(UUID nodeId, OperationType type, int cacheId, long startTime, long duration) {\n+        // No-op.\n+    }\n+\n+    @Override public void transaction(UUID nodeId, GridIntList cacheIds, long startTime, long duration,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4Nzg2NzIx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448786721", "createdAt": "2020-07-15T09:32:21Z", "commit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTozMjoyMVrOGx2Hkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTozMjoyMVrOGx2Hkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyMDA4Mw==", "bodyText": "We should clear persistence value in the finally block.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454920083", "createdAt": "2020-07-15T09:32:21Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/TopologyChangesTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.junit.Test;\n+\n+/**\n+ * Tests topology changes during collecting performance statistics.\n+ */\n+public class TopologyChangesTest extends AbstractPerformanceStatisticsTest {\n+    /** */\n+    private boolean persistence;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        cfg.setDataStorageConfiguration(\n+            new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(\n+                    new DataRegionConfiguration().setPersistenceEnabled(persistence)\n+                )\n+        );\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** @throws Exception If failed. */\n+    @Test\n+    public void testNodeJoin() throws Exception {\n+        startGrid(0);\n+\n+        startCollectStatistics();\n+\n+        startGrid(1);\n+\n+        waitForStatisticsEnabled(true);\n+    }\n+\n+    /** @throws Exception If failed. */\n+    @Test\n+    public void testClusterRestartWithPersistence() throws Exception {\n+        persistence = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NzkzMzA0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448793304", "createdAt": "2020-07-15T09:41:14Z", "commit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MToxNFrOGx2bnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MToxNFrOGx2bnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTIxMg==", "bodyText": "Typo: formatting.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454925212", "createdAt": "2020-07-15T09:41:14Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsSelfTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.function.Consumer;\n+import javax.cache.processor.EntryProcessor;\n+import javax.cache.processor.EntryProcessorException;\n+import javax.cache.processor.MutableEntry;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheEntryProcessor;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.testframework.ListeningTestLogger;\n+import org.apache.ignite.testframework.junits.GridAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_AND_PUT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_AND_REMOVE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_INVOKE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_INVOKE_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_LOCK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_PUT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_PUT_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_REMOVE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_REMOVE_ALL;\n+\n+/**\n+ * Tests performance statistics.\n+ */\n+@SuppressWarnings({\"LockAcquiredButNotSafelyReleased\"})\n+public class PerformanceStatisticsSelfTest extends AbstractPerformanceStatisticsTest {\n+    /** Test entry processor. */\n+    private static final EntryProcessor<Object, Object, Object> ENTRY_PROC =\n+        new EntryProcessor<Object, Object, Object>() {\n+        @Override public Object process(MutableEntry<Object, Object> entry, Object... arguments)\n+            throws EntryProcessorException {\n+            return null;\n+        }\n+    };\n+\n+    /** Test cache entry processor. */\n+    private static final CacheEntryProcessor<Object, Object, Object> CACHE_ENTRY_PROC =\n+        new CacheEntryProcessor<Object, Object, Object>() {\n+        @Override public Object process(MutableEntry<Object, Object> entry, Object... arguments)\n+            throws EntryProcessorException {\n+            return null;\n+        }\n+    };\n+\n+    /** Cache entry count. */\n+    private static final int ENTRY_COUNT = 100;\n+\n+    /** Ignite. */\n+    private static IgniteEx ignite;\n+\n+    /** Test cache. */\n+    private static IgniteCache<Object, Object> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        cfg.setCacheConfiguration(defaultCacheConfiguration());\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        log = new ListeningTestLogger(GridAbstractTest.log);\n+\n+        ignite = startGrid(0);\n+\n+        ignite.cluster().state(ClusterState.ACTIVE);\n+\n+        cache = ignite.cache(DEFAULT_CACHE_NAME);\n+\n+        for (int i = 0; i < ENTRY_COUNT; i++)\n+            cache.put(i, i);\n+    }\n+\n+    /** @throws Exception If failed. */\n+    @Test\n+    public void testCompute() throws Exception {\n+        String testTaskName = \"testTask\";\n+        int executions = 5;\n+\n+        startCollectStatistics();\n+\n+        IgniteRunnable task = new IgniteRunnable() {\n+            @Override public void run() {\n+                // No-op.\n+            }\n+        };\n+\n+        for (int i = 0; i < executions; i++)\n+            ignite.compute().withName(testTaskName).run(task);\n+\n+        HashMap<IgniteUuid, Integer> sessions = new HashMap<>();\n+        AtomicInteger tasks = new AtomicInteger();\n+        AtomicInteger jobs = new AtomicInteger();\n+\n+        stopCollectStatisticsAndRead(new TestHandler() {\n+            @Override public void task(UUID nodeId, IgniteUuid sesId, String taskName, long startTime, long duration,\n+                int affPartId) {\n+                sessions.compute(sesId, (uuid, val) -> val == null ? 1 : ++val);\n+\n+                tasks.incrementAndGet();\n+\n+                assertEquals(ignite.context().localNodeId(), nodeId);\n+                assertEquals(testTaskName, taskName);\n+                assertTrue(startTime > 0);\n+                assertTrue(duration >= 0);\n+                assertEquals(-1, affPartId);\n+            }\n+\n+            @Override public void job(UUID nodeId, IgniteUuid sesId, long queuedTime, long startTime, long duration,\n+            boolean timedOut) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e26fb7343649e764f433f528e93683ac783a8f3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/5e26fb7343649e764f433f528e93683ac783a8f3", "committedDate": "2020-07-15T09:42:51Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4Nzk3NTIw", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448797520", "createdAt": "2020-07-15T09:46:37Z", "commit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0NjozN1rOGx2oLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0NjozN1rOGx2oLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyODQyOQ==", "bodyText": "val should be renamed to cnt here and below.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454928429", "createdAt": "2020-07-15T09:46:37Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsSelfTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.function.Consumer;\n+import javax.cache.processor.EntryProcessor;\n+import javax.cache.processor.EntryProcessorException;\n+import javax.cache.processor.MutableEntry;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheEntryProcessor;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.testframework.ListeningTestLogger;\n+import org.apache.ignite.testframework.junits.GridAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_AND_PUT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_AND_REMOVE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_INVOKE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_INVOKE_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_LOCK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_PUT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_PUT_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_REMOVE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_REMOVE_ALL;\n+\n+/**\n+ * Tests performance statistics.\n+ */\n+@SuppressWarnings({\"LockAcquiredButNotSafelyReleased\"})\n+public class PerformanceStatisticsSelfTest extends AbstractPerformanceStatisticsTest {\n+    /** Test entry processor. */\n+    private static final EntryProcessor<Object, Object, Object> ENTRY_PROC =\n+        new EntryProcessor<Object, Object, Object>() {\n+        @Override public Object process(MutableEntry<Object, Object> entry, Object... arguments)\n+            throws EntryProcessorException {\n+            return null;\n+        }\n+    };\n+\n+    /** Test cache entry processor. */\n+    private static final CacheEntryProcessor<Object, Object, Object> CACHE_ENTRY_PROC =\n+        new CacheEntryProcessor<Object, Object, Object>() {\n+        @Override public Object process(MutableEntry<Object, Object> entry, Object... arguments)\n+            throws EntryProcessorException {\n+            return null;\n+        }\n+    };\n+\n+    /** Cache entry count. */\n+    private static final int ENTRY_COUNT = 100;\n+\n+    /** Ignite. */\n+    private static IgniteEx ignite;\n+\n+    /** Test cache. */\n+    private static IgniteCache<Object, Object> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        cfg.setCacheConfiguration(defaultCacheConfiguration());\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        log = new ListeningTestLogger(GridAbstractTest.log);\n+\n+        ignite = startGrid(0);\n+\n+        ignite.cluster().state(ClusterState.ACTIVE);\n+\n+        cache = ignite.cache(DEFAULT_CACHE_NAME);\n+\n+        for (int i = 0; i < ENTRY_COUNT; i++)\n+            cache.put(i, i);\n+    }\n+\n+    /** @throws Exception If failed. */\n+    @Test\n+    public void testCompute() throws Exception {\n+        String testTaskName = \"testTask\";\n+        int executions = 5;\n+\n+        startCollectStatistics();\n+\n+        IgniteRunnable task = new IgniteRunnable() {\n+            @Override public void run() {\n+                // No-op.\n+            }\n+        };\n+\n+        for (int i = 0; i < executions; i++)\n+            ignite.compute().withName(testTaskName).run(task);\n+\n+        HashMap<IgniteUuid, Integer> sessions = new HashMap<>();\n+        AtomicInteger tasks = new AtomicInteger();\n+        AtomicInteger jobs = new AtomicInteger();\n+\n+        stopCollectStatisticsAndRead(new TestHandler() {\n+            @Override public void task(UUID nodeId, IgniteUuid sesId, String taskName, long startTime, long duration,\n+                int affPartId) {\n+                sessions.compute(sesId, (uuid, val) -> val == null ? 1 : ++val);\n+\n+                tasks.incrementAndGet();\n+\n+                assertEquals(ignite.context().localNodeId(), nodeId);\n+                assertEquals(testTaskName, taskName);\n+                assertTrue(startTime > 0);\n+                assertTrue(duration >= 0);\n+                assertEquals(-1, affPartId);\n+            }\n+\n+            @Override public void job(UUID nodeId, IgniteUuid sesId, long queuedTime, long startTime, long duration,\n+            boolean timedOut) {\n+                sessions.compute(sesId, (uuid, val) -> val == null ? 1 : ++val);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3"}, "originalPosition": 147}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b886d5823f31a24bfb1b49e07ab45649c745b40", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/4b886d5823f31a24bfb1b49e07ab45649c745b40", "committedDate": "2020-07-15T10:17:42Z", "message": "Var renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ad9b68b0fc5937f94df34082cf4dd82863c736e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/2ad9b68b0fc5937f94df34082cf4dd82863c736e", "committedDate": "2020-07-15T11:15:02Z", "message": "Parameterized test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c6643bb1d41f11484a1581b8b73b9e16632c627", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/2c6643bb1d41f11484a1581b8b73b9e16632c627", "committedDate": "2020-07-15T11:17:48Z", "message": "Remove unnecessary cleanup directory for non-persist tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "644dc2845b2283c26a265c0357b0f9f361ce4cbd", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/644dc2845b2283c26a265c0357b0f9f361ce4cbd", "committedDate": "2020-07-15T11:23:04Z", "message": "Revert unnecessary changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2012653e3c1a2adebdd7103f21d2663ba7d5677b", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/2012653e3c1a2adebdd7103f21d2663ba7d5677b", "committedDate": "2020-07-15T11:26:15Z", "message": "Revert unnecessary changes 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abd7678b1d75421a7cff0ed1015757b0e6c32790", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/abd7678b1d75421a7cff0ed1015757b0e6c32790", "committedDate": "2020-07-15T11:29:01Z", "message": "Inlude system transactions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NjgwNTkz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-449680593", "createdAt": "2020-07-16T09:32:55Z", "commit": {"oid": "abd7678b1d75421a7cff0ed1015757b0e6c32790"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOTozMjo1NVrOGyi9HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOTozMjo1NVrOGyi9HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY1NDY4NQ==", "bodyText": "We should add tests with pageSize less than the entire result set to ensure that with the several pages we track all query results correctly.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r455654685", "createdAt": "2020-07-16T09:32:55Z", "author": {"login": "nizhikov"}, "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsQueryTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.query.Query;\n+import org.apache.ignite.cache.query.ScanQuery;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cluster.ClusterState.ACTIVE;\n+import static org.apache.ignite.cluster.ClusterState.INACTIVE;\n+import static org.apache.ignite.internal.processors.cache.query.GridCacheQueryType.SCAN;\n+import static org.apache.ignite.internal.processors.cache.query.GridCacheQueryType.SQL_FIELDS;\n+\n+/** Tests query performance statistics. */\n+public class PerformanceStatisticsQueryTest extends AbstractPerformanceStatisticsTest {\n+    /** Cache entry count. */\n+    private static final int ENTRY_COUNT = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd7678b1d75421a7cff0ed1015757b0e6c32790"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039199daf3005bb1b801096e304a5cda8d307dfb", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/039199daf3005bb1b801096e304a5cda8d307dfb", "committedDate": "2020-07-16T10:18:50Z", "message": "Add ddl dml query test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "750fa4ad1fb734dade599ef308e2a3a54bf15db9", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/750fa4ad1fb734dade599ef308e2a3a54bf15db9", "committedDate": "2020-07-20T11:26:07Z", "message": "Fix query reads multiple pages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5284a7a5b8c05e7a71a985b5c9d2f5ad3f686b13", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/5284a7a5b8c05e7a71a985b5c9d2f5ad3f686b13", "committedDate": "2020-07-20T22:02:32Z", "message": "Fix reads ids for DML sql fields queries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad5539e33dac5274d0bfe21808b0df3979098145", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/ad5539e33dac5274d0bfe21808b0df3979098145", "committedDate": "2020-07-20T22:36:24Z", "message": "Handle only sql type queries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd11d9c78114a8db40e9a80be7d1caa3014ea93c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/cd11d9c78114a8db40e9a80be7d1caa3014ea93c", "committedDate": "2020-07-21T08:13:07Z", "message": "Remove unnecessary reads holder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d4482e7006c7c5e5b467e7580b4304be3cfe73e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/3d4482e7006c7c5e5b467e7580b4304be3cfe73e", "committedDate": "2020-07-21T14:23:28Z", "message": "+ join query tests, additional reads checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf2c4bcb1fba572f0c765def10d7b628219b3e4e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/cf2c4bcb1fba572f0c765def10d7b628219b3e4e", "committedDate": "2020-07-23T13:39:30Z", "message": "fix codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "660203eb54f6ad58c949ada8f5950dfce41e3e69", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/660203eb54f6ad58c949ada8f5950dfce41e3e69", "committedDate": "2020-07-23T13:40:24Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e90d99909e9ae29ac7d2dc1607fd6a3079ccad9", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/4e90d99909e9ae29ac7d2dc1607fd6a3079ccad9", "committedDate": "2020-08-10T08:14:33Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/IgniteTxAdapter.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17446c4e7423aae2c63380e6b220eaade09e5ff4", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/17446c4e7423aae2c63380e6b220eaade09e5ff4", "committedDate": "2020-08-19T13:46:19Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ddcd4c7ac3d96975960ed605b6809731dec84bc", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/6ddcd4c7ac3d96975960ed605b6809731dec84bc", "committedDate": "2020-08-19T13:47:52Z", "message": "Fix feature ID."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07480f1cc2668a794351ae9ab468a9ff4c358b82", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/07480f1cc2668a794351ae9ab468a9ff4c358b82", "committedDate": "2020-08-21T14:43:47Z", "message": "code review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167b3b680d45e0b11626675e75a242be56eee69b", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/167b3b680d45e0b11626675e75a242be56eee69b", "committedDate": "2020-09-09T15:14:04Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3e45a1e89d660006d424917bced69e00ec93c5c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e3e45a1e89d660006d424917bced69e00ec93c5c", "committedDate": "2020-09-09T21:48:17Z", "message": "Thin client tests. Gather local iterator stats. Minor fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "176d8b57526304183ef06537d05c732a6bdbbab2", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/176d8b57526304183ef06537d05c732a6bdbbab2", "committedDate": "2020-09-10T08:50:28Z", "message": "fix modifiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a62a9b37f05c80ca3192287a29f3d429b7564a0c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/a62a9b37f05c80ca3192287a29f3d429b7564a0c", "committedDate": "2020-09-10T10:35:13Z", "message": "Fix javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ca93bbbf29a6e7cb2e70507a9a6bd387cd86285", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0ca93bbbf29a6e7cb2e70507a9a6bd387cd86285", "committedDate": "2020-09-10T11:48:38Z", "message": "Fix try finally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bae9b099b021f0a83119fbedba5a394a8f4ea0d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/3bae9b099b021f0a83119fbedba5a394a8f4ea0d", "committedDate": "2020-09-11T08:30:31Z", "message": "Add load from client node to tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ff3aca00b06c356dcf2b465b01a62982db87982", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/4ff3aca00b06c356dcf2b465b01a62982db87982", "committedDate": "2020-09-11T10:15:14Z", "message": "Remove unnecessary changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NDc3MDEz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-487477013", "createdAt": "2020-09-14T07:20:07Z", "commit": {"oid": "4ff3aca00b06c356dcf2b465b01a62982db87982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzoyMDowN1rOHRG28g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzoyMDowN1rOHRG28g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwMDIxMA==", "bodyText": "LoadNode -> ClientType", "url": "https://github.com/apache/ignite/pull/7693#discussion_r487700210", "createdAt": "2020-09-14T07:20:07Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/AbstractPerformanceStatisticsTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.lang.management.ThreadInfo;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.mxbean.PerformanceStatisticsMBean;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatisticsWriter.PERF_STAT_DIR;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatisticsWriter.WRITER_THREAD_NAME;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ * Ignite performance statistics abstract test.\n+ */\n+public abstract class AbstractPerformanceStatisticsTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 30_000;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        super.beforeTestsStarted();\n+\n+        U.resolveWorkDirectory(U.defaultWorkDirectory(), PERF_STAT_DIR, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTestsStopped() throws Exception {\n+        super.afterTestsStopped();\n+\n+        stopAllGrids();\n+\n+        U.resolveWorkDirectory(U.defaultWorkDirectory(), PERF_STAT_DIR, true);\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    protected static void startCollectStatistics() throws Exception {\n+        List<Ignite> grids = G.allGrids();\n+\n+        assertFalse(grids.isEmpty());\n+\n+        statisticsMBean(grids.get(0).name()).start();\n+\n+        waitForStatisticsEnabled(true);\n+    }\n+\n+    /** Stops and reads collecting performance statistics. */\n+    protected static void stopCollectStatisticsAndRead(TestHandler... handlers) throws Exception {\n+        List<Ignite> grids = G.allGrids();\n+\n+        assertFalse(grids.isEmpty());\n+\n+        statisticsMBean(grids.get(0).name()).stop();\n+\n+        waitForStatisticsEnabled(false);\n+\n+        File dir = U.resolveWorkDirectory(U.defaultWorkDirectory(), PERF_STAT_DIR, false);\n+\n+        new FilePerformanceStatisticsReader(handlers).read(Collections.singletonList(dir));\n+    }\n+\n+    /** Wait for statistics started/stopped in the cluster. */\n+    protected static void waitForStatisticsEnabled(boolean performanceStatsEnabled) throws Exception {\n+        assertTrue(waitForCondition(() -> {\n+            List<Ignite> grids = G.allGrids();\n+\n+            for (Ignite grid : grids)\n+                if (performanceStatsEnabled != statisticsMBean(grid.name()).started())\n+                    return false;\n+\n+            // Make sure that writer flushed data and stopped.\n+            if (!performanceStatsEnabled) {\n+                for (long id : U.getThreadMx().getAllThreadIds()) {\n+                    ThreadInfo info = U.getThreadMx().getThreadInfo(id);\n+\n+                    if (info != null && info.getThreadState() != Thread.State.TERMINATED &&\n+                        info.getThreadName().startsWith(WRITER_THREAD_NAME))\n+                        return false;\n+                }\n+            }\n+\n+            return true;\n+        }, TIMEOUT));\n+    }\n+\n+    /**\n+     * @param igniteInstanceName Ignite instance name.\n+     * @return Ignite performance statistics MBean.\n+     */\n+    protected static PerformanceStatisticsMBean statisticsMBean(String igniteInstanceName) {\n+        return getMxBean(igniteInstanceName, \"PerformanceStatistics\", PerformanceStatisticsMBeanImpl.class,\n+            PerformanceStatisticsMBean.class);\n+    }\n+\n+    /** Test performance statistics handler. */\n+    public class TestHandler implements PerformanceStatisticsHandler {\n+        /** {@inheritDoc} */\n+        @Override public void cacheOperation(UUID nodeId, OperationType type, int cacheId, long startTime, long duration) {\n+            // No-op.\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void transaction(UUID nodeId, GridIntList cacheIds, long startTime, long duration,\n+            boolean commited) {\n+            // No-op.\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void query(UUID nodeId, GridCacheQueryType type, String text, long id, long startTime,\n+            long duration, boolean success) {\n+            // No-op.\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void queryReads(UUID nodeId, GridCacheQueryType type, UUID queryNodeId, long id,\n+            long logicalReads, long physicalReads) {\n+            // No-op.\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void task(UUID nodeId, IgniteUuid sesId, String taskName, long startTime, long duration,\n+            int affPartId) {\n+            // No-op.\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void job(UUID nodeId, IgniteUuid sesId, long queuedTime, long startTime, long duration,\n+            boolean timedOut) {\n+            // No-op.\n+        }\n+    }\n+\n+    /** Node to run load from. */\n+    enum LoadNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff3aca00b06c356dcf2b465b01a62982db87982"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NDc4NjY0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-487478664", "createdAt": "2020-09-14T07:22:42Z", "commit": {"oid": "4ff3aca00b06c356dcf2b465b01a62982db87982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzoyMjo0M1rOHRG8EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzoyMjo0M1rOHRG8EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwMTUyMQ==", "bodyText": "Let's store System.currentTimeMillis before running jobs and here check.\nassertTrue(startTime >= jobsStartTime);", "url": "https://github.com/apache/ignite/pull/7693#discussion_r487701521", "createdAt": "2020-09-14T07:22:43Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsSelfTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.function.Consumer;\n+import javax.cache.processor.EntryProcessor;\n+import javax.cache.processor.EntryProcessorException;\n+import javax.cache.processor.MutableEntry;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheEntryProcessor;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.transactions.Transaction;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.AbstractPerformanceStatisticsTest.LoadNode.CLIENT;\n+import static org.apache.ignite.internal.processors.performancestatistics.AbstractPerformanceStatisticsTest.LoadNode.SERVER;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_AND_PUT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_GET_AND_REMOVE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_INVOKE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_INVOKE_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_LOCK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_PUT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_PUT_ALL;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_REMOVE;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.CACHE_REMOVE_ALL;\n+\n+/**\n+ * Tests performance statistics.\n+ */\n+@RunWith(Parameterized.class)\n+@SuppressWarnings({\"LockAcquiredButNotSafelyReleased\"})\n+public class PerformanceStatisticsSelfTest extends AbstractPerformanceStatisticsTest {\n+    /** Test entry processor. */\n+    private static final EntryProcessor<Object, Object, Object> ENTRY_PROC =\n+        new EntryProcessor<Object, Object, Object>() {\n+        @Override public Object process(MutableEntry<Object, Object> entry, Object... arguments)\n+            throws EntryProcessorException {\n+            return null;\n+        }\n+    };\n+\n+    /** Test cache entry processor. */\n+    private static final CacheEntryProcessor<Object, Object, Object> CACHE_ENTRY_PROC =\n+        new CacheEntryProcessor<Object, Object, Object>() {\n+        @Override public Object process(MutableEntry<Object, Object> entry, Object... arguments)\n+            throws EntryProcessorException {\n+            return null;\n+        }\n+    };\n+\n+    /** Cache entry count. */\n+    private static final int ENTRY_COUNT = 100;\n+\n+    /** Load node to run operations from. */\n+    @Parameterized.Parameter\n+    public LoadNode loadNode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"loadNode={0}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {{SERVER}, {CLIENT}});\n+    }\n+\n+    /** Ignite. */\n+    private static IgniteEx srv;\n+\n+    /** Ignite node to run load from. */\n+    private static IgniteEx node;\n+\n+    /** Test cache. */\n+    private static IgniteCache<Object, Object> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        cfg.setCacheConfiguration(defaultCacheConfiguration());\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        srv = startGrid(0);\n+\n+        IgniteEx client = startClientGrid(1);\n+\n+        node = loadNode == SERVER ? srv : client;\n+\n+        cache = node.cache(DEFAULT_CACHE_NAME);\n+\n+        for (int i = 0; i < ENTRY_COUNT; i++)\n+            cache.put(i, i);\n+    }\n+\n+    /** @throws Exception If failed. */\n+    @Test\n+    public void testCompute() throws Exception {\n+        String testTaskName = \"testTask\";\n+        int executions = 5;\n+\n+        startCollectStatistics();\n+\n+        IgniteRunnable task = new IgniteRunnable() {\n+            @Override public void run() {\n+                // No-op.\n+            }\n+        };\n+\n+        for (int i = 0; i < executions; i++)\n+            node.compute().withName(testTaskName).run(task);\n+\n+        HashMap<IgniteUuid, Integer> sessions = new HashMap<>();\n+        AtomicInteger tasks = new AtomicInteger();\n+        AtomicInteger jobs = new AtomicInteger();\n+\n+        stopCollectStatisticsAndRead(new TestHandler() {\n+            @Override public void task(UUID nodeId, IgniteUuid sesId, String taskName, long startTime, long duration,\n+                int affPartId) {\n+                sessions.compute(sesId, (uuid, cnt) -> cnt == null ? 1 : ++cnt);\n+\n+                tasks.incrementAndGet();\n+\n+                assertEquals(node.context().localNodeId(), nodeId);\n+                assertEquals(testTaskName, taskName);\n+                assertTrue(startTime > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ff3aca00b06c356dcf2b465b01a62982db87982"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b80b399b985f4a4e655d6ac0462c44a453b62ca1", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/b80b399b985f4a4e655d6ac0462c44a453b62ca1", "committedDate": "2020-09-14T08:51:34Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd4e55c57dacf0a2d8a9244e40eda304d11b3a49", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/dd4e55c57dacf0a2d8a9244e40eda304d11b3a49", "committedDate": "2020-09-14T09:50:47Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57539ab667d2ec6a61ee53dbd4c402f537008c17", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/57539ab667d2ec6a61ee53dbd4c402f537008c17", "committedDate": "2020-09-14T10:10:47Z", "message": "Warning on close"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NjI1NTE1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-487625515", "createdAt": "2020-09-14T10:34:31Z", "commit": {"oid": "57539ab667d2ec6a61ee53dbd4c402f537008c17"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd4cf33c29dec47de59556564830300e413d96df", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/dd4cf33c29dec47de59556564830300e413d96df", "committedDate": "2020-09-14T10:34:42Z", "message": "Fix CacheLockImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09de1eb618c998f5d6e0779c1c9d7fe6054168e3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/09de1eb618c998f5d6e0779c1c9d7fe6054168e3", "committedDate": "2020-09-14T11:24:24Z", "message": "Fix codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51e539a5f356aaa1ec9967ba0506e23a63896381", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/51e539a5f356aaa1ec9967ba0506e23a63896381", "committedDate": "2020-09-14T11:35:52Z", "message": "Fix start time reset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42796ebbc2af15426a6f4d6a5618cf8502561c52", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/42796ebbc2af15426a6f4d6a5618cf8502561c52", "committedDate": "2020-09-18T14:53:09Z", "message": "Merge branch 'master' into ignite-12666"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfb216d092e7591d806980f9eb7a831ca22558af", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/dfb216d092e7591d806980f9eb7a831ca22558af", "committedDate": "2020-09-23T15:20:21Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/processors/query/GridRunningQueryInfo.java\n#\tmodules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/twostep/GridMapQueryExecutor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa47ca1afc89505e602e0d5bcfc345e550f8ae95", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/aa47ca1afc89505e602e0d5bcfc345e550f8ae95", "committedDate": "2020-09-24T07:45:21Z", "message": "Fix merge master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38ab4044b45bf49c8de9afe2316ecd3caf32512a", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/38ab4044b45bf49c8de9afe2316ecd3caf32512a", "committedDate": "2020-09-29T07:55:53Z", "message": "Performance statistics impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64867cf300324e1e952d72cc201b70d2fa25ee03", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/64867cf300324e1e952d72cc201b70d2fa25ee03", "committedDate": "2020-09-29T09:54:28Z", "message": "Fix merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b01c55755f9b2e074a189ae331df98a56bc26a16", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/b01c55755f9b2e074a189ae331df98a56bc26a16", "committedDate": "2020-10-19T12:07:48Z", "message": "Merge branch 'master' into ignite-12666-main\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/GridKernalContextImpl.java\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0de6276f256bf0043bd6f337fc6d8cb7f0c9e0c2", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0de6276f256bf0043bd6f337fc6d8cb7f0c9e0c2", "committedDate": "2020-11-10T08:53:48Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/GridKernalContextImpl.java\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c85df7099ab02eda78abc5da9d49db1660e0f3f6", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/c85df7099ab02eda78abc5da9d49db1660e0f3f6", "committedDate": "2020-11-10T09:00:36Z", "message": "Merge branch 'ignite-12666-main' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/IgniteSystemProperties.java\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java\n#\tmodules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsReader.java\n#\tmodules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java\n#\tmodules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/OperationType.java\n#\tmodules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/AbstractPerformanceStatisticsTest.java\n#\tmodules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsSelfTest.java\n#\tmodules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsThinClientTest.java\n#\tmodules/core/src/test/java/org/apache/ignite/testsuites/IgniteBasicWithPersistenceTestSuite.java\n#\tmodules/indexing/src/test/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsQueryTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a2ad06f0837fd884ba910160ba79cc78bae936d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0a2ad06f0837fd884ba910160ba79cc78bae936d", "committedDate": "2020-11-10T09:28:39Z", "message": "Fix codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0e017e39fe80cc0dba61ceaaacc43d8bb9fb402", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/b0e017e39fe80cc0dba61ceaaacc43d8bb9fb402", "committedDate": "2020-11-11T12:33:09Z", "message": "Rename processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "748e27dcd7b0588417ad4eb568afc40779463446", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/748e27dcd7b0588417ad4eb568afc40779463446", "committedDate": "2020-12-01T06:48:10Z", "message": "Merge branch 'master' into ignite-12666"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af9c68e4e08e88fc0113e3cdba49afc1894f0a78", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/af9c68e4e08e88fc0113e3cdba49afc1894f0a78", "committedDate": "2020-12-01T09:54:00Z", "message": "Add cache start op"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8fb955975e79bf2aa5dc48862f36c8e941e4c7b", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/a8fb955975e79bf2aa5dc48862f36c8e941e4c7b", "committedDate": "2020-12-03T22:36:37Z", "message": "Fix modifier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17260860a7e8bd439975a278897bf734757882b7", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/17260860a7e8bd439975a278897bf734757882b7", "committedDate": "2020-12-15T06:17:22Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/IgniteSystemProperties.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82616b2c0035b71067fddf4e3ea65e11b126b44f", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/82616b2c0035b71067fddf4e3ea65e11b126b44f", "committedDate": "2020-12-15T13:29:50Z", "message": "Make class static"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNzE1NjI2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-552715626", "createdAt": "2020-12-15T17:49:00Z", "commit": {"oid": "82616b2c0035b71067fddf4e3ea65e11b126b44f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74baca7b3cda982b52a02c0d434a5eefd3e0b2dc", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/74baca7b3cda982b52a02c0d434a5eefd3e0b2dc", "committedDate": "2020-07-02T16:34:07Z", "message": "Review fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee29b199c5bd37354c9e6dfc7be23f0265601830", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/ee29b199c5bd37354c9e6dfc7be23f0265601830", "committedDate": "2020-07-02T16:36:14Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/managers/IgniteMBeansManager.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/133d8e6ff4a28eb606bcb28af247d87bb1557c00", "committedDate": "2020-07-02T16:37:35Z", "message": "Fix merge."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTI0OTY2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441924966", "createdAt": "2020-07-02T18:17:58Z", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxNzo1OFrOGsYjqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxNzo1OFrOGsYjqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5Mjg3NA==", "bodyText": "Let's introduce the following method to generalize write:\npublic void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n        FileWriter writer = fileWriter;\n\n        if (writer == null)\n            return;\n\n        int size = sizeSupplier.apply();\n        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(op, size);\n\n        if (seg == null)\n            return;\n\n        writer.apply(seg.buffer());\n        seg.release();\n}\n\nThis will allow us to implement only size calculation and write to the ByteBuffer logic for specific operations.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449192874", "createdAt": "2020-07-02T18:17:58Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter == null)\n+            return new GridFinishedFuture<>();\n+\n+        return fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTM5MTU2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441939156", "createdAt": "2020-07-02T18:41:28Z", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0MToyOFrOGsZO-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0MToyOFrOGsZO-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMzk2MA==", "bodyText": "Why we distinguish CacheOperation and OperationType?\nIt seems to me that this two enums can be combiner into one pretty natural.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449203960", "createdAt": "2020-07-02T18:41:28Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/OperationType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+/**\n+ * Operation type.\n+ */\n+public enum OperationType {\n+    /** Cache operation. */\n+    CACHE_OPERATION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTQyNTM5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441942539", "createdAt": "2020-07-02T18:47:16Z", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0NzoxNlrOGsZZgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0NzoxNlrOGsZZgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwNjY1OQ==", "bodyText": "This constant not used now. Please, remove it.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449206659", "createdAt": "2020-07-02T18:47:16Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter == null)\n+            return new GridFinishedFuture<>();\n+\n+        return fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.putInt(cacheId);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        int size = /*cacheIds*/ 4 + cacheIds.size() * 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*commit*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TRANSACTION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.putInt(cacheIds.size());\n+\n+        GridIntIterator iter = cacheIds.iterator();\n+\n+        while (iter.hasNext())\n+            buf.putInt(iter.next());\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(commited ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*type*/ 1 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 4 +\n+            /*id*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*success*/ 1;\n+\n+        if (needWriteStr) {\n+            strBytes = text.getBytes();\n+\n+            size += /*text*/ 4 + strBytes.length;\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putInt(text.hashCode());\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(id);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(success ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        int size = /*type*/ 1 +\n+            /*queryNodeId*/ 16 +\n+            /*id*/ 8 +\n+            /*logicalReads*/ 8 +\n+            /*physicalReads*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY_READS, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        writeUuid(buf, queryNodeId);\n+        buf.putLong(id);\n+        buf.putLong(logicalReads);\n+        buf.putLong(physicalReads);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*sesId*/ 24 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*affPartId*/ 4;\n+\n+        if (needWriteStr) {\n+            strBytes = taskName.getBytes();\n+\n+            size += /*taskName*/ 4 + strBytes.length;\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TASK, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putInt(taskName.hashCode());\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.putInt(affPartId);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        int size = /*sesId*/ 24 +\n+            /*queuedTime*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*timedOut*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.JOB, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.putLong(queuedTime);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(timedOut ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(OperationType type, int size) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return null;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Maximum cached string count. */\n+        private static final short MAX_CACHED_STRING_COUNT = Short.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "originalPosition": 460}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTQzOTgw", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441943980", "createdAt": "2020-07-02T18:49:49Z", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0OTo0OVrOGsZd4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0OTo0OVrOGsZd4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwNzc3OA==", "bodyText": "Why we ignore poll results here?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449207778", "createdAt": "2020-07-02T18:49:49Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter == null)\n+            return new GridFinishedFuture<>();\n+\n+        return fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.putInt(cacheId);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        int size = /*cacheIds*/ 4 + cacheIds.size() * 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*commit*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TRANSACTION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.putInt(cacheIds.size());\n+\n+        GridIntIterator iter = cacheIds.iterator();\n+\n+        while (iter.hasNext())\n+            buf.putInt(iter.next());\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(commited ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*type*/ 1 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 4 +\n+            /*id*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*success*/ 1;\n+\n+        if (needWriteStr) {\n+            strBytes = text.getBytes();\n+\n+            size += /*text*/ 4 + strBytes.length;\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putInt(text.hashCode());\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(id);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(success ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        int size = /*type*/ 1 +\n+            /*queryNodeId*/ 16 +\n+            /*id*/ 8 +\n+            /*logicalReads*/ 8 +\n+            /*physicalReads*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY_READS, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        writeUuid(buf, queryNodeId);\n+        buf.putLong(id);\n+        buf.putLong(logicalReads);\n+        buf.putLong(physicalReads);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*sesId*/ 24 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*affPartId*/ 4;\n+\n+        if (needWriteStr) {\n+            strBytes = taskName.getBytes();\n+\n+            size += /*taskName*/ 4 + strBytes.length;\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TASK, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putInt(taskName.hashCode());\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.putInt(affPartId);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        int size = /*sesId*/ 24 +\n+            /*queuedTime*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*timedOut*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.JOB, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.putLong(queuedTime);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(timedOut ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(OperationType type, int size) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return null;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Maximum cached string count. */\n+        private static final short MAX_CACHED_STRING_COUNT = Short.MAX_VALUE;\n+\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Stop file writer future. */\n+        GridFutureAdapter<Void> stopFut = new GridFutureAdapter<>();\n+\n+        /** Hashcodes of cached strings. */\n+        private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+\n+                flushBuffer();\n+            }\n+\n+            fileWriter = null;\n+\n+            ringByteBuffer.close();\n+\n+            // Make sure that all producers released their buffers to safe deallocate memory.\n+            ringByteBuffer.poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "originalPosition": 529}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTQ2ODU0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441946854", "createdAt": "2020-07-02T18:54:43Z", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NDo0M1rOGsZmwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NDo0M1rOGsZmwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDA1MA==", "bodyText": "Can you, please, move this method to the bottom of the class, but above the FileWriter declaration to improve code readability.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449210050", "createdAt": "2020-07-02T18:54:43Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTQ3MTg5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441947189", "createdAt": "2020-07-02T18:55:19Z", "commit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NToxOVrOGsZnxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NToxOVrOGsZnxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDMxMQ==", "bodyText": "It seems, stop results are ignored.\nCan we make this method to return void?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449210311", "createdAt": "2020-07-02T18:55:19Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "133d8e6ff4a28eb606bcb28af247d87bb1557c00"}, "originalPosition": 139}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/66a46d52fb6469a3066f05ae97f19bc54f3af1f3", "committedDate": "2020-07-02T19:32:39Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTY4NDU2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442168456", "createdAt": "2020-07-03T06:14:23Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxNDoyM1rOGsk23w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoxNDoyM1rOGsk23w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5NDM5OQ==", "bodyText": "this method used only once. Let's inline it.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449394399", "createdAt": "2020-07-03T06:14:23Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        doWrite(OperationType.CACHE_OPERATION,\n+            () -> 1 + 4 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(OperationType.TRANSACTION,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8 + 1,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(commited ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(OperationType.QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(OperationType.QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(OperationType.TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(OperationType.JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt();\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(fileWriter, op, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        writer.accept(seg.buffer());\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @param fileWriter File writer.\n+     * @param type Operation type.\n+     * @param size Record size.\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(FileWriter fileWriter, OperationType type, int size) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 339}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTczOTk5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442173999", "createdAt": "2020-07-03T06:28:46Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoyODo0NlrOGslIKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoyODo0NlrOGslIKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5ODgyNA==", "bodyText": "This method should be moved to the reader.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449398824", "createdAt": "2020-07-03T06:28:46Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        doWrite(OperationType.CACHE_OPERATION,\n+            () -> 1 + 4 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(OperationType.TRANSACTION,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8 + 1,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(commited ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(OperationType.QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(OperationType.QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(OperationType.TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(OperationType.JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt();\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(fileWriter, op, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        writer.accept(seg.buffer());\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @param fileWriter File writer.\n+     * @param type Operation type.\n+     * @param size Record size.\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(FileWriter fileWriter, OperationType type, int size) {\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 393}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc0MjY4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442174268", "createdAt": "2020-07-03T06:29:26Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoyOToyNlrOGslJCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjoyOToyNlrOGslJCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5OTA0OQ==", "bodyText": "This method should be moved to the reader of some utility class.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449399049", "createdAt": "2020-07-03T06:29:26Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        doWrite(OperationType.CACHE_OPERATION,\n+            () -> 1 + 4 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(OperationType.TRANSACTION,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8 + 1,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(commited ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(OperationType.QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(OperationType.QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(OperationType.TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(OperationType.JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt();\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(fileWriter, op, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        writer.accept(seg.buffer());\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @param fileWriter File writer.\n+     * @param type Operation type.\n+     * @param size Record size.\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(FileWriter fileWriter, OperationType type, int size) {\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 381}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc1MDc4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442175078", "createdAt": "2020-07-03T06:31:24Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMToyNFrOGslLyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMToyNFrOGslLyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5OTc1NA==", "bodyText": "It seems to me that all resource cleaning should be done in finally block to prevent resource leaking on any unhandled exception.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449399754", "createdAt": "2020-07-03T06:31:24Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        doWrite(OperationType.CACHE_OPERATION,\n+            () -> 1 + 4 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(OperationType.TRANSACTION,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8 + 1,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(commited ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(OperationType.QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(OperationType.QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(OperationType.TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(OperationType.JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt();\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(fileWriter, op, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        writer.accept(seg.buffer());\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @param fileWriter File writer.\n+     * @param type Operation type.\n+     * @param size Record size.\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(FileWriter fileWriter, OperationType type, int size) {\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Hashcodes of cached strings. */\n+        private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+\n+                flushBuffer();\n+            }\n+\n+            fileWriter = null;\n+\n+            ringByteBuffer.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 467}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc1MzM2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442175336", "createdAt": "2020-07-03T06:32:04Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMjowNFrOGslMmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMjowNFrOGslMmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5OTk2MA==", "bodyText": "This method used only once. Let's inline it.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449399960", "createdAt": "2020-07-03T06:32:04Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        doWrite(OperationType.CACHE_OPERATION,\n+            () -> 1 + 4 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(OperationType.TRANSACTION,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8 + 1,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(commited ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(OperationType.QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(OperationType.QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(OperationType.TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(OperationType.JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt();\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(fileWriter, op, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        writer.accept(seg.buffer());\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @param fileWriter File writer.\n+     * @param type Operation type.\n+     * @param size Record size.\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(FileWriter fileWriter, OperationType type, int size) {\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Hashcodes of cached strings. */\n+        private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+\n+                flushBuffer();\n+            }\n+\n+            fileWriter = null;\n+\n+            ringByteBuffer.close();\n+\n+            // Make sure that all producers released their buffers to safe deallocate memory.\n+            flushBuffer();\n+\n+            ringByteBuffer.free();\n+\n+            U.closeQuiet(fileIo);\n+\n+            cachedStrings.clear();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+\n+        /** @return {@code True} if string hash code is cached. {@code False} if need write string.  */\n+        boolean stringCached(String str) {\n+            boolean cached = cachedStrings.contains(str.hashCode());\n+\n+            if (!cached)\n+                cachedStrings.add(str.hashCode());\n+\n+            return cached;\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 492}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc1ODcy", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442175872", "createdAt": "2020-07-03T06:33:26Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMzoyN1rOGslOSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjozMzoyN1rOGslOSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwMDM5Mw==", "bodyText": "Can you please, add a comment to clarify that this notify required to start writing data to the file.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449400393", "createdAt": "2020-07-03T06:33:27Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        doWrite(OperationType.CACHE_OPERATION,\n+            () -> 1 + 4 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(OperationType.TRANSACTION,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8 + 1,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(commited ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(OperationType.QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(OperationType.QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        boolean needWriteStr = !writer.stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(OperationType.TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(OperationType.JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt();\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(fileWriter, op, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        writer.accept(seg.buffer());\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @param fileWriter File writer.\n+     * @param type Operation type.\n+     * @param size Record size.\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(FileWriter fileWriter, OperationType type, int size) {\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Hashcodes of cached strings. */\n+        private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+\n+                flushBuffer();\n+            }\n+\n+            fileWriter = null;\n+\n+            ringByteBuffer.close();\n+\n+            // Make sure that all producers released their buffers to safe deallocate memory.\n+            flushBuffer();\n+\n+            ringByteBuffer.free();\n+\n+            U.closeQuiet(fileIo);\n+\n+            cachedStrings.clear();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+\n+        /** @return {@code True} if string hash code is cached. {@code False} if need write string.  */\n+        boolean stringCached(String str) {\n+            boolean cached = cachedStrings.contains(str.hashCode());\n+\n+            if (!cached)\n+                cachedStrings.add(str.hashCode());\n+\n+            return cached;\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {\n+            SegmentedRingByteBuffer.WriteSegment seg = ringByteBuffer.offer(size);\n+\n+            if (seg != null) {\n+                int readySize = readyForFlushSize.addAndGet(size);\n+\n+                if (readySize >= DFLT_FLUSH_SIZE) {\n+                    synchronized (this) {\n+                        notify();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 500}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc5NDUy", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442179452", "createdAt": "2020-07-03T06:41:57Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0MTo1OFrOGslaVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0MTo1OFrOGslaVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwMzQ3OQ==", "bodyText": "Let's use IgniteUtils#GB here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449403479", "createdAt": "2020-07-03T06:41:58Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTc5NjU3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442179657", "createdAt": "2020-07-03T06:42:23Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0MjoyNFrOGslbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0MjoyNFrOGslbAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwMzY1MA==", "bodyText": "Let's use IgniteUtils#MB here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449403650", "createdAt": "2020-07-03T06:42:24Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMTgwMDI2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442180026", "createdAt": "2020-07-03T06:43:16Z", "commit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0MzoxNlrOGslcIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNjo0MzoxNlrOGslcIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwMzkzOA==", "bodyText": "Let's use IgniteUtils#MB here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449403938", "createdAt": "2020-07-03T06:43:16Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,580 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66a46d52fb6469a3066f05ae97f19bc54f3af1f3"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "679e11d8106d6e13030857428fd692446ffb9a86", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/679e11d8106d6e13030857428fd692446ffb9a86", "committedDate": "2020-07-03T07:50:13Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMjIxNTEx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442221511", "createdAt": "2020-07-03T08:00:09Z", "commit": {"oid": "679e11d8106d6e13030857428fd692446ffb9a86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwODowMDowOVrOGsndRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwODowMDowOVrOGsndRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQzNjk5OA==", "bodyText": "we can check writer inside doWrite", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449436998", "createdAt": "2020-07-03T08:00:09Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,559 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "679e11d8106d6e13030857428fd692446ffb9a86"}, "originalPosition": 203}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/6027e11a98bcfac1b95690a32ac46e7b87b53726", "committedDate": "2020-07-03T09:42:01Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzE5MjEz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442319213", "createdAt": "2020-07-03T10:32:58Z", "commit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozMjo1OFrOGssBaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozMjo1OFrOGssBaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMTc4NQ==", "bodyText": "This method can be private.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449511785", "createdAt": "2020-07-03T10:32:58Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    boolean stringCached(String str) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "originalPosition": 345}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzE5Njg0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442319684", "createdAt": "2020-07-03T10:33:45Z", "commit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozMzo0NVrOGssCww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozMzo0NVrOGssCww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMjEzMQ==", "bodyText": "This method can be private.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449512131", "createdAt": "2020-07-03T10:33:45Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "originalPosition": 355}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzE5Nzk4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442319798", "createdAt": "2020-07-03T10:33:56Z", "commit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozMzo1N1rOGssDFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozMzo1N1rOGssDFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMjIxMw==", "bodyText": "This method can be private.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449512213", "createdAt": "2020-07-03T10:33:57Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "originalPosition": 364}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzE5ODQ4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442319848", "createdAt": "2020-07-03T10:34:01Z", "commit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozNDowMlrOGssDOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozNDowMlrOGssDOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMjI1MQ==", "bodyText": "This method can be private.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449512251", "createdAt": "2020-07-03T10:34:02Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "originalPosition": 370}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzIxMzg5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442321389", "createdAt": "2020-07-03T10:36:43Z", "commit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozNjo0M1rOGssHyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozNjo0M1rOGssHyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMzQxOQ==", "bodyText": "We shouldn't remove gathered statistics on each restart.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449513419", "createdAt": "2020-07-03T10:36:43Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6027e11a98bcfac1b95690a32ac46e7b87b53726"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/d860c9d0a72ab744c7fac03894d2d57b055a1001", "committedDate": "2020-07-03T11:08:25Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzg3NTY5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442387569", "createdAt": "2020-07-03T12:43:11Z", "commit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo0MzoxMVrOGsvNYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo0MzoxMVrOGsvNYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2NDAwMg==", "bodyText": "This method used only once. Let's inline it.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449564002", "createdAt": "2020-07-03T12:43:11Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    private boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    private static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    private static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    private static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            try {\n+                while (!isCancelled()) {\n+                    blockingSectionBegin();\n+\n+                    try {\n+                        synchronized (this) {\n+                            while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                                wait();\n+                        }\n+                    }\n+                    finally {\n+                        blockingSectionEnd();\n+                    }\n+\n+                    flushBuffer();\n+                }\n+            }\n+            finally {\n+                fileWriter = null;\n+\n+                ringByteBuffer.close();\n+\n+                // Make sure that all producers released their buffers to safe deallocate memory.\n+                flushBuffer();\n+\n+                ringByteBuffer.free();\n+\n+                U.closeQuiet(fileIo);\n+\n+                cachedStrings.clear();\n+\n+                log.info(\"Performance statistics writer stopped.\");\n+            }\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {\n+            SegmentedRingByteBuffer.WriteSegment seg = ringByteBuffer.offer(size);\n+\n+            if (seg != null) {\n+                int readySize = readyForFlushSize.addAndGet(size);\n+\n+                if (readySize >= DFLT_FLUSH_SIZE) {\n+                    synchronized (this) {\n+                        // Required to start writing data to the file.\n+                        notify();\n+                    }\n+                }\n+            }\n+\n+            return seg;\n+        }\n+\n+        /** Flushes to disk available bytes from the ring buffer. */\n+        private void flushBuffer() {\n+            List<SegmentedRingByteBuffer.ReadSegment> segs = ringByteBuffer.poll();\n+\n+            if (segs == null)\n+                return;\n+\n+            try {\n+                for (int i = 0; i < segs.size(); i++) {\n+                    updateHeartbeat();\n+\n+                    SegmentedRingByteBuffer.ReadSegment seg = segs.get(i);\n+\n+                    try {\n+                        readyForFlushSize.addAndGet(-seg.buffer().remaining());\n+\n+                        fileIo.writeFully(seg.buffer());\n+                    }\n+                    finally {\n+                        seg.release();\n+                    }\n+                }\n+\n+                fileIo.force();\n+            } catch (IOException e) {\n+                log.error(\"Unable to write to file. Performance statistics collecting will be stopped.\", e);\n+\n+                fileWriter.shutdown();\n+\n+                stopStatistics();\n+            }\n+        }\n+\n+        /** Shutted down the worker. */\n+        private void shutdown() {\n+            isCancelled = true;\n+\n+            synchronized (this) {\n+                // Required to start writing data to the file.\n+                notify();\n+            }\n+        }\n+\n+        /** Logs warning message about small buffer size if not logged yet. */\n+        void logSmallBufferMessage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001"}, "originalPosition": 520}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzg3OTU3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442387957", "createdAt": "2020-07-03T12:43:52Z", "commit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo0Mzo1M1rOGsvOlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo0Mzo1M1rOGsvOlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2NDMwOA==", "bodyText": "This method used only once. Let's inline it.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449564308", "createdAt": "2020-07-03T12:43:53Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    private boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    private static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    private static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    private static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            try {\n+                while (!isCancelled()) {\n+                    blockingSectionBegin();\n+\n+                    try {\n+                        synchronized (this) {\n+                            while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                                wait();\n+                        }\n+                    }\n+                    finally {\n+                        blockingSectionEnd();\n+                    }\n+\n+                    flushBuffer();\n+                }\n+            }\n+            finally {\n+                fileWriter = null;\n+\n+                ringByteBuffer.close();\n+\n+                // Make sure that all producers released their buffers to safe deallocate memory.\n+                flushBuffer();\n+\n+                ringByteBuffer.free();\n+\n+                U.closeQuiet(fileIo);\n+\n+                cachedStrings.clear();\n+\n+                log.info(\"Performance statistics writer stopped.\");\n+            }\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {\n+            SegmentedRingByteBuffer.WriteSegment seg = ringByteBuffer.offer(size);\n+\n+            if (seg != null) {\n+                int readySize = readyForFlushSize.addAndGet(size);\n+\n+                if (readySize >= DFLT_FLUSH_SIZE) {\n+                    synchronized (this) {\n+                        // Required to start writing data to the file.\n+                        notify();\n+                    }\n+                }\n+            }\n+\n+            return seg;\n+        }\n+\n+        /** Flushes to disk available bytes from the ring buffer. */\n+        private void flushBuffer() {\n+            List<SegmentedRingByteBuffer.ReadSegment> segs = ringByteBuffer.poll();\n+\n+            if (segs == null)\n+                return;\n+\n+            try {\n+                for (int i = 0; i < segs.size(); i++) {\n+                    updateHeartbeat();\n+\n+                    SegmentedRingByteBuffer.ReadSegment seg = segs.get(i);\n+\n+                    try {\n+                        readyForFlushSize.addAndGet(-seg.buffer().remaining());\n+\n+                        fileIo.writeFully(seg.buffer());\n+                    }\n+                    finally {\n+                        seg.release();\n+                    }\n+                }\n+\n+                fileIo.force();\n+            } catch (IOException e) {\n+                log.error(\"Unable to write to file. Performance statistics collecting will be stopped.\", e);\n+\n+                fileWriter.shutdown();\n+\n+                stopStatistics();\n+            }\n+        }\n+\n+        /** Shutted down the worker. */\n+        private void shutdown() {\n+            isCancelled = true;\n+\n+            synchronized (this) {\n+                // Required to start writing data to the file.\n+                notify();\n+            }\n+        }\n+\n+        /** Logs warning message about small buffer size if not logged yet. */\n+        void logSmallBufferMessage() {\n+            if (smallBufLogged.compareAndSet(false, true)) {\n+                log.warning(\"The performance statistics in-memory buffer size is too small. Some operations \" +\n+                    \"will not be logged.\");\n+            }\n+        }\n+\n+        /** Logs warning message and stops collecting statistics. */\n+        void onMaxFileSizeReached() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001"}, "originalPosition": 528}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzkyMzQ1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-442392345", "createdAt": "2020-07-03T12:51:51Z", "commit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1MTo1MVrOGsvb9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMjo1MTo1MVrOGsvb9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2NzczNQ==", "bodyText": "We should override or use existing cancel method to stop this worker.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449567735", "createdAt": "2020-07-03T12:51:51Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.shutdown();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    private boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    private static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    private static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    private static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            try {\n+                while (!isCancelled()) {\n+                    blockingSectionBegin();\n+\n+                    try {\n+                        synchronized (this) {\n+                            while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                                wait();\n+                        }\n+                    }\n+                    finally {\n+                        blockingSectionEnd();\n+                    }\n+\n+                    flushBuffer();\n+                }\n+            }\n+            finally {\n+                fileWriter = null;\n+\n+                ringByteBuffer.close();\n+\n+                // Make sure that all producers released their buffers to safe deallocate memory.\n+                flushBuffer();\n+\n+                ringByteBuffer.free();\n+\n+                U.closeQuiet(fileIo);\n+\n+                cachedStrings.clear();\n+\n+                log.info(\"Performance statistics writer stopped.\");\n+            }\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {\n+            SegmentedRingByteBuffer.WriteSegment seg = ringByteBuffer.offer(size);\n+\n+            if (seg != null) {\n+                int readySize = readyForFlushSize.addAndGet(size);\n+\n+                if (readySize >= DFLT_FLUSH_SIZE) {\n+                    synchronized (this) {\n+                        // Required to start writing data to the file.\n+                        notify();\n+                    }\n+                }\n+            }\n+\n+            return seg;\n+        }\n+\n+        /** Flushes to disk available bytes from the ring buffer. */\n+        private void flushBuffer() {\n+            List<SegmentedRingByteBuffer.ReadSegment> segs = ringByteBuffer.poll();\n+\n+            if (segs == null)\n+                return;\n+\n+            try {\n+                for (int i = 0; i < segs.size(); i++) {\n+                    updateHeartbeat();\n+\n+                    SegmentedRingByteBuffer.ReadSegment seg = segs.get(i);\n+\n+                    try {\n+                        readyForFlushSize.addAndGet(-seg.buffer().remaining());\n+\n+                        fileIo.writeFully(seg.buffer());\n+                    }\n+                    finally {\n+                        seg.release();\n+                    }\n+                }\n+\n+                fileIo.force();\n+            } catch (IOException e) {\n+                log.error(\"Unable to write to file. Performance statistics collecting will be stopped.\", e);\n+\n+                fileWriter.shutdown();\n+\n+                stopStatistics();\n+            }\n+        }\n+\n+        /** Shutted down the worker. */\n+        private void shutdown() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d860c9d0a72ab744c7fac03894d2d57b055a1001"}, "originalPosition": 510}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a595a08b976a6f3fabea1d4b54078331d37f1206", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/a595a08b976a6f3fabea1d4b54078331d37f1206", "committedDate": "2020-07-05T11:44:13Z", "message": "Use Worker#cancel"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNjYxNjY0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-443661664", "createdAt": "2020-07-07T08:13:53Z", "commit": {"oid": "a595a08b976a6f3fabea1d4b54078331d37f1206"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODoxMzo1M1rOGtzvnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODoxMzo1M1rOGtzvnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY4Njg3Nw==", "bodyText": "Let's use explicit list of the operation instead of range here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r450686877", "createdAt": "2020-07-07T08:13:53Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/OperationType.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.EnumSet;\n+\n+/**\n+ * Operation type.\n+ */\n+public enum OperationType {\n+    /** Cache get. */\n+    CACHE_GET,\n+\n+    /** Cache put. */\n+    CACHE_PUT,\n+\n+    /** Cache remove. */\n+    CACHE_REMOVE,\n+\n+    /** Cache get and put. */\n+    CACHE_GET_AND_PUT,\n+\n+    /** Cache get and remove. */\n+    CACHE_GET_AND_REMOVE,\n+\n+    /** Cache invoke. */\n+    CACHE_INVOKE,\n+\n+    /** Cache lock. */\n+    CACHE_LOCK,\n+\n+    /** Cache get all. */\n+    CACHE_GET_ALL,\n+\n+    /** Cache put all. */\n+    CACHE_PUT_ALL,\n+\n+    /** Cache remove all. */\n+    CACHE_REMOVE_ALL,\n+\n+    /** Cache invoke all. */\n+    CACHE_INVOKE_ALL,\n+\n+    /** Transaction commit. */\n+    TX_COMMIT,\n+\n+    /** Transaction rollback. */\n+    TX_ROLLBACK,\n+\n+    /** Query. */\n+    QUERY,\n+\n+    /** Query reads. */\n+    QUERY_READS,\n+\n+    /** Task. */\n+    TASK,\n+\n+    /** Job. */\n+    JOB;\n+\n+    /** Cache operations. */\n+    public static final EnumSet<OperationType> CACHE_OPS = EnumSet.range(CACHE_GET, CACHE_INVOKE_ALL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a595a08b976a6f3fabea1d4b54078331d37f1206"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072", "committedDate": "2020-07-07T08:40:53Z", "message": "Explicit enum list"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzg4NjI0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-443788624", "createdAt": "2020-07-07T11:08:57Z", "commit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTowODo1N1rOGt5wJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTowODo1N1rOGt5wJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4NTMxNw==", "bodyText": "Let's use MB constant here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r450785317", "createdAt": "2020-07-07T11:08:57Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsReader.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static java.nio.file.Files.walkFileTree;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.cacheOperation;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.transactionOperation;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ */\n+public class FilePerformanceStatisticsReader {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = 8 * 1024 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzkzMjE1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-443793215", "createdAt": "2020-07-07T11:16:22Z", "commit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxNjoyMlrOGt5-FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMToxNjoyMlrOGt5-FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4ODg4NA==", "bodyText": "Let's remove those 3 parameters, because we only use constants for it, for now.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r450788884", "createdAt": "2020-07-07T11:16:22Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,539 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.cancel();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    private boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    private static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    private static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    private static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072"}, "originalPosition": 404}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "862862df42e94ef723a01776b8d13ba0b8454e8e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/862862df42e94ef723a01776b8d13ba0b8454e8e", "committedDate": "2020-07-07T11:54:56Z", "message": "Use U.MB + code review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzODIwODk1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-443820895", "createdAt": "2020-07-07T11:59:48Z", "commit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTo1OTo0OFrOGt7SmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMTo1OTo0OFrOGt7SmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxMDUyMA==", "bodyText": "We can use foreach loop here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r450810520", "createdAt": "2020-07-07T11:59:48Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,539 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                U.join(writer.runner());\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            fileWriter.cancel();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(sizeSupplier.getAsInt() + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    private boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    private static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    private static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    private static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            try {\n+                while (!isCancelled()) {\n+                    blockingSectionBegin();\n+\n+                    try {\n+                        synchronized (this) {\n+                            while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                                wait();\n+                        }\n+                    }\n+                    finally {\n+                        blockingSectionEnd();\n+                    }\n+\n+                    flushBuffer();\n+                }\n+            }\n+            finally {\n+                fileWriter = null;\n+\n+                ringByteBuffer.close();\n+\n+                // Make sure that all producers released their buffers to safe deallocate memory.\n+                flushBuffer();\n+\n+                ringByteBuffer.free();\n+\n+                U.closeQuiet(fileIo);\n+\n+                cachedStrings.clear();\n+\n+                log.info(\"Performance statistics writer stopped.\");\n+            }\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {\n+            SegmentedRingByteBuffer.WriteSegment seg = ringByteBuffer.offer(size);\n+\n+            if (seg != null) {\n+                int readySize = readyForFlushSize.addAndGet(size);\n+\n+                if (readySize >= DFLT_FLUSH_SIZE) {\n+                    synchronized (this) {\n+                        // Required to start writing data to the file.\n+                        notify();\n+                    }\n+                }\n+            }\n+\n+            return seg;\n+        }\n+\n+        /** Flushes to disk available bytes from the ring buffer. */\n+        private void flushBuffer() {\n+            List<SegmentedRingByteBuffer.ReadSegment> segs = ringByteBuffer.poll();\n+\n+            if (segs == null)\n+                return;\n+\n+            try {\n+                for (int i = 0; i < segs.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a9f63ef5ed1c27f4b1ad36e14baeb51ea09a072"}, "originalPosition": 484}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65bbb89e8de96a223c6034cdac736174fa27a871", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/65bbb89e8de96a223c6034cdac736174fa27a871", "committedDate": "2020-07-07T14:06:19Z", "message": "Move ring buffer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e602a0d2726a4696b54f72c06a8ea810867e036", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/2e602a0d2726a4696b54f72c06a8ea810867e036", "committedDate": "2020-07-07T20:56:45Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/513495bdee11a3e024a6a5efa1363b95be552511", "committedDate": "2020-07-07T20:57:53Z", "message": "Use foreach loop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjU2NDE0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-444656414", "createdAt": "2020-07-08T11:34:13Z", "commit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozNDoxM1rOGujzqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozNDoxM1rOGujzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NDM0NA==", "bodyText": "Let's append to the file if it exists.\nIt seems all we need to do is to remove this line.\nWe need a ticket to provide clear command, also.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r451474344", "createdAt": "2020-07-08T11:34:13Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    @Nullable private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Size of ready for flushing bytes. */\n+    private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjYwMzEx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-444660311", "createdAt": "2020-07-08T11:40:23Z", "commit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MDoyM1rOGuj_ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0MDoyM1rOGuj_ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NzQwNg==", "bodyText": "It seems we can just use regular cancel implementation if we will catch InterruptedException and handle it accordingly.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r451477406", "createdAt": "2020-07-08T11:40:23Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    @Nullable private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Size of ready for flushing bytes. */\n+    private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);\n+\n+                fileIo = fileIoFactory.create(file);\n+\n+                ringByteBuffer = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+                    SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+                ringByteBuffer.init(0);\n+\n+                fileWriter = new FileWriter(ctx, log);\n+\n+                new IgniteThread(fileWriter).start();\n+\n+                log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+            }\n+            catch (IOException | IgniteCheckedException e) {\n+                log.error(\"Failed to start performance statistics writer.\", e);\n+\n+                stopStatistics();\n+\n+                throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            FileWriter fileWriter = this.fileWriter;\n+\n+            SegmentedRingByteBuffer buf = ringByteBuffer;\n+\n+            // Stop write new data.\n+            if (buf != null)\n+                buf.close();\n+\n+            // Make sure that all buffer's producers released to safe deallocate memory.\n+            if (fileWriter != null)\n+                U.awaitForWorkersStop(Collections.singleton(fileWriter), true, log);\n+\n+            if (buf != null)\n+                buf.free();\n+\n+            U.closeQuiet(fileIo);\n+\n+            readyForFlushSize.set(0);\n+            smallBufLogged.set(false);\n+            stopByMaxSize.set(false);\n+            cachedStrings.clear();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt() + /*type*/ 1;\n+\n+        SegmentedRingByteBuffer ringBuf = ringByteBuffer;\n+\n+        // Starting.\n+        if (ringBuf == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = ringBuf.offer(size);\n+\n+        if (seg == null) {\n+            if (smallBufLogged.compareAndSet(false, true)) {\n+                log.warning(\"The performance statistics in-memory buffer size is too small. Some operations \" +\n+                    \"will not be logged.\");\n+            }\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled() && stopByMaxSize.compareAndSet(false, true)) {\n+                stopStatistics();\n+\n+                log.warning(\"The performance statistics file maximum size is reached. \" +\n+                    \"Performance statistics collecting will be stopped.\");\n+            }\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+\n+        int readySize = readyForFlushSize.addAndGet(size);\n+\n+        if (readySize >= DFLT_FLUSH_SIZE)\n+            fileWriter.wakeUp();\n+    }\n+\n+    /** @return {@code True} if string is cached. {@code False} if need write string.  */\n+    private boolean stringCached(String str) {\n+        boolean cached = cachedStrings.contains(str.hashCode());\n+\n+        if (!cached)\n+            cachedStrings.add(str.hashCode());\n+\n+        return cached;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    private static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    private static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    private static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** Stops collecting statistics in the cluster. */\n+    void stopStatistics() {\n+        try {\n+            ctx.performanceStatistics().stopCollectStatistics();\n+        }\n+        catch (IgniteCheckedException e) {\n+            log.error(\"Failed to stop performance statistics.\", e);\n+        }\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /**\n+         * @param ctx Kernal context.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log,\n+                ctx.workersRegistry());\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < DFLT_FLUSH_SIZE && !isCancelled())\n+                            wait();\n+                    }\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+\n+                flushBuffer();\n+            }\n+\n+            // Make sure that all producers released their buffers to safe deallocate memory.\n+            flushBuffer();\n+        }\n+\n+        /** Flushes to disk available bytes from the ring buffer. */\n+        private void flushBuffer() {\n+            List<SegmentedRingByteBuffer.ReadSegment> segs = ringByteBuffer.poll();\n+\n+            if (segs == null)\n+                return;\n+\n+            try {\n+                for (SegmentedRingByteBuffer.ReadSegment seg : segs) {\n+                    updateHeartbeat();\n+\n+                    try {\n+                        readyForFlushSize.addAndGet(-seg.buffer().remaining());\n+\n+                        fileIo.writeFully(seg.buffer());\n+                    }\n+                    finally {\n+                        seg.release();\n+                    }\n+                }\n+\n+                fileIo.force();\n+            } catch (IOException e) {\n+                log.error(\"Unable to write to file. Performance statistics collecting will be stopped.\", e);\n+\n+                stopStatistics();\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void cancel() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511"}, "originalPosition": 503}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjcxMjE1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-444671215", "createdAt": "2020-07-08T11:49:43Z", "commit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0OTo0M1rOGukRqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTo0OTo0M1rOGukRqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ4MjAyNw==", "bodyText": "We have a race here.\n\nFileWriter - writes some data and decrease readyForFlushSize.\nOther threads executes doWrite and constantly increase readySize so it's become bigger than DFLT_FLUSH_SIZE. This leads that those threads will have contention of wakeUp synchronization.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r451482027", "createdAt": "2020-07-08T11:49:43Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    @Nullable private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Size of ready for flushing bytes. */\n+    private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);\n+\n+                fileIo = fileIoFactory.create(file);\n+\n+                ringByteBuffer = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+                    SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+                ringByteBuffer.init(0);\n+\n+                fileWriter = new FileWriter(ctx, log);\n+\n+                new IgniteThread(fileWriter).start();\n+\n+                log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+            }\n+            catch (IOException | IgniteCheckedException e) {\n+                log.error(\"Failed to start performance statistics writer.\", e);\n+\n+                stopStatistics();\n+\n+                throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            FileWriter fileWriter = this.fileWriter;\n+\n+            SegmentedRingByteBuffer buf = ringByteBuffer;\n+\n+            // Stop write new data.\n+            if (buf != null)\n+                buf.close();\n+\n+            // Make sure that all buffer's producers released to safe deallocate memory.\n+            if (fileWriter != null)\n+                U.awaitForWorkersStop(Collections.singleton(fileWriter), true, log);\n+\n+            if (buf != null)\n+                buf.free();\n+\n+            U.closeQuiet(fileIo);\n+\n+            readyForFlushSize.set(0);\n+            smallBufLogged.set(false);\n+            stopByMaxSize.set(false);\n+            cachedStrings.clear();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return;\n+\n+        int size = sizeSupplier.getAsInt() + /*type*/ 1;\n+\n+        SegmentedRingByteBuffer ringBuf = ringByteBuffer;\n+\n+        // Starting.\n+        if (ringBuf == null)\n+            return;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = ringBuf.offer(size);\n+\n+        if (seg == null) {\n+            if (smallBufLogged.compareAndSet(false, true)) {\n+                log.warning(\"The performance statistics in-memory buffer size is too small. Some operations \" +\n+                    \"will not be logged.\");\n+            }\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled() && stopByMaxSize.compareAndSet(false, true)) {\n+                stopStatistics();\n+\n+                log.warning(\"The performance statistics file maximum size is reached. \" +\n+                    \"Performance statistics collecting will be stopped.\");\n+            }\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());\n+\n+        writer.accept(buf);\n+\n+        seg.release();\n+\n+        int readySize = readyForFlushSize.addAndGet(size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "513495bdee11a3e024a6a5efa1363b95be552511"}, "originalPosition": 387}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "defa90f419a0ae63d46a941cff821c00a7fdd652", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/defa90f419a0ae63d46a941cff821c00a7fdd652", "committedDate": "2020-07-08T12:27:31Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f23c9d2689a8322c63b13f2ab4f588ac74cdd5c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/6f23c9d2689a8322c63b13f2ab4f588ac74cdd5c", "committedDate": "2020-07-08T12:30:30Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd71cb92b01a9cc323da1333a4bc4dcf8669796c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/fd71cb92b01a9cc323da1333a4bc4dcf8669796c", "committedDate": "2020-07-08T12:50:15Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df898c7ede051495ea4a88c50be9d4e28bcb1dff", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/df898c7ede051495ea4a88c50be9d4e28bcb1dff", "committedDate": "2020-07-08T12:58:17Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecd46720db5181fb0c246197acce48d717fa2f82", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/ecd46720db5181fb0c246197acce48d717fa2f82", "committedDate": "2020-07-08T13:34:58Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "688c8b6b4c4eb3d90e8eb0e05e10c259b3c9afda", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/688c8b6b4c4eb3d90e8eb0e05e10c259b3c9afda", "committedDate": "2020-07-08T14:42:05Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efca43559e82c709000e32511302fbc44f64e2f2", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/efca43559e82c709000e32511302fbc44f64e2f2", "committedDate": "2020-07-08T14:59:43Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e828f38aff3370ad6821d248e55b5e0250a4756d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e828f38aff3370ad6821d248e55b5e0250a4756d", "committedDate": "2020-07-08T15:34:53Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8213e492b09f0239d938ad9668026adb9bb72854", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/8213e492b09f0239d938ad9668026adb9bb72854", "committedDate": "2020-07-08T16:01:26Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bb61c03914d34b30588e91c9ca00e5bd405fd1a", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/1bb61c03914d34b30588e91c9ca00e5bd405fd1a", "committedDate": "2020-07-08T16:09:15Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4ea4952dc4d7294c0fd90f5bcb0e1b4e3f7455", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/7f4ea4952dc4d7294c0fd90f5bcb0e1b4e3f7455", "committedDate": "2020-07-08T16:10:06Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/8e5c295d6ea7254f459f0665ea8d669da59fe766", "committedDate": "2020-07-08T16:13:46Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzMyMDU4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-445332058", "createdAt": "2020-07-09T06:49:55Z", "commit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo0OTo1NVrOGvD3wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo0OTo1NVrOGvD3wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk5OTY4Mg==", "bodyText": "I can't see why we should cache this variable here?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r451999682", "createdAt": "2020-07-09T06:49:55Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Count of written to buffer bytes. */\n+    private final AtomicInteger writtenToBuffer = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);\n+\n+                fileIo = fileIoFactory.create(file);\n+\n+                ringByteBuffer = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+                    SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+                ringByteBuffer.init(0);\n+\n+                fileWriter = new FileWriter(ctx, log);\n+\n+                new IgniteThread(fileWriter).start();\n+\n+                log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+            }\n+            catch (IOException | IgniteCheckedException e) {\n+                log.error(\"Failed to start performance statistics writer.\", e);\n+\n+                stopStatistics();\n+\n+                throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            FileWriter fileWriter = this.fileWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzMyMjk4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-445332298", "createdAt": "2020-07-09T06:50:19Z", "commit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo1MDoxOVrOGvD4kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo1MDoxOVrOGvD4kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk5OTg5MA==", "bodyText": "It seems we should set up default values in the start method.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r451999890", "createdAt": "2020-07-09T06:50:19Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Count of written to buffer bytes. */\n+    private final AtomicInteger writtenToBuffer = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);\n+\n+                fileIo = fileIoFactory.create(file);\n+\n+                ringByteBuffer = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+                    SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+                ringByteBuffer.init(0);\n+\n+                fileWriter = new FileWriter(ctx, log);\n+\n+                new IgniteThread(fileWriter).start();\n+\n+                log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+            }\n+            catch (IOException | IgniteCheckedException e) {\n+                log.error(\"Failed to start performance statistics writer.\", e);\n+\n+                stopStatistics();\n+\n+                throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            FileWriter fileWriter = this.fileWriter;\n+\n+            // Make sure that all buffer's producers released to safe deallocate memory.\n+            if (fileWriter != null)\n+                U.awaitForWorkersStop(Collections.singleton(fileWriter), true, log);\n+\n+            SegmentedRingByteBuffer buf = ringByteBuffer;\n+\n+            if (buf != null) {\n+                buf.close();\n+\n+                // Make sure that all producers released their buffers to safe deallocate memory.\n+                buf.poll();\n+\n+                buf.free();\n+            }\n+\n+            U.closeQuiet(fileIo);\n+\n+            writtenToBuffer.set(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzMzMzM1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-445333335", "createdAt": "2020-07-09T06:52:05Z", "commit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo1MjowNVrOGvD74g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo1MjowNVrOGvD74g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAwMDczOA==", "bodyText": "I can't see why we should cache this variable.\nWe also, should check enabled flag here, but assign it to true as a last statement in the start.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r452000738", "createdAt": "2020-07-09T06:52:05Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Count of written to buffer bytes. */\n+    private final AtomicInteger writtenToBuffer = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);\n+\n+                fileIo = fileIoFactory.create(file);\n+\n+                ringByteBuffer = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+                    SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+                ringByteBuffer.init(0);\n+\n+                fileWriter = new FileWriter(ctx, log);\n+\n+                new IgniteThread(fileWriter).start();\n+\n+                log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+            }\n+            catch (IOException | IgniteCheckedException e) {\n+                log.error(\"Failed to start performance statistics writer.\", e);\n+\n+                stopStatistics();\n+\n+                throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            FileWriter fileWriter = this.fileWriter;\n+\n+            // Make sure that all buffer's producers released to safe deallocate memory.\n+            if (fileWriter != null)\n+                U.awaitForWorkersStop(Collections.singleton(fileWriter), true, log);\n+\n+            SegmentedRingByteBuffer buf = ringByteBuffer;\n+\n+            if (buf != null) {\n+                buf.close();\n+\n+                // Make sure that all producers released their buffers to safe deallocate memory.\n+                buf.poll();\n+\n+                buf.free();\n+            }\n+\n+            U.closeQuiet(fileIo);\n+\n+            writtenToBuffer.set(0);\n+            smallBufLogged.set(false);\n+            stopByMaxSize.set(false);\n+            cachedStrings.clear();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        boolean needWriteStr = !stringCached(text);\n+        byte[] strBytes = needWriteStr ? text.getBytes() : null;\n+\n+        doWrite(QUERY, () -> {\n+            int size = 1 + 1 + 4 + 8 + 8 + 8 + 1;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            buf.put((byte)type.ordinal());\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(text.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(id);\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.put(success ? (byte)1 : 0);\n+        });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        boolean needWriteStr = !stringCached(taskName);\n+        byte[] strBytes = needWriteStr ? taskName.getBytes() : null;\n+\n+        doWrite(TASK, () -> {\n+            int size = 24 + 1 + 4 + 8 + 8 + 4;\n+\n+            if (needWriteStr)\n+                size += 4 + strBytes.length;\n+\n+            return size;\n+        }, buf -> {\n+            writeIgniteUuid(buf, sesId);\n+            buf.put(needWriteStr ? (byte)1 : 0);\n+            buf.putInt(taskName.hashCode());\n+\n+            if (needWriteStr) {\n+                buf.putInt(strBytes.length);\n+                buf.put(strBytes);\n+            }\n+\n+            buf.putLong(startTime);\n+            buf.putLong(duration);\n+            buf.putInt(affPartId);\n+        });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        FileWriter fileWriter = this.fileWriter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "originalPosition": 343}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzM0MDQ5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-445334049", "createdAt": "2020-07-09T06:53:12Z", "commit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo1MzoxM1rOGvD-BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNjo1MzoxM1rOGvD-BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAwMTI4NQ==", "bodyText": "I can't see why we should cache this variable.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r452001285", "createdAt": "2020-07-09T06:53:13Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    private volatile FileIO fileIo;\n+\n+    /** File write buffer. */\n+    @Nullable private volatile SegmentedRingByteBuffer ringByteBuffer;\n+\n+    /** Count of written to buffer bytes. */\n+    private final AtomicInteger writtenToBuffer = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Hashcodes of cached strings. */\n+    private final ConcurrentSkipListSet<Integer> cachedStrings = new ConcurrentSkipListSet<>();\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public void start() {\n+        synchronized (this) {\n+            if (enabled)\n+                return;\n+\n+            enabled = true;\n+\n+            try {\n+                File file = statisticsFile(ctx);\n+\n+                U.delete(file);\n+\n+                fileIo = fileIoFactory.create(file);\n+\n+                ringByteBuffer = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+                    SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+                ringByteBuffer.init(0);\n+\n+                fileWriter = new FileWriter(ctx, log);\n+\n+                new IgniteThread(fileWriter).start();\n+\n+                log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+            }\n+            catch (IOException | IgniteCheckedException e) {\n+                log.error(\"Failed to start performance statistics writer.\", e);\n+\n+                stopStatistics();\n+\n+                throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public void stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            FileWriter fileWriter = this.fileWriter;\n+\n+            // Make sure that all buffer's producers released to safe deallocate memory.\n+            if (fileWriter != null)\n+                U.awaitForWorkersStop(Collections.singleton(fileWriter), true, log);\n+\n+            SegmentedRingByteBuffer buf = ringByteBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e5c295d6ea7254f459f0665ea8d669da59fe766"}, "originalPosition": 169}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccc53253b1d09326b624f41df47d152cd14c29ae", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/ccc53253b1d09326b624f41df47d152cd14c29ae", "committedDate": "2020-07-09T12:22:22Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8982bb6cd5c1c667f41fadb7130280d29e5275e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e8982bb6cd5c1c667f41fadb7130280d29e5275e", "committedDate": "2020-07-09T12:42:05Z", "message": "Unnecessary stopWriter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7466f2272a72ea0f97916251c0b67ce90f3af4a1", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/7466f2272a72ea0f97916251c0b67ce90f3af4a1", "committedDate": "2020-07-09T14:07:24Z", "message": "Refactor cache lock statistics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c46c3ce43f82ec4b98a6d50a6e4ec72bc8f2a2e3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/c46c3ce43f82ec4b98a6d50a6e4ec72bc8f2a2e3", "committedDate": "2020-07-09T21:21:33Z", "message": "Add and refactor tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8559a99fc1998ac5ad659bca4f2bed4a7bd2a20d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/8559a99fc1998ac5ad659bca4f2bed4a7bd2a20d", "committedDate": "2020-07-10T08:40:58Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebf92fff45710c90104c18f7240b660b99b5dc4d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/ebf92fff45710c90104c18f7240b660b99b5dc4d", "committedDate": "2020-07-10T08:50:33Z", "message": "Naming fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f8fb9b39309ead7b2e0e1d8b6bd19d804849738", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/8f8fb9b39309ead7b2e0e1d8b6bd19d804849738", "committedDate": "2020-07-10T10:48:01Z", "message": "Test suite and minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/65c083a7045a64ecb1500aada5bc040b29359d20", "committedDate": "2020-07-13T12:23:04Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Mjk3MjQ2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447297246", "createdAt": "2020-07-13T14:21:19Z", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyMToyMFrOGwqxKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyMToyMFrOGwqxKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4NTU0NQ==", "bodyText": "We should log outside of the synchronized section.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453685545", "createdAt": "2020-07-13T14:21:20Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.NodeStoppingException;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetaStorage;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetastorageLifecycleListener;\n+import org.apache.ignite.internal.processors.metastorage.ReadableDistributedMetaStorage;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting performance statistics.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ * @see FilePerformanceStatisticsReader\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Prefix for performance statistics enabled property name. */\n+    private static final String PERFORMANCE_STAT_ENABLED_PREFIX = \"performanceStatistics.enabled\";\n+\n+    /** Performance statistics writer. */\n+    @Nullable private volatile FilePerformanceStatisticsWriter writer;\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Metastorage with the write access. */\n+    @Nullable private volatile DistributedMetaStorage metastorage;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        ctx.internalSubscriptionProcessor().registerDistributedMetastorageListener(\n+            new DistributedMetastorageLifecycleListener() {\n+            @Override public void onReadyForRead(ReadableDistributedMetaStorage metastorage) {\n+                metastorage.listen(PERFORMANCE_STAT_ENABLED_PREFIX::equals, (key, oldVal, newVal) -> {\n+                    // Skip history on local join.\n+                    if (!ctx.discovery().localJoinFuture().isDone())\n+                        return;\n+\n+                    onMetastorageUpdate((boolean)newVal);\n+                });\n+            }\n+\n+            @Override public void onReadyForWrite(DistributedMetaStorage metastorage) {\n+                PerformaceStatisticsProcessor.this.metastorage = metastorage;\n+\n+                try {\n+                    Boolean performanceStatsEnabled = metastorage.read(PERFORMANCE_STAT_ENABLED_PREFIX);\n+\n+                    if (performanceStatsEnabled == null)\n+                        return;\n+\n+                    onMetastorageUpdate(performanceStatsEnabled);\n+                }\n+                catch (IgniteCheckedException e) {\n+                    throw new IgniteException(e);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        write(writer -> writer.cacheOperation(type, cacheId, startTime, duration));\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        write(writer -> writer.transaction(cacheIds, startTime, duration, commited));\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        write(writer -> writer.query(type, text, id, startTime, duration, success));\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        write(writer -> writer.queryReads(type, queryNodeId, id, logicalReads, physicalReads));\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        write(writer -> writer.task(sesId, taskName, startTime, duration, affPartId));\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        write(writer -> writer.job(sesId, queuedTime, startTime, duration, timedOut));\n+    }\n+\n+    /**\n+     * Starts collecting performance statistics.\n+     *\n+     * @throws IgniteCheckedException If starting failed.\n+     */\n+    public void startCollectStatistics() throws IgniteCheckedException {\n+        A.notNull(metastorage, \"Metastorage not ready. Node not started?\");\n+\n+        if (!allNodesSupports(ctx.discovery().allNodes(), IgniteFeatures.PERFORMANCE_STATISTICS))\n+            throw new IllegalStateException(\"Not all nodes in the cluster support collecting performance statistics.\");\n+\n+        if (ctx.isStopping())\n+            throw new NodeStoppingException(\"Operation has been cancelled (node is stopping)\");\n+\n+        metastorage.write(PERFORMANCE_STAT_ENABLED_PREFIX, true);\n+    }\n+\n+    /**\n+     * Stops collecting performance statistics.\n+     *\n+     * @throws IgniteCheckedException If stopping failed.\n+     */\n+    public void stopCollectStatistics() throws IgniteCheckedException {\n+        A.notNull(metastorage, \"Metastorage not ready. Node not started?\");\n+\n+        if (ctx.isStopping())\n+            throw new NodeStoppingException(\"Operation has been cancelled (node is stopping)\");\n+\n+        metastorage.write(PERFORMANCE_STAT_ENABLED_PREFIX, false);\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void onKernalStop(boolean cancel) {\n+        if (enabled())\n+            stopWriter();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void onDisconnected(IgniteFuture<?> reconnectFut) {\n+        if (enabled())\n+            stopWriter();\n+    }\n+\n+    /** Starts or stops collecting statistics on metastorage update. */\n+    private void onMetastorageUpdate(boolean start) {\n+        ctx.closure().runLocalSafe(() -> {\n+            if (start)\n+                startWriter();\n+            else\n+                stopWriter();\n+        });\n+    }\n+\n+    /** Starts performance statistics writer. */\n+    private void startWriter() {\n+        try {\n+            synchronized (this) {\n+                if (enabled)\n+                    return;\n+\n+                writer = new FilePerformanceStatisticsWriter(ctx);\n+\n+                writer.start();\n+\n+                enabled = true;\n+\n+                log.info(\"Performance statistics writer started.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "originalPosition": 231}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Mjk3MzQx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447297341", "createdAt": "2020-07-13T14:21:26Z", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyMToyNlrOGwqxcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyMToyNlrOGwqxcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4NTYxOA==", "bodyText": "We should log outside of synchronized section.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453685618", "createdAt": "2020-07-13T14:21:26Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.NodeStoppingException;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetaStorage;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetastorageLifecycleListener;\n+import org.apache.ignite.internal.processors.metastorage.ReadableDistributedMetaStorage;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting performance statistics.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ * @see FilePerformanceStatisticsReader\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Prefix for performance statistics enabled property name. */\n+    private static final String PERFORMANCE_STAT_ENABLED_PREFIX = \"performanceStatistics.enabled\";\n+\n+    /** Performance statistics writer. */\n+    @Nullable private volatile FilePerformanceStatisticsWriter writer;\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Metastorage with the write access. */\n+    @Nullable private volatile DistributedMetaStorage metastorage;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        ctx.internalSubscriptionProcessor().registerDistributedMetastorageListener(\n+            new DistributedMetastorageLifecycleListener() {\n+            @Override public void onReadyForRead(ReadableDistributedMetaStorage metastorage) {\n+                metastorage.listen(PERFORMANCE_STAT_ENABLED_PREFIX::equals, (key, oldVal, newVal) -> {\n+                    // Skip history on local join.\n+                    if (!ctx.discovery().localJoinFuture().isDone())\n+                        return;\n+\n+                    onMetastorageUpdate((boolean)newVal);\n+                });\n+            }\n+\n+            @Override public void onReadyForWrite(DistributedMetaStorage metastorage) {\n+                PerformaceStatisticsProcessor.this.metastorage = metastorage;\n+\n+                try {\n+                    Boolean performanceStatsEnabled = metastorage.read(PERFORMANCE_STAT_ENABLED_PREFIX);\n+\n+                    if (performanceStatsEnabled == null)\n+                        return;\n+\n+                    onMetastorageUpdate(performanceStatsEnabled);\n+                }\n+                catch (IgniteCheckedException e) {\n+                    throw new IgniteException(e);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        write(writer -> writer.cacheOperation(type, cacheId, startTime, duration));\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        write(writer -> writer.transaction(cacheIds, startTime, duration, commited));\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        write(writer -> writer.query(type, text, id, startTime, duration, success));\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        write(writer -> writer.queryReads(type, queryNodeId, id, logicalReads, physicalReads));\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        write(writer -> writer.task(sesId, taskName, startTime, duration, affPartId));\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        write(writer -> writer.job(sesId, queuedTime, startTime, duration, timedOut));\n+    }\n+\n+    /**\n+     * Starts collecting performance statistics.\n+     *\n+     * @throws IgniteCheckedException If starting failed.\n+     */\n+    public void startCollectStatistics() throws IgniteCheckedException {\n+        A.notNull(metastorage, \"Metastorage not ready. Node not started?\");\n+\n+        if (!allNodesSupports(ctx.discovery().allNodes(), IgniteFeatures.PERFORMANCE_STATISTICS))\n+            throw new IllegalStateException(\"Not all nodes in the cluster support collecting performance statistics.\");\n+\n+        if (ctx.isStopping())\n+            throw new NodeStoppingException(\"Operation has been cancelled (node is stopping)\");\n+\n+        metastorage.write(PERFORMANCE_STAT_ENABLED_PREFIX, true);\n+    }\n+\n+    /**\n+     * Stops collecting performance statistics.\n+     *\n+     * @throws IgniteCheckedException If stopping failed.\n+     */\n+    public void stopCollectStatistics() throws IgniteCheckedException {\n+        A.notNull(metastorage, \"Metastorage not ready. Node not started?\");\n+\n+        if (ctx.isStopping())\n+            throw new NodeStoppingException(\"Operation has been cancelled (node is stopping)\");\n+\n+        metastorage.write(PERFORMANCE_STAT_ENABLED_PREFIX, false);\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void onKernalStop(boolean cancel) {\n+        if (enabled())\n+            stopWriter();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void onDisconnected(IgniteFuture<?> reconnectFut) {\n+        if (enabled())\n+            stopWriter();\n+    }\n+\n+    /** Starts or stops collecting statistics on metastorage update. */\n+    private void onMetastorageUpdate(boolean start) {\n+        ctx.closure().runLocalSafe(() -> {\n+            if (start)\n+                startWriter();\n+            else\n+                stopWriter();\n+        });\n+    }\n+\n+    /** Starts performance statistics writer. */\n+    private void startWriter() {\n+        try {\n+            synchronized (this) {\n+                if (enabled)\n+                    return;\n+\n+                writer = new FilePerformanceStatisticsWriter(ctx);\n+\n+                writer.start();\n+\n+                enabled = true;\n+\n+                log.info(\"Performance statistics writer started.\");\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops performance statistics writer. */\n+    private void stopWriter() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return;\n+\n+            enabled = false;\n+\n+            writer.stop();\n+\n+            writer = null;\n+\n+            log.info(\"Performance statistics writer stopped.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "originalPosition": 251}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Mjk3ODg2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447297886", "createdAt": "2020-07-13T14:22:02Z", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyMjowMlrOGwqzLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyMjowMlrOGwqzLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY4NjA2Mw==", "bodyText": "Let's have explicit mux Object for synchronization to avoid contention if some external object will sync of processor.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453686063", "createdAt": "2020-07-13T14:22:02Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.NodeStoppingException;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetaStorage;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetastorageLifecycleListener;\n+import org.apache.ignite.internal.processors.metastorage.ReadableDistributedMetaStorage;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting performance statistics.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ * @see FilePerformanceStatisticsReader\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Prefix for performance statistics enabled property name. */\n+    private static final String PERFORMANCE_STAT_ENABLED_PREFIX = \"performanceStatistics.enabled\";\n+\n+    /** Performance statistics writer. */\n+    @Nullable private volatile FilePerformanceStatisticsWriter writer;\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Metastorage with the write access. */\n+    @Nullable private volatile DistributedMetaStorage metastorage;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        ctx.internalSubscriptionProcessor().registerDistributedMetastorageListener(\n+            new DistributedMetastorageLifecycleListener() {\n+            @Override public void onReadyForRead(ReadableDistributedMetaStorage metastorage) {\n+                metastorage.listen(PERFORMANCE_STAT_ENABLED_PREFIX::equals, (key, oldVal, newVal) -> {\n+                    // Skip history on local join.\n+                    if (!ctx.discovery().localJoinFuture().isDone())\n+                        return;\n+\n+                    onMetastorageUpdate((boolean)newVal);\n+                });\n+            }\n+\n+            @Override public void onReadyForWrite(DistributedMetaStorage metastorage) {\n+                PerformaceStatisticsProcessor.this.metastorage = metastorage;\n+\n+                try {\n+                    Boolean performanceStatsEnabled = metastorage.read(PERFORMANCE_STAT_ENABLED_PREFIX);\n+\n+                    if (performanceStatsEnabled == null)\n+                        return;\n+\n+                    onMetastorageUpdate(performanceStatsEnabled);\n+                }\n+                catch (IgniteCheckedException e) {\n+                    throw new IgniteException(e);\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        write(writer -> writer.cacheOperation(type, cacheId, startTime, duration));\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        write(writer -> writer.transaction(cacheIds, startTime, duration, commited));\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        write(writer -> writer.query(type, text, id, startTime, duration, success));\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        write(writer -> writer.queryReads(type, queryNodeId, id, logicalReads, physicalReads));\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        write(writer -> writer.task(sesId, taskName, startTime, duration, affPartId));\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        write(writer -> writer.job(sesId, queuedTime, startTime, duration, timedOut));\n+    }\n+\n+    /**\n+     * Starts collecting performance statistics.\n+     *\n+     * @throws IgniteCheckedException If starting failed.\n+     */\n+    public void startCollectStatistics() throws IgniteCheckedException {\n+        A.notNull(metastorage, \"Metastorage not ready. Node not started?\");\n+\n+        if (!allNodesSupports(ctx.discovery().allNodes(), IgniteFeatures.PERFORMANCE_STATISTICS))\n+            throw new IllegalStateException(\"Not all nodes in the cluster support collecting performance statistics.\");\n+\n+        if (ctx.isStopping())\n+            throw new NodeStoppingException(\"Operation has been cancelled (node is stopping)\");\n+\n+        metastorage.write(PERFORMANCE_STAT_ENABLED_PREFIX, true);\n+    }\n+\n+    /**\n+     * Stops collecting performance statistics.\n+     *\n+     * @throws IgniteCheckedException If stopping failed.\n+     */\n+    public void stopCollectStatistics() throws IgniteCheckedException {\n+        A.notNull(metastorage, \"Metastorage not ready. Node not started?\");\n+\n+        if (ctx.isStopping())\n+            throw new NodeStoppingException(\"Operation has been cancelled (node is stopping)\");\n+\n+        metastorage.write(PERFORMANCE_STAT_ENABLED_PREFIX, false);\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    public boolean enabled() {\n+        return enabled;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void onKernalStop(boolean cancel) {\n+        if (enabled())\n+            stopWriter();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void onDisconnected(IgniteFuture<?> reconnectFut) {\n+        if (enabled())\n+            stopWriter();\n+    }\n+\n+    /** Starts or stops collecting statistics on metastorage update. */\n+    private void onMetastorageUpdate(boolean start) {\n+        ctx.closure().runLocalSafe(() -> {\n+            if (start)\n+                startWriter();\n+            else\n+                stopWriter();\n+        });\n+    }\n+\n+    /** Starts performance statistics writer. */\n+    private void startWriter() {\n+        try {\n+            synchronized (this) {\n+                if (enabled)\n+                    return;\n+\n+                writer = new FilePerformanceStatisticsWriter(ctx);\n+\n+                writer.start();\n+\n+                enabled = true;\n+\n+                log.info(\"Performance statistics writer started.\");\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops performance statistics writer. */\n+    private void stopWriter() {\n+        synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzAzODE4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447303818", "createdAt": "2020-07-13T14:28:29Z", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyODoyOVrOGwrE0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDoyODoyOVrOGwrE0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5MDU3OA==", "bodyText": "Other components use _ as a separator and more compact naming such as cp, binary_meta.\nLet's use perf_stat name here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453690578", "createdAt": "2020-07-13T14:28:29Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics writer based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c6e99d016c4742b3e6ff039df9355961acc0cb", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/64c6e99d016c4742b3e6ff039df9355961acc0cb", "committedDate": "2020-07-13T14:46:09Z", "message": "Separate mux + log + renaming"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzQ2MjIw", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447346220", "createdAt": "2020-07-13T15:14:04Z", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxNDowNFrOGwtHKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNToxNDowNFrOGwtHKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMzk0Nw==", "bodyText": "we use buffer here but buf in smallBufLogged.\nLet's use buf every where.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453723947", "createdAt": "2020-07-13T15:14:04Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics writer based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics file writer worker. */\n+    private final FileWriter fileWriter;\n+\n+    /** Performance statistics file I/O. */\n+    private final FileIO fileIo;\n+\n+    /** File write buffer. */\n+    private final SegmentedRingByteBuffer ringByteBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a8ecfddb296c296e2f476b13681b63a66d763d7", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/3a8ecfddb296c296e2f476b13681b63a66d763d7", "committedDate": "2020-07-13T15:17:05Z", "message": "Renaming"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzkxODA0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447391804", "createdAt": "2020-07-13T16:05:25Z", "commit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjowNToyNVrOGwvYGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNjowNToyNVrOGwvYGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2MTA0OQ==", "bodyText": "This name is not a prefix, it a full name, isnt'it?\nLet's rename this to PERFORMANCE_STAT_KEY", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453761049", "createdAt": "2020-07-13T16:05:25Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.NodeStoppingException;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetaStorage;\n+import org.apache.ignite.internal.processors.metastorage.DistributedMetastorageLifecycleListener;\n+import org.apache.ignite.internal.processors.metastorage.ReadableDistributedMetaStorage;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting performance statistics.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ * @see FilePerformanceStatisticsReader\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Prefix for performance statistics enabled property name. */\n+    private static final String PERFORMANCE_STAT_ENABLED_PREFIX = \"performanceStatistics.enabled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c083a7045a64ecb1500aada5bc040b29359d20"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af178f633ec8bba7f7c0b41f0d2ecea3c15f3267", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/af178f633ec8bba7f7c0b41f0d2ecea3c15f3267", "committedDate": "2020-07-13T16:09:32Z", "message": "Remove enabled. Check for a one writer thread"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "444cad8b17a0652225c46ac77c64e28c05e30ece", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/444cad8b17a0652225c46ac77c64e28c05e30ece", "committedDate": "2020-07-13T16:13:37Z", "message": "Renaming. perf_stat dir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fc84a3a1f6e7d10f6cbdee848d18d194cba1f3f", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/4fc84a3a1f6e7d10f6cbdee848d18d194cba1f3f", "committedDate": "2020-07-13T16:38:58Z", "message": "Remove unnecessary vars. Review fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e32cf4bd518396bb392b011af9396e8d82fad2de", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e32cf4bd518396bb392b011af9396e8d82fad2de", "committedDate": "2020-07-13T16:40:08Z", "message": "Renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3cda0ecc7aa37a30e135ffec8389b15492b79bd", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e3cda0ecc7aa37a30e135ffec8389b15492b79bd", "committedDate": "2020-07-13T16:46:49Z", "message": "Renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ca39a3ca03a7d6e8c165fd2593a170d8ec1e44e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/7ca39a3ca03a7d6e8c165fd2593a170d8ec1e44e", "committedDate": "2020-07-13T17:06:49Z", "message": "assert started/stopped. package private writer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04414a3f69b0fb74f82d694baf98577b58c2e4e2", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/04414a3f69b0fb74f82d694baf98577b58c2e4e2", "committedDate": "2020-07-13T17:23:47Z", "message": "Removed string caching. Inline wakeUp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/1fd124f28978f710c8f313dce6ebb92d91b2f7ff", "committedDate": "2020-07-13T18:06:14Z", "message": "Fix thread name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTE3NDg2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447517486", "createdAt": "2020-07-13T18:57:38Z", "commit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxODo1NzozOVrOGw1p_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxODo1NzozOVrOGw1p_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MzkzNQ==", "bodyText": "We should introduce an explicit index here.\nOtherwise, any edit in the middle of OperationType will broke deserialization.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r453863935", "createdAt": "2020-07-13T18:57:39Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_ROLLBACK;\n+\n+/**\n+ * Performance statistics writer based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERF_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+class FilePerformanceStatisticsWriter {\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERF_STAT_DIR = \"perf_stat\";\n+\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * U.GB;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = (int)(32 * U.MB);\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = (int)(8 * U.MB);\n+\n+    /** File writer thread name. */\n+    static final String WRITER_THREAD_NAME = \"performance-statistics-writer\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics file I/O. */\n+    private final FileIO fileIo;\n+\n+    /** Performance statistics file writer worker. */\n+    private final FileWriter fileWriter;\n+\n+    /** File writer thread started flag. */\n+    private boolean started;\n+\n+    /** File write buffer. */\n+    private final SegmentedRingByteBuffer ringByteBuf;\n+\n+    /** Count of written to buffer bytes. */\n+    private final AtomicInteger writtenToBuf = new AtomicInteger();\n+\n+    /** {@code True} if the small buffer warning message logged. */\n+    private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+    /** {@code True} if worker stopped due to maximum file size reached. */\n+    private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) throws IgniteCheckedException, IOException {\n+        log = ctx.log(getClass());\n+\n+        File file = statisticsFile(ctx);\n+\n+        U.delete(file);\n+\n+        fileIo = fileIoFactory.create(file);\n+\n+        log.info(\"Performance statistics file created [file=\" + file.getAbsolutePath() + ']');\n+\n+        ringByteBuf = new SegmentedRingByteBuffer(DFLT_BUFFER_SIZE, DFLT_FILE_MAX_SIZE,\n+            SegmentedRingByteBuffer.BufferMode.DIRECT);\n+\n+        fileWriter = new FileWriter(ctx, log);\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        assert !started;\n+\n+        new IgniteThread(fileWriter).start();\n+\n+        started = true;\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public synchronized void stop() {\n+        assert started;\n+\n+        // Stop accepting new records.\n+        ringByteBuf.close();\n+\n+        U.awaitForWorkersStop(Collections.singleton(fileWriter), true, log);\n+\n+        // Make sure that all producers released their buffers to safe deallocate memory (in case of worker\n+        // stopped abnormally).\n+        ringByteBuf.poll();\n+\n+        ringByteBuf.free();\n+\n+        U.closeQuiet(fileIo);\n+\n+        started = false;\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(OperationType type, int cacheId, long startTime, long duration) {\n+        doWrite(type,\n+            () -> 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheId);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        doWrite(commited ? TX_COMMIT : TX_ROLLBACK,\n+            () -> 4 + cacheIds.size() * 4 + 8 + 8,\n+            buf -> {\n+                buf.putInt(cacheIds.size());\n+\n+                GridIntIterator iter = cacheIds.iterator();\n+\n+                while (iter.hasNext())\n+                    buf.putInt(iter.next());\n+\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        byte[] textBytes = text.getBytes();\n+\n+        doWrite(QUERY,\n+            () -> 1 + 4 + textBytes.length + 4 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                buf.putInt(textBytes.length);\n+                buf.put(textBytes);\n+                buf.putLong(id);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(success ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        doWrite(QUERY_READS,\n+            () -> 1 + 16 + 8 + 8 + 8,\n+            buf -> {\n+                buf.put((byte)type.ordinal());\n+                writeUuid(buf, queryNodeId);\n+                buf.putLong(id);\n+                buf.putLong(logicalReads);\n+                buf.putLong(physicalReads);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        byte[] nameBytes = taskName.getBytes();\n+\n+        doWrite(TASK,\n+            () -> 24 + 4 + nameBytes.length + 8 + 8 + 4,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putInt(nameBytes.length);\n+                buf.put(nameBytes);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.putInt(affPartId);\n+            });\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        doWrite(JOB,\n+            () -> 24 + 8 + 8 + 8 + 1,\n+            buf -> {\n+                writeIgniteUuid(buf, sesId);\n+                buf.putLong(queuedTime);\n+                buf.putLong(startTime);\n+                buf.putLong(duration);\n+                buf.put(timedOut ? (byte)1 : 0);\n+            });\n+    }\n+\n+    /**\n+     * @param op Operation type.\n+     * @param sizeSupplier Record size supplier.\n+     * @param writer Record writer.\n+     */\n+    private void doWrite(OperationType op, IntSupplier sizeSupplier, Consumer<ByteBuffer> writer) {\n+        int size = sizeSupplier.getAsInt() + /*type*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = ringByteBuf.offer(size);\n+\n+        if (seg == null) {\n+            if (smallBufLogged.compareAndSet(false, true)) {\n+                log.warning(\"The performance statistics in-memory buffer size is too small. Some operations \" +\n+                    \"will not be logged.\");\n+            }\n+\n+            return;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled() && stopByMaxSize.compareAndSet(false, true))\n+                log.warning(\"The performance statistics file maximum size is reached.\");\n+\n+            return;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)op.ordinal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff"}, "originalPosition": 306}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5e78715df3c0aaf1f4bec3bba3fbf6418204228", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/b5e78715df3c0aaf1f4bec3bba3fbf6418204228", "committedDate": "2020-07-13T19:02:16Z", "message": "fix fsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83f7c1153ecefdc4225c6dfa3fb5b86c535c23d4", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/83f7c1153ecefdc4225c6dfa3fb5b86c535c23d4", "committedDate": "2020-07-13T19:38:48Z", "message": "Add index of operations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3ODgzNjk4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447883698", "createdAt": "2020-07-14T08:10:05Z", "commit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoxMDowNVrOGxI_VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoxMDowNVrOGxI_VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4MDY5Mg==", "bodyText": "Nit: We should firstly check read results and after flip the buffer.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454180692", "createdAt": "2020-07-14T08:10:05Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsReader.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static java.nio.file.Files.walkFileTree;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.cacheOperation;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.transactionOperation;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ */\n+public class FilePerformanceStatisticsReader {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = (int)(8 * U.MB);\n+\n+    /** Uuid as string pattern. */\n+    private static final String UUID_STR_PATTERN =\n+        \"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\";\n+\n+    /** File name pattern. */\n+    private static final Pattern FILE_PATTERN = Pattern.compile(\"^node-(\" + UUID_STR_PATTERN + \").prf$\");\n+\n+    /** IO factory. */\n+    private static final RandomAccessFileIOFactory ioFactory = new RandomAccessFileIOFactory();\n+\n+    /**\n+     * Walks over performance statistics files.\n+     *\n+     * @param filesOrDirs Files or directories.\n+     * @param handlers Handlers to process deserialized operation.\n+     */\n+    public static void read(List<File> filesOrDirs, PerformanceStatisticsHandler... handlers) throws IOException {\n+        List<File> files = resolveFiles(filesOrDirs);\n+\n+        if (files.isEmpty())\n+            return;\n+\n+        for (File file : files)\n+            readFile(file, handlers);\n+    }\n+\n+    /**\n+     * Walks over performance statistics file.\n+     *\n+     * @param file Performance statistics file.\n+     * @param handlers Handlers to process deserialized operation.\n+     */\n+    private static void readFile(File file, PerformanceStatisticsHandler... handlers) throws IOException {\n+        UUID nodeId = checkFileName(file);\n+\n+        ByteBuffer buf = allocateDirect(READ_BUFFER_SIZE).order(nativeOrder());\n+\n+        PerformanceStatisticsDeserializer des = new PerformanceStatisticsDeserializer(nodeId, handlers);\n+\n+        try (FileIO io = ioFactory.create(file)) {\n+            while (true) {\n+                int read = io.read(buf);\n+\n+                buf.flip();\n+\n+                if (read <= 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3ODg1NTI5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-447885529", "createdAt": "2020-07-14T08:12:33Z", "commit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoxMjozM1rOGxJEuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwODoxMjozM1rOGxJEuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE4MjA3Mw==", "bodyText": "We have code to calculate record size both in the writer and in the reader.\nLet's have it in one place - OperationType.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454182073", "createdAt": "2020-07-14T08:12:33Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsReader.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static java.nio.file.Files.walkFileTree;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.cacheOperation;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.transactionOperation;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ */\n+public class FilePerformanceStatisticsReader {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = (int)(8 * U.MB);\n+\n+    /** Uuid as string pattern. */\n+    private static final String UUID_STR_PATTERN =\n+        \"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\";\n+\n+    /** File name pattern. */\n+    private static final Pattern FILE_PATTERN = Pattern.compile(\"^node-(\" + UUID_STR_PATTERN + \").prf$\");\n+\n+    /** IO factory. */\n+    private static final RandomAccessFileIOFactory ioFactory = new RandomAccessFileIOFactory();\n+\n+    /**\n+     * Walks over performance statistics files.\n+     *\n+     * @param filesOrDirs Files or directories.\n+     * @param handlers Handlers to process deserialized operation.\n+     */\n+    public static void read(List<File> filesOrDirs, PerformanceStatisticsHandler... handlers) throws IOException {\n+        List<File> files = resolveFiles(filesOrDirs);\n+\n+        if (files.isEmpty())\n+            return;\n+\n+        for (File file : files)\n+            readFile(file, handlers);\n+    }\n+\n+    /**\n+     * Walks over performance statistics file.\n+     *\n+     * @param file Performance statistics file.\n+     * @param handlers Handlers to process deserialized operation.\n+     */\n+    private static void readFile(File file, PerformanceStatisticsHandler... handlers) throws IOException {\n+        UUID nodeId = checkFileName(file);\n+\n+        ByteBuffer buf = allocateDirect(READ_BUFFER_SIZE).order(nativeOrder());\n+\n+        PerformanceStatisticsDeserializer des = new PerformanceStatisticsDeserializer(nodeId, handlers);\n+\n+        try (FileIO io = ioFactory.create(file)) {\n+            while (true) {\n+                int read = io.read(buf);\n+\n+                buf.flip();\n+\n+                if (read <= 0)\n+                    break;\n+\n+                while (des.read(buf));\n+\n+                buf.compact();\n+            }\n+        }\n+        finally {\n+            GridUnsafe.cleanDirectBuffer(buf);\n+        }\n+    }\n+\n+    /** Resolves performance statistics files. */\n+    private static List<File> resolveFiles(List<File> filesOrDirs) throws IOException {\n+        if (filesOrDirs == null || filesOrDirs.isEmpty())\n+            return Collections.emptyList();\n+\n+        List<File> files = new LinkedList<>();\n+\n+        for (File file : filesOrDirs) {\n+            if (file.isDirectory()) {\n+                walkFileTree(file.toPath(), EnumSet.noneOf(FileVisitOption.class), 1,\n+                    new SimpleFileVisitor<Path>() {\n+                        @Override public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+                            if (checkFileName(path.toFile()) != null)\n+                                files.add(path.toFile());\n+\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                    });\n+\n+                continue;\n+            }\n+\n+            if (checkFileName(file) != null)\n+                files.add(file);\n+        }\n+\n+        return files;\n+    }\n+\n+    /** @return UUID node of file. {@code Null} if this is not a statistics file. */\n+    @Nullable private static UUID checkFileName(File file) {\n+        Matcher matcher = FILE_PATTERN.matcher(file.getName());\n+\n+        if (matcher.matches())\n+            return UUID.fromString(matcher.group(1));\n+\n+        return null;\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Performance statistics operations deserializer. */\n+    private static class PerformanceStatisticsDeserializer {\n+        /** Handlers to process deserialized operation. */\n+        private final PerformanceStatisticsHandler[] handlers;\n+\n+        /** Node id. */\n+        private final UUID nodeId;\n+\n+        /** @param handlers Handlers to process deserialized operation. */\n+        PerformanceStatisticsDeserializer(UUID nodeId, PerformanceStatisticsHandler... handlers) {\n+            this.nodeId = nodeId;\n+            this.handlers = handlers;\n+        }\n+\n+        /**\n+         * Tries to deserialize performance statistics operation from buffer and notify handlers.\n+         *\n+         * @param buf Buffer.\n+         * @return {@code True} if operation deserialized and handlers notified. {@code False} if not enough bytes.\n+         */\n+        boolean read(ByteBuffer buf) {\n+            int pos = buf.position();\n+\n+            if (deserialize(buf))\n+                return true;\n+\n+            buf.position(pos);\n+\n+            return false;\n+        }\n+\n+        /**\n+         * @param buf Buffer.\n+         * @return {@code True} if operation deserialized. {@code False} if not enough bytes.\n+         */\n+        private boolean deserialize(ByteBuffer buf) {\n+            if (buf.remaining() < 1)\n+                return false;\n+\n+            byte opTypeByte = buf.get();\n+\n+            OperationType opType = OperationType.fromOrdinal(opTypeByte);\n+\n+            if (cacheOperation(opType)) {\n+                if (buf.remaining() < 4 + 8 + 8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fd124f28978f710c8f313dce6ebb92d91b2f7ff"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bf16fb2ad9f3c74d811195f74f534057ec0e11b", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0bf16fb2ad9f3c74d811195f74f534057ec0e11b", "committedDate": "2020-07-14T08:24:43Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e57b8e43f4e1e5324d9e334b3800d7decd193618", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e57b8e43f4e1e5324d9e334b3800d7decd193618", "committedDate": "2020-07-14T08:36:26Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56a39389d004dfa0250441989f38e6cb50b89b7d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/56a39389d004dfa0250441989f38e6cb50b89b7d", "committedDate": "2020-07-14T08:48:43Z", "message": "Cast in the constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80cc53c16e511f6ec65a6d5a34577b0554d3844a", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/80cc53c16e511f6ec65a6d5a34577b0554d3844a", "committedDate": "2020-07-14T09:56:19Z", "message": "Record size methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdcee81cb6cd180151f33882ea5b4bb449b66a54", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/cdcee81cb6cd180151f33882ea5b4bb449b66a54", "committedDate": "2020-07-14T11:55:17Z", "message": "Refactor reader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MDQ0NTcw", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448044570", "createdAt": "2020-07-14T12:07:36Z", "commit": {"oid": "cdcee81cb6cd180151f33882ea5b4bb449b66a54"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjowNzozNlrOGxQwbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjowNzozNlrOGxQwbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMwNzk0OQ==", "bodyText": "We can use A.notEmpty here.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454307949", "createdAt": "2020-07-14T12:07:36Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsReader.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static java.nio.file.Files.walkFileTree;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.JOB;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.QUERY_READS;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TASK;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.TX_COMMIT;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.cacheOperation;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.cacheRecordSize;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.jobRecordSize;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.queryReadsRecordSize;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.queryRecordSize;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.taskRecordSize;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.transactionOperation;\n+import static org.apache.ignite.internal.processors.performancestatistics.OperationType.transactionRecordSize;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatisticsWriter\n+ */\n+public class FilePerformanceStatisticsReader {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = (int)(8 * U.MB);\n+\n+    /** Uuid as string pattern. */\n+    private static final String UUID_STR_PATTERN =\n+        \"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\";\n+\n+    /** File name pattern. */\n+    private static final Pattern FILE_PATTERN = Pattern.compile(\"^node-(\" + UUID_STR_PATTERN + \").prf$\");\n+\n+    /** IO factory. */\n+    private final RandomAccessFileIOFactory ioFactory = new RandomAccessFileIOFactory();\n+\n+    /** Handlers to process deserialized operations. */\n+    private final PerformanceStatisticsHandler[] handlers;\n+\n+    /** @param handlers Handlers to process deserialized operations. */\n+    FilePerformanceStatisticsReader(PerformanceStatisticsHandler... handlers) {\n+        A.ensure(handlers != null, \"At least one handler expected.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdcee81cb6cd180151f33882ea5b4bb449b66a54"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e56e5556cdbec0b2b338872352eb135cbe5a4f17", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e56e5556cdbec0b2b338872352eb135cbe5a4f17", "committedDate": "2020-07-14T12:15:43Z", "message": "use A.notEmpty"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MDY4MTQw", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-448068140", "createdAt": "2020-07-14T12:41:45Z", "commit": {"oid": "e56e5556cdbec0b2b338872352eb135cbe5a4f17"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjo0MTo0NVrOGxR6nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjo0MTo0NVrOGxR6nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNjk0MQ==", "bodyText": "Let's use PerformanceStatisticsMBean#start here and in the other tests.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r454326941", "createdAt": "2020-07-14T12:41:45Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/performancestatistics/AbstractPerformanceStatisticsTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.lang.management.ThreadInfo;\n+import java.util.List;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.ListeningTestLogger;\n+import org.apache.ignite.testframework.LogListener;\n+import org.apache.ignite.testframework.junits.GridAbstractTest;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatisticsWriter.PERF_STAT_DIR;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatisticsWriter.WRITER_THREAD_NAME;\n+import static org.apache.ignite.internal.processors.performancestatistics.TestFilePerformanceStatisticsReader.readToLog;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ * Ignite performance statistics abstract test.\n+ */\n+public abstract class AbstractPerformanceStatisticsTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 30_000;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        super.beforeTestsStarted();\n+\n+        U.delete(U.resolveWorkDirectory(U.defaultWorkDirectory(), PERF_STAT_DIR, false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTestsStopped() throws Exception {\n+        super.afterTestsStopped();\n+\n+        stopAllGrids();\n+\n+        U.delete(U.resolveWorkDirectory(U.defaultWorkDirectory(), PERF_STAT_DIR, false));\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    protected static void startCollectStatistics() throws Exception {\n+        List<Ignite> grids = G.allGrids();\n+\n+        assertFalse(grids.isEmpty());\n+\n+        IgniteEx ignite = (IgniteEx)grids.get(0);\n+\n+        ignite.context().performanceStatistics().startCollectStatistics();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e56e5556cdbec0b2b338872352eb135cbe5a4f17"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65c902bfe45c8981d586b2d430753a28aa42076f", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/65c902bfe45c8981d586b2d430753a28aa42076f", "committedDate": "2020-07-14T14:08:02Z", "message": "Use handlers in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd2d08c05ceb4fdab5b923dad0c129081f2a0f51", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/fd2d08c05ceb4fdab5b923dad0c129081f2a0f51", "committedDate": "2020-07-14T14:10:19Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "470587263f9bddc8dd52b14cac35fbd1bff7f4d3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/470587263f9bddc8dd52b14cac35fbd1bff7f4d3", "committedDate": "2020-07-15T07:10:47Z", "message": "Fix codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17b3df8a2acda15ad9353c3d6c75620808e9f4ae", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/17b3df8a2acda15ad9353c3d6c75620808e9f4ae", "committedDate": "2020-04-20T01:29:17Z", "message": "Ignite profiling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10753112844574b9b9aa836eaecf309ad71b4c15", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/10753112844574b9b9aa836eaecf309ad71b4c15", "committedDate": "2020-04-20T01:35:06Z", "message": "Fix merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a61eca1dd1e69359557cb33ae1c417afc83aca98", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/a61eca1dd1e69359557cb33ae1c417afc83aca98", "committedDate": "2020-04-20T21:07:43Z", "message": "Add javadocs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e1cb7602ea8fa7314e02ab077a73fbca5c4d0dc", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/6e1cb7602ea8fa7314e02ab077a73fbca5c4d0dc", "committedDate": "2020-04-21T12:39:47Z", "message": "Fix codestyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff2d64cf7278581ba75c00f044a0f3eb48dd901e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/ff2d64cf7278581ba75c00f044a0f3eb48dd901e", "committedDate": "2020-04-27T21:28:41Z", "message": "Merge branch 'master' into ignite-12666"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df42ab84bd0f9b6e522502df0cc281537aeefb23", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/df42ab84bd0f9b6e522502df0cc281537aeefb23", "committedDate": "2020-04-27T21:35:29Z", "message": "Fix codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "546998faf83e0eb64c87cac3b95985ad06ac18d6", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/546998faf83e0eb64c87cac3b95985ad06ac18d6", "committedDate": "2020-05-02T10:51:57Z", "message": "the new serializer like wal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a081e04e017bec4aeeda1addeed892caedc0ba9", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/9a081e04e017bec4aeeda1addeed892caedc0ba9", "committedDate": "2020-05-02T14:03:44Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efe3bf2d8763d4e7121191139578031b2d596044", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/efe3bf2d8763d4e7121191139578031b2d596044", "committedDate": "2020-05-03T00:03:35Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "890167ffd66369a78cbb174833ca8f4ac219625c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/890167ffd66369a78cbb174833ca8f4ac219625c", "committedDate": "2020-05-03T11:49:43Z", "message": "Merge branch 'master' into ignite-12666"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a39e6d41c2811a67ea249828d6ce93ae587777", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/35a39e6d41c2811a67ea249828d6ce93ae587777", "committedDate": "2020-05-14T23:25:39Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5aa74cec2b21793e461e514e4cac3dff5eb5bf9", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/d5aa74cec2b21793e461e514e4cac3dff5eb5bf9", "committedDate": "2020-05-15T02:31:19Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20ad83e38b25214e108a8df3f8be3653a81a1b7e", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/20ad83e38b25214e108a8df3f8be3653a81a1b7e", "committedDate": "2020-05-15T16:38:23Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "826249e6e529cecfa5ed264d2ce204247418f179", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/826249e6e529cecfa5ed264d2ce204247418f179", "committedDate": "2020-05-21T22:41:46Z", "message": "WIP. Add deserializer. One phase report build. Add tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d32af8616f224f3273db01f650a1c41abf2e2b5", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/1d32af8616f224f3273db01f650a1c41abf2e2b5", "committedDate": "2020-05-21T23:21:13Z", "message": "WIP. Revert unnecessary changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "807d4df21d79b9937feb93d287b76ae3ee1f3b8c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/807d4df21d79b9937feb93d287b76ae3ee1f3b8c", "committedDate": "2020-05-21T23:22:06Z", "message": "Merge branch 'master' into ignite-12666"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52af08015e6f4d2506433402188a0d14493afae0", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/52af08015e6f4d2506433402188a0d14493afae0", "committedDate": "2020-05-22T15:38:51Z", "message": "WIP. Use CDN links"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "016492a549e59fd2b13e1b8411bb3f26d715094c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/016492a549e59fd2b13e1b8411bb3f26d715094c", "committedDate": "2020-05-23T19:37:24Z", "message": "WIP. Codestyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c50051a11cbb5124b27da13341a98c4e4d334b59", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/c50051a11cbb5124b27da13341a98c4e4d334b59", "committedDate": "2020-05-26T09:51:56Z", "message": "WIP. Tests and renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d64b2b5a3ef059200346e9607cc391fb604fa457", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/d64b2b5a3ef059200346e9607cc391fb604fa457", "committedDate": "2020-05-27T09:11:36Z", "message": "WIP. UI refactoring. Compact strings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2d1c733e0094d861dc839c31cbbd03161fa9ce1", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/c2d1c733e0094d861dc839c31cbbd03161fa9ce1", "committedDate": "2020-05-27T11:17:06Z", "message": "WIP. Fix concurrent start timings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "138642a417e422a950e1950c32c422d860d66d27", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/138642a417e422a950e1950c32c422d860d66d27", "committedDate": "2020-05-28T15:52:58Z", "message": "WIP. Cluster info tab + one data file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5643676c04a38401f123618ca6b1193aeafa6bc", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/d5643676c04a38401f123618ca6b1193aeafa6bc", "committedDate": "2020-06-03T11:14:04Z", "message": "Fix code style + renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32e4150bb8a11221c23fc2ebd2c4f1bbd97d4987", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/32e4150bb8a11221c23fc2ebd2c4f1bbd97d4987", "committedDate": "2020-06-03T11:15:53Z", "message": "Merge branch 'master' into ignite-12666"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cf6f4c8ffe46a8f3172b0acbb54d13fa929b8ee", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0cf6f4c8ffe46a8f3172b0acbb54d13fa929b8ee", "committedDate": "2020-06-03T11:28:28Z", "message": "Add package info and readme files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4b319c0b30ae7fa4f2ca1df5de4731009671bf3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/a4b319c0b30ae7fa4f2ca1df5de4731009671bf3", "committedDate": "2020-06-04T06:37:10Z", "message": "Javadocs fix. Todo fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc", "committedDate": "2020-06-04T06:52:15Z", "message": "Exception fix."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MDMwOTEx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-426030911", "createdAt": "2020-06-08T08:52:50Z", "commit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODo1Mjo1MVrOGgUrvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOToxNDozNlrOGgVe3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0NjQ5NQ==", "bodyText": "Such nested maps are very hard to read, please introduce separate classes for internal maps.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r436546495", "createdAt": "2020-06-08T08:52:51Z", "author": {"login": "agoncharuk"}, "path": "modules/profiling/src/main/java/org/apache/ignite/internal/profiling/handlers/CacheOperationsHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.profiling.handlers;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+import static org.apache.ignite.internal.profiling.ProfilingFilesParser.currentNodeId;\n+import static org.apache.ignite.internal.profiling.util.Utils.MAPPER;\n+import static org.apache.ignite.internal.profiling.util.Utils.createArrayIfAbsent;\n+import static org.apache.ignite.internal.profiling.util.Utils.createObjectIfAbsent;\n+\n+/**\n+ * Builds JSON with aggregated cache operations statistics.\n+ *\n+ * Example:\n+ * <pre>\n+ * {\n+ *    $nodeId : {\n+ *       $cacheId : {\n+ *          $opType : [ [ $startTime, $count] ]\n+ *       }\n+ *    }\n+ * }\n+ * </pre>\n+ */\n+public class CacheOperationsHandler implements IgniteProfilingHandler {\n+    /** Field name of aggregated by caches/nodes values. */\n+    private static final String TOTAL = \"total\";\n+\n+    /** Cache operations statistics: nodeId->cacheId->opType->aggregatedResults. */\n+    private final Map<UUID, Map<Integer, Map<String, Map<Long, Integer>>>> res = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0ODQzOA==", "bodyText": "What is the reason of putting this into a separate file? There is an activity on the dev-list to extend control.sh to be able to support pluggable commands. I think it makes sense to include profiling control to control.sh instead of a separate file.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r436548438", "createdAt": "2020-06-08T08:56:11Z", "author": {"login": "agoncharuk"}, "path": "bin/profiling.sh", "diffHunk": "@@ -0,0 +1,130 @@\n+#!/usr/bin/env bash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU1NTQ2Mw==", "bodyText": "Such calculations are present at least in LogFileProfiling too, need to extract them to a single place to avoid errors.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r436555463", "createdAt": "2020-06-08T09:07:48Z", "author": {"login": "agoncharuk"}, "path": "modules/profiling/src/main/java/org/apache/ignite/internal/profiling/util/ProfilingDeserializer.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.profiling.util;\n+\n+import java.nio.ByteBuffer;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.profiling.IgniteProfiling;\n+import org.apache.ignite.internal.profiling.IgniteProfiling.CacheOperationType;\n+import org.apache.ignite.internal.profiling.LogFileProfiling;\n+import org.apache.ignite.internal.profiling.LogFileProfiling.OperationType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+import static org.apache.ignite.internal.profiling.LogFileProfiling.readIgniteUuid;\n+import static org.apache.ignite.internal.profiling.LogFileProfiling.readUuid;\n+\n+/**\n+ * Profiling operations deserializer.\n+ *\n+ * @see LogFileProfiling\n+ */\n+public class ProfilingDeserializer implements AutoCloseable {\n+    /** Cached strings by id. */\n+    private final ConcurrentHashMap<Short, String> stringById = new ConcurrentHashMap<>();\n+\n+    /** Handlers to process deserialized operation. */\n+    private final IgniteProfiling[] handlers;\n+\n+    /** @param handlers Handlers to process deserialized operation. */\n+    public ProfilingDeserializer(IgniteProfiling... handlers) {\n+        this.handlers = handlers;\n+    }\n+\n+    /**\n+     * Tries to deserialize profiling operation from buffer.\n+     *\n+     * @param buf Buffer.\n+     * @return {@code True} if operation parsed. {@code False} if not enough bytes.\n+     */\n+    public boolean deserialize(ByteBuffer buf) {\n+        int pos = buf.position();\n+\n+        if (buf.remaining() < 1)\n+            return false;\n+\n+        byte opTypeByte = buf.get();\n+\n+        OperationType opType = OperationType.fromOrdinal(opTypeByte);\n+\n+        switch (opType) {\n+            case CACHE_OPERATION: {\n+                if (buf.remaining() < 1 + 4 + 8 + 8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU1ODAxMw==", "bodyText": "Need to add a test that validates serializing-deserializing of the operations. There is no need to start Ignite, just an instance of LogFileProfiling writing all possible operations and then an instance of ProfilingDeserializer reading those logged operations.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r436558013", "createdAt": "2020-06-08T09:11:45Z", "author": {"login": "agoncharuk"}, "path": "modules/profiling/src/main/java/org/apache/ignite/internal/profiling/util/ProfilingDeserializer.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU1OTU4Mw==", "bodyText": "This relates to .js as well.\nThe report will not work without internet connection. We should consider either dropping external dependencies or packing them in tool resources so it can generate a standalone self-sufficient report.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r436559583", "createdAt": "2020-06-08T09:14:36Z", "author": {"login": "agoncharuk"}, "path": "modules/profiling/report/index.html", "diffHunk": "@@ -0,0 +1,188 @@\n+<!DOCTYPE html>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n+    <meta name=\"theme-color\" content=\"#563d7c\">\n+\n+    <title>Ignite profiling report</title>\n+\n+    <!-- Bootstrap CSS. -->\n+    <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\"\n+          integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\"\n+          crossorigin=\"anonymous\">\n+\n+    <!-- Bootstrap table. -->\n+    <link rel=\"stylesheet\" href=\"https://unpkg.com/bootstrap-table@1.16.0/dist/bootstrap-table.min.css\">\n+\n+    <!-- Bootstrap select. -->\n+    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.14/dist/css/bootstrap-select.min.css\">\n+\n+    <!-- Feather Icons. -->\n+    <link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.6.3/css/all.css\"\n+          integrity=\"sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/\"\n+          crossorigin=\"anonymous\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfb8a8cfab6b045acc5b26f686c4e4a907dcf5fc"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8901889895d1a1d9a6bda1d108452e91661eab8", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e8901889895d1a1d9a6bda1d108452e91661eab8", "committedDate": "2020-06-10T12:18:17Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c86c502ff699285b1e0b10176a7e49988bd2edf", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/9c86c502ff699285b1e0b10176a7e49988bd2edf", "committedDate": "2020-06-11T08:02:07Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7dad1d61fd8f67b947042b1563edf6cc35e5014", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/a7dad1d61fd8f67b947042b1563edf6cc35e5014", "committedDate": "2020-06-11T12:53:58Z", "message": "WIP. Remove LT, minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "605f3b912a02224073d5aace6af6304876159c89", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/605f3b912a02224073d5aace6af6304876159c89", "committedDate": "2020-06-15T07:29:54Z", "message": "Fix tests: add checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/67444c855b316cdfd9f1595b6c667037ec8446ad", "committedDate": "2020-06-15T08:30:20Z", "message": "Add tests. Use full node version."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODg4Mzgx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-434888381", "createdAt": "2020-06-22T12:47:51Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjo0Nzo1MlrOGm_GTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjo0Nzo1MlrOGm_GTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUzMjg3Nw==", "bodyText": "The word 'profiling' exists in each method of this bean. Can we remove it? start, stop, enabled seems less verbose.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443532877", "createdAt": "2020-06-22T12:47:52Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/profiling/IgniteProfilingMBean.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.profiling;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.mxbean.MXBeanDescription;\n+import org.apache.ignite.mxbean.MXBeanParameter;\n+\n+/**\n+ * MBean provide access to profiling management.\n+ */\n+@MXBeanDescription(\"MBean provide access to profiling management.\")\n+public interface IgniteProfilingMBean {\n+    /**\n+     * Start profiling in the cluster with default settings.\n+     *\n+     * @see FileProfiling#DFLT_FILE_MAX_SIZE\n+     * @see FileProfiling#DFLT_BUFFER_SIZE\n+     * @see FileProfiling#DFLT_FLUSH_SIZE\n+     */\n+    @MXBeanDescription(\"Start profiling in the cluster.\")\n+    public void startProfiling() throws IgniteCheckedException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0OTUxMDE4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-434951018", "createdAt": "2020-06-22T13:59:59Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzo1OTo1OVrOGnB5Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzo1OTo1OVrOGnB5Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU3ODY2Ng==", "bodyText": "Why we ignore cancelled operations?\nWe should gather statistics about all operations that user initiate no matter if it succeeds or failed.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443578666", "createdAt": "2020-06-22T13:59:59Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheAdapter.java", "diffHunk": "@@ -6794,6 +6899,55 @@ public InvokeAllTimeStatClosure(CacheMetricsImpl metrics, final long start) {\n         }\n     }\n \n+    /** */\n+    private class ProfileClosure<T> implements CI1<IgniteInternalFuture<T>> {\n+        /** */\n+        private static final long serialVersionUID = 0L;\n+\n+        /** Operation type. */\n+        private final CacheOperationType op;\n+\n+        /** Start time in nanoseconds. */\n+        private final long start;\n+\n+        /**\n+         * @param op Operation type.\n+         * @param start Start time in nanoseconds.\n+         */\n+        public ProfileClosure(CacheOperationType op, long start) {\n+            this.op = op;\n+            this.start = start;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void apply(IgniteInternalFuture<T> fut) {\n+            try {\n+                if (!fut.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 580}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0OTUxMzQ0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-434951344", "createdAt": "2020-06-22T14:00:18Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDowMDoxOFrOGnB6MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDowMDoxOFrOGnB6MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU3ODkyOA==", "bodyText": "Why do we need fut.get() here?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443578928", "createdAt": "2020-06-22T14:00:18Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheAdapter.java", "diffHunk": "@@ -6794,6 +6899,55 @@ public InvokeAllTimeStatClosure(CacheMetricsImpl metrics, final long start) {\n         }\n     }\n \n+    /** */\n+    private class ProfileClosure<T> implements CI1<IgniteInternalFuture<T>> {\n+        /** */\n+        private static final long serialVersionUID = 0L;\n+\n+        /** Operation type. */\n+        private final CacheOperationType op;\n+\n+        /** Start time in nanoseconds. */\n+        private final long start;\n+\n+        /**\n+         * @param op Operation type.\n+         * @param start Start time in nanoseconds.\n+         */\n+        public ProfileClosure(CacheOperationType op, long start) {\n+            this.op = op;\n+            this.start = start;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public void apply(IgniteInternalFuture<T> fut) {\n+            try {\n+                if (!fut.isCancelled()) {\n+                    fut.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 581}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0OTgwNDgy", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-434980482", "createdAt": "2020-06-22T14:30:23Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDozMDoyM1rOGnDRMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDozMDoyM1rOGnDRMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMTIwMA==", "bodyText": "We should have separate class for each operations so we can eliminate operation variable from ProfileClosure.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443601200", "createdAt": "2020-06-22T14:30:23Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheAdapter.java", "diffHunk": "@@ -3324,6 +3418,9 @@ protected void removeAll0(final Collection<? extends K> keys) throws IgniteCheck\n         if (statsEnabled)\n             fut.listen(new UpdateRemoveTimeStatClosure<>(metrics0(), start));\n \n+        if (profilingEnabled)\n+            fut.listen(new ProfileClosure<>(CacheOperationType.REMOVE_ALL, start));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 506}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MDkwNzQ3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-435090747", "createdAt": "2020-06-22T16:30:59Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozMTowMFrOGnIWnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozMTowMFrOGnIWnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NDUwOQ==", "bodyText": "I don't think we need to collect performance statistics about cache start.\nIt a rare operation that should be analyzed via log files.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443684509", "createdAt": "2020-06-22T16:31:00Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheProcessor.java", "diffHunk": "@@ -2248,6 +2248,15 @@ private void onCacheStarted(GridCacheContext cacheCtx) throws IgniteCheckedExcep\n                 \", mvcc=\" + cacheCtx.mvccEnabled() + ']');\n         }\n \n+        if (ctx.metric().profilingEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MDkzMDgx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-435093081", "createdAt": "2020-06-22T16:33:54Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozMzo1NVrOGnIdxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozMzo1NVrOGnIdxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NjM0Mw==", "bodyText": "Typo: flag name should be committed or isCommitted", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443686343", "createdAt": "2020-06-22T16:33:55Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/transactions/IgniteTxManager.java", "diffHunk": "@@ -3190,6 +3198,23 @@ private void collectInfo() {\n         }\n     }\n \n+    /**\n+     * Profiles transaction.\n+     *\n+     * @param tx Transaction.\n+     * @param commit {@code True} if transaction commited.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MDk0OTQ5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-435094949", "createdAt": "2020-06-22T16:36:15Z", "commit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozNjoxNVrOGnIjPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozNjoxNVrOGnIjPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4Nzc0MA==", "bodyText": "It seems, code that related to performance statistics should be moved to separate Manager.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r443687740", "createdAt": "2020-06-22T16:36:15Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/metric/GridMetricManager.java", "diffHunk": "@@ -234,6 +241,9 @@\n     /** Nonheap memory metrics. */\n     private final MemoryUsageMetrics nonHeap;\n \n+    /** Profiling. */\n+    private final FileProfiling profiling;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67444c855b316cdfd9f1595b6c667037ec8446ad"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32e8fe68e06b99c36dd6c64c2cc045e3e98b3736", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/32e8fe68e06b99c36dd6c64c2cc045e3e98b3736", "committedDate": "2020-06-22T18:14:29Z", "message": "Rename MBean methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b718e797dd84185296a66f1c7cafc88483648186", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/b718e797dd84185296a66f1c7cafc88483648186", "committedDate": "2020-06-22T18:51:03Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a2fcc37a9bc8fec136c5720b7112da3fe8c259f", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/2a2fcc37a9bc8fec136c5720b7112da3fe8c259f", "committedDate": "2020-06-23T10:49:36Z", "message": "Use lambda in the CacheAdapter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ac0dcf8535bde07557a6aa89eddf7a3d025c418", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/5ac0dcf8535bde07557a6aa89eddf7a3d025c418", "committedDate": "2020-06-23T13:09:00Z", "message": " Renaming step 1."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "221ed81362a32062b26ac7467eef5d02197eaa85", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/221ed81362a32062b26ac7467eef5d02197eaa85", "committedDate": "2020-06-23T14:36:48Z", "message": "Renaming step 2. Remove cacheStart profilingStart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7db0b02a8d8fec6fc16dedf4dad36f877366999d", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/7db0b02a8d8fec6fc16dedf4dad36f877366999d", "committedDate": "2020-06-23T15:59:58Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0329f8d1015dfdcb9a33ac2fd122a9b94a637e53", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0329f8d1015dfdcb9a33ac2fd122a9b94a637e53", "committedDate": "2020-06-25T22:06:40Z", "message": "Move to separate processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88", "committedDate": "2020-06-26T07:06:14Z", "message": "Minor fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDc2MDc1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438076075", "createdAt": "2020-06-26T07:36:28Z", "commit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzozNjoyOVrOGpWy9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzozNjoyOVrOGpWy9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxODI5NQ==", "bodyText": "Typo: let's use performanceStatsEnabled name here and in all other cases.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446018295", "createdAt": "2020-06-26T07:36:29Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheAdapter.java", "diffHunk": "@@ -2588,6 +2630,9 @@ public boolean put(final K key, final V val, final CacheEntryPredicate filter)\n         if (statsEnabled && stored)\n             metrics0().addPutTimeNanos(System.nanoTime() - start);\n \n+        if (performanceStatsEnabled)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "originalPosition": 233}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDc3NTY1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438077565", "createdAt": "2020-06-26T07:39:03Z", "commit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzozOTowM1rOGpW3aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzozOTowM1rOGpW3aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxOTQzMg==", "bodyText": "Typo: let's rename this to enabled", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446019432", "createdAt": "2020-06-26T07:39:03Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.util.distributed.DistributedProcess;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteFutureCancelledException;\n+import org.apache.ignite.spi.discovery.DiscoveryDataBag;\n+\n+import static org.apache.ignite.internal.GridComponent.DiscoveryDataExchangeType.PERFORMANCE_STAT_PROC;\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.PERFORMANCE_STATISTICS;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting statistics.\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Process to start/stop statistics. */\n+    private final DistributedProcess<Boolean, Boolean> proc;\n+\n+    /** Performance statistics writer. */\n+    private final FilePerformanceStatistics writer;\n+\n+    /** Synchronization mutex for request futures. */\n+    private final Object mux = new Object();\n+\n+    /** Enable/disable statistics request futures. */\n+    private final ConcurrentMap<UUID, GridFutureAdapter<Void>> reqFuts = new ConcurrentHashMap<>();\n+\n+    /** Disconnected flag. */\n+    private volatile boolean disconnected;\n+\n+    /** Stopped flag. */\n+    private volatile boolean stopped;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        writer = new FilePerformanceStatistics(ctx);\n+\n+        proc = new DistributedProcess<>(ctx, PERFORMANCE_STATISTICS, start -> {\n+            if (start) {\n+                return ctx.closure().callLocalSafe(() -> {\n+                    if (start)\n+                        writer.start();\n+\n+                    return true;\n+                });\n+            }\n+\n+            return writer.stop().chain(f -> true);\n+        }, (uuid, res, err) -> {\n+            if (!F.isEmpty(err) && statisticsEnabled())\n+                writer.stop();\n+\n+            synchronized (mux) {\n+                GridFutureAdapter<Void> fut = reqFuts.get(uuid);\n+\n+                if (fut != null) {\n+                    if (!F.isEmpty(err))\n+                        fut.onDone(new IgniteException(\"Unable to process request [err=\" + err + ']'));\n+                    else\n+                        fut.onDone();\n+                }\n+            }\n+        });\n+    }\n+\n+    /** @return Performance statistics writer. */\n+    public IgnitePerformanceStatistics writer() {\n+        return writer;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    public boolean statisticsEnabled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDc5NTk3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438079597", "createdAt": "2020-06-26T07:42:32Z", "commit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0MjozMlrOGpW9fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0MjozMlrOGpW9fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMDk5MA==", "bodyText": "Typo: let's rename it to startCollectStatistics()", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446020990", "createdAt": "2020-06-26T07:42:32Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.util.distributed.DistributedProcess;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteFutureCancelledException;\n+import org.apache.ignite.spi.discovery.DiscoveryDataBag;\n+\n+import static org.apache.ignite.internal.GridComponent.DiscoveryDataExchangeType.PERFORMANCE_STAT_PROC;\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.PERFORMANCE_STATISTICS;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting statistics.\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Process to start/stop statistics. */\n+    private final DistributedProcess<Boolean, Boolean> proc;\n+\n+    /** Performance statistics writer. */\n+    private final FilePerformanceStatistics writer;\n+\n+    /** Synchronization mutex for request futures. */\n+    private final Object mux = new Object();\n+\n+    /** Enable/disable statistics request futures. */\n+    private final ConcurrentMap<UUID, GridFutureAdapter<Void>> reqFuts = new ConcurrentHashMap<>();\n+\n+    /** Disconnected flag. */\n+    private volatile boolean disconnected;\n+\n+    /** Stopped flag. */\n+    private volatile boolean stopped;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        writer = new FilePerformanceStatistics(ctx);\n+\n+        proc = new DistributedProcess<>(ctx, PERFORMANCE_STATISTICS, start -> {\n+            if (start) {\n+                return ctx.closure().callLocalSafe(() -> {\n+                    if (start)\n+                        writer.start();\n+\n+                    return true;\n+                });\n+            }\n+\n+            return writer.stop().chain(f -> true);\n+        }, (uuid, res, err) -> {\n+            if (!F.isEmpty(err) && statisticsEnabled())\n+                writer.stop();\n+\n+            synchronized (mux) {\n+                GridFutureAdapter<Void> fut = reqFuts.get(uuid);\n+\n+                if (fut != null) {\n+                    if (!F.isEmpty(err))\n+                        fut.onDone(new IgniteException(\"Unable to process request [err=\" + err + ']'));\n+                    else\n+                        fut.onDone();\n+                }\n+            }\n+        });\n+    }\n+\n+    /** @return Performance statistics writer. */\n+    public IgnitePerformanceStatistics writer() {\n+        return writer;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    public boolean statisticsEnabled() {\n+        return writer.performanceStatisticsEnabled();\n+    }\n+\n+    /**\n+     * Starts collecting performance statistics.\n+     *\n+     * @return Future to be completed on collecting started.\n+     */\n+    public IgniteInternalFuture<Void> startStatistics() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MDc5NzU2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438079756", "createdAt": "2020-06-26T07:42:48Z", "commit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0Mjo0OFrOGpW-Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0Mjo0OFrOGpW-Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTEzNQ==", "bodyText": "Typo: let's rename it to stopCollectStatistics()", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446021135", "createdAt": "2020-06-26T07:42:48Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.util.distributed.DistributedProcess;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteFutureCancelledException;\n+import org.apache.ignite.spi.discovery.DiscoveryDataBag;\n+\n+import static org.apache.ignite.internal.GridComponent.DiscoveryDataExchangeType.PERFORMANCE_STAT_PROC;\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.PERFORMANCE_STATISTICS;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting statistics.\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Process to start/stop statistics. */\n+    private final DistributedProcess<Boolean, Boolean> proc;\n+\n+    /** Performance statistics writer. */\n+    private final FilePerformanceStatistics writer;\n+\n+    /** Synchronization mutex for request futures. */\n+    private final Object mux = new Object();\n+\n+    /** Enable/disable statistics request futures. */\n+    private final ConcurrentMap<UUID, GridFutureAdapter<Void>> reqFuts = new ConcurrentHashMap<>();\n+\n+    /** Disconnected flag. */\n+    private volatile boolean disconnected;\n+\n+    /** Stopped flag. */\n+    private volatile boolean stopped;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        writer = new FilePerformanceStatistics(ctx);\n+\n+        proc = new DistributedProcess<>(ctx, PERFORMANCE_STATISTICS, start -> {\n+            if (start) {\n+                return ctx.closure().callLocalSafe(() -> {\n+                    if (start)\n+                        writer.start();\n+\n+                    return true;\n+                });\n+            }\n+\n+            return writer.stop().chain(f -> true);\n+        }, (uuid, res, err) -> {\n+            if (!F.isEmpty(err) && statisticsEnabled())\n+                writer.stop();\n+\n+            synchronized (mux) {\n+                GridFutureAdapter<Void> fut = reqFuts.get(uuid);\n+\n+                if (fut != null) {\n+                    if (!F.isEmpty(err))\n+                        fut.onDone(new IgniteException(\"Unable to process request [err=\" + err + ']'));\n+                    else\n+                        fut.onDone();\n+                }\n+            }\n+        });\n+    }\n+\n+    /** @return Performance statistics writer. */\n+    public IgnitePerformanceStatistics writer() {\n+        return writer;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    public boolean statisticsEnabled() {\n+        return writer.performanceStatisticsEnabled();\n+    }\n+\n+    /**\n+     * Starts collecting performance statistics.\n+     *\n+     * @return Future to be completed on collecting started.\n+     */\n+    public IgniteInternalFuture<Void> startStatistics() {\n+        if (!allNodesSupports(ctx.discovery().allNodes(), IgniteFeatures.PERFORMANCE_STATISTICS)) {\n+            return new GridFinishedFuture<>(\n+                new IllegalStateException(\"Not all nodes in the cluster support collecting performance statistics.\"));\n+        }\n+\n+        GridFutureAdapter<Void> fut = new GridFutureAdapter<>();\n+\n+        UUID uuid = UUID.randomUUID();\n+\n+        synchronized (mux) {\n+            if (disconnected || stopped) {\n+                return new GridFinishedFuture<>(\n+                    new IgniteFutureCancelledException(\"Node \" + (stopped ? \"stopped\" : \"disconnected\")));\n+            }\n+\n+            reqFuts.put(uuid, fut);\n+        }\n+\n+        proc.start(uuid, true);\n+\n+        return fut;\n+    }\n+\n+    /**\n+     * Stops collecting performance statistics.\n+     *\n+     * @return Future to be completed on collecting stopped.\n+     */\n+    public IgniteInternalFuture<Void> stopStatistics() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTAwMTcz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438100173", "createdAt": "2020-06-26T08:15:28Z", "commit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODoxNToyOFrOGpX7BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODoxNToyOFrOGpX7BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzNjc0MQ==", "bodyText": "Let's encapsulate writer and introduce methods of this interface directly in the processor:\nWe may want to filter out some event later or have several writers, etc.\nThese changes should go directly in the processor and don't bother writer or core code.\n                    ctx.performanceStatistics().task(\n                        ses.getId(),\n                        ses.getTaskName(),\n                        ses.getStartTime(),\n                        U.currentTimeMillis() - ses.getStartTime(),\n                        worker.affPartId());", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446036741", "createdAt": "2020-06-26T08:15:28Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.util.distributed.DistributedProcess;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteFutureCancelledException;\n+import org.apache.ignite.spi.discovery.DiscoveryDataBag;\n+\n+import static org.apache.ignite.internal.GridComponent.DiscoveryDataExchangeType.PERFORMANCE_STAT_PROC;\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.PERFORMANCE_STATISTICS;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting statistics.\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter {\n+    /** Process to start/stop statistics. */\n+    private final DistributedProcess<Boolean, Boolean> proc;\n+\n+    /** Performance statistics writer. */\n+    private final FilePerformanceStatistics writer;\n+\n+    /** Synchronization mutex for request futures. */\n+    private final Object mux = new Object();\n+\n+    /** Enable/disable statistics request futures. */\n+    private final ConcurrentMap<UUID, GridFutureAdapter<Void>> reqFuts = new ConcurrentHashMap<>();\n+\n+    /** Disconnected flag. */\n+    private volatile boolean disconnected;\n+\n+    /** Stopped flag. */\n+    private volatile boolean stopped;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        writer = new FilePerformanceStatistics(ctx);\n+\n+        proc = new DistributedProcess<>(ctx, PERFORMANCE_STATISTICS, start -> {\n+            if (start) {\n+                return ctx.closure().callLocalSafe(() -> {\n+                    if (start)\n+                        writer.start();\n+\n+                    return true;\n+                });\n+            }\n+\n+            return writer.stop().chain(f -> true);\n+        }, (uuid, res, err) -> {\n+            if (!F.isEmpty(err) && statisticsEnabled())\n+                writer.stop();\n+\n+            synchronized (mux) {\n+                GridFutureAdapter<Void> fut = reqFuts.get(uuid);\n+\n+                if (fut != null) {\n+                    if (!F.isEmpty(err))\n+                        fut.onDone(new IgniteException(\"Unable to process request [err=\" + err + ']'));\n+                    else\n+                        fut.onDone();\n+                }\n+            }\n+        });\n+    }\n+\n+    /** @return Performance statistics writer. */\n+    public IgnitePerformanceStatistics writer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e2e2fbcf4a09661e3a7b6e64b919073c62d3f88"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd333453d3723a39cf57a303b445de357b23d98a", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/bd333453d3723a39cf57a303b445de357b23d98a", "committedDate": "2020-06-26T08:28:03Z", "message": "Renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/058cd7af8f01842c00dbd4241586b305e5a69166", "committedDate": "2020-06-26T08:33:13Z", "message": "Writer encapsulate"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTM2NDkz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438136493", "createdAt": "2020-06-26T09:08:11Z", "commit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTowODoxMlrOGpZjrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTowODoxMlrOGpZjrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA2MzUzNQ==", "bodyText": "Typo: plese, revert this change", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446063535", "createdAt": "2020-06-26T09:08:12Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/metric/GridMetricManager.java", "diffHunk": "@@ -58,8 +58,8 @@\n import org.apache.ignite.spi.metric.HistogramMetric;\n import org.apache.ignite.spi.metric.Metric;\n import org.apache.ignite.spi.metric.MetricExporterSpi;\n-import org.apache.ignite.spi.metric.ReadOnlyMetricRegistry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTUzOTk5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438153999", "createdAt": "2020-06-26T09:35:02Z", "commit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTozNTowMlrOGpaYzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTozNTowMlrOGpaYzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA3NzEzNA==", "bodyText": "Let's rename this to FilePerformanceStatisticsReader", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446077134", "createdAt": "2020-06-26T09:35:02Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWalker.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.performancestatistics.IgnitePerformanceStatistics.CacheOperationType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readIgniteUuid;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readUuid;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatistics\n+ */\n+public class FilePerformanceStatisticsWalker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTU0Mjc2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438154276", "createdAt": "2020-06-26T09:35:29Z", "commit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTozNToyOVrOGpaZlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTozNToyOVrOGpaZlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA3NzMzMw==", "bodyText": "Let's rename this to read", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446077333", "createdAt": "2020-06-26T09:35:29Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWalker.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.performancestatistics.IgnitePerformanceStatistics.CacheOperationType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readIgniteUuid;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readUuid;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatistics\n+ */\n+public class FilePerformanceStatisticsWalker {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = 8 * 1024 * 1024;\n+\n+    /** IO factory. */\n+    private static final RandomAccessFileIOFactory ioFactory = new RandomAccessFileIOFactory();\n+\n+    /**\n+     * Walks over performance statistics file.\n+     *\n+     * @param file Performance statistics file.\n+     * @param handlers Handlers to process deserialized operation.\n+     */\n+    public static void walkFile(Path file, IgnitePerformanceStatistics... handlers) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTU1OTIw", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438155920", "createdAt": "2020-06-26T09:38:02Z", "commit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTozODowMlrOGpaeeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTozODowMlrOGpaeeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA3ODU4Ng==", "bodyText": "Let's rewrite it to the while (des.deserialize(buf));", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446078586", "createdAt": "2020-06-26T09:38:02Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWalker.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.performancestatistics.IgnitePerformanceStatistics.CacheOperationType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readIgniteUuid;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readUuid;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatistics\n+ */\n+public class FilePerformanceStatisticsWalker {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = 8 * 1024 * 1024;\n+\n+    /** IO factory. */\n+    private static final RandomAccessFileIOFactory ioFactory = new RandomAccessFileIOFactory();\n+\n+    /**\n+     * Walks over performance statistics file.\n+     *\n+     * @param file Performance statistics file.\n+     * @param handlers Handlers to process deserialized operation.\n+     */\n+    public static void walkFile(Path file, IgnitePerformanceStatistics... handlers) throws IOException {\n+        ByteBuffer buf = allocateDirect(READ_BUFFER_SIZE).order(nativeOrder());\n+\n+        try (\n+            FileIO io = ioFactory.create(file.toFile());\n+            PerformanceStatisticsDeserializer des = new PerformanceStatisticsDeserializer(handlers)\n+        ) {\n+            while (true) {\n+                int read = io.read(buf);\n+\n+                buf.flip();\n+\n+                if (read <= 0)\n+                    break;\n+\n+                while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTY5Mzcz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438169373", "createdAt": "2020-06-26T09:59:03Z", "commit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1OTowM1rOGpbHPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwOTo1OTowM1rOGpbHPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4OTAyMg==", "bodyText": "We should support the case when file represents a directory", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446089022", "createdAt": "2020-06-26T09:59:03Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWalker.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.performancestatistics.IgnitePerformanceStatistics.CacheOperationType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.GridUnsafe;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+import static java.nio.ByteBuffer.allocateDirect;\n+import static java.nio.ByteOrder.nativeOrder;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readIgniteUuid;\n+import static org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatistics.readUuid;\n+\n+/**\n+ * Walker over the performance statistics file.\n+ *\n+ * @see FilePerformanceStatistics\n+ */\n+public class FilePerformanceStatisticsWalker {\n+    /** File read buffer size. */\n+    private static final int READ_BUFFER_SIZE = 8 * 1024 * 1024;\n+\n+    /** IO factory. */\n+    private static final RandomAccessFileIOFactory ioFactory = new RandomAccessFileIOFactory();\n+\n+    /**\n+     * Walks over performance statistics file.\n+     *\n+     * @param file Performance statistics file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "058cd7af8f01842c00dbd4241586b305e5a69166"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/5d3fa84d04e82a831b48190409aa75fea74794f2", "committedDate": "2020-06-26T10:00:30Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTg2MTAz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438186103", "createdAt": "2020-06-26T10:26:50Z", "commit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDoyNjo1MVrOGpb5JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDoyNjo1MVrOGpb5JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwMTc5Ng==", "bodyText": "Typo: finally should be on new line.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446101796", "createdAt": "2020-06-26T10:26:51Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/GridCacheDistributedQueryManager.java", "diffHunk": "@@ -198,54 +201,74 @@ protected void removeQueryFuture(long reqId) {\n         assert req.mvccSnapshot() != null || !cctx.mvccEnabled() || req.cancel() ||\n             (req.type() == null && !req.fields()) : req; // Last assertion means next page request.\n \n-        if (req.cancel()) {\n-            cancelIds.add(new CancelMessageId(req.id(), sndId));\n+        boolean performanceStatsEnabled = cctx.kernalContext().performanceStatistics().enabled();\n \n-            if (req.fields())\n-                removeFieldsQueryResult(sndId, req.id());\n-            else\n-                removeQueryResult(sndId, req.id());\n-        }\n-        else {\n-            if (!cancelIds.contains(new CancelMessageId(req.id(), sndId))) {\n-                if (!F.eq(req.cacheName(), cctx.name())) {\n-                    GridCacheQueryResponse res = new GridCacheQueryResponse(\n-                        cctx.cacheId(),\n-                        req.id(),\n-                        new IgniteCheckedException(\"Received request for incorrect cache [expected=\" + cctx.name() +\n-                            \", actual=\" + req.cacheName()),\n-                        cctx.deploymentEnabled());\n+        if (performanceStatsEnabled)\n+            IoStatisticsQueryHelper.startGatheringQueryStatistics();\n \n-                    sendQueryResponse(sndId, res, 0);\n-                }\n-                else {\n-                    threads.put(req.id(), Thread.currentThread());\n+        try {\n+            if (req.cancel()) {\n+                cancelIds.add(new CancelMessageId(req.id(), sndId));\n \n-                    try {\n-                        GridCacheQueryInfo info = distributedQueryInfo(sndId, req);\n+                if (req.fields())\n+                    removeFieldsQueryResult(sndId, req.id());\n+                else\n+                    removeQueryResult(sndId, req.id());\n+            }\n+            else {\n+                if (!cancelIds.contains(new CancelMessageId(req.id(), sndId))) {\n+                    if (!F.eq(req.cacheName(), cctx.name())) {\n+                        GridCacheQueryResponse res = new GridCacheQueryResponse(\n+                            cctx.cacheId(),\n+                            req.id(),\n+                            new IgniteCheckedException(\"Received request for incorrect cache [expected=\" + cctx.name() +\n+                                \", actual=\" + req.cacheName()),\n+                            cctx.deploymentEnabled());\n+\n+                        sendQueryResponse(sndId, res, 0);\n+                    }\n+                    else {\n+                        threads.put(req.id(), Thread.currentThread());\n \n-                        if (info == null)\n-                            return;\n+                        try {\n+                            GridCacheQueryInfo info = distributedQueryInfo(sndId, req);\n \n-                        if (req.fields())\n-                            runFieldsQuery(info);\n-                        else\n-                            runQuery(info);\n-                    }\n-                    catch (Throwable e) {\n-                        U.error(log(), \"Failed to run query.\", e);\n+                            if (info == null)\n+                                return;\n+\n+                            if (req.fields())\n+                                runFieldsQuery(info);\n+                            else\n+                                runQuery(info);\n+                        }\n+                        catch (Throwable e) {\n+                            U.error(log(), \"Failed to run query.\", e);\n \n-                        sendQueryResponse(sndId, new GridCacheQueryResponse(cctx.cacheId(), req.id(), e.getCause(),\n-                            cctx.deploymentEnabled()), 0);\n+                            sendQueryResponse(sndId, new GridCacheQueryResponse(cctx.cacheId(), req.id(), e.getCause(),\n+                                cctx.deploymentEnabled()), 0);\n \n-                        if (e instanceof Error)\n-                            throw (Error)e;\n-                    }\n-                    finally {\n-                        threads.remove(req.id());\n+                            if (e instanceof Error)\n+                                throw (Error)e;\n+                        }\n+                        finally {\n+                            threads.remove(req.id());\n+                        }\n                     }\n                 }\n             }\n+        } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MTk1OTc2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438195976", "createdAt": "2020-06-26T10:45:01Z", "commit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDo0NTowMVrOGpcWxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDo0NTowMVrOGpcWxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEwOTM4Mg==", "bodyText": "Typo: this can be rewritten as else if (!cancelIds.contains(new CancelMessageId(req.id(), sndId))) { to reduce one indentation level.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446109382", "createdAt": "2020-06-26T10:45:01Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/GridCacheDistributedQueryManager.java", "diffHunk": "@@ -198,54 +201,74 @@ protected void removeQueryFuture(long reqId) {\n         assert req.mvccSnapshot() != null || !cctx.mvccEnabled() || req.cancel() ||\n             (req.type() == null && !req.fields()) : req; // Last assertion means next page request.\n \n-        if (req.cancel()) {\n-            cancelIds.add(new CancelMessageId(req.id(), sndId));\n+        boolean performanceStatsEnabled = cctx.kernalContext().performanceStatistics().enabled();\n \n-            if (req.fields())\n-                removeFieldsQueryResult(sndId, req.id());\n-            else\n-                removeQueryResult(sndId, req.id());\n-        }\n-        else {\n-            if (!cancelIds.contains(new CancelMessageId(req.id(), sndId))) {\n-                if (!F.eq(req.cacheName(), cctx.name())) {\n-                    GridCacheQueryResponse res = new GridCacheQueryResponse(\n-                        cctx.cacheId(),\n-                        req.id(),\n-                        new IgniteCheckedException(\"Received request for incorrect cache [expected=\" + cctx.name() +\n-                            \", actual=\" + req.cacheName()),\n-                        cctx.deploymentEnabled());\n+        if (performanceStatsEnabled)\n+            IoStatisticsQueryHelper.startGatheringQueryStatistics();\n \n-                    sendQueryResponse(sndId, res, 0);\n-                }\n-                else {\n-                    threads.put(req.id(), Thread.currentThread());\n+        try {\n+            if (req.cancel()) {\n+                cancelIds.add(new CancelMessageId(req.id(), sndId));\n \n-                    try {\n-                        GridCacheQueryInfo info = distributedQueryInfo(sndId, req);\n+                if (req.fields())\n+                    removeFieldsQueryResult(sndId, req.id());\n+                else\n+                    removeQueryResult(sndId, req.id());\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MjAxMDIx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438201021", "createdAt": "2020-06-26T10:54:41Z", "commit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDo1NDo0MVrOGpclpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMDo1NDo0MVrOGpclpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjExMzE5MQ==", "bodyText": "Why we do this inside if (!worker.isInternal()) {?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446113191", "createdAt": "2020-06-26T10:54:41Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/job/GridJobProcessor.java", "diffHunk": "@@ -2020,6 +2020,14 @@ else if (removeFromActive(jobWorker)) {\n                         rwLock.readUnlock();\n                     }\n                 }\n+\n+                if (ctx.performanceStatistics().enabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d3fa84d04e82a831b48190409aa75fea74794f2"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4adb5737a6d7627914ae69b81999e7c97541609c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/4adb5737a6d7627914ae69b81999e7c97541609c", "committedDate": "2020-06-26T11:07:43Z", "message": "Multiple files reader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f04f08d9553fd8e2a8d249c64c595d15afc15e8", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/1f04f08d9553fd8e2a8d249c64c595d15afc15e8", "committedDate": "2020-06-26T11:11:10Z", "message": "Review fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e3eb66f7f3b2335cee6533487d27afd3a8739cb", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/4e3eb66f7f3b2335cee6533487d27afd3a8739cb", "committedDate": "2020-06-26T11:18:09Z", "message": "Merge branch 'master' into ignite-12666\n\n# Conflicts:\n#\tmodules/core/src/main/java/org/apache/ignite/internal/IgniteFeatures.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4", "committedDate": "2020-06-26T11:22:19Z", "message": "Write internal tasks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MjI1MjM4", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438225238", "createdAt": "2020-06-26T11:38:48Z", "commit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozODo0OFrOGpdtQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozODo0OFrOGpdtQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzMTUyMQ==", "bodyText": "Let's rename this to FilePerformanceStatisticsWriter", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446131521", "createdAt": "2020-06-26T11:38:48Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatistics.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatistics implements IgnitePerformanceStatistics {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MjMxMzMz", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438231333", "createdAt": "2020-06-26T11:50:15Z", "commit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo1MDoxNVrOGpd_mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo1MDoxNVrOGpd_mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNjIxNw==", "bodyText": "This interface should be in org.apache.ignite.mxbean.\nAlso, let's mark all public API with the @IgniteExperimental.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446136217", "createdAt": "2020-06-26T11:50:15Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/IgnitePerformanceStatisticsMBean.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.mxbean.MXBeanDescription;\n+\n+/**\n+ * MBean that provides access to performance statistics management.\n+ */\n+@MXBeanDescription(\"MBean provide access to performance statistics management.\")\n+public interface IgnitePerformanceStatisticsMBean {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4MjMzMDQ5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-438233049", "createdAt": "2020-06-26T11:53:19Z", "commit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo1MzoxOVrOGpeEgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTo1MzoxOVrOGpeEgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEzNzQ3Mg==", "bodyText": "Typo: MbeanImpl -> MBeanImpl", "url": "https://github.com/apache/ignite/pull/7693#discussion_r446137472", "createdAt": "2020-06-26T11:53:19Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/IgnitePerformanceStatisticsMbeanImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.internal.GridKernalContext;\n+\n+/**\n+ * {@link IgnitePerformanceStatisticsMBean} implementation.\n+ */\n+public class IgnitePerformanceStatisticsMbeanImpl implements IgnitePerformanceStatisticsMBean {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5ac5f2e05611ff990a33730c7dbf91cc5ef3c4"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ba68bb6e5ea562b5a91db752d7bc4fc441f14e2", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/6ba68bb6e5ea562b5a91db752d7bc4fc441f14e2", "committedDate": "2020-06-26T12:01:52Z", "message": "Review fixes + stopping on max file size fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b1ec0bcbf3473670a9227c5e8ba39c58c0c914c", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/5b1ec0bcbf3473670a9227c5e8ba39c58c0c914c", "committedDate": "2020-06-26T12:11:10Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f979b41d84c7751647c3a4582932f5d8ea275eb", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/5f979b41d84c7751647c3a4582932f5d8ea275eb", "committedDate": "2020-06-26T12:12:17Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b4df908ad69b3383dcf03cdd7119f4b04a84d06", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/0b4df908ad69b3383dcf03cdd7119f4b04a84d06", "committedDate": "2020-06-26T12:17:40Z", "message": "Fix cancelling req future"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f94020f754d002283a3b7dbb7f8578e54af34582", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/f94020f754d002283a3b7dbb7f8578e54af34582", "committedDate": "2020-06-26T14:01:03Z", "message": "Codestyle fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjE2MDAx", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-439216001", "createdAt": "2020-06-29T14:43:23Z", "commit": {"oid": "0b4df908ad69b3383dcf03cdd7119f4b04a84d06"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo0MzoyNFrOGqUSFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo0MzoyNFrOGqUSFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNTY4Nw==", "bodyText": "Let's rename this to PerformanceStatisticsHandler.\nAlso, this is part of the public API, right?\nIf yes, then\n\nit should be located in org.apache.ignite.performancestatistics.\nlet's mark this with the @IgniteExperimental.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r447025687", "createdAt": "2020-06-29T14:43:24Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/IgnitePerformanceStatistics.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * The interface represents performance statistics operations collection for purposes of troubleshooting and\n+ * performance analysis.\n+ */\n+public interface IgnitePerformanceStatistics {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b4df908ad69b3383dcf03cdd7119f4b04a84d06"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjI0ODU2", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-439224856", "createdAt": "2020-06-29T14:52:26Z", "commit": {"oid": "0b4df908ad69b3383dcf03cdd7119f4b04a84d06"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo1MjoyNlrOGqUsPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDo1MjoyNlrOGqUsPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjM4Mg==", "bodyText": "Why do we need DistributedProcess here?\nWhat is the \"process\" here in the first place?\nLet's implement this as 'DistributedMetaStorage' listener.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r447032382", "createdAt": "2020-06-29T14:52:26Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformaceStatisticsProcessor.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteFeatures;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.processors.GridProcessorAdapter;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.distributed.DistributedProcess;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.lang.IgniteFuture;\n+import org.apache.ignite.lang.IgniteFutureCancelledException;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.spi.discovery.DiscoveryDataBag;\n+\n+import static org.apache.ignite.internal.GridComponent.DiscoveryDataExchangeType.PERFORMANCE_STAT_PROC;\n+import static org.apache.ignite.internal.IgniteFeatures.allNodesSupports;\n+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.PERFORMANCE_STATISTICS;\n+\n+/**\n+ * Performance statistics processor.\n+ * <p>\n+ * Manages collecting statistics.\n+ */\n+public class PerformaceStatisticsProcessor extends GridProcessorAdapter implements IgnitePerformanceStatistics {\n+    /** Process to start/stop statistics. */\n+    private final DistributedProcess<Boolean, Boolean> proc;\n+\n+    /** Performance statistics writer. */\n+    private final FilePerformanceStatisticsWriter writer;\n+\n+    /** Synchronization mutex for request futures. */\n+    private final Object mux = new Object();\n+\n+    /** Enable/disable statistics request futures. */\n+    private final ConcurrentMap<UUID, GridFutureAdapter<Void>> reqFuts = new ConcurrentHashMap<>();\n+\n+    /** Disconnected flag. */\n+    private volatile boolean disconnected;\n+\n+    /** Stopped flag. */\n+    private volatile boolean stopped;\n+\n+    /** @param ctx Kernal context. */\n+    public PerformaceStatisticsProcessor(GridKernalContext ctx) {\n+        super(ctx);\n+\n+        writer = new FilePerformanceStatisticsWriter(ctx);\n+\n+        proc = new DistributedProcess<>(ctx, PERFORMANCE_STATISTICS, start -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b4df908ad69b3383dcf03cdd7119f4b04a84d06"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9c0c32907ae7f4ef428b78d5dfee2321bb2b892", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/f9c0c32907ae7f4ef428b78d5dfee2321bb2b892", "committedDate": "2020-06-30T05:39:28Z", "message": "Use metastore + renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7196cbde628798b4af6b1c4c6b5135756cad4c78", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/7196cbde628798b4af6b1c4c6b5135756cad4c78", "committedDate": "2020-06-30T05:53:19Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48baa82559a312f716b444acfc20aa46aec03ed3", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/48baa82559a312f716b444acfc20aa46aec03ed3", "committedDate": "2020-06-30T05:58:07Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08f8f49a08371437f7083607919e2623647cb491", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/08f8f49a08371437f7083607919e2623647cb491", "committedDate": "2020-06-30T08:23:48Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efd562d555f9f6963cd93f441800b2a420c7ba7f", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/efd562d555f9f6963cd93f441800b2a420c7ba7f", "committedDate": "2020-06-30T08:25:52Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/e7e8511a51577587a8a4a7128fe429a9af281981", "committedDate": "2020-07-02T06:43:27Z", "message": "Fix codestyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDgwMDU5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441480059", "createdAt": "2020-07-02T08:53:01Z", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo1MzowMlrOGsDrWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo1MzowMlrOGsDrWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1MDc3Ng==", "bodyText": "AFAIK we don't need package descriptions for internal packages.\nLet's remove this file.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448850776", "createdAt": "2020-07-02T08:53:02Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/package-info.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * <!-- Package description. -->\n+ * Contains classes for Ignite performance statistics.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDgwNTc1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441480575", "createdAt": "2020-07-02T08:53:42Z", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo1Mzo0MlrOGsDswA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODo1Mzo0MlrOGsDswA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1MTEzNg==", "bodyText": "AFAIK we don't need package descriptions for internal packages.\nLet's remove this file.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448851136", "createdAt": "2020-07-02T08:53:42Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/performancestatistics/package-info.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * <!-- Package description. -->\n+ * Ignite performance statistics tests.\n+ */\n+\n+package org.apache.ignite.internal.performancestatistics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDg2MzE0", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441486314", "createdAt": "2020-07-02T09:00:52Z", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTowMDo1MlrOGsD-Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTowMDo1MlrOGsD-Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1NTYzOA==", "bodyText": "Let's rename this to started", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448855638", "createdAt": "2020-07-02T09:00:52Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/mxbean/PerformanceStatisticsMBean.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.mxbean;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.internal.processors.performancestatistics.FilePerformanceStatisticsWriter;\n+import org.apache.ignite.lang.IgniteExperimental;\n+\n+/**\n+ * MBean that provides access to performance statistics management.\n+ */\n+@IgniteExperimental\n+@MXBeanDescription(\"MBean provide access to performance statistics management.\")\n+public interface PerformanceStatisticsMBean {\n+    /**\n+     * Start collecting performance statistics in the cluster with default settings.\n+     *\n+     * @see FilePerformanceStatisticsWriter#DFLT_FILE_MAX_SIZE\n+     * @see FilePerformanceStatisticsWriter#DFLT_BUFFER_SIZE\n+     * @see FilePerformanceStatisticsWriter#DFLT_FLUSH_SIZE\n+     */\n+    @MXBeanDescription(\"Start collecting performance statistics in the cluster.\")\n+    public void start() throws IgniteCheckedException;\n+\n+    /** Stop collecting performance statistics in the cluster. */\n+    @MXBeanDescription(\"Stop collecting performance statistics in the cluster.\")\n+    public void stop() throws IgniteCheckedException;\n+\n+    /** @return {@code True} if collecting performance statistics is enabled. */\n+    @MXBeanDescription(\"True if collecting performance statistics is enabled.\")\n+    public boolean enabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDg3NzQ3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441487747", "createdAt": "2020-07-02T09:02:36Z", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTowMjozNlrOGsECeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTowMjozNlrOGsECeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1NjY5Ng==", "bodyText": "Let's rename this to CacheOperation", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448856696", "createdAt": "2020-07-02T09:02:36Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsHandler.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * The interface represents performance statistics operations collection for purposes of troubleshooting and\n+ * performance analysis.\n+ */\n+public interface PerformanceStatisticsHandler {\n+    /**\n+     * @param nodeId Node id.\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    void cacheOperation(UUID nodeId, CacheOperationType type, int cacheId, long startTime, long duration);\n+\n+    /**\n+     * @param nodeId Node id.\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commit {@code True} if commited.\n+     */\n+    void transaction(UUID nodeId, GridIntList cacheIds, long startTime, long duration, boolean commit);\n+\n+    /**\n+     * @param nodeId Node id.\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    void query(UUID nodeId, GridCacheQueryType type, String text, long id, long startTime, long duration,\n+        boolean success);\n+\n+    /**\n+     * @param nodeId Node id.\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    void queryReads(UUID nodeId, GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads,\n+        long physicalReads);\n+\n+    /**\n+     * @param nodeId Node id.\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    void task(UUID nodeId, IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId);\n+\n+    /**\n+     * @param nodeId Node id.\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    void job(UUID nodeId, IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut);\n+\n+    /** Cache operations types. */\n+    public enum CacheOperationType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDkxNjQ3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441491647", "createdAt": "2020-07-02T09:07:40Z", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTowNzo0MFrOGsEOEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOTowNzo0MFrOGsEOEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1OTY2Ng==", "bodyText": "This flag should be named committed", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448859666", "createdAt": "2020-07-02T09:07:40Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/PerformanceStatisticsHandler.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * The interface represents performance statistics operations collection for purposes of troubleshooting and\n+ * performance analysis.\n+ */\n+public interface PerformanceStatisticsHandler {\n+    /**\n+     * @param nodeId Node id.\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    void cacheOperation(UUID nodeId, CacheOperationType type, int cacheId, long startTime, long duration);\n+\n+    /**\n+     * @param nodeId Node id.\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commit {@code True} if commited.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNDk4MTUy", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441498152", "createdAt": "2020-07-02T09:16:13Z", "commit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOToxNjoxNFrOGsEhrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwOToxNjoxNFrOGsEhrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2NDY4Nw==", "bodyText": "Let's make this enum not internal.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448864687", "createdAt": "2020-07-02T09:16:14Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.performancestatistics.PerformanceStatisticsHandler.CacheOperationType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        assert fileWriter == null;\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileIo.position(0);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            return fileWriter.shutdown();\n+\n+        return new GridFinishedFuture<>();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperationType type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.putInt(cacheId);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commit {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commit) {\n+        int size = /*cacheIds*/ 4 + cacheIds.size() * 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*commit*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TRANSACTION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.putInt(cacheIds.size());\n+\n+        GridIntIterator iter = cacheIds.iterator();\n+\n+        while (iter.hasNext())\n+            buf.putInt(iter.next());\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(commit ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(text);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*type*/ 1 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*id*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*success*/ 1;\n+\n+        if (needWriteStr) {\n+            strBytes = text.getBytes();\n+\n+            size += /*text*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(text);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(id);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(success ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        int size = /*type*/ 1 +\n+            /*queryNodeId*/ 16 +\n+            /*id*/ 8 +\n+            /*logicalReads*/ 8 +\n+            /*physicalReads*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY_READS, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        writeUuid(buf, queryNodeId);\n+        buf.putLong(id);\n+        buf.putLong(logicalReads);\n+        buf.putLong(physicalReads);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(taskName);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*sesId*/ 24 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*affPartId*/ 4;\n+\n+        if (needWriteStr) {\n+            strBytes = taskName.getBytes();\n+\n+            size += /*taskName*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(taskName);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TASK, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.putInt(affPartId);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        int size = /*sesId*/ 24 +\n+            /*queuedTime*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*timedOut*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.JOB, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.putLong(queuedTime);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(timedOut ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(OperationType type, int size) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return null;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Maximum cached string count. */\n+        private static final short MAX_CACHED_STRING_COUNT = Short.MAX_VALUE;\n+\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Stop file writer future. */\n+        GridFutureAdapter<Void> stopFut = new GridFutureAdapter<>();\n+\n+        /** Cached strings by id. */\n+        private final ConcurrentHashMap<String, Short> stringIds = new ConcurrentHashMap<>();\n+\n+        /** String id generator. */\n+        private final AtomicInteger idsGen = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled() && !Thread.interrupted()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+\n+                    flushBuffer();\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+            }\n+\n+            fileWriter = null;\n+\n+            ringByteBuffer.close();\n+\n+            // Make sure that all producers released their buffers to safe deallocate memory.\n+            ringByteBuffer.poll();\n+\n+            ringByteBuffer.free();\n+\n+            U.closeQuiet(fileIo);\n+\n+            stringIds.clear();\n+\n+            stopFut.onDone();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+\n+        /** @return Unique per file string identifier. {@code Null} if there is no cached identifier. */\n+        Short stringId(String str) {\n+            return stringIds.get(str);\n+        }\n+\n+        /** @return Generate unique per file string identifier. {@code -1} if max cached limit exceeded. */\n+        short generateStringId(String str) {\n+            if (idsGen.get() > MAX_CACHED_STRING_COUNT)\n+                return -1;\n+\n+            return stringIds.computeIfAbsent(str,\n+                s -> (short)idsGen.updateAndGet(id -> id < MAX_CACHED_STRING_COUNT ? id + 1 : -1));\n+        }\n+\n+        /** @return Write segment.*/\n+        SegmentedRingByteBuffer.WriteSegment writeSegment(int size) {\n+            SegmentedRingByteBuffer.WriteSegment seg = ringByteBuffer.offer(size);\n+\n+            if (seg != null) {\n+                int readySize = readyForFlushSize.addAndGet(size);\n+\n+                if (readySize >= DFLT_FLUSH_SIZE) {\n+                    synchronized (this) {\n+                        notify();\n+                    }\n+                }\n+            }\n+\n+            return seg;\n+        }\n+\n+        /** Flushes to disk available bytes from the ring buffer. */\n+        private void flushBuffer() {\n+            List<SegmentedRingByteBuffer.ReadSegment> segs = ringByteBuffer.poll();\n+\n+            if (segs == null)\n+                return;\n+\n+            try {\n+                for (int i = 0; i < segs.size(); i++) {\n+                    SegmentedRingByteBuffer.ReadSegment seg = segs.get(i);\n+\n+                    try {\n+                        readyForFlushSize.addAndGet(-seg.buffer().remaining());\n+\n+                        fileIo.writeFully(seg.buffer());\n+                    }\n+                    finally {\n+                        seg.release();\n+                    }\n+                }\n+\n+                fileIo.force();\n+            } catch (IOException e) {\n+                log.error(\"Unable to write to file. Performance statistics collecting will be stopped.\", e);\n+\n+                fileWriter.shutdown();\n+\n+                stopStatistics();\n+            }\n+        }\n+\n+        /** Shutted down the worker. */\n+        private IgniteInternalFuture<Void> shutdown() {\n+            isCancelled = true;\n+\n+            synchronized (this) {\n+                notify();\n+            }\n+\n+            return stopFut;\n+        }\n+\n+        /** Logs warning message about small buffer size if not logged yet. */\n+        void logSmallBufferMessage() {\n+            if (smallBufLogged.compareAndSet(false, true)) {\n+                log.warning(\"The performance statistics in-memory buffer size is too small. Some operations \" +\n+                    \"will not be logged.\");\n+            }\n+        }\n+\n+        /** Logs warning message and stops collecting statistics. */\n+        void onMaxFileSizeReached() {\n+            if (stopByMaxSize.compareAndSet(false, true)) {\n+                fileWriter.shutdown();\n+\n+                stopStatistics();\n+\n+                log.warning(\"The performance statistics file maximum size is reached. \" +\n+                    \"Performance statistics collecting will be stopped.\");\n+            }\n+        }\n+\n+        /** Stops collecting statistics. */\n+        void stopStatistics() {\n+            try {\n+                ctx.performanceStatistics().stopCollectStatistics();\n+            }\n+            catch (IgniteCheckedException e) {\n+                log.error(\"Failed to stop performance statistics.\", e);\n+            }\n+        }\n+    }\n+\n+    /** Operation type. */\n+    public enum OperationType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7e8511a51577587a8a4a7128fe429a9af281981"}, "originalPosition": 663}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "870ac68912e8142c99bc3a276e0f9a7ca6434abe", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/870ac68912e8142c99bc3a276e0f9a7ca6434abe", "committedDate": "2020-07-02T09:22:19Z", "message": "Review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/15dcf55d7542987a0916aaec1f8647c9ac225ac7", "committedDate": "2020-07-02T09:35:51Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjM4NDY5", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441638469", "createdAt": "2020-07-02T12:40:35Z", "commit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo0MDozNVrOGsLChw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo0MDozNVrOGsLChw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MTM5OQ==", "bodyText": "Can we rewrite flow a bit to make this code more readable.\nif (fileWriter == null)\n    return new GridFinishedFuture<>();\n\nreturn fileWriter.shutdown();", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448971399", "createdAt": "2020-07-02T12:40:35Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,660 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        assert fileWriter == null;\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileIo.position(0);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjM5MzM1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441639335", "createdAt": "2020-07-02T12:41:41Z", "commit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo0MTo0MlrOGsLFDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo0MTo0MlrOGsLFDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MjA0Ng==", "bodyText": "The essence of this assert is not clear for me.\nCan you, please, clarify it?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448972046", "createdAt": "2020-07-02T12:41:42Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,660 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        assert fileWriter == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjUwMDY3", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441650067", "createdAt": "2020-07-02T12:55:38Z", "commit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo1NTozOFrOGsLlkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo1NTozOFrOGsLlkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4MDM3MA==", "bodyText": "Why flushBuffer is in blocking section?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448980370", "createdAt": "2020-07-02T12:55:38Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,660 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        assert fileWriter == null;\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileIo.position(0);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            return fileWriter.shutdown();\n+\n+        return new GridFinishedFuture<>();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.putInt(cacheId);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        int size = /*cacheIds*/ 4 + cacheIds.size() * 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*commit*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TRANSACTION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.putInt(cacheIds.size());\n+\n+        GridIntIterator iter = cacheIds.iterator();\n+\n+        while (iter.hasNext())\n+            buf.putInt(iter.next());\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(commited ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(text);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*type*/ 1 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*id*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*success*/ 1;\n+\n+        if (needWriteStr) {\n+            strBytes = text.getBytes();\n+\n+            size += /*text*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(text);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(id);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(success ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        int size = /*type*/ 1 +\n+            /*queryNodeId*/ 16 +\n+            /*id*/ 8 +\n+            /*logicalReads*/ 8 +\n+            /*physicalReads*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY_READS, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        writeUuid(buf, queryNodeId);\n+        buf.putLong(id);\n+        buf.putLong(logicalReads);\n+        buf.putLong(physicalReads);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(taskName);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*sesId*/ 24 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*affPartId*/ 4;\n+\n+        if (needWriteStr) {\n+            strBytes = taskName.getBytes();\n+\n+            size += /*taskName*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(taskName);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TASK, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.putInt(affPartId);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        int size = /*sesId*/ 24 +\n+            /*queuedTime*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*timedOut*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.JOB, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.putLong(queuedTime);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(timedOut ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(OperationType type, int size) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return null;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Maximum cached string count. */\n+        private static final short MAX_CACHED_STRING_COUNT = Short.MAX_VALUE;\n+\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Stop file writer future. */\n+        GridFutureAdapter<Void> stopFut = new GridFutureAdapter<>();\n+\n+        /** Cached strings by id. */\n+        private final ConcurrentHashMap<String, Short> stringIds = new ConcurrentHashMap<>();\n+\n+        /** String id generator. */\n+        private final AtomicInteger idsGen = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled() && !Thread.interrupted()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+\n+                    flushBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "originalPosition": 532}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjUyNDU1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441652455", "createdAt": "2020-07-02T12:58:34Z", "commit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo1ODozNVrOGsLsxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo1ODozNVrOGsLsxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4MjIxMg==", "bodyText": "Why do we need to check Thread.interrupted here?", "url": "https://github.com/apache/ignite/pull/7693#discussion_r448982212", "createdAt": "2020-07-02T12:58:35Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,660 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        assert fileWriter == null;\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileIo.position(0);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            return fileWriter.shutdown();\n+\n+        return new GridFinishedFuture<>();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.putInt(cacheId);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        int size = /*cacheIds*/ 4 + cacheIds.size() * 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*commit*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TRANSACTION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.putInt(cacheIds.size());\n+\n+        GridIntIterator iter = cacheIds.iterator();\n+\n+        while (iter.hasNext())\n+            buf.putInt(iter.next());\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(commited ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(text);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*type*/ 1 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*id*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*success*/ 1;\n+\n+        if (needWriteStr) {\n+            strBytes = text.getBytes();\n+\n+            size += /*text*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(text);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(id);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(success ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        int size = /*type*/ 1 +\n+            /*queryNodeId*/ 16 +\n+            /*id*/ 8 +\n+            /*logicalReads*/ 8 +\n+            /*physicalReads*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY_READS, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        writeUuid(buf, queryNodeId);\n+        buf.putLong(id);\n+        buf.putLong(logicalReads);\n+        buf.putLong(physicalReads);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(taskName);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*sesId*/ 24 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*affPartId*/ 4;\n+\n+        if (needWriteStr) {\n+            strBytes = taskName.getBytes();\n+\n+            size += /*taskName*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(taskName);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TASK, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.putInt(affPartId);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        int size = /*sesId*/ 24 +\n+            /*queuedTime*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*timedOut*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.JOB, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.putLong(queuedTime);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(timedOut ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(OperationType type, int size) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return null;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Maximum cached string count. */\n+        private static final short MAX_CACHED_STRING_COUNT = Short.MAX_VALUE;\n+\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Stop file writer future. */\n+        GridFutureAdapter<Void> stopFut = new GridFutureAdapter<>();\n+\n+        /** Cached strings by id. */\n+        private final ConcurrentHashMap<String, Short> stringIds = new ConcurrentHashMap<>();\n+\n+        /** String id generator. */\n+        private final AtomicInteger idsGen = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled() && !Thread.interrupted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "originalPosition": 523}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03c8223d8d0632860148fed785934b08423a6562", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/03c8223d8d0632860148fed785934b08423a6562", "committedDate": "2020-07-02T13:08:11Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNjg3MTY1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441687165", "createdAt": "2020-07-02T13:38:59Z", "commit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzozODo1OVrOGsNTGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzozODo1OVrOGsNTGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwODQxMA==", "bodyText": "Can we use the string hash code as an identifier?\nStoring ConcurrentHashMap with the query string will create GC pressure if the user executes many different queries.\nWe can use Set or even BloomFilter implementation to check if some string already seen in the current statistics.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449008410", "createdAt": "2020-07-02T13:38:59Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,660 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {\n+        return enabled;\n+    }\n+\n+    /** Starts collecting performance statistics. */\n+    public synchronized void start() {\n+        if (enabled)\n+            return;\n+\n+        FileWriter writer = fileWriter;\n+\n+        // Writer is stopping.\n+        if (writer != null) {\n+            try {\n+                writer.shutdown().get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to wait for previous writer stopping.\", e);\n+            }\n+        }\n+\n+        assert fileWriter == null;\n+\n+        try {\n+            File file = statisticsFile(ctx);\n+\n+            U.delete(file);\n+\n+            FileIO fileIo = fileIoFactory.create(file);\n+\n+            fileIo.position(0);\n+\n+            fileWriter = new FileWriter(ctx, fileIo, DFLT_FILE_MAX_SIZE, DFLT_BUFFER_SIZE, DFLT_FLUSH_SIZE, log);\n+\n+            new IgniteThread(fileWriter).start();\n+\n+            enabled = true;\n+\n+            log.info(\"Performance statistics writer started [file=\" + file.getAbsolutePath() + ']');\n+        }\n+        catch (IOException | IgniteCheckedException e) {\n+            log.error(\"Failed to start performance statistics writer.\", e);\n+\n+            throw new IgniteException(\"Failed to start performance statistics writer.\", e);\n+        }\n+    }\n+\n+    /** Stops collecting performance statistics. */\n+    public IgniteInternalFuture<Void> stop() {\n+        synchronized (this) {\n+            if (!enabled)\n+                return new GridFinishedFuture<>();\n+\n+            enabled = false;\n+        }\n+\n+        log.info(\"Stopping performance statistics writer.\");\n+\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        if (fileWriter != null)\n+            return fileWriter.shutdown();\n+\n+        return new GridFinishedFuture<>();\n+    }\n+\n+    /**\n+     * @param type Operation type.\n+     * @param cacheId Cache id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     */\n+    public void cacheOperation(CacheOperation type, int cacheId, long startTime, long duration) {\n+        int size = /*type*/ 1 +\n+            /*cacheId*/ 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.CACHE_OPERATION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.putInt(cacheId);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param cacheIds Cache IDs.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param commited {@code True} if commited.\n+     */\n+    public void transaction(GridIntList cacheIds, long startTime, long duration, boolean commited) {\n+        int size = /*cacheIds*/ 4 + cacheIds.size() * 4 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*commit*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TRANSACTION, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.putInt(cacheIds.size());\n+\n+        GridIntIterator iter = cacheIds.iterator();\n+\n+        while (iter.hasNext())\n+            buf.putInt(iter.next());\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(commited ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param text Query text in case of SQL query. Cache name in case of SCAN query.\n+     * @param id Query id.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration in nanoseconds.\n+     * @param success Success flag.\n+     */\n+    public void query(GridCacheQueryType type, String text, long id, long startTime, long duration, boolean success) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(text);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*type*/ 1 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*id*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*success*/ 1;\n+\n+        if (needWriteStr) {\n+            strBytes = text.getBytes();\n+\n+            size += /*text*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(text);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(id);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(success ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param type Cache query type.\n+     * @param queryNodeId Originating node id.\n+     * @param id Query id.\n+     * @param logicalReads Number of logical reads.\n+     * @param physicalReads Number of physical reads.\n+     */\n+    public void queryReads(GridCacheQueryType type, UUID queryNodeId, long id, long logicalReads, long physicalReads) {\n+        int size = /*type*/ 1 +\n+            /*queryNodeId*/ 16 +\n+            /*id*/ 8 +\n+            /*logicalReads*/ 8 +\n+            /*physicalReads*/ 8;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.QUERY_READS, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+        writeUuid(buf, queryNodeId);\n+        buf.putLong(id);\n+        buf.putLong(logicalReads);\n+        buf.putLong(physicalReads);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param taskName Task name.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Duration.\n+     * @param affPartId Affinity partition id.\n+     */\n+    public void task(IgniteUuid sesId, String taskName, long startTime, long duration, int affPartId) {\n+        FileWriter writer = fileWriter;\n+\n+        if (writer == null)\n+            return;\n+\n+        Short strId = writer.stringId(taskName);\n+\n+        boolean needWriteStr = strId == null;\n+\n+        byte[] strBytes = null;\n+\n+        int size = /*sesId*/ 24 +\n+            /*compactStringFlag*/ 1 +\n+            /*strId*/ 2 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*affPartId*/ 4;\n+\n+        if (needWriteStr) {\n+            strBytes = taskName.getBytes();\n+\n+            size += /*taskName*/ 4 + strBytes.length;\n+\n+            strId = writer.generateStringId(taskName);\n+        }\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.TASK, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.put(needWriteStr ? (byte)1 : 0);\n+        buf.putShort(strId);\n+\n+        if (needWriteStr) {\n+            buf.putInt(strBytes.length);\n+            buf.put(strBytes);\n+        }\n+\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.putInt(affPartId);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * @param sesId Session id.\n+     * @param queuedTime Time job spent on waiting queue.\n+     * @param startTime Start time in milliseconds.\n+     * @param duration Job execution time.\n+     * @param timedOut {@code True} if job is timed out.\n+     */\n+    public void job(IgniteUuid sesId, long queuedTime, long startTime, long duration, boolean timedOut) {\n+        int size = /*sesId*/ 24 +\n+            /*queuedTime*/ 8 +\n+            /*startTime*/ 8 +\n+            /*duration*/ 8 +\n+            /*timedOut*/ 1;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = reserveBuffer(OperationType.JOB, size);\n+\n+        if (seg == null)\n+            return;\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        writeIgniteUuid(buf, sesId);\n+        buf.putLong(queuedTime);\n+        buf.putLong(startTime);\n+        buf.putLong(duration);\n+        buf.put(timedOut ? (byte)1 : 0);\n+\n+        seg.release();\n+    }\n+\n+    /**\n+     * Reserves buffer's write segment.\n+     *\n+     * @return Buffer's write segment or {@code null} if not enought space or writer stopping.\n+     */\n+    private SegmentedRingByteBuffer.WriteSegment reserveBuffer(OperationType type, int size) {\n+        FileWriter fileWriter = this.fileWriter;\n+\n+        // Writer stopping.\n+        if (fileWriter == null)\n+            return null;\n+\n+        SegmentedRingByteBuffer.WriteSegment seg = fileWriter.writeSegment(size + /*type*/ 1);\n+\n+        if (seg == null) {\n+            fileWriter.logSmallBufferMessage();\n+\n+            return null;\n+        }\n+\n+        // Ring buffer closed (writer stopping) or maximum size reached.\n+        if (seg.buffer() == null) {\n+            seg.release();\n+\n+            if (!fileWriter.isCancelled())\n+                fileWriter.onMaxFileSizeReached();\n+\n+            return null;\n+        }\n+\n+        ByteBuffer buf = seg.buffer();\n+\n+        buf.put((byte)type.ordinal());\n+\n+        return seg;\n+    }\n+\n+    /** @return Performance statistics file. */\n+    public static File statisticsFile(GridKernalContext ctx) throws IgniteCheckedException {\n+        String igniteWorkDir = U.workDirectory(ctx.config().getWorkDirectory(), ctx.config().getIgniteHome());\n+\n+        File fileDir = U.resolveWorkDirectory(igniteWorkDir, PERFORMANCE_STAT_DIR, false);\n+\n+        return new File(fileDir, \"node-\" + ctx.localNodeId() + \".prf\");\n+    }\n+\n+    /** Writes {@link UUID} to buffer. */\n+    public static void writeUuid(ByteBuffer buf, UUID uuid) {\n+        buf.putLong(uuid.getMostSignificantBits());\n+        buf.putLong(uuid.getLeastSignificantBits());\n+    }\n+\n+    /** Reads {@link UUID} from buffer. */\n+    public static UUID readUuid(ByteBuffer buf) {\n+        return new UUID(buf.getLong(), buf.getLong());\n+    }\n+\n+    /** Writes {@link IgniteUuid} to buffer. */\n+    public static void writeIgniteUuid(ByteBuffer buf, IgniteUuid uuid) {\n+        buf.putLong(uuid.globalId().getMostSignificantBits());\n+        buf.putLong(uuid.globalId().getLeastSignificantBits());\n+        buf.putLong(uuid.localId());\n+    }\n+\n+    /** Reads {@link IgniteUuid} from buffer. */\n+    public static IgniteUuid readIgniteUuid(ByteBuffer buf) {\n+        UUID globalId = new UUID(buf.getLong(), buf.getLong());\n+\n+        return new IgniteUuid(globalId, buf.getLong());\n+    }\n+\n+    /** Worker to write to performance statistics file. */\n+    private class FileWriter extends GridWorker {\n+        /** Maximum cached string count. */\n+        private static final short MAX_CACHED_STRING_COUNT = Short.MAX_VALUE;\n+\n+        /** Performance statistics file I/O. */\n+        private final FileIO fileIo;\n+\n+        /** File write buffer. */\n+        private final SegmentedRingByteBuffer ringByteBuffer;\n+\n+        /** Minimal batch size to flush in bytes. */\n+        private final int flushBatchSize;\n+\n+        /** Size of ready for flushing bytes. */\n+        private final AtomicInteger readyForFlushSize = new AtomicInteger();\n+\n+        /** Stop file writer future. */\n+        GridFutureAdapter<Void> stopFut = new GridFutureAdapter<>();\n+\n+        /** Cached strings by id. */\n+        private final ConcurrentHashMap<String, Short> stringIds = new ConcurrentHashMap<>();\n+\n+        /** String id generator. */\n+        private final AtomicInteger idsGen = new AtomicInteger();\n+\n+        /** {@code True} if the small buffer warning message logged. */\n+        private final AtomicBoolean smallBufLogged = new AtomicBoolean();\n+\n+        /** {@code True} if worker stopped due to maximum file size reached. */\n+        private final AtomicBoolean stopByMaxSize = new AtomicBoolean();\n+\n+        /**\n+         * @param ctx Kernal context.\n+         * @param fileIo Performance statistics file I/O.\n+         * @param maxFileSize Maximum file size in bytes.\n+         * @param bufferSize Off heap buffer size in bytes.\n+         * @param flushBatchSize Minimal batch size to flush in bytes.\n+         * @param log Logger.\n+         */\n+        FileWriter(GridKernalContext ctx, FileIO fileIo, long maxFileSize, int bufferSize, int flushBatchSize,\n+            IgniteLogger log) {\n+            super(ctx.igniteInstanceName(), \"performance-statistics-writer%\" + ctx.igniteInstanceName(), log);\n+\n+            this.fileIo = fileIo;\n+            this.flushBatchSize = flushBatchSize;\n+\n+            ringByteBuffer = new SegmentedRingByteBuffer(bufferSize, maxFileSize, BufferMode.DIRECT);\n+\n+            ringByteBuffer.init(0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override protected void body() throws InterruptedException, IgniteInterruptedCheckedException {\n+            while (!isCancelled() && !Thread.interrupted()) {\n+                blockingSectionBegin();\n+\n+                try {\n+                    synchronized (this) {\n+                        while (readyForFlushSize.get() < flushBatchSize && !isCancelled())\n+                            wait();\n+                    }\n+\n+                    flushBuffer();\n+                }\n+                finally {\n+                    blockingSectionEnd();\n+                }\n+            }\n+\n+            fileWriter = null;\n+\n+            ringByteBuffer.close();\n+\n+            // Make sure that all producers released their buffers to safe deallocate memory.\n+            ringByteBuffer.poll();\n+\n+            ringByteBuffer.free();\n+\n+            U.closeQuiet(fileIo);\n+\n+            stringIds.clear();\n+\n+            stopFut.onDone();\n+\n+            log.info(\"Performance statistics writer stopped.\");\n+        }\n+\n+        /** @return Unique per file string identifier. {@code Null} if there is no cached identifier. */\n+        Short stringId(String str) {\n+            return stringIds.get(str);\n+        }\n+\n+        /** @return Generate unique per file string identifier. {@code -1} if max cached limit exceeded. */\n+        short generateStringId(String str) {\n+            if (idsGen.get() > MAX_CACHED_STRING_COUNT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15dcf55d7542987a0916aaec1f8647c9ac225ac7"}, "originalPosition": 564}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7873fc3323864aa01a6bc16133676d7be49efa9", "author": {"user": {"login": "NSAmelchev", "name": "Nikita Amelchev"}}, "url": "https://github.com/apache/ignite/commit/c7873fc3323864aa01a6bc16133676d7be49efa9", "committedDate": "2020-07-02T14:51:38Z", "message": "Review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODQzMDU1", "url": "https://github.com/apache/ignite/pull/7693#pullrequestreview-441843055", "createdAt": "2020-07-02T16:18:11Z", "commit": {"oid": "c7873fc3323864aa01a6bc16133676d7be49efa9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxODoxMVrOGsUq5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxODoxMVrOGsUq5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyOTE5MA==", "bodyText": "Let's rename this to enabled.", "url": "https://github.com/apache/ignite/pull/7693#discussion_r449129190", "createdAt": "2020-07-02T16:18:11Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/performancestatistics/FilePerformanceStatisticsWriter.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.performancestatistics;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIO;\n+import org.apache.ignite.internal.processors.cache.persistence.file.FileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.file.RandomAccessFileIOFactory;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer;\n+import org.apache.ignite.internal.processors.cache.persistence.wal.SegmentedRingByteBuffer.BufferMode;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.util.GridIntIterator;\n+import org.apache.ignite.internal.util.GridIntList;\n+import org.apache.ignite.internal.util.future.GridFinishedFuture;\n+import org.apache.ignite.internal.util.future.GridFutureAdapter;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.internal.util.worker.GridWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.thread.IgniteThread;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Performance statistics collector based on logging to a file.\n+ * <p>\n+ * Each node collects statistics to a file placed under {@link #PERFORMANCE_STAT_DIR}.\n+ * <p>\n+ * <b>Note:</b> Start again will erase previous performance statistics files.\n+ * <p>\n+ * To iterate over records use {@link FilePerformanceStatisticsReader}.\n+ */\n+public class FilePerformanceStatisticsWriter {\n+    /** Default maximum file size in bytes. Performance statistics will be stopped when the size exceeded. */\n+    public static final long DFLT_FILE_MAX_SIZE = 32 * 1024 * 1024 * 1024L;\n+\n+    /** Default off heap buffer size in bytes. */\n+    public static final int DFLT_BUFFER_SIZE = 32 * 1024 * 1024;\n+\n+    /** Default minimal batch size to flush in bytes. */\n+    public static final int DFLT_FLUSH_SIZE = 8 * 1024 * 1024;\n+\n+    /** Directory to store performance statistics files. Placed under Ignite work directory. */\n+    public static final String PERFORMANCE_STAT_DIR = \"performanceStatistics\";\n+\n+    /** Factory to provide I/O interface. */\n+    private final FileIOFactory fileIoFactory = new RandomAccessFileIOFactory();\n+\n+    /** Performance statistics enabled flag. */\n+    private volatile boolean enabled;\n+\n+    /** Performance statistics file writer worker. */\n+    @Nullable private volatile FileWriter fileWriter;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Logger. */\n+    private final IgniteLogger log;\n+\n+    /** @param ctx Kernal context. */\n+    public FilePerformanceStatisticsWriter(GridKernalContext ctx) {\n+        log = ctx.log(getClass());\n+\n+        this.ctx = ctx;\n+    }\n+\n+    /** @return {@code True} if collecting performance statistics enabled. */\n+    public boolean performanceStatisticsEnabled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7873fc3323864aa01a6bc16133676d7be49efa9"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2731, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}