{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0NTAxNjE4", "number": 8483, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNzo0MzozOFrOE7a2wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTozNzowOVrOE_HEow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzQxNDQwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwNzo0MzozOFrOH3Dt1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMTozMDoxOFrOH6XeDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ==", "bodyText": "To be honest, there is no need to create more than one selector. One thread for processing IO event\nis more than enough", "url": "https://github.com/apache/ignite/pull/8483#discussion_r527494615", "createdAt": "2020-11-20T07:43:38Z", "author": {"login": "ivandasch"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MjI1NQ==", "bodyText": "@ivandasch I don't think so:\n\nWith Partition Awareness a single IgniteClient connects to all server nodes\nIgniteClient can be used from multiple threads\n\nSingle worker thread can easily become a bottleneck.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r529552255", "createdAt": "2020-11-24T13:40:38Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1NjY5NA==", "bodyText": "This is not a bottleneck at all, it's common practice to create 1 thread per selector and for clients 1 selector is more than enough. Remember, tarantool or redis use 1 thread for all network activity and this is more than enough. This is not even a server (sometimes it's desirable to split acceptor task to another selector)", "url": "https://github.com/apache/ignite/pull/8483#discussion_r529556694", "createdAt": "2020-11-24T13:47:19Z", "author": {"login": "ivandasch"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1OTA1MQ==", "bodyText": "With Partition Awareness a single IgniteClient connects to all server nodes\n\n1 thread easily can handle thousands connections. Look at nodejs for another example.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r529559051", "createdAt": "2020-11-24T13:50:44Z", "author": {"login": "ivandasch"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NjE3MQ==", "bodyText": "Ok, you may be right. I'll do some benchmarks and we'll see.\n\nnodejs for another example\n\nNot a good example because of single-threaded javascript nature; also, not anymore https://nodejs.org/api/worker_threads.html", "url": "https://github.com/apache/ignite/pull/8483#discussion_r529576171", "createdAt": "2020-11-24T14:14:47Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNDk1Mg==", "bodyText": "Workers (threads) are useful for performing CPU-intensive JavaScript operations. They will not help much with I/O-intensive work. Node.js\u2019s built-in asynchronous I/O operations are more efficient than Workers can be.\n\nCitation above is from your link... And, AFAIU you use ForkJoinPool for user code...", "url": "https://github.com/apache/ignite/pull/8483#discussion_r529624952", "createdAt": "2020-11-24T15:17:58Z", "author": {"login": "ivandasch"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MDk5NQ==", "bodyText": "Yes, GridNioServer workers are used solely for encoding and decoding requests in form of byte buffers and arrays - essentially copying some bytes around, which is trivial, so maybe one thread is really enough. We'll see. I'm happy to use a single worker and avoid one more config parameter.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r529650995", "createdAt": "2020-11-24T15:39:27Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk2Mzk4Mw==", "bodyText": "@ivandasch I've done some basic benchmarks (see JmhThinClientCacheBenchmark) and could not come up with a config where multiple selectors work faster than one (various cluster sizes, thread counts, entry sizes). You are right, let's keep this hardcoded to 1 and not bother with making it configurable. Thank you for raising this point.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r530963983", "createdAt": "2020-11-26T11:30:18Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioServerClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.failure.FailureType;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioServerListener;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.logger.java.JavaLogger;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioServerClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv; // TODO: <ByteBuffer> possible?\n+\n+    public GridNioServerClientConnectionMultiplexer() {\n+        IgniteLogger gridLog = new JavaLogger(false);\n+\n+        ClientMessageDecoder decoder = new ClientMessageDecoder();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioParser() {\n+            @Override\n+            public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) throws IOException, IgniteCheckedException {\n+                byte[] bytes = decoder.apply(buf);\n+\n+                return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());\n+            }\n+\n+            @Override\n+            public ByteBuffer encode(GridNioSession ses, Object msg) throws IOException, IgniteCheckedException {\n+                return (ByteBuffer)msg;\n+            }\n+        }, gridLog, false);\n+\n+//        if (sslCtx != null) {\n+//            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+//\n+//            sslFilter.directMode(false);\n+//\n+//            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+//        }\n+//        else\n+        filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .address(InetAddress.getLoopbackAddress()) // TODO: Remove?\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioServerListener<ByteBuffer>() {\n+                        @Override\n+                        public void onConnected(GridNioSession ses) {\n+                            System.out.println(\"Connect\");\n+                        }\n+\n+                        @Override\n+                        public void onDisconnected(GridNioSession ses, @Nullable Exception e) {\n+                            System.out.println(\"Disconnect\");\n+                        }\n+\n+                        @Override\n+                        public void onMessageSent(GridNioSession ses, ByteBuffer msg) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onMessage(GridNioSession ses, ByteBuffer msg) {\n+                            GridNioServerClientConnection conn = ses.meta(GridNioServerClientConnection.SES_META_CONN);\n+\n+                            conn.onMessage(msg);\n+                        }\n+\n+                        @Override\n+                        public void onSessionWriteTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onSessionIdleTimeout(GridNioSession ses) {\n+\n+                        }\n+\n+                        @Override\n+                        public void onFailure(FailureType failureType, Throwable failure) {\n+                            System.out.println(\"Fail\");\n+                        }\n+                    })\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // TODO: Get from settings", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ5NDYxNQ=="}, "originalCommit": {"oid": "3058159c9c7b439cb646bf6b343f7b55b511a2a4"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDY2MjMwOnYy", "diffSide": "RIGHT", "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientCacheBenchmark.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzozMTowMFrOH6bjPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwOToxMzowMlrOH7xzOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzMDg0NA==", "bodyText": "Maybe we should also specify the hardware used to get those results.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r531030844", "createdAt": "2020-11-26T13:31:00Z", "author": {"login": "isapego"}, "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientCacheBenchmark.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.benchmarks.jmh.thin;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.apache.ignite.internal.benchmarks.jmh.runner.JmhIdeBenchmarkRunner;\n+import org.openjdk.jmh.annotations.Benchmark;\n+\n+/**\n+ * Thin client cache benchmark.\n+ *\n+ * Benchmark                         Mode  Cnt      Score      Error  Units\n+ * JmhThinClientCacheBenchmark.get  thrpt   10  92501.557 \u00b1 1380.384  ops/s\n+ * JmhThinClientCacheBenchmark.put  thrpt   10  82907.446 \u00b1 7572.537  ops/s", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb29f33ac3ff668b567a5e3d863558445b029fbe"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA4NDExNg==", "bodyText": "+1\nAlso, it will be great if we measure also latency (org.openjdk.jmh.annotations.Mode#AverageTime), not only trouhgput", "url": "https://github.com/apache/ignite/pull/8483#discussion_r531084116", "createdAt": "2020-11-26T14:58:17Z", "author": {"login": "ivandasch"}, "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientCacheBenchmark.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.benchmarks.jmh.thin;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.apache.ignite.internal.benchmarks.jmh.runner.JmhIdeBenchmarkRunner;\n+import org.openjdk.jmh.annotations.Benchmark;\n+\n+/**\n+ * Thin client cache benchmark.\n+ *\n+ * Benchmark                         Mode  Cnt      Score      Error  Units\n+ * JmhThinClientCacheBenchmark.get  thrpt   10  92501.557 \u00b1 1380.384  ops/s\n+ * JmhThinClientCacheBenchmark.put  thrpt   10  82907.446 \u00b1 7572.537  ops/s", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzMDg0NA=="}, "originalCommit": {"oid": "eb29f33ac3ff668b567a5e3d863558445b029fbe"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ0Mzk2Mw==", "bodyText": "Added Mode.AverageTime, added system config to the results comment.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r532443963", "createdAt": "2020-11-30T09:13:02Z", "author": {"login": "ptupitsyn"}, "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientCacheBenchmark.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.benchmarks.jmh.thin;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.apache.ignite.internal.benchmarks.jmh.runner.JmhIdeBenchmarkRunner;\n+import org.openjdk.jmh.annotations.Benchmark;\n+\n+/**\n+ * Thin client cache benchmark.\n+ *\n+ * Benchmark                         Mode  Cnt      Score      Error  Units\n+ * JmhThinClientCacheBenchmark.get  thrpt   10  92501.557 \u00b1 1380.384  ops/s\n+ * JmhThinClientCacheBenchmark.put  thrpt   10  82907.446 \u00b1 7572.537  ops/s", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzMDg0NA=="}, "originalCommit": {"oid": "eb29f33ac3ff668b567a5e3d863558445b029fbe"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTE3OTE5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpIgniteClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTowNzoxNlrOH8fLQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1MTo0N1rOH8td4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4NzM5NQ==", "bodyText": "NL between } and catch according to code style", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533187395", "createdAt": "2020-12-01T09:07:16Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpIgniteClient.java", "diffHunk": "@@ -116,18 +117,23 @@ private TcpIgniteClient(ClientConfiguration cfg) throws ClientException {\n \n         ch = new ReliableChannel(chFactory, cfg, binary);\n \n-        ch.channelsInit();\n+        try {\n+            ch.channelsInit();\n \n-        ch.addChannelFailListener(() -> metadataHandler.onReconnect());\n+            ch.addChannelFailListener(() -> metadataHandler.onReconnect());\n \n-        transactions = new TcpClientTransactions(ch, marsh,\n-            new ClientTransactionConfiguration(cfg.getTransactionConfiguration()));\n+            transactions = new TcpClientTransactions(ch, marsh,\n+                    new ClientTransactionConfiguration(cfg.getTransactionConfiguration()));\n \n-        cluster = new ClientClusterImpl(ch, marsh);\n+            cluster = new ClientClusterImpl(ch, marsh);\n \n-        compute = new ClientComputeImpl(ch, marsh, cluster.defaultClusterGroup());\n+            compute = new ClientComputeImpl(ch, marsh, cluster.defaultClusterGroup());\n \n-        services = new ClientServicesImpl(ch, marsh, cluster.defaultClusterGroup());\n+            services = new ClientServicesImpl(ch, marsh, cluster.defaultClusterGroup());\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMTUzNg==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533421536", "createdAt": "2020-12-01T13:51:47Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpIgniteClient.java", "diffHunk": "@@ -116,18 +117,23 @@ private TcpIgniteClient(ClientConfiguration cfg) throws ClientException {\n \n         ch = new ReliableChannel(chFactory, cfg, binary);\n \n-        ch.channelsInit();\n+        try {\n+            ch.channelsInit();\n \n-        ch.addChannelFailListener(() -> metadataHandler.onReconnect());\n+            ch.addChannelFailListener(() -> metadataHandler.onReconnect());\n \n-        transactions = new TcpClientTransactions(ch, marsh,\n-            new ClientTransactionConfiguration(cfg.getTransactionConfiguration()));\n+            transactions = new TcpClientTransactions(ch, marsh,\n+                    new ClientTransactionConfiguration(cfg.getTransactionConfiguration()));\n \n-        cluster = new ClientClusterImpl(ch, marsh);\n+            cluster = new ClientClusterImpl(ch, marsh);\n \n-        compute = new ClientComputeImpl(ch, marsh, cluster.defaultClusterGroup());\n+            compute = new ClientComputeImpl(ch, marsh, cluster.defaultClusterGroup());\n \n-        services = new ClientServicesImpl(ch, marsh, cluster.defaultClusterGroup());\n+            services = new ClientServicesImpl(ch, marsh, cluster.defaultClusterGroup());\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4NzM5NQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTE4MDYzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTowNzoyN1rOH8fMMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1MjowN1rOH8te1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4NzYzNA==", "bodyText": "NL between } and catch according to code style", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533187634", "createdAt": "2020-12-01T09:07:27Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioClientListener())\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // Using more selectors does not seem to improve performance.\n+                    .byteOrder(ByteOrder.nativeOrder())\n+                    .directBuffer(true)\n+                    .directMode(false)\n+                    .igniteInstanceName(\"thinClient\")\n+                    .serverName(THREAD_PREFIX)\n+                    .idleTimeout(Long.MAX_VALUE)\n+                    .socketReceiveBufferSize(cfg.getReceiveBufferSize())\n+                    .socketSendBufferSize(cfg.getSendBufferSize())\n+                    .tcpNoDelay(true)\n+                    .build();\n+        } catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMTc4Mw==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533421783", "createdAt": "2020-12-01T13:52:07Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioClientListener())\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // Using more selectors does not seem to improve performance.\n+                    .byteOrder(ByteOrder.nativeOrder())\n+                    .directBuffer(true)\n+                    .directMode(false)\n+                    .igniteInstanceName(\"thinClient\")\n+                    .serverName(THREAD_PREFIX)\n+                    .idleTimeout(Long.MAX_VALUE)\n+                    .socketReceiveBufferSize(cfg.getReceiveBufferSize())\n+                    .socketSendBufferSize(cfg.getSendBufferSize())\n+                    .tcpNoDelay(true)\n+                    .build();\n+        } catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4NzYzNA=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTE4MTQ0OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTowNzozN1rOH8fMwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1MjoyMFrOH8tfcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4Nzc3Nw==", "bodyText": "NL between } and catch according to code style", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533187777", "createdAt": "2020-12-01T09:07:37Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioClientListener())\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // Using more selectors does not seem to improve performance.\n+                    .byteOrder(ByteOrder.nativeOrder())\n+                    .directBuffer(true)\n+                    .directMode(false)\n+                    .igniteInstanceName(\"thinClient\")\n+                    .serverName(THREAD_PREFIX)\n+                    .idleTimeout(Long.MAX_VALUE)\n+                    .socketReceiveBufferSize(cfg.getReceiveBufferSize())\n+                    .socketSendBufferSize(cfg.getSendBufferSize())\n+                    .tcpNoDelay(true)\n+                    .build();\n+        } catch (IgniteCheckedException e) {\n+            throw new IgniteException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void start() {\n+        srv.start();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void stop() {\n+        srv.stop();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ClientConnection open(InetSocketAddress addr,\n+                                           ClientMessageHandler msgHnd,\n+                                           ClientConnectionStateHandler stateHnd)\n+            throws ClientConnectionException {\n+        try {\n+            java.nio.channels.SocketChannel ch = java.nio.channels.SocketChannel.open();\n+            ch.socket().connect(new InetSocketAddress(addr.getHostName(), addr.getPort()), Integer.MAX_VALUE);\n+\n+            Map<Integer, Object> meta = new HashMap<>();\n+            GridNioFuture<?> sslHandshakeFut = null;\n+\n+            if (sslCtx != null) {\n+                sslHandshakeFut = new GridNioFutureImpl<>(null);\n+\n+                meta.put(GridNioSslFilter.HANDSHAKE_FUT_META_KEY, sslHandshakeFut);\n+            }\n+\n+            GridNioSession ses = srv.createSession(ch, meta, false, null).get();\n+\n+            if (sslHandshakeFut != null)\n+                sslHandshakeFut.get();\n+\n+            return new GridNioClientConnection(ses, msgHnd, stateHnd);\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMTkzNg==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533421936", "createdAt": "2020-12-01T13:52:20Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioClientListener())\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // Using more selectors does not seem to improve performance.\n+                    .byteOrder(ByteOrder.nativeOrder())\n+                    .directBuffer(true)\n+                    .directMode(false)\n+                    .igniteInstanceName(\"thinClient\")\n+                    .serverName(THREAD_PREFIX)\n+                    .idleTimeout(Long.MAX_VALUE)\n+                    .socketReceiveBufferSize(cfg.getReceiveBufferSize())\n+                    .socketSendBufferSize(cfg.getSendBufferSize())\n+                    .tcpNoDelay(true)\n+                    .build();\n+        } catch (IgniteCheckedException e) {\n+            throw new IgniteException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void start() {\n+        srv.start();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void stop() {\n+        srv.stop();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ClientConnection open(InetSocketAddress addr,\n+                                           ClientMessageHandler msgHnd,\n+                                           ClientConnectionStateHandler stateHnd)\n+            throws ClientConnectionException {\n+        try {\n+            java.nio.channels.SocketChannel ch = java.nio.channels.SocketChannel.open();\n+            ch.socket().connect(new InetSocketAddress(addr.getHostName(), addr.getPort()), Integer.MAX_VALUE);\n+\n+            Map<Integer, Object> meta = new HashMap<>();\n+            GridNioFuture<?> sslHandshakeFut = null;\n+\n+            if (sslCtx != null) {\n+                sslHandshakeFut = new GridNioFutureImpl<>(null);\n+\n+                meta.put(GridNioSslFilter.HANDSHAKE_FUT_META_KEY, sslHandshakeFut);\n+            }\n+\n+            GridNioSession ses = srv.createSession(ch, meta, false, null).get();\n+\n+            if (sslHandshakeFut != null)\n+                sslHandshakeFut.get();\n+\n+            return new GridNioClientConnection(ses, msgHnd, stateHnd);\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4Nzc3Nw=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTIwNDAwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/client/ConnectToStartingNodeTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOToxMDo0NFrOH8fbgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1MjozMVrOH8tf_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE5MTU1NA==", "bodyText": "NL after }", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533191554", "createdAt": "2020-12-01T09:10:44Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/client/ConnectToStartingNodeTest.java", "diffHunk": "@@ -71,14 +71,20 @@ public void testClientConnectBeforeDiscoveryStart() throws Exception {\n         IgniteInternalFuture<IgniteClient> futStartClient = GridTestUtils.runAsync(\n             () -> startClient(grid()));\n \n-        // Server doesn't accept connection before discovery SPI started.\n-        assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        try {\n+            // Server doesn't accept connection before discovery SPI started.\n+            assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n \n-        barrier.await();\n+            barrier.await();\n+\n+            futStartGrid.get();\n \n-        futStartGrid.get();\n+            // Server accept connection after discovery SPI started.\n+            assertTrue(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        } finally {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMjA3Ng==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533422076", "createdAt": "2020-12-01T13:52:31Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/test/java/org/apache/ignite/client/ConnectToStartingNodeTest.java", "diffHunk": "@@ -71,14 +71,20 @@ public void testClientConnectBeforeDiscoveryStart() throws Exception {\n         IgniteInternalFuture<IgniteClient> futStartClient = GridTestUtils.runAsync(\n             () -> startClient(grid()));\n \n-        // Server doesn't accept connection before discovery SPI started.\n-        assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        try {\n+            // Server doesn't accept connection before discovery SPI started.\n+            assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n \n-        barrier.await();\n+            barrier.await();\n+\n+            futStartGrid.get();\n \n-        futStartGrid.get();\n+            // Server accept connection after discovery SPI started.\n+            assertTrue(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        } finally {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE5MTU1NA=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTIwODQ4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/client/ConnectToStartingNodeTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOToxMToxOVrOH8feSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1MjozNFrOH8tgIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE5MjI2Ng==", "bodyText": "Redundant NL", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533192266", "createdAt": "2020-12-01T09:11:19Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/client/ConnectToStartingNodeTest.java", "diffHunk": "@@ -71,14 +71,20 @@ public void testClientConnectBeforeDiscoveryStart() throws Exception {\n         IgniteInternalFuture<IgniteClient> futStartClient = GridTestUtils.runAsync(\n             () -> startClient(grid()));\n \n-        // Server doesn't accept connection before discovery SPI started.\n-        assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        try {\n+            // Server doesn't accept connection before discovery SPI started.\n+            assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n \n-        barrier.await();\n+            barrier.await();\n+\n+            futStartGrid.get();\n \n-        futStartGrid.get();\n+            // Server accept connection after discovery SPI started.\n+            assertTrue(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        } finally {\n+            if (futStartClient.isDone())\n+                futStartClient.get().close();\n+        }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMjExMg==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533422112", "createdAt": "2020-12-01T13:52:34Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/test/java/org/apache/ignite/client/ConnectToStartingNodeTest.java", "diffHunk": "@@ -71,14 +71,20 @@ public void testClientConnectBeforeDiscoveryStart() throws Exception {\n         IgniteInternalFuture<IgniteClient> futStartClient = GridTestUtils.runAsync(\n             () -> startClient(grid()));\n \n-        // Server doesn't accept connection before discovery SPI started.\n-        assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        try {\n+            // Server doesn't accept connection before discovery SPI started.\n+            assertFalse(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n \n-        barrier.await();\n+            barrier.await();\n+\n+            futStartGrid.get();\n \n-        futStartGrid.get();\n+            // Server accept connection after discovery SPI started.\n+            assertTrue(GridTestUtils.waitForCondition(futStartClient::isDone, 500L));\n+        } finally {\n+            if (futStartClient.isDone())\n+                futStartClient.get().close();\n+        }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE5MjI2Ng=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTQ2MTM1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo0MTo0MVrOH8iFHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1Mjo1OFrOH8thGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIzNDk3NA==", "bodyText": "NL between } and catch according to code style", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533234974", "createdAt": "2020-12-01T09:41:41Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -680,12 +571,12 @@ else if (!supportedVers.contains(srvVer) ||\n \n     /** Write bytes to the output stream. */\n     private void write(byte[] bytes, int len) throws ClientConnectionException {\n+        ByteBuffer buf = ByteBuffer.wrap(bytes, 0, len);\n+\n         try {\n-            out.write(bytes, 0, len);\n-            out.flush();\n-        }\n-        catch (IOException e) {\n-            throw handleIOError(e);\n+            sock.send(buf);\n+        } catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 471}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMjM2Mg==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533422362", "createdAt": "2020-12-01T13:52:58Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -680,12 +571,12 @@ else if (!supportedVers.contains(srvVer) ||\n \n     /** Write bytes to the output stream. */\n     private void write(byte[] bytes, int len) throws ClientConnectionException {\n+        ByteBuffer buf = ByteBuffer.wrap(bytes, 0, len);\n+\n         try {\n-            out.write(bytes, 0, len);\n-            out.flush();\n-        }\n-        catch (IOException e) {\n-            throw handleIOError(e);\n+            sock.send(buf);\n+        } catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIzNDk3NA=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 471}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTQ2Mzk4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo0MjowMVrOH8iGrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo1Mzo0MFrOH8ti_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIzNTM3NA==", "bodyText": "NL between } and catch according to code style", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533235374", "createdAt": "2020-12-01T09:42:01Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -543,31 +450,20 @@ else if (addr.getPort() < 1024 || addr.getPort() > 49151)\n             throw new IllegalArgumentException(error);\n     }\n \n-    /** Create socket. */\n-    private static Socket createSocket(ClientChannelConfiguration cfg) throws IOException {\n-        Socket sock = cfg.getSslMode() == SslMode.REQUIRED ?\n-            new ClientSslSocketFactory(cfg).create() :\n-            new Socket(cfg.getAddress().getHostName(), cfg.getAddress().getPort());\n-\n-        sock.setTcpNoDelay(cfg.isTcpNoDelay());\n-\n-        if (cfg.getTimeout() > 0)\n-            sock.setSoTimeout(cfg.getTimeout());\n-\n-        if (cfg.getSendBufferSize() > 0)\n-            sock.setSendBufferSize(cfg.getSendBufferSize());\n-\n-        if (cfg.getReceiveBufferSize() > 0)\n-            sock.setReceiveBufferSize(cfg.getReceiveBufferSize());\n-\n-        return sock;\n-    }\n-\n     /** Client handshake. */\n     private void handshake(ProtocolVersion ver, String user, String pwd, Map<String, String> userAttrs)\n         throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n+        ClientRequestFuture fut = new ClientRequestFuture();\n+        pendingReqs.put(-1L, fut);\n+\n         handshakeReq(ver, user, pwd, userAttrs);\n-        handshakeRes(ver, user, pwd, userAttrs);\n+\n+        try {\n+            ByteBuffer res = timeout > 0 ? fut.get(timeout) : fut.get();\n+            handshakeRes(res, ver, user, pwd, userAttrs);\n+        } catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 419}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyMjg0Nw==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533422847", "createdAt": "2020-12-01T13:53:40Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -543,31 +450,20 @@ else if (addr.getPort() < 1024 || addr.getPort() > 49151)\n             throw new IllegalArgumentException(error);\n     }\n \n-    /** Create socket. */\n-    private static Socket createSocket(ClientChannelConfiguration cfg) throws IOException {\n-        Socket sock = cfg.getSslMode() == SslMode.REQUIRED ?\n-            new ClientSslSocketFactory(cfg).create() :\n-            new Socket(cfg.getAddress().getHostName(), cfg.getAddress().getPort());\n-\n-        sock.setTcpNoDelay(cfg.isTcpNoDelay());\n-\n-        if (cfg.getTimeout() > 0)\n-            sock.setSoTimeout(cfg.getTimeout());\n-\n-        if (cfg.getSendBufferSize() > 0)\n-            sock.setSendBufferSize(cfg.getSendBufferSize());\n-\n-        if (cfg.getReceiveBufferSize() > 0)\n-            sock.setReceiveBufferSize(cfg.getReceiveBufferSize());\n-\n-        return sock;\n-    }\n-\n     /** Client handshake. */\n     private void handshake(ProtocolVersion ver, String user, String pwd, Map<String, String> userAttrs)\n         throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n+        ClientRequestFuture fut = new ClientRequestFuture();\n+        pendingReqs.put(-1L, fut);\n+\n         handshakeReq(ver, user, pwd, userAttrs);\n-        handshakeRes(ver, user, pwd, userAttrs);\n+\n+        try {\n+            ByteBuffer res = timeout > 0 ? fut.get(timeout) : fut.get();\n+            handshakeRes(res, ver, user, pwd, userAttrs);\n+        } catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIzNTM3NA=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 419}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTU3MjQ4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1NjoyN1rOH8jOIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNjowNjo1MlrOH98CPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MzY2NQ==", "bodyText": "I don't quite understand. In PayloadOutputChannel constructor we have created a new BinaryHeapOutputStream, which doesn't leaks to anywhere. Why do we need another array copy here?", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533253665", "createdAt": "2020-12-01T09:56:27Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -292,7 +233,8 @@ private ClientRequestFuture send(ClientOperation op, Consumer<PayloadOutputChann\n \n             req.writeInt(0, req.position() - 4); // Actual size.\n \n-            write(req.array(), req.position());\n+            // arrayCopy is required, because buffer is pooled, and write is async.\n+            write(req.arrayCopy(), req.position());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyODM0OA==", "bodyText": "PayloadOutputChannel creates BinaryHeapOutputStream, which uses BinaryMemoryAllocator.THREAD_LOCAL.chunk(). This thread-local chunk will be released as soon as we leave the scope, because PayloadOutputChannel is wrapped in a try-with-resources block. However, write passes the buffer to the NIO framework, which may process it later, causing \"use-after-free\" of sorts.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533428348", "createdAt": "2020-12-01T14:01:16Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -292,7 +233,8 @@ private ClientRequestFuture send(ClientOperation op, Consumer<PayloadOutputChann\n \n             req.writeInt(0, req.position() - 4); // Actual size.\n \n-            write(req.array(), req.position());\n+            // arrayCopy is required, because buffer is pooled, and write is async.\n+            write(req.arrayCopy(), req.position());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MzY2NQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMzkzNw==", "bodyText": "Got it. Thanks.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533433937", "createdAt": "2020-12-01T14:09:10Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -292,7 +233,8 @@ private ClientRequestFuture send(ClientOperation op, Consumer<PayloadOutputChann\n \n             req.writeInt(0, req.position() - 4); // Actual size.\n \n-            write(req.array(), req.position());\n+            // arrayCopy is required, because buffer is pooled, and write is async.\n+            write(req.arrayCopy(), req.position());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MzY2NQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxNTc1Nw==", "bodyText": "We can also make micro-optimization - avoid arrayCopy for sync requests without a timeout, in this case, the thread can't reuse buffer again until the response is received. And latency for such operations will be a little bit better. (Perhaps this can be made in another ticket)", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533915757", "createdAt": "2020-12-02T05:59:49Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -292,7 +233,8 @@ private ClientRequestFuture send(ClientOperation op, Consumer<PayloadOutputChann\n \n             req.writeInt(0, req.position() - 4); // Actual size.\n \n-            write(req.array(), req.position());\n+            // arrayCopy is required, because buffer is pooled, and write is async.\n+            write(req.arrayCopy(), req.position());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MzY2NQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4NDkxNg==", "bodyText": "@alex-plekhanov ticket filed: https://issues.apache.org/jira/browse/IGNITE-13804\n\nwithout a timeout\n\nHow does the timeout affect this logic?", "url": "https://github.com/apache/ignite/pull/8483#discussion_r534284916", "createdAt": "2020-12-02T16:02:36Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -292,7 +233,8 @@ private ClientRequestFuture send(ClientOperation op, Consumer<PayloadOutputChann\n \n             req.writeInt(0, req.position() - 4); // Actual size.\n \n-            write(req.array(), req.position());\n+            // arrayCopy is required, because buffer is pooled, and write is async.\n+            write(req.arrayCopy(), req.position());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MzY2NQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcwODc5Nw==", "bodyText": "If the timeout is too low, there are no guarantees that the message already sent when control returned to the user thread after pendingReq.get(timeout)", "url": "https://github.com/apache/ignite/pull/8483#discussion_r534708797", "createdAt": "2020-12-03T06:06:52Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpClientChannel.java", "diffHunk": "@@ -292,7 +233,8 @@ private ClientRequestFuture send(ClientOperation op, Consumer<PayloadOutputChann\n \n             req.writeInt(0, req.position() - 4); // Actual size.\n \n-            write(req.array(), req.position());\n+            // arrayCopy is required, because buffer is pooled, and write is async.\n+            write(req.arrayCopy(), req.position());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MzY2NQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTU5NzAwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/ClientMessageDecoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo1OTo0NFrOH8jeMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowMTo1MVrOH8t6GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1Nzc3OQ==", "bodyText": "Wrong indent", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533257779", "createdAt": "2020-12-01T09:59:44Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/ClientMessageDecoder.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Decodes thin client messages from partial buffers.\n+  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyODc2MQ==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533428761", "createdAt": "2020-12-01T14:01:51Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/ClientMessageDecoder.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Decodes thin client messages from partial buffers.\n+  */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1Nzc3OQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTYwNzM1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/ClientConnectionStateHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDowMToxMFrOH8jlEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowMjowOFrOH8t61w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1OTUzNw==", "bodyText": "Point at the end", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533259537", "createdAt": "2020-12-01T10:01:10Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/ClientConnectionStateHandler.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Handles thin client connection state.\n+ */\n+public interface ClientConnectionStateHandler {\n+    /**\n+     * Handles connection loss", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyODk1MQ==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533428951", "createdAt": "2020-12-01T14:02:08Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/ClientConnectionStateHandler.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Handles thin client connection state.\n+ */\n+public interface ClientConnectionStateHandler {\n+    /**\n+     * Handles connection loss", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1OTUzNw=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTcyNDQ4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNzo0M1rOH8kw0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowMjo0NFrOH8t8kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3ODkzMA==", "bodyText": "NL after }", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533278930", "createdAt": "2020-12-01T10:17:43Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyOTM5NA==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533429394", "createdAt": "2020-12-01T14:02:44Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3ODkzMA=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTc1OTI1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoyMjozOVrOH8lH0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowMjo1OVrOH8t9MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI4NDgxOQ==", "bodyText": "Space before  {", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533284819", "createdAt": "2020-12-01T10:22:39Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyOTU1Mw==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533429553", "createdAt": "2020-12-01T14:02:59Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI4NDgxOQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTc1OTkzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoyMjo0NVrOH8lITw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowMzowOFrOH8t9mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI4NDk0Mw==", "bodyText": "Space before  {", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533284943", "createdAt": "2020-12-01T10:22:45Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQyOTY1OQ==", "bodyText": "fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533429659", "createdAt": "2020-12-01T14:03:08Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI4NDk0Mw=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NTk2ODgxOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDo1NzowOVrOH8nP6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDowMzo0NVrOH8t_KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxOTY1Ng==", "bodyText": "Add java.nio.channels.SocketChannel to imports?", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533319656", "createdAt": "2020-12-01T10:57:09Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioClientListener())\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // Using more selectors does not seem to improve performance.\n+                    .byteOrder(ByteOrder.nativeOrder())\n+                    .directBuffer(true)\n+                    .directMode(false)\n+                    .igniteInstanceName(\"thinClient\")\n+                    .serverName(THREAD_PREFIX)\n+                    .idleTimeout(Long.MAX_VALUE)\n+                    .socketReceiveBufferSize(cfg.getReceiveBufferSize())\n+                    .socketSendBufferSize(cfg.getSendBufferSize())\n+                    .tcpNoDelay(true)\n+                    .build();\n+        } catch (IgniteCheckedException e) {\n+            throw new IgniteException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void start() {\n+        srv.start();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void stop() {\n+        srv.stop();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ClientConnection open(InetSocketAddress addr,\n+                                           ClientMessageHandler msgHnd,\n+                                           ClientConnectionStateHandler stateHnd)\n+            throws ClientConnectionException {\n+        try {\n+            java.nio.channels.SocketChannel ch = java.nio.channels.SocketChannel.open();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMDA1Nw==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533430057", "createdAt": "2020-12-01T14:03:45Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientConnectionMultiplexer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.client.thin.ClientSslUtils;\n+import org.apache.ignite.internal.client.thin.io.ClientConnection;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionMultiplexer;\n+import org.apache.ignite.internal.client.thin.io.ClientConnectionStateHandler;\n+import org.apache.ignite.internal.client.thin.io.ClientMessageHandler;\n+import org.apache.ignite.internal.util.nio.GridNioCodecFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFilter;\n+import org.apache.ignite.internal.util.nio.GridNioFuture;\n+import org.apache.ignite.internal.util.nio.GridNioFutureImpl;\n+import org.apache.ignite.internal.util.nio.GridNioServer;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter;\n+import org.apache.ignite.logger.NullLogger;\n+\n+/**\n+ * Client connection multiplexer based on {@link org.apache.ignite.internal.util.nio.GridNioServer}.\n+ */\n+public class GridNioClientConnectionMultiplexer implements ClientConnectionMultiplexer {\n+    /** Worker thread prefix. */\n+    private static final String THREAD_PREFIX = \"thin-client-channel\";\n+\n+    /** */\n+    private static final int CLIENT_MODE_PORT = -1;\n+\n+    /** */\n+    private final GridNioServer<ByteBuffer> srv;\n+\n+    /** */\n+    private final SSLContext sslCtx;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param cfg Client config.\n+     */\n+    public GridNioClientConnectionMultiplexer(ClientConfiguration cfg) {\n+        IgniteLogger gridLog = new NullLogger();\n+\n+        GridNioFilter[] filters;\n+\n+        GridNioFilter codecFilter = new GridNioCodecFilter(new GridNioClientParser(), gridLog, false);\n+\n+        sslCtx = ClientSslUtils.getSslContext(cfg);\n+\n+        if (sslCtx != null) {\n+            GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, true, ByteOrder.nativeOrder(), gridLog);\n+            sslFilter.directMode(false);\n+            filters = new GridNioFilter[]{codecFilter, sslFilter};\n+        } else\n+            filters = new GridNioFilter[]{codecFilter};\n+\n+        try {\n+            srv = GridNioServer.<ByteBuffer>builder()\n+                    .port(CLIENT_MODE_PORT)\n+                    .listener(new GridNioClientListener())\n+                    .filters(filters)\n+                    .logger(gridLog)\n+                    .selectorCount(1) // Using more selectors does not seem to improve performance.\n+                    .byteOrder(ByteOrder.nativeOrder())\n+                    .directBuffer(true)\n+                    .directMode(false)\n+                    .igniteInstanceName(\"thinClient\")\n+                    .serverName(THREAD_PREFIX)\n+                    .idleTimeout(Long.MAX_VALUE)\n+                    .socketReceiveBufferSize(cfg.getReceiveBufferSize())\n+                    .socketSendBufferSize(cfg.getSendBufferSize())\n+                    .tcpNoDelay(true)\n+                    .build();\n+        } catch (IgniteCheckedException e) {\n+            throw new IgniteException(e);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void start() {\n+        srv.start();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void stop() {\n+        srv.stop();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ClientConnection open(InetSocketAddress addr,\n+                                           ClientMessageHandler msgHnd,\n+                                           ClientConnectionStateHandler stateHnd)\n+            throws ClientConnectionException {\n+        try {\n+            java.nio.channels.SocketChannel ch = java.nio.channels.SocketChannel.open();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxOTY1Ng=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjA4ODE5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientParser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTozMDowMFrOH8oZjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNjowNzo0OVrOH80ROQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzODUxMQ==", "bodyText": "I think here ByteOrder.LITTLE_ENDIAN should be used since this ByteBuffer is passed to payload readers", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533338511", "createdAt": "2020-12-01T11:30:00Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientParser.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.GridNioSessionMetaKey;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Client message parser.\n+ */\n+class GridNioClientParser implements GridNioParser {\n+    /** */\n+    private static final int SES_META_DECODER = GridNioSessionMetaKey.nextUniqueKey();\n+\n+    /** {@inheritDoc} */\n+    @Override public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) {\n+        ClientMessageDecoder decoder = ses.meta(SES_META_DECODER);\n+\n+        if (decoder == null) {\n+            decoder = new ClientMessageDecoder();\n+\n+            ses.addMeta(SES_META_DECODER, decoder);\n+        }\n+\n+        byte[] bytes = decoder.apply(buf);\n+\n+        if (bytes == null)\n+            return null; // Message is not yet completely received.\n+\n+        return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzMjk4NQ==", "bodyText": "Good catch! Fixed.", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533532985", "createdAt": "2020-12-01T16:07:49Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/io/gridnioserver/GridNioClientParser.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin.io.gridnioserver;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.apache.ignite.internal.client.thin.io.ClientMessageDecoder;\n+import org.apache.ignite.internal.util.nio.GridNioParser;\n+import org.apache.ignite.internal.util.nio.GridNioSession;\n+import org.apache.ignite.internal.util.nio.GridNioSessionMetaKey;\n+import org.jetbrains.annotations.Nullable;\n+\n+/**\n+ * Client message parser.\n+ */\n+class GridNioClientParser implements GridNioParser {\n+    /** */\n+    private static final int SES_META_DECODER = GridNioSessionMetaKey.nextUniqueKey();\n+\n+    /** {@inheritDoc} */\n+    @Override public @Nullable Object decode(GridNioSession ses, ByteBuffer buf) {\n+        ClientMessageDecoder decoder = ses.meta(SES_META_DECODER);\n+\n+        if (decoder == null) {\n+            decoder = new ClientMessageDecoder();\n+\n+            ses.addMeta(SES_META_DECODER, decoder);\n+        }\n+\n+        byte[] bytes = decoder.apply(buf);\n+\n+        if (bytes == null)\n+            return null; // Message is not yet completely received.\n+\n+        return ByteBuffer.wrap(bytes).order(ByteOrder.nativeOrder());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzODUxMQ=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjExNjE5OnYy", "diffSide": "RIGHT", "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientAbstractBenchmark.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTozNzowOVrOH8op3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNjowMDoyOFrOH8z7Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM0MjY4NA==", "bodyText": "public abstract class?", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533342684", "createdAt": "2020-12-01T11:37:09Z", "author": {"login": "alex-plekhanov"}, "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientAbstractBenchmark.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.benchmarks.jmh.thin;\n+\n+import java.util.stream.IntStream;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.client.IgniteClient;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.benchmarks.jmh.JmhAbstractBenchmark;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\n+import org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+/**\n+ * Base class for thin client benchmarks.\n+ */\n+@State(Scope.Benchmark)\n+public class JmhThinClientAbstractBenchmark extends JmhAbstractBenchmark {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyNzM1NA==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8483#discussion_r533527354", "createdAt": "2020-12-01T16:00:28Z", "author": {"login": "ptupitsyn"}, "path": "modules/benchmarks/src/main/java/org/apache/ignite/internal/benchmarks/jmh/thin/JmhThinClientAbstractBenchmark.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.benchmarks.jmh.thin;\n+\n+import java.util.stream.IntStream;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.client.IgniteClient;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.benchmarks.jmh.JmhAbstractBenchmark;\n+import org.apache.ignite.internal.util.typedef.internal.A;\n+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\n+import org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+/**\n+ * Base class for thin client benchmarks.\n+ */\n+@State(Scope.Benchmark)\n+public class JmhThinClientAbstractBenchmark extends JmhAbstractBenchmark {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM0MjY4NA=="}, "originalCommit": {"oid": "054bf139a27909223f8f1b6f929d2d3431a1f774"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2618, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}