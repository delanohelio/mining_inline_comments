{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MDU0MDE1", "number": 8204, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNzozNzo1MFrOEg0LqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwODoxMzoyOFrOEg1Rlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODQ0ODQwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/tracing/TraceableIterator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNzozNzo1MFrOHNzilg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTozNjoxOFrOHQbURQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNzk3NA==", "bodyText": "This seems a little bit confusing. Abstracting from the current format of use, on every iteration we reset MTC.span with what we get from MTC.span() within constructor. Why we need this?", "url": "https://github.com/apache/ignite/pull/8204#discussion_r484237974", "createdAt": "2020-09-07T07:37:50Z", "author": {"login": "sanpwc"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/tracing/TraceableIterator.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.tracing;\n+\n+import java.util.Iterator;\n+\n+import static org.apache.ignite.internal.processors.tracing.SpanTags.ERROR;\n+\n+/**\n+ * Represents wrapper which allows the iterator methods to execute within context of a specified span.\n+ */\n+public class TraceableIterator<T> implements Iterator<T> {\n+    /** Iterator to which all calls will be delegated. */\n+    private final Iterator<T> iter;\n+\n+    /** Span that reperesents trace context in which iterator runs. */\n+    private final Span span;\n+\n+    /**\n+     * @param iter Iterator to which all calls will be delegated.\n+     */\n+    public TraceableIterator(Iterator<T> iter) {\n+        this.iter = iter;\n+        this.span = MTC.span();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean hasNext() {\n+        MTC.supportInitial(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5585ae55c68f30bcb4dcff060787abe775351ca0"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwMjU4Mg==", "bodyText": "The main reason to use MTC.supportInitial(span); is that methods hasNext and next can be called from user threads for which MTC.span is not set. During this methods execution important spans produce and they should be part of span tree that represents SQL query to which current iterator belongs to. So if we don't use MTC.supportInitial(span); this spans will not be inherited from the query root span.", "url": "https://github.com/apache/ignite/pull/8204#discussion_r484302582", "createdAt": "2020-09-07T09:16:06Z", "author": {"login": "ololo3000"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/tracing/TraceableIterator.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.tracing;\n+\n+import java.util.Iterator;\n+\n+import static org.apache.ignite.internal.processors.tracing.SpanTags.ERROR;\n+\n+/**\n+ * Represents wrapper which allows the iterator methods to execute within context of a specified span.\n+ */\n+public class TraceableIterator<T> implements Iterator<T> {\n+    /** Iterator to which all calls will be delegated. */\n+    private final Iterator<T> iter;\n+\n+    /** Span that reperesents trace context in which iterator runs. */\n+    private final Span span;\n+\n+    /**\n+     * @param iter Iterator to which all calls will be delegated.\n+     */\n+    public TraceableIterator(Iterator<T> iter) {\n+        this.iter = iter;\n+        this.span = MTC.span();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean hasNext() {\n+        MTC.supportInitial(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNzk3NA=="}, "originalCommit": {"oid": "5585ae55c68f30bcb4dcff060787abe775351ca0"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NjgyMQ==", "bodyText": "Well, TraceableIterator still looks confusing to me, however, cause it's further use is unclear I'm ok with it.", "url": "https://github.com/apache/ignite/pull/8204#discussion_r486986821", "createdAt": "2020-09-11T11:36:18Z", "author": {"login": "sanpwc"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/tracing/TraceableIterator.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.tracing;\n+\n+import java.util.Iterator;\n+\n+import static org.apache.ignite.internal.processors.tracing.SpanTags.ERROR;\n+\n+/**\n+ * Represents wrapper which allows the iterator methods to execute within context of a specified span.\n+ */\n+public class TraceableIterator<T> implements Iterator<T> {\n+    /** Iterator to which all calls will be delegated. */\n+    private final Iterator<T> iter;\n+\n+    /** Span that reperesents trace context in which iterator runs. */\n+    private final Span span;\n+\n+    /**\n+     * @param iter Iterator to which all calls will be delegated.\n+     */\n+    public TraceableIterator(Iterator<T> iter) {\n+        this.iter = iter;\n+        this.span = MTC.span();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean hasNext() {\n+        MTC.supportInitial(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNzk3NA=="}, "originalCommit": {"oid": "5585ae55c68f30bcb4dcff060787abe775351ca0"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODYyNzQzOnYy", "diffSide": "RIGHT", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/dml/DmlUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwODoxMzoyOFrOHN1M_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOToxNjoxN1rOHN3faA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NTIxMg==", "bodyText": "Constant?", "url": "https://github.com/apache/ignite/pull/8204#discussion_r484265212", "createdAt": "2020-09-07T08:13:28Z", "author": {"login": "sanpwc"}, "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/dml/DmlUtils.java", "diffHunk": "@@ -194,10 +197,16 @@ private static long dmlDoInsert(UpdatePlan plan, Iterable<List<?>> cursor, int p\n         if (plan.rowCount() == 1) {\n             IgniteBiTuple t = plan.processRow(cursor.iterator().next());\n \n-            if (cctx.cache().putIfAbsent(t.getKey(), t.getValue()))\n-                return 1;\n-            else\n-                throw new TransactionDuplicateKeyException(\"Duplicate key during INSERT [key=\" + t.getKey() + ']');\n+            try (\n+                MTC.TraceSurroundings ignored = MTC.support(cctx.kernalContext().tracing()\n+                    .create(SQL_CACHE_UPDATE, MTC.span())\n+                    .addTag(SQL_CACHE_UPDATES, () -> Integer.toString(1)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5585ae55c68f30bcb4dcff060787abe775351ca0"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwMjY5Ng==", "bodyText": "Thanks. Done.", "url": "https://github.com/apache/ignite/pull/8204#discussion_r484302696", "createdAt": "2020-09-07T09:16:17Z", "author": {"login": "ololo3000"}, "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/dml/DmlUtils.java", "diffHunk": "@@ -194,10 +197,16 @@ private static long dmlDoInsert(UpdatePlan plan, Iterable<List<?>> cursor, int p\n         if (plan.rowCount() == 1) {\n             IgniteBiTuple t = plan.processRow(cursor.iterator().next());\n \n-            if (cctx.cache().putIfAbsent(t.getKey(), t.getValue()))\n-                return 1;\n-            else\n-                throw new TransactionDuplicateKeyException(\"Duplicate key during INSERT [key=\" + t.getKey() + ']');\n+            try (\n+                MTC.TraceSurroundings ignored = MTC.support(cctx.kernalContext().tracing()\n+                    .create(SQL_CACHE_UPDATE, MTC.span())\n+                    .addTag(SQL_CACHE_UPDATES, () -> Integer.toString(1)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NTIxMg=="}, "originalCommit": {"oid": "5585ae55c68f30bcb4dcff060787abe775351ca0"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2738, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}