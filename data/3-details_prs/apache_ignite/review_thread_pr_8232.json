{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMTAwNzE3", "number": 8232, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMToxMzo1N1rOEigIDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODo0Mjo0N1rOEjBd9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjEzMzg4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMToxMzo1N1rOHQatdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMToyMDo0MlrOHRPMzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njg4NQ==", "bodyText": "Can we replace 1 with 0?", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486976885", "createdAt": "2020-09-11T11:13:57Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params\n \n     def start(self):\n         super().start()\n \n         self.logger.info(\"Waiting for Ignite aware Application (%s) to start...\" % self.java_class_name)\n \n         self.await_event(\"Topology snapshot\", self.timeout_sec, from_the_beginning=True)\n-        self.await_event(\"IGNITE_APPLICATION_INITIALIZED\\\\|IGNITE_APPLICATION_BROKEN\", self.timeout_sec,\n-                         from_the_beginning=True)\n \n-        try:\n-            self.await_event(\"IGNITE_APPLICATION_INITIALIZED\", 1, from_the_beginning=True)\n-        except Exception:\n-            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\")) from None\n+        self.__check_status(\"IGNITE_APPLICATION_INITIALIZED\", timeout=self.timeout_sec)\n \n-    # pylint: disable=W0221\n-    def stop_node(self, node, clean_shutdown=True, timeout_sec=20):\n-        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(node.account)))\n-        node.account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown, allow_fail=True)\n+    def stop_async(self, clean_shutdown=True):\n+        \"\"\"\n+        Stops node in async way.\n+        \"\"\"\n+        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(self.nodes[0].account)))\n+        self.nodes[0].account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown,\n+                                                  allow_fail=True)\n \n-        stopped = self.wait_node(node, timeout_sec=self.stop_timeout_sec)\n+    def await_stopped(self, timeout_sec=10):\n+        \"\"\"\n+        Awaits node stop finish.\n+        \"\"\"\n+        stopped = self.wait_node(self.nodes[0], timeout_sec=timeout_sec)\n         assert stopped, \"Node %s: did not stop within the specified timeout of %s seconds\" % \\\n-                        (str(node.account), str(self.stop_timeout_sec))\n+                        (str(self.nodes[0].account), str(timeout_sec))\n \n-        self.await_event(\"IGNITE_APPLICATION_FINISHED\\\\|IGNITE_APPLICATION_BROKEN\", from_the_beginning=True,\n-                         timeout_sec=timeout_sec)\n+        self.__check_status(\"IGNITE_APPLICATION_FINISHED\", timeout=timeout_sec)\n+\n+    # pylint: disable=W0221\n+    def stop_node(self, node, clean_shutdown=True, timeout_sec=10):\n+        assert node == self.nodes[0]\n+        self.stop_async(clean_shutdown)\n+        self.await_stopped(timeout_sec)\n+\n+    def __check_status(self, desired, timeout=1):\n+        self.await_event(\"%s\\\\|IGNITE_APPLICATION_BROKEN\" % desired, timeout, from_the_beginning=True)\n+\n+        try:\n+            self.await_event(\"IGNITE_APPLICATION_BROKEN\", 1, from_the_beginning=True)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyNzMyOA==", "bodyText": "0 cause (may cause?) no-op wait and cause no exception if the statement missed.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487727328", "createdAt": "2020-09-14T08:09:15Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params\n \n     def start(self):\n         super().start()\n \n         self.logger.info(\"Waiting for Ignite aware Application (%s) to start...\" % self.java_class_name)\n \n         self.await_event(\"Topology snapshot\", self.timeout_sec, from_the_beginning=True)\n-        self.await_event(\"IGNITE_APPLICATION_INITIALIZED\\\\|IGNITE_APPLICATION_BROKEN\", self.timeout_sec,\n-                         from_the_beginning=True)\n \n-        try:\n-            self.await_event(\"IGNITE_APPLICATION_INITIALIZED\", 1, from_the_beginning=True)\n-        except Exception:\n-            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\")) from None\n+        self.__check_status(\"IGNITE_APPLICATION_INITIALIZED\", timeout=self.timeout_sec)\n \n-    # pylint: disable=W0221\n-    def stop_node(self, node, clean_shutdown=True, timeout_sec=20):\n-        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(node.account)))\n-        node.account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown, allow_fail=True)\n+    def stop_async(self, clean_shutdown=True):\n+        \"\"\"\n+        Stops node in async way.\n+        \"\"\"\n+        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(self.nodes[0].account)))\n+        self.nodes[0].account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown,\n+                                                  allow_fail=True)\n \n-        stopped = self.wait_node(node, timeout_sec=self.stop_timeout_sec)\n+    def await_stopped(self, timeout_sec=10):\n+        \"\"\"\n+        Awaits node stop finish.\n+        \"\"\"\n+        stopped = self.wait_node(self.nodes[0], timeout_sec=timeout_sec)\n         assert stopped, \"Node %s: did not stop within the specified timeout of %s seconds\" % \\\n-                        (str(node.account), str(self.stop_timeout_sec))\n+                        (str(self.nodes[0].account), str(timeout_sec))\n \n-        self.await_event(\"IGNITE_APPLICATION_FINISHED\\\\|IGNITE_APPLICATION_BROKEN\", from_the_beginning=True,\n-                         timeout_sec=timeout_sec)\n+        self.__check_status(\"IGNITE_APPLICATION_FINISHED\", timeout=timeout_sec)\n+\n+    # pylint: disable=W0221\n+    def stop_node(self, node, clean_shutdown=True, timeout_sec=10):\n+        assert node == self.nodes[0]\n+        self.stop_async(clean_shutdown)\n+        self.await_stopped(timeout_sec)\n+\n+    def __check_status(self, desired, timeout=1):\n+        self.await_event(\"%s\\\\|IGNITE_APPLICATION_BROKEN\" % desired, timeout, from_the_beginning=True)\n+\n+        try:\n+            self.await_event(\"IGNITE_APPLICATION_BROKEN\", 1, from_the_beginning=True)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njg4NQ=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxNTA3Mg==", "bodyText": "I mean there should be return immediately if log contains the specified line. As I see this line just checks that previous wait finishes due to error.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487815072", "createdAt": "2020-09-14T10:37:55Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params\n \n     def start(self):\n         super().start()\n \n         self.logger.info(\"Waiting for Ignite aware Application (%s) to start...\" % self.java_class_name)\n \n         self.await_event(\"Topology snapshot\", self.timeout_sec, from_the_beginning=True)\n-        self.await_event(\"IGNITE_APPLICATION_INITIALIZED\\\\|IGNITE_APPLICATION_BROKEN\", self.timeout_sec,\n-                         from_the_beginning=True)\n \n-        try:\n-            self.await_event(\"IGNITE_APPLICATION_INITIALIZED\", 1, from_the_beginning=True)\n-        except Exception:\n-            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\")) from None\n+        self.__check_status(\"IGNITE_APPLICATION_INITIALIZED\", timeout=self.timeout_sec)\n \n-    # pylint: disable=W0221\n-    def stop_node(self, node, clean_shutdown=True, timeout_sec=20):\n-        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(node.account)))\n-        node.account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown, allow_fail=True)\n+    def stop_async(self, clean_shutdown=True):\n+        \"\"\"\n+        Stops node in async way.\n+        \"\"\"\n+        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(self.nodes[0].account)))\n+        self.nodes[0].account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown,\n+                                                  allow_fail=True)\n \n-        stopped = self.wait_node(node, timeout_sec=self.stop_timeout_sec)\n+    def await_stopped(self, timeout_sec=10):\n+        \"\"\"\n+        Awaits node stop finish.\n+        \"\"\"\n+        stopped = self.wait_node(self.nodes[0], timeout_sec=timeout_sec)\n         assert stopped, \"Node %s: did not stop within the specified timeout of %s seconds\" % \\\n-                        (str(node.account), str(self.stop_timeout_sec))\n+                        (str(self.nodes[0].account), str(timeout_sec))\n \n-        self.await_event(\"IGNITE_APPLICATION_FINISHED\\\\|IGNITE_APPLICATION_BROKEN\", from_the_beginning=True,\n-                         timeout_sec=timeout_sec)\n+        self.__check_status(\"IGNITE_APPLICATION_FINISHED\", timeout=timeout_sec)\n+\n+    # pylint: disable=W0221\n+    def stop_node(self, node, clean_shutdown=True, timeout_sec=10):\n+        assert node == self.nodes[0]\n+        self.stop_async(clean_shutdown)\n+        self.await_stopped(timeout_sec)\n+\n+    def __check_status(self, desired, timeout=1):\n+        self.await_event(\"%s\\\\|IGNITE_APPLICATION_BROKEN\" % desired, timeout, from_the_beginning=True)\n+\n+        try:\n+            self.await_event(\"IGNITE_APPLICATION_BROKEN\", 1, from_the_beginning=True)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njg4NQ=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNjg3Nw==", "bodyText": "I tried to set 0 during development and this caused error-less behaviour where they were expected.\nSeems 0 unacceptable here.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487836877", "createdAt": "2020-09-14T11:20:42Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params\n \n     def start(self):\n         super().start()\n \n         self.logger.info(\"Waiting for Ignite aware Application (%s) to start...\" % self.java_class_name)\n \n         self.await_event(\"Topology snapshot\", self.timeout_sec, from_the_beginning=True)\n-        self.await_event(\"IGNITE_APPLICATION_INITIALIZED\\\\|IGNITE_APPLICATION_BROKEN\", self.timeout_sec,\n-                         from_the_beginning=True)\n \n-        try:\n-            self.await_event(\"IGNITE_APPLICATION_INITIALIZED\", 1, from_the_beginning=True)\n-        except Exception:\n-            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\")) from None\n+        self.__check_status(\"IGNITE_APPLICATION_INITIALIZED\", timeout=self.timeout_sec)\n \n-    # pylint: disable=W0221\n-    def stop_node(self, node, clean_shutdown=True, timeout_sec=20):\n-        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(node.account)))\n-        node.account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown, allow_fail=True)\n+    def stop_async(self, clean_shutdown=True):\n+        \"\"\"\n+        Stops node in async way.\n+        \"\"\"\n+        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(self.nodes[0].account)))\n+        self.nodes[0].account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown,\n+                                                  allow_fail=True)\n \n-        stopped = self.wait_node(node, timeout_sec=self.stop_timeout_sec)\n+    def await_stopped(self, timeout_sec=10):\n+        \"\"\"\n+        Awaits node stop finish.\n+        \"\"\"\n+        stopped = self.wait_node(self.nodes[0], timeout_sec=timeout_sec)\n         assert stopped, \"Node %s: did not stop within the specified timeout of %s seconds\" % \\\n-                        (str(node.account), str(self.stop_timeout_sec))\n+                        (str(self.nodes[0].account), str(timeout_sec))\n \n-        self.await_event(\"IGNITE_APPLICATION_FINISHED\\\\|IGNITE_APPLICATION_BROKEN\", from_the_beginning=True,\n-                         timeout_sec=timeout_sec)\n+        self.__check_status(\"IGNITE_APPLICATION_FINISHED\", timeout=timeout_sec)\n+\n+    # pylint: disable=W0221\n+    def stop_node(self, node, clean_shutdown=True, timeout_sec=10):\n+        assert node == self.nodes[0]\n+        self.stop_async(clean_shutdown)\n+        self.await_stopped(timeout_sec)\n+\n+    def __check_status(self, desired, timeout=1):\n+        self.await_event(\"%s\\\\|IGNITE_APPLICATION_BROKEN\" % desired, timeout, from_the_beginning=True)\n+\n+        try:\n+            self.await_event(\"IGNITE_APPLICATION_BROKEN\", 1, from_the_beginning=True)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njg4NQ=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjEzODQ2OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMToxNToyM1rOHQawIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODoxMDo0OVrOHRIkjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NzU3MA==", "bodyText": "falied -> failed", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486977570", "createdAt": "2020-09-11T11:15:23Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params\n \n     def start(self):\n         super().start()\n \n         self.logger.info(\"Waiting for Ignite aware Application (%s) to start...\" % self.java_class_name)\n \n         self.await_event(\"Topology snapshot\", self.timeout_sec, from_the_beginning=True)\n-        self.await_event(\"IGNITE_APPLICATION_INITIALIZED\\\\|IGNITE_APPLICATION_BROKEN\", self.timeout_sec,\n-                         from_the_beginning=True)\n \n-        try:\n-            self.await_event(\"IGNITE_APPLICATION_INITIALIZED\", 1, from_the_beginning=True)\n-        except Exception:\n-            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\")) from None\n+        self.__check_status(\"IGNITE_APPLICATION_INITIALIZED\", timeout=self.timeout_sec)\n \n-    # pylint: disable=W0221\n-    def stop_node(self, node, clean_shutdown=True, timeout_sec=20):\n-        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(node.account)))\n-        node.account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown, allow_fail=True)\n+    def stop_async(self, clean_shutdown=True):\n+        \"\"\"\n+        Stops node in async way.\n+        \"\"\"\n+        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(self.nodes[0].account)))\n+        self.nodes[0].account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown,\n+                                                  allow_fail=True)\n \n-        stopped = self.wait_node(node, timeout_sec=self.stop_timeout_sec)\n+    def await_stopped(self, timeout_sec=10):\n+        \"\"\"\n+        Awaits node stop finish.\n+        \"\"\"\n+        stopped = self.wait_node(self.nodes[0], timeout_sec=timeout_sec)\n         assert stopped, \"Node %s: did not stop within the specified timeout of %s seconds\" % \\\n-                        (str(node.account), str(self.stop_timeout_sec))\n+                        (str(self.nodes[0].account), str(timeout_sec))\n \n-        self.await_event(\"IGNITE_APPLICATION_FINISHED\\\\|IGNITE_APPLICATION_BROKEN\", from_the_beginning=True,\n-                         timeout_sec=timeout_sec)\n+        self.__check_status(\"IGNITE_APPLICATION_FINISHED\", timeout=timeout_sec)\n+\n+    # pylint: disable=W0221\n+    def stop_node(self, node, clean_shutdown=True, timeout_sec=10):\n+        assert node == self.nodes[0]\n+        self.stop_async(clean_shutdown)\n+        self.await_stopped(timeout_sec)\n+\n+    def __check_status(self, desired, timeout=1):\n+        self.await_event(\"%s\\\\|IGNITE_APPLICATION_BROKEN\" % desired, timeout, from_the_beginning=True)\n+\n+        try:\n+            self.await_event(\"IGNITE_APPLICATION_BROKEN\", 1, from_the_beginning=True)\n+            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\"))\n+        except TimeoutError:\n+            pass\n+\n+        try:\n+            self.await_event(desired, 1, from_the_beginning=True)\n+        except Exception:\n+            raise Exception(\"Java application execution falied.\") from None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyODI2OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487728269", "createdAt": "2020-09-14T08:10:49Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params\n \n     def start(self):\n         super().start()\n \n         self.logger.info(\"Waiting for Ignite aware Application (%s) to start...\" % self.java_class_name)\n \n         self.await_event(\"Topology snapshot\", self.timeout_sec, from_the_beginning=True)\n-        self.await_event(\"IGNITE_APPLICATION_INITIALIZED\\\\|IGNITE_APPLICATION_BROKEN\", self.timeout_sec,\n-                         from_the_beginning=True)\n \n-        try:\n-            self.await_event(\"IGNITE_APPLICATION_INITIALIZED\", 1, from_the_beginning=True)\n-        except Exception:\n-            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\")) from None\n+        self.__check_status(\"IGNITE_APPLICATION_INITIALIZED\", timeout=self.timeout_sec)\n \n-    # pylint: disable=W0221\n-    def stop_node(self, node, clean_shutdown=True, timeout_sec=20):\n-        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(node.account)))\n-        node.account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown, allow_fail=True)\n+    def stop_async(self, clean_shutdown=True):\n+        \"\"\"\n+        Stops node in async way.\n+        \"\"\"\n+        self.logger.info(\"%s Stopping node %s\" % (self.__class__.__name__, str(self.nodes[0].account)))\n+        self.nodes[0].account.kill_java_processes(self.servicejava_class_name, clean_shutdown=clean_shutdown,\n+                                                  allow_fail=True)\n \n-        stopped = self.wait_node(node, timeout_sec=self.stop_timeout_sec)\n+    def await_stopped(self, timeout_sec=10):\n+        \"\"\"\n+        Awaits node stop finish.\n+        \"\"\"\n+        stopped = self.wait_node(self.nodes[0], timeout_sec=timeout_sec)\n         assert stopped, \"Node %s: did not stop within the specified timeout of %s seconds\" % \\\n-                        (str(node.account), str(self.stop_timeout_sec))\n+                        (str(self.nodes[0].account), str(timeout_sec))\n \n-        self.await_event(\"IGNITE_APPLICATION_FINISHED\\\\|IGNITE_APPLICATION_BROKEN\", from_the_beginning=True,\n-                         timeout_sec=timeout_sec)\n+        self.__check_status(\"IGNITE_APPLICATION_FINISHED\", timeout=timeout_sec)\n+\n+    # pylint: disable=W0221\n+    def stop_node(self, node, clean_shutdown=True, timeout_sec=10):\n+        assert node == self.nodes[0]\n+        self.stop_async(clean_shutdown)\n+        self.await_stopped(timeout_sec)\n+\n+    def __check_status(self, desired, timeout=1):\n+        self.await_event(\"%s\\\\|IGNITE_APPLICATION_BROKEN\" % desired, timeout, from_the_beginning=True)\n+\n+        try:\n+            self.await_event(\"IGNITE_APPLICATION_BROKEN\", 1, from_the_beginning=True)\n+            raise Exception(\"Java application execution failed. %s\" % self.extract_result(\"ERROR\"))\n+        except TimeoutError:\n+            pass\n+\n+        try:\n+            self.await_event(desired, 1, from_the_beginning=True)\n+        except Exception:\n+            raise Exception(\"Java application execution falied.\") from None", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NzU3MA=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjE4MzQ5OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTozMTowNVrOHQbLNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDo0NToxNFrOHROGiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDUwMQ==", "bodyText": "How is it used?", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486984501", "createdAt": "2020-09-11T11:31:05Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyOTMzOQ==", "bodyText": "It is used to gain start params of the application.\nsee cellular_affinity_test.py:155 for example.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487729339", "createdAt": "2020-09-14T08:12:37Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDUwMQ=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxODg4OQ==", "bodyText": "ok", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487818889", "createdAt": "2020-09-14T10:45:14Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/ignite_app.py", "diffHunk": "@@ -38,33 +41,54 @@ def __init__(self, context, config, java_class_name, params=\"\", timeout_sec=60,\n         self.servicejava_class_name = servicejava_class_name\n         self.java_class_name = java_class_name\n         self.timeout_sec = timeout_sec\n-        self.stop_timeout_sec = 10\n+        self.params = params", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDUwMQ=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjE4NjAxOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_spec.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTozMTo1NVrOHQbMrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMToyMjo0OVrOHRPRIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDg3Ng==", "bodyText": "Why do you add ducktests to NodeSpec?", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486984876", "createdAt": "2020-09-11T11:31:55Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_spec.py", "diffHunk": "@@ -147,6 +146,8 @@ def __init__(self, modules, **kwargs):\n         libs.append(\"log4j\")\n         libs = list(map(lambda m: self.path.module(m) + \"/*\", libs))\n \n+        libs.append(IgnitePath(DEV_BRANCH).module(\"ducktests\") + \"/*\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzczMDE5MA==", "bodyText": "At this test, we have a special node filter (see CellularAffinityBackupFilter.java) and we have to deploy it to all server node's classpath.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487730190", "createdAt": "2020-09-14T08:14:03Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_spec.py", "diffHunk": "@@ -147,6 +146,8 @@ def __init__(self, modules, **kwargs):\n         libs.append(\"log4j\")\n         libs = list(map(lambda m: self.path.module(m) + \"/*\", libs))\n \n+        libs.append(IgnitePath(DEV_BRANCH).module(\"ducktests\") + \"/*\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDg3Ng=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxOTk2Mg==", "bodyText": "There is a code duplication - the same in ApplicationSpec. Could you please move this code to function?", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487819962", "createdAt": "2020-09-14T10:47:24Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_spec.py", "diffHunk": "@@ -147,6 +146,8 @@ def __init__(self, modules, **kwargs):\n         libs.append(\"log4j\")\n         libs = list(map(lambda m: self.path.module(m) + \"/*\", libs))\n \n+        libs.append(IgnitePath(DEV_BRANCH).module(\"ducktests\") + \"/*\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDg3Ng=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNzk4Nw==", "bodyText": "Seems, we have to plan some refactoring here (at specs), can we postpone this to refactoring?", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487837987", "createdAt": "2020-09-14T11:22:49Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_spec.py", "diffHunk": "@@ -147,6 +146,8 @@ def __init__(self, modules, **kwargs):\n         libs.append(\"log4j\")\n         libs = list(map(lambda m: self.path.module(m) + \"/*\", libs))\n \n+        libs.append(IgnitePath(DEV_BRANCH).module(\"ducktests\") + \"/*\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDg3Ng=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjIyNTU4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/PreparedTxStreamer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTo0NTowMlrOHQbjuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODoxNjo1MlrOHRIyZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MDc3Nw==", "bodyText": "IgniteAwareApplication::start already catch any exception and mark app as broken", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486990777", "createdAt": "2020-09-11T11:45:02Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/PreparedTxStreamer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+import org.apache.ignite.internal.processors.cache.transactions.TransactionProxyImpl;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.Transaction;\n+\n+/**\n+ *\n+ */\n+public class PreparedTxStreamer extends IgniteAwareApplication {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override protected void run(JsonNode jsonNode) throws Exception {\n+        final String cacheName = jsonNode.get(\"cacheName\").asText();\n+        final String attr = jsonNode.get(\"attr\").asText();\n+        final String cell = jsonNode.get(\"cell\").asText();\n+        final int txCnt = jsonNode.get(\"txCnt\").asInt();\n+\n+        markInitialized();\n+\n+        waitForActivation();\n+\n+        IgniteCache<Integer, Integer> cache = ignite.getOrCreateCache(cacheName);\n+\n+        log.info(\"Starting Prepared Txs...\");\n+\n+        Affinity<Integer> aff = ignite.affinity(cacheName);\n+\n+        int cnt = 0;\n+        int i = -1; // Negative keys to have no intersection with load.\n+\n+        while (cnt != txCnt && !terminated()) {\n+            Collection<ClusterNode> nodes = aff.mapKeyToPrimaryAndBackups(i);\n+\n+            Map<Object, Long> stat = nodes.stream().collect(\n+                Collectors.groupingBy(n -> n.attributes().get(attr), Collectors.counting()));\n+\n+            assert 1 == stat.keySet().size() :\n+                \"Partition should be located on nodes from only one cell \" +\n+                    \"[key=\" + i + \", nodes=\" + nodes.size() + \", stat=\" + stat + \"]\";\n+\n+            if (stat.containsKey(cell)) {\n+                cnt++;\n+\n+                Transaction tx = ignite.transactions().txStart();\n+\n+                cache.put(i, i);\n+\n+                try {\n+                    ((TransactionProxyImpl<?, ?>)tx).tx().prepare(true);\n+                }\n+                catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzczMTgxMw==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487731813", "createdAt": "2020-09-14T08:16:52Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/PreparedTxStreamer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+import org.apache.ignite.internal.processors.cache.transactions.TransactionProxyImpl;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.Transaction;\n+\n+/**\n+ *\n+ */\n+public class PreparedTxStreamer extends IgniteAwareApplication {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override protected void run(JsonNode jsonNode) throws Exception {\n+        final String cacheName = jsonNode.get(\"cacheName\").asText();\n+        final String attr = jsonNode.get(\"attr\").asText();\n+        final String cell = jsonNode.get(\"cell\").asText();\n+        final int txCnt = jsonNode.get(\"txCnt\").asInt();\n+\n+        markInitialized();\n+\n+        waitForActivation();\n+\n+        IgniteCache<Integer, Integer> cache = ignite.getOrCreateCache(cacheName);\n+\n+        log.info(\"Starting Prepared Txs...\");\n+\n+        Affinity<Integer> aff = ignite.affinity(cacheName);\n+\n+        int cnt = 0;\n+        int i = -1; // Negative keys to have no intersection with load.\n+\n+        while (cnt != txCnt && !terminated()) {\n+            Collection<ClusterNode> nodes = aff.mapKeyToPrimaryAndBackups(i);\n+\n+            Map<Object, Long> stat = nodes.stream().collect(\n+                Collectors.groupingBy(n -> n.attributes().get(attr), Collectors.counting()));\n+\n+            assert 1 == stat.keySet().size() :\n+                \"Partition should be located on nodes from only one cell \" +\n+                    \"[key=\" + i + \", nodes=\" + nodes.size() + \", stat=\" + stat + \"]\";\n+\n+            if (stat.containsKey(cell)) {\n+                cnt++;\n+\n+                Transaction tx = ignite.transactions().txStart();\n+\n+                cache.put(i, i);\n+\n+                try {\n+                    ((TransactionProxyImpl<?, ?>)tx).tx().prepare(true);\n+                }\n+                catch (IgniteCheckedException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MDc3Nw=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjI0NDU5OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/TxStreamer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTo1MTo0M1rOHQbvOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODoyNDozNlrOHRJDtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzcyMA==", "bodyText": "Could you please provide a short brief of the class", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486993720", "createdAt": "2020-09-11T11:51:43Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/TxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzczNjI0Nw==", "bodyText": "Done", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487736247", "createdAt": "2020-09-14T08:24:36Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/TxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzcyMA=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjI0NTE3OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/PreparedTxStreamer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTo1MTo1NlrOHQbvjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODoyNDo0OVrOHRJEOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzgwNw==", "bodyText": "Could you please provide a short brief of the class", "url": "https://github.com/apache/ignite/pull/8232#discussion_r486993807", "createdAt": "2020-09-11T11:51:56Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/PreparedTxStreamer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+import org.apache.ignite.internal.processors.cache.transactions.TransactionProxyImpl;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.Transaction;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzczNjM3OQ==", "bodyText": "Done", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487736379", "createdAt": "2020-09-14T08:24:49Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/PreparedTxStreamer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+import org.apache.ignite.internal.processors.cache.transactions.TransactionProxyImpl;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.Transaction;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5MzgwNw=="}, "originalCommit": {"oid": "13393bba8c1bc45103b2cac8aa99cc870de284f3"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTU3Nzk5OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODozODowNVrOHRJkPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTozMDo0N1rOHRLhjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NDU3Mg==", "bodyText": "I suppose that this should be one-lined", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487744572", "createdAt": "2020-09-14T08:38:05Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ * Streams transactions to specified cell.\n+ */\n+public class CellularTxStreamer extends IgniteAwareApplication {\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc686f3af44c0c90ca6efbaccf6cd5bf8006575"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3NjY1Mw==", "bodyText": "Correct. Fixed.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487776653", "createdAt": "2020-09-14T09:30:47Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ * Streams transactions to specified cell.\n+ */\n+public class CellularTxStreamer extends IgniteAwareApplication {\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NDU3Mg=="}, "originalCommit": {"oid": "6bc686f3af44c0c90ca6efbaccf6cd5bf8006575"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTU4NzI4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODo0MDoyM1rOHRJpwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTozODoyNFrOHRLykQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NTk4Ng==", "bodyText": "Why 10_000_000? You never use this fact in the code.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487745986", "createdAt": "2020-09-14T08:40:23Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ * Streams transactions to specified cell.\n+ */\n+public class CellularTxStreamer extends IgniteAwareApplication {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override public void run(JsonNode jsonNode) throws Exception {\n+        String cacheName = jsonNode.get(\"cacheName\").asText();\n+        int warmup = jsonNode.get(\"warmup\").asInt();\n+        String cell = jsonNode.get(\"cell\").asText();\n+        String attr = jsonNode.get(\"attr\").asText();\n+\n+        markInitialized();\n+\n+        waitForActivation();\n+\n+        IgniteCache<Integer, Integer> cache = ignite.getOrCreateCache(cacheName);\n+\n+        long[] max = new long[20];\n+\n+        Arrays.fill(max, -1);\n+\n+        int key = 10_000_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc686f3af44c0c90ca6efbaccf6cd5bf8006575"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MTAwOQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487781009", "createdAt": "2020-09-14T09:38:24Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ * Streams transactions to specified cell.\n+ */\n+public class CellularTxStreamer extends IgniteAwareApplication {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override public void run(JsonNode jsonNode) throws Exception {\n+        String cacheName = jsonNode.get(\"cacheName\").asText();\n+        int warmup = jsonNode.get(\"warmup\").asInt();\n+        String cell = jsonNode.get(\"cell\").asText();\n+        String attr = jsonNode.get(\"attr\").asText();\n+\n+        markInitialized();\n+\n+        waitForActivation();\n+\n+        IgniteCache<Integer, Integer> cache = ignite.getOrCreateCache(cacheName);\n+\n+        long[] max = new long[20];\n+\n+        Arrays.fill(max, -1);\n+\n+        int key = 10_000_000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NTk4Ng=="}, "originalCommit": {"oid": "6bc686f3af44c0c90ca6efbaccf6cd5bf8006575"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTU5NjcwOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwODo0Mjo0N1rOHRJvNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwOTozMTo1MVrOHRLj4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NzM4Mg==", "bodyText": "Use PriorityQueue (binary heap) here", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487747382", "createdAt": "2020-09-14T08:42:47Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ * Streams transactions to specified cell.\n+ */\n+public class CellularTxStreamer extends IgniteAwareApplication {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override public void run(JsonNode jsonNode) throws Exception {\n+        String cacheName = jsonNode.get(\"cacheName\").asText();\n+        int warmup = jsonNode.get(\"warmup\").asInt();\n+        String cell = jsonNode.get(\"cell\").asText();\n+        String attr = jsonNode.get(\"attr\").asText();\n+\n+        markInitialized();\n+\n+        waitForActivation();\n+\n+        IgniteCache<Integer, Integer> cache = ignite.getOrCreateCache(cacheName);\n+\n+        long[] max = new long[20];\n+\n+        Arrays.fill(max, -1);\n+\n+        int key = 10_000_000;\n+\n+        int cnt = 0;\n+\n+        long initTime = 0;\n+\n+        boolean record = false;\n+\n+        Affinity<Integer> aff = ignite.affinity(cacheName);\n+\n+        while (!terminated()) {\n+            key++;\n+\n+            Collection<ClusterNode> nodes = aff.mapKeyToPrimaryAndBackups(key);\n+\n+            Map<Object, Long> stat = nodes.stream().collect(\n+                Collectors.groupingBy(n -> n.attributes().get(attr), Collectors.counting()));\n+\n+            if (!stat.containsKey(cell))\n+                continue;\n+\n+            cnt++;\n+\n+            long start = System.currentTimeMillis();\n+\n+            cache.put(key, key);\n+\n+            long finish = System.currentTimeMillis();\n+\n+            long time = finish - start;\n+\n+            if (!record && cnt > warmup) {\n+                record = true;\n+\n+                initTime = System.currentTimeMillis();\n+\n+                log.info(\"Warmup finished\");\n+            }\n+\n+            if (record) {\n+                for (int i = 0; i < max.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bc686f3af44c0c90ca6efbaccf6cd5bf8006575"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3NzI1MA==", "bodyText": "Discussed privately, the array is ok.", "url": "https://github.com/apache/ignite/pull/8232#discussion_r487777250", "createdAt": "2020-09-14T09:31:51Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/src/main/java/org/apache/ignite/internal/ducktest/tests/cellular_affinity_test/CellularTxStreamer.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.ducktest.tests.cellular_affinity_test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.internal.ducktest.utils.IgniteAwareApplication;\n+\n+/**\n+ * Streams transactions to specified cell.\n+ */\n+public class CellularTxStreamer extends IgniteAwareApplication {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override public void run(JsonNode jsonNode) throws Exception {\n+        String cacheName = jsonNode.get(\"cacheName\").asText();\n+        int warmup = jsonNode.get(\"warmup\").asInt();\n+        String cell = jsonNode.get(\"cell\").asText();\n+        String attr = jsonNode.get(\"attr\").asText();\n+\n+        markInitialized();\n+\n+        waitForActivation();\n+\n+        IgniteCache<Integer, Integer> cache = ignite.getOrCreateCache(cacheName);\n+\n+        long[] max = new long[20];\n+\n+        Arrays.fill(max, -1);\n+\n+        int key = 10_000_000;\n+\n+        int cnt = 0;\n+\n+        long initTime = 0;\n+\n+        boolean record = false;\n+\n+        Affinity<Integer> aff = ignite.affinity(cacheName);\n+\n+        while (!terminated()) {\n+            key++;\n+\n+            Collection<ClusterNode> nodes = aff.mapKeyToPrimaryAndBackups(key);\n+\n+            Map<Object, Long> stat = nodes.stream().collect(\n+                Collectors.groupingBy(n -> n.attributes().get(attr), Collectors.counting()));\n+\n+            if (!stat.containsKey(cell))\n+                continue;\n+\n+            cnt++;\n+\n+            long start = System.currentTimeMillis();\n+\n+            cache.put(key, key);\n+\n+            long finish = System.currentTimeMillis();\n+\n+            long time = finish - start;\n+\n+            if (!record && cnt > warmup) {\n+                record = true;\n+\n+                initTime = System.currentTimeMillis();\n+\n+                log.info(\"Warmup finished\");\n+            }\n+\n+            if (record) {\n+                for (int i = 0; i < max.length; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NzM4Mg=="}, "originalCommit": {"oid": "6bc686f3af44c0c90ca6efbaccf6cd5bf8006575"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2764, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}