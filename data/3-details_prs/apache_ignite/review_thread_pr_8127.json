{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MDkxNDAz", "number": 8127, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzowMzoyNFrOEWyFHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzo1MDo0NlrOEWzTPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzI0NjM5OnYy", "diffSide": "RIGHT", "path": "bin/include/build-classpath.sh", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzowMzoyNFrOG-NkcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzowMzoyNFrOG-NkcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4NzIxNg==", "bodyText": "do we really need EXCLUDE_MODULES?", "url": "https://github.com/apache/ignite/pull/8127#discussion_r467887216", "createdAt": "2020-08-10T13:03:24Z", "author": {"login": "timoninmaxim"}, "path": "bin/include/build-classpath.sh", "diffHunk": "@@ -47,14 +47,13 @@ includeToClassPath() {\n \n     for file in $1/*\n     do\n-        if [[ -z \"${EXCLUDE_MODULES}\" ]] || [[ ${EXCLUDE_MODULES} != *\"`basename $file`\"* ]]; then\n-            echo \"$file included\"\n+        if [[ -z \"${EXCLUDE_MODULES:-}\" ]] || [[ ${EXCLUDE_MODULES:-} != *\"`basename $file`\"* ]]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzI2MTM4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/utils/control_utility.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzowNzozOFrOG-Ntng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzowNzozOFrOG-Ntng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4OTU2Ng==", "bodyText": "What do you think, is it better to use named group instead of indices?\nhttps://docs.python.org/3/howto/regex.html#non-capturing-and-named-groups", "url": "https://github.com/apache/ignite/pull/8127#discussion_r467889566", "createdAt": "2020-08-10T13:07:38Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/utils/control_utility.py", "diffHunk": "@@ -0,0 +1,167 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains control utility wrapper.\n+\"\"\"\n+import random\n+import re\n+from collections import namedtuple\n+\n+from ducktape.cluster.remoteaccount import RemoteCommandError\n+\n+\n+class ControlUtility:\n+    \"\"\"\n+    Control utility (control.sh) wrapper.\n+    \"\"\"\n+    BASE_COMMAND = \"control.sh\"\n+\n+    def __init__(self, cluster, text_context):\n+        self._cluster = cluster\n+        self.logger = text_context.logger\n+\n+    def baseline(self):\n+        \"\"\"\n+        :return Baseline nodes.\n+        \"\"\"\n+        return self.cluster_state().baseline\n+\n+    def cluster_state(self):\n+        \"\"\"\n+        :return: Cluster state.\n+        \"\"\"\n+        output = self.__run(\"--baseline\")\n+\n+        return self.__parse_cluster_state(output)\n+\n+    def set_baseline(self, baseline):\n+        \"\"\"\n+        :param baseline: Baseline nodes or topology version to set as baseline.\n+        \"\"\"\n+        if isinstance(baseline, int):\n+            result = self.__run(\"--baseline version %d --yes\" % baseline)\n+        else:\n+            result = self.__run(\"--baseline set %s --yes\" %\n+                                \",\".join([node.account.externally_routable_ip for node in baseline]))\n+\n+        return self.__parse_cluster_state(result)\n+\n+    def add_to_baseline(self, nodes):\n+        \"\"\"\n+        :param nodes: Nodes that should be added to baseline.\n+        \"\"\"\n+        result = self.__run(\"--baseline add %s --yes\" %\n+                            \",\".join([node.account.externally_routable_ip for node in nodes]))\n+\n+        return self.__parse_cluster_state(result)\n+\n+    def remove_from_baseline(self, nodes):\n+        \"\"\"\n+        :param nodes: Nodes that should be removed to baseline.\n+        \"\"\"\n+        result = self.__run(\"--baseline remove %s --yes\" %\n+                            \",\".join([node.account.externally_routable_ip for node in nodes]))\n+\n+        return self.__parse_cluster_state(result)\n+\n+    def disable_baseline_auto_adjust(self):\n+        \"\"\"\n+        Disable baseline auto adjust.\n+        \"\"\"\n+        return self.__run(\"--baseline auto_adjust disable --yes\")\n+\n+    def enable_baseline_auto_adjust(self, timeout=None):\n+        \"\"\"\n+        Enable baseline auto adjust.\n+        :param timeout: Auto adjust timeout in millis.\n+        \"\"\"\n+        timeout_str = \"timeout %d\" % timeout if timeout else \"\"\n+        return self.__run(\"--baseline auto_adjust enable %s --yes\" % timeout_str)\n+\n+    def activate(self):\n+        \"\"\"\n+        Activate cluster.\n+        \"\"\"\n+        return self.__run(\"--activate --yes\")\n+\n+    def deactivate(self):\n+        \"\"\"\n+        Deactivate cluster.\n+        \"\"\"\n+        return self.__run(\"--deactivate --yes\")\n+\n+    @staticmethod\n+    def __parse_cluster_state(output):\n+        state_pattern = re.compile(\"Cluster state: ([^\\\\s]+)\")\n+        topology_pattern = re.compile(\"Current topology version: (\\\\d+)\")\n+        baseline_pattern = re.compile(\"Consistent(Id|ID)=([^\\\\s]+),\\\\sS(tate|TATE)=([^\\\\s]+),?(\\\\sOrder=(\\\\d+))?\")\n+\n+        match = state_pattern.search(output)\n+        state = match.group(1) if match else None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzI3NzE4OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/utils/control_utility.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzoxMTo0NlrOG-N3IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzoxMTo0NlrOG-N3IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg5MjAwMQ==", "bodyText": "Use 'result' instead of 'output', as it's used in other methods. Or vice versa", "url": "https://github.com/apache/ignite/pull/8127#discussion_r467892001", "createdAt": "2020-08-10T13:11:46Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/utils/control_utility.py", "diffHunk": "@@ -0,0 +1,167 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains control utility wrapper.\n+\"\"\"\n+import random\n+import re\n+from collections import namedtuple\n+\n+from ducktape.cluster.remoteaccount import RemoteCommandError\n+\n+\n+class ControlUtility:\n+    \"\"\"\n+    Control utility (control.sh) wrapper.\n+    \"\"\"\n+    BASE_COMMAND = \"control.sh\"\n+\n+    def __init__(self, cluster, text_context):\n+        self._cluster = cluster\n+        self.logger = text_context.logger\n+\n+    def baseline(self):\n+        \"\"\"\n+        :return Baseline nodes.\n+        \"\"\"\n+        return self.cluster_state().baseline\n+\n+    def cluster_state(self):\n+        \"\"\"\n+        :return: Cluster state.\n+        \"\"\"\n+        output = self.__run(\"--baseline\")\n+\n+        return self.__parse_cluster_state(output)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzM2MTkwOnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/tests/control_utility_test.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzozMTowMlrOG-OoPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwODowMDoxM1rOG-ssVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkwNDU3NQ==", "bodyText": "This condition is not part of test itself, let's make decorator from that. Otherwise we should not used it at all, as every test should be marked this way.", "url": "https://github.com/apache/ignite/pull/8127#discussion_r467904575", "createdAt": "2020-08-10T13:31:02Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/tests/control_utility_test.py", "diffHunk": "@@ -0,0 +1,235 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains control.sh utility tests.\n+\"\"\"\n+from ducktape.mark import parametrize\n+from ducktape.mark.resource import cluster\n+from ducktape.utils.util import wait_until\n+from jinja2 import Template\n+\n+from ignitetest.services.ignite import IgniteService\n+from ignitetest.services.utils.control_utility import ControlUtility, ControlUtilityError\n+from ignitetest.tests.utils.ignite_test import IgniteTest\n+from ignitetest.tests.utils.version import DEV_BRANCH, LATEST_2_8, IgniteVersion, LATEST_2_7, V_2_8_0\n+\n+\n+# pylint: disable=W0223\n+class BaselineTests(IgniteTest):\n+    \"\"\"\n+    Tests baseline command\n+    \"\"\"\n+    NUM_NODES = 3\n+\n+    CONFIG_TEMPLATE = \"\"\"\n+        {% if version > \"2.9.0\" %}\n+            <property name=\"clusterStateOnStart\" value=\"INACTIVE\"/>\n+        {%  else %}\n+            <property name=\"activeOnStart\" value=\"false\"/>\n+        {% endif %}\n+        <property name=\"dataStorageConfiguration\">\n+            <bean class=\"org.apache.ignite.configuration.DataStorageConfiguration\">\n+                <property name=\"defaultDataRegionConfiguration\">\n+                    <bean class=\"org.apache.ignite.configuration.DataRegionConfiguration\">\n+                        <property name=\"persistenceEnabled\" value=\"true\"/>\n+                        <property name=\"maxSize\" value=\"#{100L * 1024 * 1024}\"/>\n+                    </bean>\n+                </property>\n+            </bean>\n+        </property>\n+    \"\"\"\n+\n+    @staticmethod\n+    def properties(version):\n+        \"\"\"\n+        Render properties for ignite node configuration.\n+        \"\"\"\n+        return Template(BaselineTests.CONFIG_TEMPLATE) \\\n+            .render(version=version)\n+\n+    def __init__(self, test_context):\n+        super(BaselineTests, self).__init__(test_context)\n+        self.servers = None\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_baseline_set(self, version):\n+        \"\"\"\n+        Test baseline set.\n+        \"\"\"\n+        blt_size = self.NUM_NODES - 2\n+        self.servers = self.__start_ignite_nodes(version, blt_size)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+        control_utility.activate()\n+\n+        # Check baseline of activated cluster.\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(self.servers.nodes, baseline)\n+\n+        # Set baseline using list of conststent ids.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        control_utility.set_baseline(self.servers.nodes + new_node.nodes)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+        # Set baseline using topology version.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        _, version, _ = control_utility.cluster_state()\n+        control_utility.set_baseline(version)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_baseline_add_remove(self, version):\n+        \"\"\"\n+        Test add and remove nodes from baseline.\n+        \"\"\"\n+        blt_size = self.NUM_NODES - 1\n+        self.servers = self.__start_ignite_nodes(version, blt_size)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+\n+        control_utility.activate()\n+\n+        # Add node to baseline.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        control_utility.add_to_baseline(new_node.nodes)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+        # Expected failure (remove of online node is not allowed).\n+        try:\n+            control_utility.remove_from_baseline(new_node.nodes)\n+\n+            assert False, \"Remove of online node from baseline should fail!\"\n+        except ControlUtilityError:\n+            pass\n+\n+        # Remove of offline node from baseline.\n+        new_node.stop()\n+\n+        self.servers.await_event(\"Node left topology\", timeout_sec=30, from_the_beginning=True)\n+\n+        control_utility.remove_from_baseline(new_node.nodes)\n+        blt_size -= 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_not_in_baseline(new_node.nodes, baseline)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_activate_deactivate(self, version):\n+        \"\"\"\n+        Test activate and deactivate cluster.\n+        \"\"\"\n+        self.servers = self.__start_ignite_nodes(version, self.NUM_NODES)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+\n+        control_utility.activate()\n+\n+        state, _, _ = control_utility.cluster_state()\n+\n+        assert state.lower() == 'active', 'Unexpected state %s' % state\n+\n+        control_utility.deactivate()\n+\n+        state, _, _ = control_utility.cluster_state()\n+\n+        assert state.lower() == 'inactive', 'Unexpected state %s' % state\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    def test_baseline_autoadjust(self, version):\n+        \"\"\"\n+        Test activate and deactivate cluster.\n+        \"\"\"\n+        if version < V_2_8_0:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MTk5Mg==", "bodyText": "@timoninmaxim could explain how to do this properly in detail, if possible.", "url": "https://github.com/apache/ignite/pull/8127#discussion_r468391992", "createdAt": "2020-08-11T07:51:03Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/tests/control_utility_test.py", "diffHunk": "@@ -0,0 +1,235 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains control.sh utility tests.\n+\"\"\"\n+from ducktape.mark import parametrize\n+from ducktape.mark.resource import cluster\n+from ducktape.utils.util import wait_until\n+from jinja2 import Template\n+\n+from ignitetest.services.ignite import IgniteService\n+from ignitetest.services.utils.control_utility import ControlUtility, ControlUtilityError\n+from ignitetest.tests.utils.ignite_test import IgniteTest\n+from ignitetest.tests.utils.version import DEV_BRANCH, LATEST_2_8, IgniteVersion, LATEST_2_7, V_2_8_0\n+\n+\n+# pylint: disable=W0223\n+class BaselineTests(IgniteTest):\n+    \"\"\"\n+    Tests baseline command\n+    \"\"\"\n+    NUM_NODES = 3\n+\n+    CONFIG_TEMPLATE = \"\"\"\n+        {% if version > \"2.9.0\" %}\n+            <property name=\"clusterStateOnStart\" value=\"INACTIVE\"/>\n+        {%  else %}\n+            <property name=\"activeOnStart\" value=\"false\"/>\n+        {% endif %}\n+        <property name=\"dataStorageConfiguration\">\n+            <bean class=\"org.apache.ignite.configuration.DataStorageConfiguration\">\n+                <property name=\"defaultDataRegionConfiguration\">\n+                    <bean class=\"org.apache.ignite.configuration.DataRegionConfiguration\">\n+                        <property name=\"persistenceEnabled\" value=\"true\"/>\n+                        <property name=\"maxSize\" value=\"#{100L * 1024 * 1024}\"/>\n+                    </bean>\n+                </property>\n+            </bean>\n+        </property>\n+    \"\"\"\n+\n+    @staticmethod\n+    def properties(version):\n+        \"\"\"\n+        Render properties for ignite node configuration.\n+        \"\"\"\n+        return Template(BaselineTests.CONFIG_TEMPLATE) \\\n+            .render(version=version)\n+\n+    def __init__(self, test_context):\n+        super(BaselineTests, self).__init__(test_context)\n+        self.servers = None\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_baseline_set(self, version):\n+        \"\"\"\n+        Test baseline set.\n+        \"\"\"\n+        blt_size = self.NUM_NODES - 2\n+        self.servers = self.__start_ignite_nodes(version, blt_size)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+        control_utility.activate()\n+\n+        # Check baseline of activated cluster.\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(self.servers.nodes, baseline)\n+\n+        # Set baseline using list of conststent ids.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        control_utility.set_baseline(self.servers.nodes + new_node.nodes)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+        # Set baseline using topology version.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        _, version, _ = control_utility.cluster_state()\n+        control_utility.set_baseline(version)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_baseline_add_remove(self, version):\n+        \"\"\"\n+        Test add and remove nodes from baseline.\n+        \"\"\"\n+        blt_size = self.NUM_NODES - 1\n+        self.servers = self.__start_ignite_nodes(version, blt_size)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+\n+        control_utility.activate()\n+\n+        # Add node to baseline.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        control_utility.add_to_baseline(new_node.nodes)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+        # Expected failure (remove of online node is not allowed).\n+        try:\n+            control_utility.remove_from_baseline(new_node.nodes)\n+\n+            assert False, \"Remove of online node from baseline should fail!\"\n+        except ControlUtilityError:\n+            pass\n+\n+        # Remove of offline node from baseline.\n+        new_node.stop()\n+\n+        self.servers.await_event(\"Node left topology\", timeout_sec=30, from_the_beginning=True)\n+\n+        control_utility.remove_from_baseline(new_node.nodes)\n+        blt_size -= 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_not_in_baseline(new_node.nodes, baseline)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_activate_deactivate(self, version):\n+        \"\"\"\n+        Test activate and deactivate cluster.\n+        \"\"\"\n+        self.servers = self.__start_ignite_nodes(version, self.NUM_NODES)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+\n+        control_utility.activate()\n+\n+        state, _, _ = control_utility.cluster_state()\n+\n+        assert state.lower() == 'active', 'Unexpected state %s' % state\n+\n+        control_utility.deactivate()\n+\n+        state, _, _ = control_utility.cluster_state()\n+\n+        assert state.lower() == 'inactive', 'Unexpected state %s' % state\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    def test_baseline_autoadjust(self, version):\n+        \"\"\"\n+        Test activate and deactivate cluster.\n+        \"\"\"\n+        if version < V_2_8_0:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkwNDU3NQ=="}, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5NzE0MQ==", "bodyText": "@anton-vinogradov See my next PR #8137", "url": "https://github.com/apache/ignite/pull/8127#discussion_r468397141", "createdAt": "2020-08-11T08:00:13Z", "author": {"login": "ivandasch"}, "path": "modules/ducktests/tests/ignitetest/tests/control_utility_test.py", "diffHunk": "@@ -0,0 +1,235 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains control.sh utility tests.\n+\"\"\"\n+from ducktape.mark import parametrize\n+from ducktape.mark.resource import cluster\n+from ducktape.utils.util import wait_until\n+from jinja2 import Template\n+\n+from ignitetest.services.ignite import IgniteService\n+from ignitetest.services.utils.control_utility import ControlUtility, ControlUtilityError\n+from ignitetest.tests.utils.ignite_test import IgniteTest\n+from ignitetest.tests.utils.version import DEV_BRANCH, LATEST_2_8, IgniteVersion, LATEST_2_7, V_2_8_0\n+\n+\n+# pylint: disable=W0223\n+class BaselineTests(IgniteTest):\n+    \"\"\"\n+    Tests baseline command\n+    \"\"\"\n+    NUM_NODES = 3\n+\n+    CONFIG_TEMPLATE = \"\"\"\n+        {% if version > \"2.9.0\" %}\n+            <property name=\"clusterStateOnStart\" value=\"INACTIVE\"/>\n+        {%  else %}\n+            <property name=\"activeOnStart\" value=\"false\"/>\n+        {% endif %}\n+        <property name=\"dataStorageConfiguration\">\n+            <bean class=\"org.apache.ignite.configuration.DataStorageConfiguration\">\n+                <property name=\"defaultDataRegionConfiguration\">\n+                    <bean class=\"org.apache.ignite.configuration.DataRegionConfiguration\">\n+                        <property name=\"persistenceEnabled\" value=\"true\"/>\n+                        <property name=\"maxSize\" value=\"#{100L * 1024 * 1024}\"/>\n+                    </bean>\n+                </property>\n+            </bean>\n+        </property>\n+    \"\"\"\n+\n+    @staticmethod\n+    def properties(version):\n+        \"\"\"\n+        Render properties for ignite node configuration.\n+        \"\"\"\n+        return Template(BaselineTests.CONFIG_TEMPLATE) \\\n+            .render(version=version)\n+\n+    def __init__(self, test_context):\n+        super(BaselineTests, self).__init__(test_context)\n+        self.servers = None\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_baseline_set(self, version):\n+        \"\"\"\n+        Test baseline set.\n+        \"\"\"\n+        blt_size = self.NUM_NODES - 2\n+        self.servers = self.__start_ignite_nodes(version, blt_size)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+        control_utility.activate()\n+\n+        # Check baseline of activated cluster.\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(self.servers.nodes, baseline)\n+\n+        # Set baseline using list of conststent ids.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        control_utility.set_baseline(self.servers.nodes + new_node.nodes)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+        # Set baseline using topology version.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        _, version, _ = control_utility.cluster_state()\n+        control_utility.set_baseline(version)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_baseline_add_remove(self, version):\n+        \"\"\"\n+        Test add and remove nodes from baseline.\n+        \"\"\"\n+        blt_size = self.NUM_NODES - 1\n+        self.servers = self.__start_ignite_nodes(version, blt_size)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+\n+        control_utility.activate()\n+\n+        # Add node to baseline.\n+        new_node = self.__start_ignite_nodes(version, 1)\n+        control_utility.add_to_baseline(new_node.nodes)\n+        blt_size += 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_in_baseline(new_node.nodes, baseline)\n+\n+        # Expected failure (remove of online node is not allowed).\n+        try:\n+            control_utility.remove_from_baseline(new_node.nodes)\n+\n+            assert False, \"Remove of online node from baseline should fail!\"\n+        except ControlUtilityError:\n+            pass\n+\n+        # Remove of offline node from baseline.\n+        new_node.stop()\n+\n+        self.servers.await_event(\"Node left topology\", timeout_sec=30, from_the_beginning=True)\n+\n+        control_utility.remove_from_baseline(new_node.nodes)\n+        blt_size -= 1\n+\n+        baseline = control_utility.baseline()\n+        self.__check_baseline_size(baseline, blt_size)\n+        self.__check_nodes_not_in_baseline(new_node.nodes, baseline)\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    @parametrize(version=str(LATEST_2_7))\n+    def test_activate_deactivate(self, version):\n+        \"\"\"\n+        Test activate and deactivate cluster.\n+        \"\"\"\n+        self.servers = self.__start_ignite_nodes(version, self.NUM_NODES)\n+\n+        control_utility = ControlUtility(self.servers, self.test_context)\n+\n+        control_utility.activate()\n+\n+        state, _, _ = control_utility.cluster_state()\n+\n+        assert state.lower() == 'active', 'Unexpected state %s' % state\n+\n+        control_utility.deactivate()\n+\n+        state, _, _ = control_utility.cluster_state()\n+\n+        assert state.lower() == 'inactive', 'Unexpected state %s' % state\n+\n+    @cluster(num_nodes=NUM_NODES)\n+    @parametrize(version=str(DEV_BRANCH))\n+    @parametrize(version=str(LATEST_2_8))\n+    def test_baseline_autoadjust(self, version):\n+        \"\"\"\n+        Test activate and deactivate cluster.\n+        \"\"\"\n+        if version < V_2_8_0:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkwNDU3NQ=="}, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzQwMTU1OnYy", "diffSide": "RIGHT", "path": "modules/ducktests/tests/ignitetest/services/utils/control_utility.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzo0MDoyMlrOG-O_-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzo0MDoyMlrOG-O_-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxMDY1MQ==", "bodyText": "Is it ok, that it's possible to receive exit_code !=0 but in the same time text output will have code equals to 0?", "url": "https://github.com/apache/ignite/pull/8127#discussion_r467910651", "createdAt": "2020-08-10T13:40:22Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/utils/control_utility.py", "diffHunk": "@@ -0,0 +1,167 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+This module contains control utility wrapper.\n+\"\"\"\n+import random\n+import re\n+from collections import namedtuple\n+\n+from ducktape.cluster.remoteaccount import RemoteCommandError\n+\n+\n+class ControlUtility:\n+    \"\"\"\n+    Control utility (control.sh) wrapper.\n+    \"\"\"\n+    BASE_COMMAND = \"control.sh\"\n+\n+    def __init__(self, cluster, text_context):\n+        self._cluster = cluster\n+        self.logger = text_context.logger\n+\n+    def baseline(self):\n+        \"\"\"\n+        :return Baseline nodes.\n+        \"\"\"\n+        return self.cluster_state().baseline\n+\n+    def cluster_state(self):\n+        \"\"\"\n+        :return: Cluster state.\n+        \"\"\"\n+        output = self.__run(\"--baseline\")\n+\n+        return self.__parse_cluster_state(output)\n+\n+    def set_baseline(self, baseline):\n+        \"\"\"\n+        :param baseline: Baseline nodes or topology version to set as baseline.\n+        \"\"\"\n+        if isinstance(baseline, int):\n+            result = self.__run(\"--baseline version %d --yes\" % baseline)\n+        else:\n+            result = self.__run(\"--baseline set %s --yes\" %\n+                                \",\".join([node.account.externally_routable_ip for node in baseline]))\n+\n+        return self.__parse_cluster_state(result)\n+\n+    def add_to_baseline(self, nodes):\n+        \"\"\"\n+        :param nodes: Nodes that should be added to baseline.\n+        \"\"\"\n+        result = self.__run(\"--baseline add %s --yes\" %\n+                            \",\".join([node.account.externally_routable_ip for node in nodes]))\n+\n+        return self.__parse_cluster_state(result)\n+\n+    def remove_from_baseline(self, nodes):\n+        \"\"\"\n+        :param nodes: Nodes that should be removed to baseline.\n+        \"\"\"\n+        result = self.__run(\"--baseline remove %s --yes\" %\n+                            \",\".join([node.account.externally_routable_ip for node in nodes]))\n+\n+        return self.__parse_cluster_state(result)\n+\n+    def disable_baseline_auto_adjust(self):\n+        \"\"\"\n+        Disable baseline auto adjust.\n+        \"\"\"\n+        return self.__run(\"--baseline auto_adjust disable --yes\")\n+\n+    def enable_baseline_auto_adjust(self, timeout=None):\n+        \"\"\"\n+        Enable baseline auto adjust.\n+        :param timeout: Auto adjust timeout in millis.\n+        \"\"\"\n+        timeout_str = \"timeout %d\" % timeout if timeout else \"\"\n+        return self.__run(\"--baseline auto_adjust enable %s --yes\" % timeout_str)\n+\n+    def activate(self):\n+        \"\"\"\n+        Activate cluster.\n+        \"\"\"\n+        return self.__run(\"--activate --yes\")\n+\n+    def deactivate(self):\n+        \"\"\"\n+        Deactivate cluster.\n+        \"\"\"\n+        return self.__run(\"--deactivate --yes\")\n+\n+    @staticmethod\n+    def __parse_cluster_state(output):\n+        state_pattern = re.compile(\"Cluster state: ([^\\\\s]+)\")\n+        topology_pattern = re.compile(\"Current topology version: (\\\\d+)\")\n+        baseline_pattern = re.compile(\"Consistent(Id|ID)=([^\\\\s]+),\\\\sS(tate|TATE)=([^\\\\s]+),?(\\\\sOrder=(\\\\d+))?\")\n+\n+        match = state_pattern.search(output)\n+        state = match.group(1) if match else None\n+\n+        match = topology_pattern.search(output)\n+        topology = int(match.group(1)) if match else None\n+\n+        baseline = [BaselineNode(consistent_id=m[1], state=m[3], order=int(m[5]) if m[5] else None)\n+                    for m in baseline_pattern.findall(output)]\n+\n+        return ClusterState(state=state, topology_version=topology, baseline=baseline)\n+\n+    def __run(self, cmd):\n+        node = random.choice(self.__alives())\n+\n+        self.logger.debug(\"Run command %s on node %s\", cmd, node.name)\n+\n+        raw_output = node.account.ssh_capture(self.__form_cmd(node, cmd), allow_fail=True)\n+        code, output = self.__parse_output(raw_output)\n+\n+        self.logger.debug(\"Output of command %s on node %s, exited with code %d, is %s\", cmd, node.name, code, output)\n+\n+        if code != 0:\n+            raise ControlUtilityError(node.account, cmd, code, output)\n+\n+        return output\n+\n+    def __form_cmd(self, node, cmd):\n+        return self._cluster.path.script(\"%s --host %s %s\" % (self.BASE_COMMAND, node.account.externally_routable_ip,\n+                                                              cmd))\n+\n+    @staticmethod\n+    def __parse_output(raw_output):\n+        exit_code = raw_output.channel_file.channel.recv_exit_status()\n+        output = \"\".join(raw_output)\n+\n+        pattern = re.compile(\"Command \\\\[[^\\\\s]*\\\\] finished with code: (\\\\d+)\")\n+        match = pattern.search(output)\n+\n+        if match:\n+            return int(match.group(1)), output", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzQ0NjM3OnYy", "diffSide": "LEFT", "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_aware.py", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMzo1MDo0NlrOG-Pa9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNzo1NDo0MlrOG-sf6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNzU1OA==", "bodyText": "Was there a reason to have the assert?", "url": "https://github.com/apache/ignite/pull/8127#discussion_r467917558", "createdAt": "2020-08-10T13:50:46Z", "author": {"login": "timoninmaxim"}, "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_aware.py", "diffHunk": "@@ -156,10 +164,9 @@ def await_event(self, evt_message, timeout_sec, from_the_beginning=False, backof\n         :param backoff_sec: Number of seconds to back off between each failure to meet the condition\n                 before checking again.\n         \"\"\"\n-        assert len(self.nodes) == 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5Mzk2MQ==", "bodyText": "@timoninmaxim It was implemented partially by me, assert was used to check it was used properly (applicable only for single-node services)", "url": "https://github.com/apache/ignite/pull/8127#discussion_r468393961", "createdAt": "2020-08-11T07:54:42Z", "author": {"login": "anton-vinogradov"}, "path": "modules/ducktests/tests/ignitetest/services/utils/ignite_aware.py", "diffHunk": "@@ -156,10 +164,9 @@ def await_event(self, evt_message, timeout_sec, from_the_beginning=False, backof\n         :param backoff_sec: Number of seconds to back off between each failure to meet the condition\n                 before checking again.\n         \"\"\"\n-        assert len(self.nodes) == 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNzU1OA=="}, "originalCommit": {"oid": "55f71024bb303f2bbf538aa59aa89b71134901e2"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2791, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}