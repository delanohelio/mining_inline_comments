{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NTQzNjYx", "number": 8004, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoyODoyOVrOEMOyUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDozNDoyNVrOEMO5ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjYwNjI0OnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoyODoyOVrOGuObeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMTozOTo1MlrOGuj-kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyNDA4OA==", "bodyText": "Can ContainsKey and ContainsKeys trigger transnational behavior?", "url": "https://github.com/apache/ignite/pull/8004#discussion_r451124088", "createdAt": "2020-07-07T20:28:29Z", "author": {"login": "gurustron"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "diffHunk": "@@ -862,6 +862,50 @@ public void TestTransactionScopeAllOperations()\n             }\n         }\n \n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        [Test]\n+        public void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead()\n+        {\n+            Action<Func<ICache<int, int>, int, int>>\n+                test = TestTransactionScopeWithSerializableIsolationLocksKeysOnRead;\n+\n+            test((cache, key) => cache[key]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86936946ac1cfb872af69ac90ae059a6d01d39db"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ3NzEzNw==", "bodyText": "Double checked this - no, ContainsKey and ContainsKeys do not participate in transactions.", "url": "https://github.com/apache/ignite/pull/8004#discussion_r451477137", "createdAt": "2020-07-08T11:39:52Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "diffHunk": "@@ -862,6 +862,50 @@ public void TestTransactionScopeAllOperations()\n             }\n         }\n \n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        [Test]\n+        public void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead()\n+        {\n+            Action<Func<ICache<int, int>, int, int>>\n+                test = TestTransactionScopeWithSerializableIsolationLocksKeysOnRead;\n+\n+            test((cache, key) => cache[key]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyNDA4OA=="}, "originalCommit": {"oid": "86936946ac1cfb872af69ac90ae059a6d01d39db"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjYyNDM3OnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDozNDoyNVrOGuOm_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMTo0MTozN1rOGu6NbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyNzAzOQ==", "bodyText": "To be honest I prefer check the optimistic serializable transaction for throwing exception (as defined in documetation) on commit it seems to me to be more predictable and no need for magic numbers and waits.", "url": "https://github.com/apache/ignite/pull/8004#discussion_r451127039", "createdAt": "2020-07-07T20:34:25Z", "author": {"login": "gurustron"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "diffHunk": "@@ -862,6 +862,50 @@ public void TestTransactionScopeAllOperations()\n             }\n         }\n \n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        [Test]\n+        public void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead()\n+        {\n+            Action<Func<ICache<int, int>, int, int>>\n+                test = TestTransactionScopeWithSerializableIsolationLocksKeysOnRead;\n+\n+            test((cache, key) => cache[key]);\n+            test((cache, key) => cache.Get(key));\n+            test((cache, key) => cache.GetAsync(key).Result);\n+            test((cache, key) => { int val; return cache.TryGet(key, out val) ? val : 0; });\n+            test((cache, key) => cache.TryGetAsync(key).Result.Value);\n+            test((cache, key) => cache.GetAll(new[] {key}).Single().Value);\n+            test((cache, key) => cache.GetAllAsync(new[] {key}).Result.Single().Value);\n+        }\n+\n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        private void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead(\n+            Func<ICache<int, int>, int, int> readOp)\n+        {\n+            var cache = Cache();\n+            cache.Put(1, 1);\n+\n+            var options = new TransactionOptions {IsolationLevel = IsolationLevel.Serializable};\n+\n+            using (var scope = new TransactionScope(TransactionScopeOption.Required, options))\n+            {\n+                Assert.AreEqual(1, readOp(cache, 1));\n+\n+                var taskFinished = Task.Factory.StartNew(() => cache.Put(1, 2)).Wait(TimeSpan.FromSeconds(1));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86936946ac1cfb872af69ac90ae059a6d01d39db"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0MTU4Nw==", "bodyText": "Or just check that transaction is started.", "url": "https://github.com/apache/ignite/pull/8004#discussion_r451341587", "createdAt": "2020-07-08T07:34:49Z", "author": {"login": "gurustron"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "diffHunk": "@@ -862,6 +862,50 @@ public void TestTransactionScopeAllOperations()\n             }\n         }\n \n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        [Test]\n+        public void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead()\n+        {\n+            Action<Func<ICache<int, int>, int, int>>\n+                test = TestTransactionScopeWithSerializableIsolationLocksKeysOnRead;\n+\n+            test((cache, key) => cache[key]);\n+            test((cache, key) => cache.Get(key));\n+            test((cache, key) => cache.GetAsync(key).Result);\n+            test((cache, key) => { int val; return cache.TryGet(key, out val) ? val : 0; });\n+            test((cache, key) => cache.TryGetAsync(key).Result.Value);\n+            test((cache, key) => cache.GetAll(new[] {key}).Single().Value);\n+            test((cache, key) => cache.GetAllAsync(new[] {key}).Result.Single().Value);\n+        }\n+\n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        private void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead(\n+            Func<ICache<int, int>, int, int> readOp)\n+        {\n+            var cache = Cache();\n+            cache.Put(1, 1);\n+\n+            var options = new TransactionOptions {IsolationLevel = IsolationLevel.Serializable};\n+\n+            using (var scope = new TransactionScope(TransactionScopeOption.Required, options))\n+            {\n+                Assert.AreEqual(1, readOp(cache, 1));\n+\n+                var taskFinished = Task.Factory.StartNew(() => cache.Put(1, 2)).Wait(TimeSpan.FromSeconds(1));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyNzAzOQ=="}, "originalCommit": {"oid": "86936946ac1cfb872af69ac90ae059a6d01d39db"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5NzcxOQ==", "bodyText": "Good point, I've added current Tx check, and replaced time-based wait with a wait handle.\nBut I'd like to keep the logic that checks whether keys are locked.\nOptimistic transactions are a different matter, we can have a separate test for them.", "url": "https://github.com/apache/ignite/pull/8004#discussion_r451497719", "createdAt": "2020-07-08T12:15:37Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "diffHunk": "@@ -862,6 +862,50 @@ public void TestTransactionScopeAllOperations()\n             }\n         }\n \n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        [Test]\n+        public void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead()\n+        {\n+            Action<Func<ICache<int, int>, int, int>>\n+                test = TestTransactionScopeWithSerializableIsolationLocksKeysOnRead;\n+\n+            test((cache, key) => cache[key]);\n+            test((cache, key) => cache.Get(key));\n+            test((cache, key) => cache.GetAsync(key).Result);\n+            test((cache, key) => { int val; return cache.TryGet(key, out val) ? val : 0; });\n+            test((cache, key) => cache.TryGetAsync(key).Result.Value);\n+            test((cache, key) => cache.GetAll(new[] {key}).Single().Value);\n+            test((cache, key) => cache.GetAllAsync(new[] {key}).Result.Single().Value);\n+        }\n+\n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        private void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead(\n+            Func<ICache<int, int>, int, int> readOp)\n+        {\n+            var cache = Cache();\n+            cache.Put(1, 1);\n+\n+            var options = new TransactionOptions {IsolationLevel = IsolationLevel.Serializable};\n+\n+            using (var scope = new TransactionScope(TransactionScopeOption.Required, options))\n+            {\n+                Assert.AreEqual(1, readOp(cache, 1));\n+\n+                var taskFinished = Task.Factory.StartNew(() => cache.Put(1, 2)).Wait(TimeSpan.FromSeconds(1));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyNzAzOQ=="}, "originalCommit": {"oid": "86936946ac1cfb872af69ac90ae059a6d01d39db"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MTM4OQ==", "bodyText": "I've added more tests for Optimistic transactions, please have a look.", "url": "https://github.com/apache/ignite/pull/8004#discussion_r451841389", "createdAt": "2020-07-08T21:41:37Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core.Tests/Cache/CacheAbstractTransactionalTest.cs", "diffHunk": "@@ -862,6 +862,50 @@ public void TestTransactionScopeAllOperations()\n             }\n         }\n \n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        [Test]\n+        public void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead()\n+        {\n+            Action<Func<ICache<int, int>, int, int>>\n+                test = TestTransactionScopeWithSerializableIsolationLocksKeysOnRead;\n+\n+            test((cache, key) => cache[key]);\n+            test((cache, key) => cache.Get(key));\n+            test((cache, key) => cache.GetAsync(key).Result);\n+            test((cache, key) => { int val; return cache.TryGet(key, out val) ? val : 0; });\n+            test((cache, key) => cache.TryGetAsync(key).Result.Value);\n+            test((cache, key) => cache.GetAll(new[] {key}).Single().Value);\n+            test((cache, key) => cache.GetAllAsync(new[] {key}).Result.Single().Value);\n+        }\n+\n+        /// <summary>\n+        /// Tests that read operations lock keys in Serializable mode.\n+        /// </summary>\n+        private void TestTransactionScopeWithSerializableIsolationLocksKeysOnRead(\n+            Func<ICache<int, int>, int, int> readOp)\n+        {\n+            var cache = Cache();\n+            cache.Put(1, 1);\n+\n+            var options = new TransactionOptions {IsolationLevel = IsolationLevel.Serializable};\n+\n+            using (var scope = new TransactionScope(TransactionScopeOption.Required, options))\n+            {\n+                Assert.AreEqual(1, readOp(cache, 1));\n+\n+                var taskFinished = Task.Factory.StartNew(() => cache.Put(1, 2)).Wait(TimeSpan.FromSeconds(1));\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyNzAzOQ=="}, "originalCommit": {"oid": "86936946ac1cfb872af69ac90ae059a6d01d39db"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2812, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}