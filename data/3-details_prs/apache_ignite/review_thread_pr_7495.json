{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMDg3MzU0", "number": 7495, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoxNToxMVrODk_C3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxMToyMFrODlKwJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTA4MjU1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoxNToxMVrOFxnU1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoxNToxMVrOFxnU1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2ODg1NA==", "bodyText": "I think it should be described what -1 is means.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387568854", "createdAt": "2020-03-04T10:15:11Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return Origin node id. */\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysCancelled() {\n+        return job.isSystemCanceled();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysStopping() {\n+        return job.isSysStopping();\n+    }\n+\n+    /** @return {@code True} if job started. */\n+    public boolean isStarted() {\n+        return job.isStarted();\n+    }\n+\n+    /** @return Executor name. */\n+    public String executorName() {\n+        return job.executorName();\n+    }\n+\n+    /** @return Job class name. */\n+    public String taskClassName() {\n+        return job.getSession().getTaskClassName();\n+    }\n+\n+    /** @return Task name. */\n+    public String taskName() {\n+        return job.getSession().getTaskName();\n+    }\n+\n+    /** @return Affinity cache ids. */\n+    public String affinityCacheIds() {\n+        GridReservable res = job.getPartsReservation();\n+\n+        if (!(res instanceof GridJobProcessor.PartitionsReservation))\n+            return null;\n+\n+        int[] ids = ((GridJobProcessor.PartitionsReservation)res).getCacheIds();\n+\n+        if (ids == null || ids.length == 0)\n+            return null;\n+\n+        StringJoiner joiner = new StringJoiner(\",\");\n+\n+        for (int id : ids)\n+            joiner.add(Integer.toString(id));\n+\n+        return joiner.toString();\n+    }\n+\n+    /** @return Affinity partition id. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTA4OTQ4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoxNzoxM1rOFxnZTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoxNzoxM1rOFxnZTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2OTk5OA==", "bodyText": "I suggest to mark nullable and update javadoc.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387569998", "createdAt": "2020-03-04T10:17:13Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return Origin node id. */\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysCancelled() {\n+        return job.isSystemCanceled();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysStopping() {\n+        return job.isSysStopping();\n+    }\n+\n+    /** @return {@code True} if job started. */\n+    public boolean isStarted() {\n+        return job.isStarted();\n+    }\n+\n+    /** @return Executor name. */\n+    public String executorName() {\n+        return job.executorName();\n+    }\n+\n+    /** @return Job class name. */\n+    public String taskClassName() {\n+        return job.getSession().getTaskClassName();\n+    }\n+\n+    /** @return Task name. */\n+    public String taskName() {\n+        return job.getSession().getTaskName();\n+    }\n+\n+    /** @return Affinity cache ids. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTA5NDY2OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoxODo0N1rOFxncug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDoyNDoyMFrOFxvNLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MDg3NA==", "bodyText": "Job or Task class name is correct?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387570874", "createdAt": "2020-03-04T10:18:47Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return Origin node id. */\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysCancelled() {\n+        return job.isSystemCanceled();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysStopping() {\n+        return job.isSysStopping();\n+    }\n+\n+    /** @return {@code True} if job started. */\n+    public boolean isStarted() {\n+        return job.isStarted();\n+    }\n+\n+    /** @return Executor name. */\n+    public String executorName() {\n+        return job.executorName();\n+    }\n+\n+    /** @return Job class name. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5Nzk2Ng==", "bodyText": "They both are correct. I think we should use taskName and taskClassName to highlight to the user that these columns are the same as in TASKS view.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387697966", "createdAt": "2020-03-04T14:24:20Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return Origin node id. */\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysCancelled() {\n+        return job.isSystemCanceled();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysStopping() {\n+        return job.isSysStopping();\n+    }\n+\n+    /** @return {@code True} if job started. */\n+    public boolean isStarted() {\n+        return job.isStarted();\n+    }\n+\n+    /** @return Executor name. */\n+    public String executorName() {\n+        return job.executorName();\n+    }\n+\n+    /** @return Job class name. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MDg3NA=="}, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTA5ODgzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoyMDowNFrOFxnfcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoyMDowNFrOFxnfcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MTU2OA==", "bodyText": "Please, add meaningful description instead ???.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387571568", "createdAt": "2020-03-04T10:20:04Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return Origin node id. */\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTA5OTA5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoyMDowOVrOFxnfog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoyMDowOVrOFxnfog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MTYxOA==", "bodyText": "Please, add meaningful description instead ???.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387571618", "createdAt": "2020-03-04T10:20:09Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return Origin node id. */\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+\n+    /** @return {@code True} if ???. */\n+    public boolean isSysCancelled() {\n+        return job.isSystemCanceled();\n+    }\n+\n+    /** @return {@code True} if ???. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTEyMjQzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoyNjoyNlrOFxnuJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDoyNjoyNlrOFxnuJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3NTMzNA==", "bodyText": "Job id", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387575334", "createdAt": "2020-03-04T10:26:26Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTE1NjY2OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDozNjoyNVrOFxoDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDozNjoyNVrOFxoDiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4MDgxMQ==", "bodyText": "in milliseconds?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387580811", "createdAt": "2020-03-04T10:36:25Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTE2MDQwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDozNzoyOVrOFxoF2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDozNzoyOVrOFxoF2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4MTQwMg==", "bodyText": "typo finishTime", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387581402", "createdAt": "2020-03-04T10:37:29Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    private final GridJobWorker job;\n+\n+    /**\n+     * @param job Job.\n+     */\n+    public ComputeJobView(GridJobWorker job) {\n+        this.job = job;\n+    }\n+\n+    /** @return Task id. */\n+    public IgniteUuid id() {\n+        return job.getJobId();\n+    }\n+\n+    /** @return Create time. */\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time. */\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time. */\n+    public long fininshTime() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTIwNTUzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/job/GridJobProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDo1MDo0NVrOFxoh9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDo1MDo0NVrOFxoh9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4ODU5OQ==", "bodyText": "Caches' identifiers ?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387588599", "createdAt": "2020-03-04T10:50:45Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/job/GridJobProcessor.java", "diffHunk": "@@ -1702,6 +1726,16 @@ public PartitionsReservation(int[] cacheIds, int partId,\n             partititons = new GridDhtLocalPartition[cacheIds.length];\n         }\n \n+        /** @return Caches. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTIwODI1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/job/GridJobWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDo1MToyN1rOFxojmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMDo1MToyN1rOFxojmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4OTAxOQ==", "bodyText": "What sys is means?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387589019", "createdAt": "2020-03-04T10:51:27Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/job/GridJobWorker.java", "diffHunk": "@@ -271,17 +271,42 @@ public GridDeployment getDeployment() {\n      *\n      * @return {@code True} if job was cancelled by the system.\n      */\n-    boolean isSystemCanceled() {\n+    public boolean isSystemCanceled() {\n         return sysCancelled;\n     }\n \n     /**\n      * @return Create time.\n      */\n-    long getCreateTime() {\n+    public long getCreateTime() {\n         return createTime;\n     }\n \n+    /** @return Start time. */\n+    public long getStartTime() {\n+        return startTime;\n+    }\n+\n+    /** @return Finish time. */\n+    public long getFinishTime() {\n+        return finishTime;\n+    }\n+\n+    /** @return Sys stopping. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b87ec0043638f0f96c9cbcafef48938a417c5973"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjA4OTQ0OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNTowOToyNlrOFxxBzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToxMjoxOVrOFxxJsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyNzgyMQ==", "bodyText": "Comma separated list of affinity cache identifiers?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387727821", "createdAt": "2020-03-04T15:09:26Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.managers.systemview.walker.Order;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    public final GridJobWorker job;\n+\n+    /** Job id. */\n+    public final IgniteUuid id;\n+\n+    /**\n+     * @param id Job id.\n+     * @param job Job.\n+     */\n+    public ComputeJobView(IgniteUuid id, GridJobWorker job) {\n+        this.id = id;\n+        this.job = job;\n+    }\n+\n+    /** @return Job id. */\n+    @Order\n+    public IgniteUuid id() {\n+        return id;\n+    }\n+\n+    /**\n+     * {@link ComputeJobView#sessionId()} value equal to the value of {@link ComputeTaskView#sessionId()}\n+     * if both records represents parts of the same computation.\n+     *\n+     * @see ComputeTaskView#sessionId()\n+     * @return Session id.\n+     */\n+    @Order(1)\n+    public IgniteUuid sessionId() {\n+        return job.getSession().getId();\n+    }\n+\n+    /** @return Origin node id. */\n+    @Order(2)\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return Task name. */\n+    @Order(3)\n+    public String taskName() {\n+        return job.getSession().getTaskName();\n+    }\n+\n+    /** @return Task class name. */\n+    @Order(4)\n+    public String taskClassName() {\n+        return job.getSession().getTaskClassName();\n+    }\n+\n+    /** @return Affinity cache name or {@code null} for non affinity call. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f53757e0f894a0961bfb0ca7a85ff93cea0ba0a"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyOTg0MQ==", "bodyText": "Yes. Thank you. Fixed.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387729841", "createdAt": "2020-03-04T15:12:19Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.managers.systemview.walker.Order;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    public final GridJobWorker job;\n+\n+    /** Job id. */\n+    public final IgniteUuid id;\n+\n+    /**\n+     * @param id Job id.\n+     * @param job Job.\n+     */\n+    public ComputeJobView(IgniteUuid id, GridJobWorker job) {\n+        this.id = id;\n+        this.job = job;\n+    }\n+\n+    /** @return Job id. */\n+    @Order\n+    public IgniteUuid id() {\n+        return id;\n+    }\n+\n+    /**\n+     * {@link ComputeJobView#sessionId()} value equal to the value of {@link ComputeTaskView#sessionId()}\n+     * if both records represents parts of the same computation.\n+     *\n+     * @see ComputeTaskView#sessionId()\n+     * @return Session id.\n+     */\n+    @Order(1)\n+    public IgniteUuid sessionId() {\n+        return job.getSession().getId();\n+    }\n+\n+    /** @return Origin node id. */\n+    @Order(2)\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return Task name. */\n+    @Order(3)\n+    public String taskName() {\n+        return job.getSession().getTaskName();\n+    }\n+\n+    /** @return Task class name. */\n+    @Order(4)\n+    public String taskClassName() {\n+        return job.getSession().getTaskClassName();\n+    }\n+\n+    /** @return Affinity cache name or {@code null} for non affinity call. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyNzgyMQ=="}, "originalCommit": {"oid": "4f53757e0f894a0961bfb0ca7a85ff93cea0ba0a"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjEwOTcwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToxNDowNFrOFxxOfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToxNDowNFrOFxxOfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczMTA3MA==", "bodyText": "@see should be placed after @return", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387731070", "createdAt": "2020-03-04T15:14:04Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.managers.systemview.walker.Order;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Job. */\n+    public final GridJobWorker job;\n+\n+    /** Job id. */\n+    public final IgniteUuid id;\n+\n+    /**\n+     * @param id Job id.\n+     * @param job Job.\n+     */\n+    public ComputeJobView(IgniteUuid id, GridJobWorker job) {\n+        this.id = id;\n+        this.job = job;\n+    }\n+\n+    /** @return Job id. */\n+    @Order\n+    public IgniteUuid id() {\n+        return id;\n+    }\n+\n+    /**\n+     * {@link ComputeJobView#sessionId()} value equal to the value of {@link ComputeTaskView#sessionId()}\n+     * if both records represents parts of the same computation.\n+     *\n+     * @see ComputeTaskView#sessionId()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450762c485a63b3efa081328c73c36aebc816d4e"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjExMTYwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeTaskView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToxNDozMVrOFxxPtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNToxNDozMVrOFxxPtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczMTM4Mg==", "bodyText": "@see should be placed after @return", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387731382", "createdAt": "2020-03-04T15:14:31Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeTaskView.java", "diffHunk": "@@ -18,73 +18,100 @@\n package org.apache.ignite.spi.systemview.view;\n \n import java.util.UUID;\n+import org.apache.ignite.internal.managers.systemview.walker.Order;\n import org.apache.ignite.internal.processors.task.GridTaskWorker;\n import org.apache.ignite.lang.IgniteUuid;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Compute task representation for a {@link SystemView}.\n  */\n public class ComputeTaskView {\n     /** Worker for task. */\n-    private final GridTaskWorker worker;\n+    public final GridTaskWorker worker;\n+\n+    /** Task id. */\n+    public final IgniteUuid id;\n \n     /**\n+     * @param id Task id.\n      * @param worker Worker for task.\n      */\n-    public ComputeTaskView(GridTaskWorker worker) {\n+    public ComputeTaskView(IgniteUuid id, GridTaskWorker worker) {\n+        this.id = id;\n         this.worker = worker;\n     }\n \n+    /** @return Task id. */\n+    @Order\n+    public IgniteUuid id() {\n+        return id;\n+    }\n+\n+    /**\n+     * {@link ComputeTaskView#sessionId()} value equal to the value of {@link ComputeJobView#sessionId()}\n+     * if both records represents parts of the same computation.\n+     *\n+     * @see ComputeJobView#sessionId()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450762c485a63b3efa081328c73c36aebc816d4e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjc0MzU5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo1MzowMlrOFx3dyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo1MzowMlrOFx3dyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzMzI5MA==", "bodyText": "check job?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387833290", "createdAt": "2020-03-04T17:53:02Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnable() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().runAsync(() -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#apply(IgniteClosure, Object)} call. */\n+    @Test\n+    public void testComputeApply() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        GridTestUtils.runAsync(() -> {\n+            client.compute().apply(x -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                return 0;\n+            }, 1);\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Tests work of {@link SystemView} for compute grid\n+     * {@link IgniteCompute#affinityCallAsync(String, Object, IgniteCallable)} call.\n+     */\n+    @Test\n+    public void testComputeAffinityCall() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        assertFalse(t.isInternal());\n+        assertEquals(String.valueOf(CU.cacheId(\"test-cache\")), t.affinityCacheIds());\n+        assertEquals(1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** */\n+    @Test\n+    public void testComputeTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().executeAsync(new ComputeTask<Object, Object>() {\n+            @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n+                @Nullable Object arg) throws IgniteException {\n+                return Collections.singletonMap(new ComputeJob() {\n+                    @Override public void cancel() {\n+                        // No-op.\n+                    }\n+\n+                    @Override public Object execute() throws IgniteException {\n+                        try {\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                        }\n+                        catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        return 1;\n+                    }\n+                }, subgrid.get(0));\n+            }\n+\n+            @Override public ComputeJobResultPolicy result(ComputeJobResult res,\n+                List<ComputeJobResult> rcvd) throws IgniteException {\n+\n+                return null;\n+            }\n+\n+            @Nullable @Override public Object reduce(List<ComputeJobResult> results) throws IgniteException {\n+                return 1;\n+            }\n+        }, 1);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnableJobAndTask() throws Exception {\n+        try (IgniteEx server2 = startGrid(2)) {\n+            barrier = new CyclicBarrier(3);\n+\n+            SystemView<ComputeJobView> jobs1 = server.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeJobView> jobs2 = server2.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+\n+            assertEquals(1, tasks.size());\n+            assertEquals(1, jobs1.size());\n+            assertEquals(1, jobs2.size());\n+\n+            ComputeTaskView task = tasks.iterator().next();\n+\n+            checkJobAndTask(task, jobs1.iterator().next());\n+            checkJobAndTask(task, jobs2.iterator().next());\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+        }\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeAffinityCallJobAndTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+        SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, tasks.size());\n+        assertEquals(1, jobs.size());\n+\n+        checkJobAndTask(tasks.iterator().next(), jobs.iterator().next());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Check fields for local {@link ComputeTaskView} and remote {@link ComputeJobView} info of the same computation.\n+     */\n+    private void checkJobAndTask(ComputeTaskView task, ComputeJobView job) {\n+        assertNotSame(task.id(), job.id());\n+        assertEquals(task.sessionId(), job.sessionId());\n+        assertEquals(task.taskNodeId(), job.originNodeId());\n+        assertEquals(task.taskName(), job.taskName());\n+        assertEquals(task.taskClassName(), job.taskClassName());\n+\n+        if (task.affinityCacheName() != null)\n+            assertEquals((Integer)CU.cacheId(task.affinityCacheName()), Integer.valueOf(job.affinityCacheIds()));\n+        else\n+            assertNull(job.affinityCacheIds());\n+\n+        assertEquals(task.affinityPartitionId(), job.affinityPartitionId());\n+    }\n+\n+    /** Check tasks fields. */\n+    private void checkTask(ComputeJobView t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjc0OTI0OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo1NDozM1rOFx3hJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzo1NDozM1rOFx3hJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNDE0OA==", "bodyText": "Lets check each job view:\nfor (ComputeJobView job : jobs)\n     checkJob(job);", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387834148", "createdAt": "2020-03-04T17:54:33Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjc3MTM3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODowMTowOFrOFx3vJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODowMTowOFrOFx3vJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNzczNA==", "bodyText": "I suggest adding a check that jobs.size will be 0 after all jobs finish.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387837734", "createdAt": "2020-03-04T18:01:08Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjgwMDIyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxMDowN1rOFx4Bpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxMDowN1rOFx4Bpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0MjQ3MQ==", "bodyText": "Getter state() can be used here.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387842471", "createdAt": "2020-03-04T18:10:07Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnable() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().runAsync(() -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#apply(IgniteClosure, Object)} call. */\n+    @Test\n+    public void testComputeApply() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        GridTestUtils.runAsync(() -> {\n+            client.compute().apply(x -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                return 0;\n+            }, 1);\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Tests work of {@link SystemView} for compute grid\n+     * {@link IgniteCompute#affinityCallAsync(String, Object, IgniteCallable)} call.\n+     */\n+    @Test\n+    public void testComputeAffinityCall() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        assertFalse(t.isInternal());\n+        assertEquals(String.valueOf(CU.cacheId(\"test-cache\")), t.affinityCacheIds());\n+        assertEquals(1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** */\n+    @Test\n+    public void testComputeTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().executeAsync(new ComputeTask<Object, Object>() {\n+            @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n+                @Nullable Object arg) throws IgniteException {\n+                return Collections.singletonMap(new ComputeJob() {\n+                    @Override public void cancel() {\n+                        // No-op.\n+                    }\n+\n+                    @Override public Object execute() throws IgniteException {\n+                        try {\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                        }\n+                        catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        return 1;\n+                    }\n+                }, subgrid.get(0));\n+            }\n+\n+            @Override public ComputeJobResultPolicy result(ComputeJobResult res,\n+                List<ComputeJobResult> rcvd) throws IgniteException {\n+\n+                return null;\n+            }\n+\n+            @Nullable @Override public Object reduce(List<ComputeJobResult> results) throws IgniteException {\n+                return 1;\n+            }\n+        }, 1);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnableJobAndTask() throws Exception {\n+        try (IgniteEx server2 = startGrid(2)) {\n+            barrier = new CyclicBarrier(3);\n+\n+            SystemView<ComputeJobView> jobs1 = server.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeJobView> jobs2 = server2.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+\n+            assertEquals(1, tasks.size());\n+            assertEquals(1, jobs1.size());\n+            assertEquals(1, jobs2.size());\n+\n+            ComputeTaskView task = tasks.iterator().next();\n+\n+            checkJobAndTask(task, jobs1.iterator().next());\n+            checkJobAndTask(task, jobs2.iterator().next());\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+        }\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeAffinityCallJobAndTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+        SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, tasks.size());\n+        assertEquals(1, jobs.size());\n+\n+        checkJobAndTask(tasks.iterator().next(), jobs.iterator().next());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Check fields for local {@link ComputeTaskView} and remote {@link ComputeJobView} info of the same computation.\n+     */\n+    private void checkJobAndTask(ComputeTaskView task, ComputeJobView job) {\n+        assertNotSame(task.id(), job.id());\n+        assertEquals(task.sessionId(), job.sessionId());\n+        assertEquals(task.taskNodeId(), job.originNodeId());\n+        assertEquals(task.taskName(), job.taskName());\n+        assertEquals(task.taskClassName(), job.taskClassName());\n+\n+        if (task.affinityCacheName() != null)\n+            assertEquals((Integer)CU.cacheId(task.affinityCacheName()), Integer.valueOf(job.affinityCacheIds()));\n+        else\n+            assertNull(job.affinityCacheIds());\n+\n+        assertEquals(task.affinityPartitionId(), job.affinityPartitionId());\n+    }\n+\n+    /** Check tasks fields. */\n+    private void checkTask(ComputeJobView t) {\n+        assertFalse(t.isInternal());\n+        assertNull(t.affinityCacheIds());\n+        assertEquals(-1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+        assertEquals(ACTIVE, t.state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjgxMzA0OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNDowMFrOFx4J8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMTozNDowM1rOFx-b7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDU5Mw==", "bodyText": "Can you cover job states(PASSIVE, CANCELED), please?", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387844593", "createdAt": "2020-03-04T18:14:00Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk0NzUwMw==", "bodyText": "tests added.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387947503", "createdAt": "2020-03-04T21:34:03Z", "author": {"login": "nizhikov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDU5Mw=="}, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjgyNDc1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNzo0NVrOFx4Rgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoxNzo0NVrOFx4Rgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NjUzMA==", "bodyText": "Let's name it checkTaskAndJob like parameters ordered  :)", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387846530", "createdAt": "2020-03-04T18:17:45Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnable() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().runAsync(() -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#apply(IgniteClosure, Object)} call. */\n+    @Test\n+    public void testComputeApply() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        GridTestUtils.runAsync(() -> {\n+            client.compute().apply(x -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                return 0;\n+            }, 1);\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Tests work of {@link SystemView} for compute grid\n+     * {@link IgniteCompute#affinityCallAsync(String, Object, IgniteCallable)} call.\n+     */\n+    @Test\n+    public void testComputeAffinityCall() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        assertFalse(t.isInternal());\n+        assertEquals(String.valueOf(CU.cacheId(\"test-cache\")), t.affinityCacheIds());\n+        assertEquals(1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** */\n+    @Test\n+    public void testComputeTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().executeAsync(new ComputeTask<Object, Object>() {\n+            @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n+                @Nullable Object arg) throws IgniteException {\n+                return Collections.singletonMap(new ComputeJob() {\n+                    @Override public void cancel() {\n+                        // No-op.\n+                    }\n+\n+                    @Override public Object execute() throws IgniteException {\n+                        try {\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                        }\n+                        catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        return 1;\n+                    }\n+                }, subgrid.get(0));\n+            }\n+\n+            @Override public ComputeJobResultPolicy result(ComputeJobResult res,\n+                List<ComputeJobResult> rcvd) throws IgniteException {\n+\n+                return null;\n+            }\n+\n+            @Nullable @Override public Object reduce(List<ComputeJobResult> results) throws IgniteException {\n+                return 1;\n+            }\n+        }, 1);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnableJobAndTask() throws Exception {\n+        try (IgniteEx server2 = startGrid(2)) {\n+            barrier = new CyclicBarrier(3);\n+\n+            SystemView<ComputeJobView> jobs1 = server.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeJobView> jobs2 = server2.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+\n+            assertEquals(1, tasks.size());\n+            assertEquals(1, jobs1.size());\n+            assertEquals(1, jobs2.size());\n+\n+            ComputeTaskView task = tasks.iterator().next();\n+\n+            checkJobAndTask(task, jobs1.iterator().next());\n+            checkJobAndTask(task, jobs2.iterator().next());\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+        }\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeAffinityCallJobAndTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+        SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, tasks.size());\n+        assertEquals(1, jobs.size());\n+\n+        checkJobAndTask(tasks.iterator().next(), jobs.iterator().next());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Check fields for local {@link ComputeTaskView} and remote {@link ComputeJobView} info of the same computation.\n+     */\n+    private void checkJobAndTask(ComputeTaskView task, ComputeJobView job) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjg0MjMyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyMzowMFrOFx4clA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyMzowMFrOFx4clA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0OTM2NA==", "bodyText": "It can be null. Let's mark as nullable and update javadoc.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387849364", "createdAt": "2020-03-04T18:23:00Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/systemview/view/ComputeJobView.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.systemview.view;\n+\n+import java.util.StringJoiner;\n+import java.util.UUID;\n+import org.apache.ignite.internal.managers.collision.GridCollisionManager;\n+import org.apache.ignite.internal.managers.systemview.walker.Order;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.GridReservable;\n+import org.apache.ignite.internal.processors.job.GridJobProcessor;\n+import org.apache.ignite.internal.processors.job.GridJobWorker;\n+import org.apache.ignite.lang.IgniteUuid;\n+import org.apache.ignite.spi.collision.CollisionSpi;\n+\n+/**\n+ * Compute job representation for a {@link SystemView}.\n+ */\n+public class ComputeJobView {\n+    /** Compute job state. */\n+    public enum ComputeJobState {\n+        /**\n+         * Job scheduled for the execution.\n+         * If collision not configured all jobs in this state by default.\n+         *\n+         * @see GridCollisionManager\n+         * @see CollisionSpi\n+         */\n+        ACTIVE,\n+\n+        /**\n+         * If collision configured jobs may be passivated before execution.\n+         *\n+         * @see GridCollisionManager\n+         * @see CollisionSpi\n+         */\n+        PASSIVE,\n+\n+        /**\n+         * Job execution canceled.\n+         *\n+         * @see GridJobProcessor#cancelJob(IgniteUuid, IgniteUuid, boolean)\n+         */\n+        CANCELED\n+    }\n+\n+    /** Job. */\n+    public final GridJobWorker job;\n+\n+    /** Job id. */\n+    public final IgniteUuid id;\n+\n+    /** Job state. */\n+    public final ComputeJobState state;\n+\n+    /**\n+     * @param id Job id.\n+     * @param job Job.\n+     * @param state Job state.\n+     */\n+    public ComputeJobView(IgniteUuid id, GridJobWorker job, ComputeJobState state) {\n+        this.id = id;\n+        this.job = job;\n+        this.state = state;\n+    }\n+\n+    /** @return Job id. */\n+    @Order\n+    public IgniteUuid id() {\n+        return id;\n+    }\n+\n+    /**\n+     * {@link ComputeJobView#sessionId()} value equal to the value of {@link ComputeTaskView#sessionId()}\n+     * if both records represents parts of the same computation.\n+     *\n+     * @return Session id.\n+     * @see ComputeTaskView#sessionId()\n+     */\n+    @Order(1)\n+    public IgniteUuid sessionId() {\n+        return job.getSession().getId();\n+    }\n+\n+    /** @return Origin node id. */\n+    @Order(2)\n+    public UUID originNodeId() {\n+        return job.getTaskNode().id();\n+    }\n+\n+    /** @return Task name. */\n+    @Order(3)\n+    public String taskName() {\n+        return job.getSession().getTaskName();\n+    }\n+\n+    /** @return Task class name. */\n+    @Order(4)\n+    public String taskClassName() {\n+        return job.getSession().getTaskClassName();\n+    }\n+\n+    /** @return Comma separated list of cache identifiers or {@code null} for non affinity call. */\n+    @Order(5)\n+    public String affinityCacheIds() {\n+        GridReservable res = job.getPartsReservation();\n+\n+        if (!(res instanceof GridJobProcessor.PartitionsReservation))\n+            return null;\n+\n+        int[] ids = ((GridJobProcessor.PartitionsReservation)res).getCacheIds();\n+\n+        if (ids == null || ids.length == 0)\n+            return null;\n+\n+        StringJoiner joiner = new StringJoiner(\",\");\n+\n+        for (int id : ids)\n+            joiner.add(Integer.toString(id));\n+\n+        return joiner.toString();\n+    }\n+\n+    /** @return Affinity partition id or {@code -1} for non affinity call. */\n+    @Order(6)\n+    public int affinityPartitionId() {\n+        GridReservable res = job.getPartsReservation();\n+\n+        if (!(res instanceof GridJobProcessor.PartitionsReservation))\n+            return -1;\n+\n+        return ((GridJobProcessor.PartitionsReservation)res).getPartId();\n+    }\n+\n+    /** @return Create time in milliseconds. */\n+    @Order(7)\n+    public long createTime() {\n+        return job.getCreateTime();\n+    }\n+\n+    /** @return Start time in milliseconds. */\n+    @Order(8)\n+    public long startTime() {\n+        return job.getStartTime();\n+    }\n+\n+    /** @return Finish time in milliseconds. */\n+    @Order(9)\n+    public long finishTime() {\n+        return job.getFinishTime();\n+    }\n+\n+    /** @return {@code True} if job is internal. */\n+    public boolean isInternal() {\n+        return job.isInternal();\n+    }\n+\n+    /** @return {@code True} if job is finishing. */\n+    public boolean isFinishing() {\n+        return job.isFinishing();\n+    }\n+\n+    /** @return {@code True} if job is timed out. */\n+    public boolean isTimedOut() {\n+        return job.isTimedOut();\n+    }\n+\n+    /** @return {@code True} if job started. */\n+    public boolean isStarted() {\n+        return job.isStarted();\n+    }\n+\n+    /** @return Executor name. */\n+    public String executorName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjg0NzU3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODoyNDoyOVrOFx4fvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODozMTo1OFrOFx4vlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MDE3Mw==", "bodyText": "Let's add additional checks:\n        assertEquals(0, j.finishTime());\n        assertTrue(j.startTime() > 0);", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387850173", "createdAt": "2020-03-04T18:24:29Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnable() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().runAsync(() -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#apply(IgniteClosure, Object)} call. */\n+    @Test\n+    public void testComputeApply() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        GridTestUtils.runAsync(() -> {\n+            client.compute().apply(x -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                return 0;\n+            }, 1);\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Tests work of {@link SystemView} for compute grid\n+     * {@link IgniteCompute#affinityCallAsync(String, Object, IgniteCallable)} call.\n+     */\n+    @Test\n+    public void testComputeAffinityCall() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        assertFalse(t.isInternal());\n+        assertEquals(String.valueOf(CU.cacheId(\"test-cache\")), t.affinityCacheIds());\n+        assertEquals(1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** */\n+    @Test\n+    public void testComputeTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().executeAsync(new ComputeTask<Object, Object>() {\n+            @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n+                @Nullable Object arg) throws IgniteException {\n+                return Collections.singletonMap(new ComputeJob() {\n+                    @Override public void cancel() {\n+                        // No-op.\n+                    }\n+\n+                    @Override public Object execute() throws IgniteException {\n+                        try {\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                        }\n+                        catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        return 1;\n+                    }\n+                }, subgrid.get(0));\n+            }\n+\n+            @Override public ComputeJobResultPolicy result(ComputeJobResult res,\n+                List<ComputeJobResult> rcvd) throws IgniteException {\n+\n+                return null;\n+            }\n+\n+            @Nullable @Override public Object reduce(List<ComputeJobResult> results) throws IgniteException {\n+                return 1;\n+            }\n+        }, 1);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnableJobAndTask() throws Exception {\n+        try (IgniteEx server2 = startGrid(2)) {\n+            barrier = new CyclicBarrier(3);\n+\n+            SystemView<ComputeJobView> jobs1 = server.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeJobView> jobs2 = server2.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+\n+            assertEquals(1, tasks.size());\n+            assertEquals(1, jobs1.size());\n+            assertEquals(1, jobs2.size());\n+\n+            ComputeTaskView task = tasks.iterator().next();\n+\n+            checkJobAndTask(task, jobs1.iterator().next());\n+            checkJobAndTask(task, jobs2.iterator().next());\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+        }\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeAffinityCallJobAndTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+        SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, tasks.size());\n+        assertEquals(1, jobs.size());\n+\n+        checkJobAndTask(tasks.iterator().next(), jobs.iterator().next());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Check fields for local {@link ComputeTaskView} and remote {@link ComputeJobView} info of the same computation.\n+     */\n+    private void checkJobAndTask(ComputeTaskView task, ComputeJobView job) {\n+        assertNotSame(task.id(), job.id());\n+        assertEquals(task.sessionId(), job.sessionId());\n+        assertEquals(task.taskNodeId(), job.originNodeId());\n+        assertEquals(task.taskName(), job.taskName());\n+        assertEquals(task.taskClassName(), job.taskClassName());\n+\n+        if (task.affinityCacheName() != null)\n+            assertEquals((Integer)CU.cacheId(task.affinityCacheName()), Integer.valueOf(job.affinityCacheIds()));\n+        else\n+            assertNull(job.affinityCacheIds());\n+\n+        assertEquals(task.affinityPartitionId(), job.affinityPartitionId());\n+    }\n+\n+    /** Check tasks fields. */\n+    private void checkTask(ComputeJobView t) {\n+        assertFalse(t.isInternal());\n+        assertNull(t.affinityCacheIds());\n+        assertEquals(-1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+        assertEquals(ACTIVE, t.state);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1NDIyOA==", "bodyText": "+ assertTrue(t.isStarted());", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387854228", "createdAt": "2020-03-04T18:31:58Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;\n+\n+    /** */\n+    private static CyclicBarrier barrier;\n+\n+    /** */\n+    private static IgniteEx server;\n+\n+    /** */\n+    private static IgniteEx client;\n+\n+    /** */\n+    private static IgniteCache<Integer, Integer> cache;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        server = startGrid(0);\n+        client = startClientGrid(1);\n+\n+        cache = server.createCache(\"test-cache\");\n+\n+        cache.put(1, 1);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#broadcastAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeBroadcast() throws Exception {\n+        barrier = new CyclicBarrier(6);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        for (int i = 0; i < 5; i++) {\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(5, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnable() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().runAsync(() -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#apply(IgniteClosure, Object)} call. */\n+    @Test\n+    public void testComputeApply() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        GridTestUtils.runAsync(() -> {\n+            client.compute().apply(x -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                return 0;\n+            }, 1);\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Tests work of {@link SystemView} for compute grid\n+     * {@link IgniteCompute#affinityCallAsync(String, Object, IgniteCallable)} call.\n+     */\n+    @Test\n+    public void testComputeAffinityCall() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        assertFalse(t.isInternal());\n+        assertEquals(String.valueOf(CU.cacheId(\"test-cache\")), t.affinityCacheIds());\n+        assertEquals(1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** */\n+    @Test\n+    public void testComputeTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+\n+        client.compute().executeAsync(new ComputeTask<Object, Object>() {\n+            @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n+                @Nullable Object arg) throws IgniteException {\n+                return Collections.singletonMap(new ComputeJob() {\n+                    @Override public void cancel() {\n+                        // No-op.\n+                    }\n+\n+                    @Override public Object execute() throws IgniteException {\n+                        try {\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                            barrier.await(TIMEOUT, MILLISECONDS);\n+                        }\n+                        catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        return 1;\n+                    }\n+                }, subgrid.get(0));\n+            }\n+\n+            @Override public ComputeJobResultPolicy result(ComputeJobResult res,\n+                List<ComputeJobResult> rcvd) throws IgniteException {\n+\n+                return null;\n+            }\n+\n+            @Nullable @Override public Object reduce(List<ComputeJobResult> results) throws IgniteException {\n+                return 1;\n+            }\n+        }, 1);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, jobs.size());\n+\n+        ComputeJobView t = jobs.iterator().next();\n+\n+        checkTask(t);\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeRunnableJobAndTask() throws Exception {\n+        try (IgniteEx server2 = startGrid(2)) {\n+            barrier = new CyclicBarrier(3);\n+\n+            SystemView<ComputeJobView> jobs1 = server.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeJobView> jobs2 = server2.context().systemView().view(JOBS_VIEW);\n+            SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+            client.compute().broadcastAsync(() -> {\n+                try {\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                    barrier.await(TIMEOUT, MILLISECONDS);\n+                }\n+                catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+\n+            assertEquals(1, tasks.size());\n+            assertEquals(1, jobs1.size());\n+            assertEquals(1, jobs2.size());\n+\n+            ComputeTaskView task = tasks.iterator().next();\n+\n+            checkJobAndTask(task, jobs1.iterator().next());\n+            checkJobAndTask(task, jobs2.iterator().next());\n+\n+            barrier.await(TIMEOUT, MILLISECONDS);\n+        }\n+    }\n+\n+    /** Tests work of {@link SystemView} for compute grid {@link IgniteCompute#runAsync(IgniteRunnable)} call. */\n+    @Test\n+    public void testComputeAffinityCallJobAndTask() throws Exception {\n+        barrier = new CyclicBarrier(2);\n+\n+        SystemView<ComputeJobView> jobs = server.context().systemView().view(JOBS_VIEW);\n+        SystemView<ComputeTaskView> tasks = client.context().systemView().view(TASKS_VIEW);\n+\n+        client.compute().affinityCallAsync(\"test-cache\", 1, () -> {\n+            try {\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+                barrier.await(TIMEOUT, MILLISECONDS);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            return 0;\n+        });\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+\n+        assertEquals(1, tasks.size());\n+        assertEquals(1, jobs.size());\n+\n+        checkJobAndTask(tasks.iterator().next(), jobs.iterator().next());\n+\n+        barrier.await(TIMEOUT, MILLISECONDS);\n+    }\n+\n+    /**\n+     * Check fields for local {@link ComputeTaskView} and remote {@link ComputeJobView} info of the same computation.\n+     */\n+    private void checkJobAndTask(ComputeTaskView task, ComputeJobView job) {\n+        assertNotSame(task.id(), job.id());\n+        assertEquals(task.sessionId(), job.sessionId());\n+        assertEquals(task.taskNodeId(), job.originNodeId());\n+        assertEquals(task.taskName(), job.taskName());\n+        assertEquals(task.taskClassName(), job.taskClassName());\n+\n+        if (task.affinityCacheName() != null)\n+            assertEquals((Integer)CU.cacheId(task.affinityCacheName()), Integer.valueOf(job.affinityCacheIds()));\n+        else\n+            assertNull(job.affinityCacheIds());\n+\n+        assertEquals(task.affinityPartitionId(), job.affinityPartitionId());\n+    }\n+\n+    /** Check tasks fields. */\n+    private void checkTask(ComputeJobView t) {\n+        assertFalse(t.isInternal());\n+        assertNull(t.affinityCacheIds());\n+        assertEquals(-1, t.affinityPartitionId());\n+        assertTrue(t.taskClassName().startsWith(getClass().getName()));\n+        assertTrue(t.taskName().startsWith(getClass().getName()));\n+        assertEquals(client.localNode().id(), t.originNodeId());\n+        assertEquals(ACTIVE, t.state);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MDE3Mw=="}, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzAwMDcxOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxMToyMFrOFx6CaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxMToyMFrOFx6CaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NTQzMg==", "bodyText": "Let's increase timeout to avoid infrastructures affect.", "url": "https://github.com/apache/ignite/pull/7495#discussion_r387875432", "createdAt": "2020-03-04T19:11:20Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/metric/SystemViewComputeJobTest.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.metric;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCompute;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.compute.ComputeJob;\n+import org.apache.ignite.compute.ComputeJobResult;\n+import org.apache.ignite.compute.ComputeJobResultPolicy;\n+import org.apache.ignite.compute.ComputeTask;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.lang.IgniteCallable;\n+import org.apache.ignite.lang.IgniteClosure;\n+import org.apache.ignite.lang.IgniteRunnable;\n+import org.apache.ignite.spi.systemview.view.ComputeJobView;\n+import org.apache.ignite.spi.systemview.view.ComputeTaskView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.internal.processors.job.GridJobProcessor.JOBS_VIEW;\n+import static org.apache.ignite.internal.processors.task.GridTaskProcessor.TASKS_VIEW;\n+import static org.apache.ignite.spi.systemview.view.ComputeJobView.ComputeJobState.ACTIVE;\n+\n+/** Tests for compute task {@link SystemView}. */\n+public class SystemViewComputeJobTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final long TIMEOUT = 5_000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b433c138b72c0092a326252a13e9f935f926aa1"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2570, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}