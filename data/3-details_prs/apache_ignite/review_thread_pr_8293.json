{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MzkzMTQ5", "number": 8293, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMToyNjoyOFrOEpNdKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMToyNjoyOFrOEpNdKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNjQ3NTMwOnYy", "diffSide": "RIGHT", "path": "docs/_docs/monitoring-metrics/system-views.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMToyNjoyOFrOHav7JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzo1MDowNFrOHa-gbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMDIxMw==", "bodyText": "@alex-plekhanov could you add and elaborate on all the possible states? Sorry, I came across this attribute description only after merging your changes. Feel free to commit the changes to the branch directly, skipping the pull-request phase.", "url": "https://github.com/apache/ignite/pull/8293#discussion_r497810213", "createdAt": "2020-09-30T21:26:28Z", "author": {"login": "dmagda"}, "path": "docs/_docs/monitoring-metrics/system-views.adoc", "diffHunk": "@@ -601,76 +601,42 @@ Page lists organized in buckets. Each bucket group pages with about the same siz\n If persistence is enabled page lists are created for each partition of each cache group, to view such page lists cacheGroupPageLists system view (SQL name CACHE_GROUP_PAGE_LISTS) can be used. If persistence is disabled page lists are created for each data region, in this case, dataRegionPageLists system view (SQL name DATA_REGION_PAGE_LISTS) can be used. These views contain information about each bucket of each page list what is useful to understand how much data can be inserted into the cache without allocating new pages and also helps to detect skews in page lists utilization.\n \n \n-////\n-=== Columns of cacheGroupPageLists\n-\n-\n-|NAME  |  SQL NAME   | TYPE |   DESCRIPTION\n-|cacheGroupId | CACHE_GROUP_ID |  int| Cache group ID\n-|partitionId | PARTITION_ID |    int| Partition ID\n-|name | NAME |    String|  Page list name\n-|bucketNumber | BUCKET_NUMBER |   int| Bucket number\n-|bucketSize | BUCKET_SIZE | long  |  Count of pages in the bucket\n-|stripesCount | STRIPES_COUNT |   int| Count of stripes used by this bucket. Stripes are used to avoid contention.\n-|cachedPagesCount | CACHED_PAGES_COUNT |  int| Count of pages in onheap page list cache for this bucket\n-|CACHE_TYPE | string ||  Cache type\n-|CACHE_MODE | string ||  Cache mode\n-|ATOMICITY_MODE | string |  Atomicity mode\n-|CACHE_GROUP_NAME | string |  Cache group name\n-|AFFINITY | string |  toString representation of affinity function\n-|AFFINITY_MAPPER | string |  toString representation of affinity mapper\n-|BACKUPS | int | backup count\n-|CACHE_GROUP_ID | int | cache group id\n-|CACHE_LOADER_FACTORY | string |  toString representation of cache loader factory\n-|CACHE_STORE_FACTORY | string |  toString representation of cache store factory\n-|CACHE_WRITER_FACTORY | string |  toString representation of cache writer factory\n-|DATA_REGION_NAME | string |  Data region name\n-|DEFAULT_LOCK_TIMEOUT | long |    Lock timeout in milliseconds\n-|EVICTION_FILTER | string |  toString representation of eviction filter\n-|EVICTION_POLICY_FACTORY | string |  toString representation of eviction policy factory\n-|EXPIRY_POLICY_FACTORY | string |  toString representation of expiry policy factory\n-|INTERCEPTOR | string |  toString representation of interceptor\n-|IS_COPY_ON_READ | boolean | Flag indicating whether a copy of the value stored in the on-heap cache\n-|IS_EAGER_TTL | boolean | Flag indicating whether expired cache entries will be eagerly removed from cache\n-|IS_ENCRYPTION_ENABLED | boolean | True if cache data encrypted\n-|IS_EVENTS_DISABLED | boolean | True if events disabled for this cache\n-|IS_INVALIDATE | boolean | True if values will be invalidated (nullified) upon commit in near cache\n-|IS_LOAD_PREVIOUS_VALUE | boolean | True if value should be loaded from store if it is not in the cache\n-|IS_MANAGEMENT_ENABLED | boolean |\n-|IS_NEAR_CACHE_ENABLED | boolean | True if near cache enabled\n-|IS_ONHEAP_CACHE_ENABLED | boolean | True if on heap cache enabled\n-|IS_READ_FROM_BACKUP | boolean | True if read operation should be performed from backup node\n-|IS_READ_THROUGH | boolean | True if read from third party storage enabled\n-|IS_SQL_ESCAPE_ALL | boolean | If true all the SQL table and field names will be escaped with double quotes\n-|IS_SQL_ONHEAP_CACHE_ENABLED | boolean | If true SQL on-heap cache is enabled. When enabled, Ignite will cache SQL rows as they are accessed by query engine. Rows are invalidated and evicted from cache when relevant cache entry is either changed or evicted.\n-|IS_STATISTICS_ENABLED | boolean |\n-|IS_STORE_KEEP_BINARY | boolean | Flag indicating that {@link CacheStore} implementation is working with binary objects instead of Java objects.\n-|IS_WRITE_BEHIND_ENABLED | boolean | Flag indicating whether Ignite should use write-behind behaviour for the cache store\n-|IS_WRITE_THROUGH | boolean | True if write to third party storage enabled\n-|MAX_CONCURRENT_ASYNC_OPERATIONS | int | Maximum number of allowed concurrent asynchronous operations. If 0 returned then number of concurrent asynchronous operations is unlimited\n-|MAX_QUERY_ITERATORS_COUNT | int | Maximum number of query iterators that can be stored. Iterators are stored to support query pagination when each page of data is sent to user's node only on demand\n-|NEAR_CACHE_EVICTION_POLICY_FACTORY | string |  toString representation of near cache eviction policy factory\n-|NEAR_CACHE_START_SIZE | int | Initial cache size for near cache which will be used to pre-create internal hash table after start.\n-|NODE_FILTER | string |  toString representation of node filter\n-|PARTITION_LOSS_POLICY | string |  toString representation of partition loss policy\n-|QUERY_DETAIL_METRICS_SIZE | int | size of queries detail metrics that will be stored in memory for monitoring purposes. If 0 then history will not be collected.\n-|QUERY_PARALLELISM | int | Hint to query execution engine on desired degree of parallelism within a single node\n-|REBALANCE_BATCH_SIZE | int | Size (in bytes) to be loaded within a single rebalance message\n-|REBALANCE_BATCHES_PREFETCH_COUNT | int | Number of batches generated by supply node at rebalancing start\n-|REBALANCE_DELAY | long |    Rebalance delay in milliseconds\n-|REBALANCE_MODE | string |  Rebalance mode\n-|REBALANCE_ORDER | int | Rebalance order\n-|REBALANCE_THROTTLE | long |    Time in milliseconds to wait between rebalance messages to avoid overloading of CPU or network\n-|REBALANCE_TIMEOUT | long |    Rebalance timeout in milliseconds\n-|SQL_INDEX_MAX_INLINE_SIZE | int | Index inline size in bytes\n-|SQL_ONHEAP_CACHE_MAX_SIZE | int | Maximum SQL on-heap cache. Measured in number of rows. When maximum size is reached oldest cached rows will be evicted.\n-|SQL_SCHEMA | string |  Schema name\n-|TOPOLOGY_VALIDATOR | string |  toString representation of topology validator\n-|WRITE_BEHIND_BATCH_SIZE | int | Maximum batch size for write-behind cache store operations\n-|WRITE_BEHIND_COALESCING | boolean | Write coalescing flag for write-behind cache store operations. Store operations (get or remove) with the same key are combined or coalesced to single, resulting operation to reduce pressure to underlying cache store\n-|WRITE_BEHIND_FLUSH_FREQUENCY | long |    Frequency with which write-behind cache is flushed to the cache store in milliseconds\n-|WRITE_BEHIND_FLUSH_SIZE | int | Maximum size of the write-behind cache. If cache size exceeds this value, all cached items are flushed to the cache store and write cache is cleared\n-|WRITE_BEHIND_FLUSH_THREAD_COUNT | int | Number of threads that will perform cache flushing\n-|WRITE_SYNCHRONIZATION_MODE | string |  Gets write synchronization mode\n+=== CACHE_GROUP_PAGE_LISTS\n+\n+[{table_opts}]\n+|===\n+|Column | Data type |  Description\n+|CACHE_GROUP_ID |  int| Cache group ID\n+|PARTITION_ID |    int| Partition ID\n+|NAME |    string|  Page list name\n+|BUCKET_NUMBER |   int| Bucket number\n+|BUCKET_SIZE | long  |  Count of pages in the bucket\n+|STRIPES_COUNT |   int| Count of stripes used by this bucket. Stripes are used to avoid contention.\n+|CACHED_PAGES_COUNT |  int| Count of pages in onheap page list cache for this bucket\n+|===\n+\n+=== DATA_REGION_PAGE_LISTS\n+\n+[{table_opts}]\n+|===\n+|Column | Data type |  Description\n+|NAME |    string|  Page list name\n+|BUCKET_NUMBER |   int| Bucket number\n+|BUCKET_SIZE | long  |  Count of pages in the bucket\n+|STRIPES_COUNT |   int| Count of stripes used by this bucket. Stripes are used to avoid contention.\n+|CACHED_PAGES_COUNT |  int| Count of pages in onheap page list cache for this bucket\n+|===\n+\n+== PARTITION_STATES\n \n-////\n+This view exposes information about distribution of cache group partitions across cluster nodes.\n+\n+[{table_opts}]\n+|===\n+|Column | Data type |  Description\n+|CACHE_GROUP_ID |  int| Cache group ID\n+|PARTITION_ID |    int| Partition ID\n+|NODE_ID | UUID | Node ID\n+|STATE | string | Partition state\n+|IS_PRIMARY | boolean  | Primary partition flag", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849d95acf6244d3deabf92d3eed001e064215a6b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0OTEzMw==", "bodyText": "Done", "url": "https://github.com/apache/ignite/pull/8293#discussion_r498049133", "createdAt": "2020-10-01T07:50:04Z", "author": {"login": "alex-plekhanov"}, "path": "docs/_docs/monitoring-metrics/system-views.adoc", "diffHunk": "@@ -601,76 +601,42 @@ Page lists organized in buckets. Each bucket group pages with about the same siz\n If persistence is enabled page lists are created for each partition of each cache group, to view such page lists cacheGroupPageLists system view (SQL name CACHE_GROUP_PAGE_LISTS) can be used. If persistence is disabled page lists are created for each data region, in this case, dataRegionPageLists system view (SQL name DATA_REGION_PAGE_LISTS) can be used. These views contain information about each bucket of each page list what is useful to understand how much data can be inserted into the cache without allocating new pages and also helps to detect skews in page lists utilization.\n \n \n-////\n-=== Columns of cacheGroupPageLists\n-\n-\n-|NAME  |  SQL NAME   | TYPE |   DESCRIPTION\n-|cacheGroupId | CACHE_GROUP_ID |  int| Cache group ID\n-|partitionId | PARTITION_ID |    int| Partition ID\n-|name | NAME |    String|  Page list name\n-|bucketNumber | BUCKET_NUMBER |   int| Bucket number\n-|bucketSize | BUCKET_SIZE | long  |  Count of pages in the bucket\n-|stripesCount | STRIPES_COUNT |   int| Count of stripes used by this bucket. Stripes are used to avoid contention.\n-|cachedPagesCount | CACHED_PAGES_COUNT |  int| Count of pages in onheap page list cache for this bucket\n-|CACHE_TYPE | string ||  Cache type\n-|CACHE_MODE | string ||  Cache mode\n-|ATOMICITY_MODE | string |  Atomicity mode\n-|CACHE_GROUP_NAME | string |  Cache group name\n-|AFFINITY | string |  toString representation of affinity function\n-|AFFINITY_MAPPER | string |  toString representation of affinity mapper\n-|BACKUPS | int | backup count\n-|CACHE_GROUP_ID | int | cache group id\n-|CACHE_LOADER_FACTORY | string |  toString representation of cache loader factory\n-|CACHE_STORE_FACTORY | string |  toString representation of cache store factory\n-|CACHE_WRITER_FACTORY | string |  toString representation of cache writer factory\n-|DATA_REGION_NAME | string |  Data region name\n-|DEFAULT_LOCK_TIMEOUT | long |    Lock timeout in milliseconds\n-|EVICTION_FILTER | string |  toString representation of eviction filter\n-|EVICTION_POLICY_FACTORY | string |  toString representation of eviction policy factory\n-|EXPIRY_POLICY_FACTORY | string |  toString representation of expiry policy factory\n-|INTERCEPTOR | string |  toString representation of interceptor\n-|IS_COPY_ON_READ | boolean | Flag indicating whether a copy of the value stored in the on-heap cache\n-|IS_EAGER_TTL | boolean | Flag indicating whether expired cache entries will be eagerly removed from cache\n-|IS_ENCRYPTION_ENABLED | boolean | True if cache data encrypted\n-|IS_EVENTS_DISABLED | boolean | True if events disabled for this cache\n-|IS_INVALIDATE | boolean | True if values will be invalidated (nullified) upon commit in near cache\n-|IS_LOAD_PREVIOUS_VALUE | boolean | True if value should be loaded from store if it is not in the cache\n-|IS_MANAGEMENT_ENABLED | boolean |\n-|IS_NEAR_CACHE_ENABLED | boolean | True if near cache enabled\n-|IS_ONHEAP_CACHE_ENABLED | boolean | True if on heap cache enabled\n-|IS_READ_FROM_BACKUP | boolean | True if read operation should be performed from backup node\n-|IS_READ_THROUGH | boolean | True if read from third party storage enabled\n-|IS_SQL_ESCAPE_ALL | boolean | If true all the SQL table and field names will be escaped with double quotes\n-|IS_SQL_ONHEAP_CACHE_ENABLED | boolean | If true SQL on-heap cache is enabled. When enabled, Ignite will cache SQL rows as they are accessed by query engine. Rows are invalidated and evicted from cache when relevant cache entry is either changed or evicted.\n-|IS_STATISTICS_ENABLED | boolean |\n-|IS_STORE_KEEP_BINARY | boolean | Flag indicating that {@link CacheStore} implementation is working with binary objects instead of Java objects.\n-|IS_WRITE_BEHIND_ENABLED | boolean | Flag indicating whether Ignite should use write-behind behaviour for the cache store\n-|IS_WRITE_THROUGH | boolean | True if write to third party storage enabled\n-|MAX_CONCURRENT_ASYNC_OPERATIONS | int | Maximum number of allowed concurrent asynchronous operations. If 0 returned then number of concurrent asynchronous operations is unlimited\n-|MAX_QUERY_ITERATORS_COUNT | int | Maximum number of query iterators that can be stored. Iterators are stored to support query pagination when each page of data is sent to user's node only on demand\n-|NEAR_CACHE_EVICTION_POLICY_FACTORY | string |  toString representation of near cache eviction policy factory\n-|NEAR_CACHE_START_SIZE | int | Initial cache size for near cache which will be used to pre-create internal hash table after start.\n-|NODE_FILTER | string |  toString representation of node filter\n-|PARTITION_LOSS_POLICY | string |  toString representation of partition loss policy\n-|QUERY_DETAIL_METRICS_SIZE | int | size of queries detail metrics that will be stored in memory for monitoring purposes. If 0 then history will not be collected.\n-|QUERY_PARALLELISM | int | Hint to query execution engine on desired degree of parallelism within a single node\n-|REBALANCE_BATCH_SIZE | int | Size (in bytes) to be loaded within a single rebalance message\n-|REBALANCE_BATCHES_PREFETCH_COUNT | int | Number of batches generated by supply node at rebalancing start\n-|REBALANCE_DELAY | long |    Rebalance delay in milliseconds\n-|REBALANCE_MODE | string |  Rebalance mode\n-|REBALANCE_ORDER | int | Rebalance order\n-|REBALANCE_THROTTLE | long |    Time in milliseconds to wait between rebalance messages to avoid overloading of CPU or network\n-|REBALANCE_TIMEOUT | long |    Rebalance timeout in milliseconds\n-|SQL_INDEX_MAX_INLINE_SIZE | int | Index inline size in bytes\n-|SQL_ONHEAP_CACHE_MAX_SIZE | int | Maximum SQL on-heap cache. Measured in number of rows. When maximum size is reached oldest cached rows will be evicted.\n-|SQL_SCHEMA | string |  Schema name\n-|TOPOLOGY_VALIDATOR | string |  toString representation of topology validator\n-|WRITE_BEHIND_BATCH_SIZE | int | Maximum batch size for write-behind cache store operations\n-|WRITE_BEHIND_COALESCING | boolean | Write coalescing flag for write-behind cache store operations. Store operations (get or remove) with the same key are combined or coalesced to single, resulting operation to reduce pressure to underlying cache store\n-|WRITE_BEHIND_FLUSH_FREQUENCY | long |    Frequency with which write-behind cache is flushed to the cache store in milliseconds\n-|WRITE_BEHIND_FLUSH_SIZE | int | Maximum size of the write-behind cache. If cache size exceeds this value, all cached items are flushed to the cache store and write cache is cleared\n-|WRITE_BEHIND_FLUSH_THREAD_COUNT | int | Number of threads that will perform cache flushing\n-|WRITE_SYNCHRONIZATION_MODE | string |  Gets write synchronization mode\n+=== CACHE_GROUP_PAGE_LISTS\n+\n+[{table_opts}]\n+|===\n+|Column | Data type |  Description\n+|CACHE_GROUP_ID |  int| Cache group ID\n+|PARTITION_ID |    int| Partition ID\n+|NAME |    string|  Page list name\n+|BUCKET_NUMBER |   int| Bucket number\n+|BUCKET_SIZE | long  |  Count of pages in the bucket\n+|STRIPES_COUNT |   int| Count of stripes used by this bucket. Stripes are used to avoid contention.\n+|CACHED_PAGES_COUNT |  int| Count of pages in onheap page list cache for this bucket\n+|===\n+\n+=== DATA_REGION_PAGE_LISTS\n+\n+[{table_opts}]\n+|===\n+|Column | Data type |  Description\n+|NAME |    string|  Page list name\n+|BUCKET_NUMBER |   int| Bucket number\n+|BUCKET_SIZE | long  |  Count of pages in the bucket\n+|STRIPES_COUNT |   int| Count of stripes used by this bucket. Stripes are used to avoid contention.\n+|CACHED_PAGES_COUNT |  int| Count of pages in onheap page list cache for this bucket\n+|===\n+\n+== PARTITION_STATES\n \n-////\n+This view exposes information about distribution of cache group partitions across cluster nodes.\n+\n+[{table_opts}]\n+|===\n+|Column | Data type |  Description\n+|CACHE_GROUP_ID |  int| Cache group ID\n+|PARTITION_ID |    int| Partition ID\n+|NODE_ID | UUID | Node ID\n+|STATE | string | Partition state\n+|IS_PRIMARY | boolean  | Primary partition flag", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMDIxMw=="}, "originalCommit": {"oid": "849d95acf6244d3deabf92d3eed001e064215a6b"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2697, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}