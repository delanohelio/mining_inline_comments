{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MTg3NjM2", "number": 8206, "title": "IGNITE-13204 Add Java thin client Kubernetes auto discovery", "bodyText": "ReliableChannel now works with dynamic list of server addresses;\nClientConfiguration can be configured with addressFinder;\nProvide Kubernetes addressFinder.", "createdAt": "2020-09-01T16:08:03Z", "url": "https://github.com/apache/ignite/pull/8206", "merged": true, "mergeCommit": {"oid": "fa9c483861d4d221b9d907f4e993e45aa9ed9d1b"}, "closed": true, "closedAt": "2020-10-16T15:27:59Z", "author": {"login": "timoninmaxim"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEpmUvAH2gAyNDc3MTg3NjM2OmRhNjBmNzJjOWIyNTBiZDFlMmExNTM5MWMwYTk2N2QxN2JkZmVhYzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTGUcAgFqTUxMDQ2NTA4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "da60f72c9b250bd1e2a15391c0a967d17bdfeac5", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/da60f72c9b250bd1e2a15391c0a967d17bdfeac5", "committedDate": "2020-09-01T16:00:54Z", "message": "IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6d1b1293b76af3bdfc7a38254e1a3a0c4cb98d", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/4f6d1b1293b76af3bdfc7a38254e1a3a0c4cb98d", "committedDate": "2020-09-01T16:22:56Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/003b164bb40369ca95eb76cc149719df5d263663", "committedDate": "2020-09-02T13:34:41Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTI0MDY4", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-481524068", "createdAt": "2020-09-03T06:22:36Z", "commit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNjoyMjozNlrOHMXhig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzoxOTozN1rOHMZVcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDM3OA==", "bodyText": "Is -> Whether", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482730378", "createdAt": "2020-09-03T06:22:36Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -62,16 +65,16 @@\n     private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n \n     /** Client channel holders for each configured address. */\n-    private final ClientChannelHolder[] channels;\n+    private final AtomicReference<List<ClientChannelHolder>> channels = new AtomicReference<>();\n \n     /** Index of the current channel. */\n-    private int curChIdx;\n+    private volatile int curChIdx = -1;\n \n-    /** Partition awareness enabled. */\n-    private final boolean partitionAwarenessEnabled;\n+    /** Is all channels should be initialized at one moment. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDQ1MQ==", "bodyText": "private", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482730451", "createdAt": "2020-09-03T06:22:46Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.\n+ */\n+class ClientChannelHolder {\n+    /** Channel configuration. */\n+    final ClientChannelConfiguration chCfg;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDkxMA==", "bodyText": "Please move this explanation to public setter/getter", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482730910", "createdAt": "2020-09-03T06:23:52Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,33 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /**\n+     * Try use other limited number of channels to send a request if default channel is not responding.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMTMzNw==", "bodyText": "shouldApplyReconnectionThrottling", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482731337", "createdAt": "2020-09-03T06:24:56Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.\n+ */\n+class ClientChannelHolder {\n+    /** Channel configuration. */\n+    final ClientChannelConfiguration chCfg;\n+\n+    /** Channel. */\n+    private volatile ClientChannel ch;\n+\n+    /** Address that holder is bind to (chCfg.addr) is not in use now. So close the holder */\n+    private volatile boolean close;\n+\n+    /** Timestamps of reconnect retries. */\n+    private final long[] reconnectRetries;\n+\n+    /** Channel factory. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n+\n+    /** Callback invokes when new channel create */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate;\n+\n+    /** Callback invokes when channel close */\n+    private final Consumer<ClientChannel> onChannelClose;\n+\n+    /**\n+     * @param chCfg Channel config.\n+     */\n+    ClientChannelHolder(ClientChannelConfiguration chCfg,\n+                        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                        BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate,\n+                        Consumer<ClientChannel> onChannelClose) {\n+        this.chCfg = chCfg;\n+        this.chFactory = chFactory;\n+        this.onChannelCreate = onChannelCreate;\n+        this.onChannelClose = onChannelClose;\n+\n+        reconnectRetries = chCfg.getReconnectThrottlingRetries() > 0 && chCfg.getReconnectThrottlingPeriod() > 0L ?\n+            new long[chCfg.getReconnectThrottlingRetries()] : null;\n+    }\n+\n+    /**\n+     * @return Whether reconnect throttling should be applied.\n+     */\n+    boolean applyReconnectionThrottling() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjc5MQ==", "bodyText": "I think we should remove this interface. There is hardly any value in sharing an interface across thin and thick configurations, but it can cause difficulties when APIs evolve in the future.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482736791", "createdAt": "2020-09-03T06:38:10Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/kubernetes/KubernetesConnectorConfigurator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.kubernetes;\n+\n+/**\n+ * Interface provide methods to configure Kubernetes connection.\n+ */\n+public interface KubernetesConnectorConfigurator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTkwNA==", "bodyText": "Can you please explain the purpose of this class?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482741904", "createdAt": "2020-09-03T06:48:18Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannelFacade.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.IgniteBinary;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+\n+/**\n+ * Communication channel with failover and partition awareness.\n+ */\n+final class ReliableChannelFacade implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0Mjc5NQ==", "bodyText": "I don't think this should be in the public package, users won't use this class directly.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482742795", "createdAt": "2020-09-03T06:50:14Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/kubernetes/KubernetesServiceAddressResolver.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.kubernetes;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.SecureRandom;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * The class is responsible to fetch list of IP address for all pods that runs the specified kubernetes service.\n+ */\n+public class KubernetesServiceAddressResolver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NjI1Mg==", "bodyText": "have to be deployed", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482746252", "createdAt": "2020-09-03T06:57:14Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzM3OA==", "bodyText": "I know this was copied from existing TcpDiscoveryKubernetesIpFinder, but the text is confusing:\n\nprior Ignite nodes startup - not true, k8s service can be created before or after the pods - does not matter\nservice will maintain a list of all endpoints - misleading, service is an abstraction over a set of pods, it does not maintain endpoints, and this is k8s implementation details https://kubernetes.io/docs/concepts/services-networking/service/", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482747378", "createdAt": "2020-09-03T06:59:38Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to\n+ * deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service that has to be created and should be deployed prior\n+ * Ignite nodes startup. The service will maintain a list of all endpoints (internal IP addresses) of all containerized", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzgwMg==", "bodyText": "This paragraph is also confusing. We don't care how users define their services and use their selectors, why mention that?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482747802", "createdAt": "2020-09-03T07:00:38Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to\n+ * deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service that has to be created and should be deployed prior\n+ * Ignite nodes startup. The service will maintain a list of all endpoints (internal IP addresses) of all containerized\n+ * Ignite pods running so far. The name of the service must be equal to {@link #setServiceName(String)} which is\n+ * `ignite` by default.\n+ * <p>\n+ * As for Ignite pods, it's recommended to label them in such a way that the service will use the label in its selector", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1MjAxMg==", "bodyText": "I think this belongs to org.apache.ignite.client package", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482752012", "createdAt": "2020-09-03T07:04:17Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1MjcyMQ==", "bodyText": "ReliableChannel is an implementation detail in the internal package, let's not mention it in the javadoc of the public class.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482752721", "createdAt": "2020-09-03T07:05:01Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to\n+ * deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service that has to be created and should be deployed prior\n+ * Ignite nodes startup. The service will maintain a list of all endpoints (internal IP addresses) of all containerized\n+ * Ignite pods running so far. The name of the service must be equal to {@link #setServiceName(String)} which is\n+ * `ignite` by default.\n+ * <p>\n+ * As for Ignite pods, it's recommended to label them in such a way that the service will use the label in its selector\n+ * configuration excluding endpoints of irrelevant Kubernetes pods running in parallel.\n+ * <p>\n+ * The address finder, in its turn, will call this service to retrieve Ignite pods IP addresses. The port will be\n+ * set with {@link ReliableChannel#parseAddresses(String[])}. Make sure that all Ignite pods occupy a similar", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NTY2Mg==", "bodyText": "Copypasted javadoc", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482755662", "createdAt": "2020-09-03T07:11:01Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1Nzg5OQ==", "bodyText": "resolvedAddrs is a List, this can be inefficient with large number of channels and addresses", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482757899", "createdAt": "2020-09-03T07:15:34Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */\n+    private final ArrayList<Predicate<ClientChannel>> topChangeFilters = new ArrayList<>();\n+\n+    /** Guard channels and curChIdx together. */\n+    private final ReadWriteLock curChannelsGuard = new ReentrantReadWriteLock();\n+\n+    /** Constructor. */\n+    ReliableChannel(ClientConfiguration clientCfg,\n+                    Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                    boolean initAllChannels) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n+        this.initAllChannels = initAllChannels;\n+    }\n+\n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n+    /** Callback is invoked after new ClientChannel has created. */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate = (holder, ch) -> {\n+        ch.addTopologyChangeListener(channel -> {\n+            if (topChangeFilters.stream().allMatch(s -> s.test(channel)))\n+                channelsInit(true);\n+        });\n \n-        channels = new ClientChannelHolder[addrs.size()];\n+        ch.addNotificationListener(this);\n \n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        nodeChannels.values().remove(holder);\n+        nodeChannels.put(ch.serverNodeId(), holder);\n+    };\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n+    /** Callback is invoked after a ClientChannel has closed. */\n+    private final Consumer<ClientChannel> onChannelClose = ch -> {\n+        for (Consumer<ClientChannel> lsnr : channelCloseLsnrs)\n+            lsnr.accept(ch);\n+    };\n \n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        List<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ==", "bodyText": "Do we need a lock around AtomicReference usage?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482760049", "createdAt": "2020-09-03T07:19:37Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */\n+    private final ArrayList<Predicate<ClientChannel>> topChangeFilters = new ArrayList<>();\n+\n+    /** Guard channels and curChIdx together. */\n+    private final ReadWriteLock curChannelsGuard = new ReentrantReadWriteLock();\n+\n+    /** Constructor. */\n+    ReliableChannel(ClientConfiguration clientCfg,\n+                    Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                    boolean initAllChannels) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n+        this.initAllChannels = initAllChannels;\n+    }\n+\n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n+    /** Callback is invoked after new ClientChannel has created. */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate = (holder, ch) -> {\n+        ch.addTopologyChangeListener(channel -> {\n+            if (topChangeFilters.stream().allMatch(s -> s.test(channel)))\n+                channelsInit(true);\n+        });\n \n-        channels = new ClientChannelHolder[addrs.size()];\n+        ch.addNotificationListener(this);\n \n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        nodeChannels.values().remove(holder);\n+        nodeChannels.put(ch.serverNodeId(), holder);\n+    };\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n+    /** Callback is invoked after a ClientChannel has closed. */\n+    private final Consumer<ClientChannel> onChannelClose = ch -> {\n+        for (Consumer<ClientChannel> lsnr : channelCloseLsnrs)\n+            lsnr.accept(ch);\n+    };\n \n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        List<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(\n+                    new ClientChannelConfiguration(clientCfg, addr), chFactory, onChannelCreate, onChannelClose);\n+\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n \n-        affinityCtx = new ClientCacheAffinityContext(binary);\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n \n-        ClientConnectionException lastEx = null;\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n \n-        for (int i = 0; i < channels.length; i++) {\n+            curChannelsGuard.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNTcyMjQ5", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-481572249", "createdAt": "2020-09-03T07:37:01Z", "commit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzozNzowMVrOHMZ7gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzozNzowMVrOHMZ7gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTc5Mw==", "bodyText": "Do we really need this property? What is the use case when this is not 0?\nI think retryLimit is a better name", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482769793", "createdAt": "2020-09-03T07:37:01Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,33 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /**\n+     * Try use other limited number of channels to send a request if default channel is not responding.\n+     * 0 means try use all configured channels before fail.\n+     */\n+    private int channelsAttemptsLimit = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjA0NzI0", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-481604724", "createdAt": "2020-09-03T08:18:59Z", "commit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwODoxODo1OVrOHMbfCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOToyNjo1OVrOHMeHzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc5NTI3NA==", "bodyText": "+1 for retryLimit", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482795274", "createdAt": "2020-09-03T08:18:59Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,33 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /**\n+     * Try use other limited number of channels to send a request if default channel is not responding.\n+     * 0 means try use all configured channels before fail.\n+     */\n+    private int channelsAttemptsLimit = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTc5Mw=="}, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzNjAyNA==", "bodyText": "private here and for other methods where apply.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482836024", "createdAt": "2020-09-03T09:23:12Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.\n+ */\n+class ClientChannelHolder {\n+    /** Channel configuration. */\n+    final ClientChannelConfiguration chCfg;\n+\n+    /** Channel. */\n+    private volatile ClientChannel ch;\n+\n+    /** Address that holder is bind to (chCfg.addr) is not in use now. So close the holder */\n+    private volatile boolean close;\n+\n+    /** Timestamps of reconnect retries. */\n+    private final long[] reconnectRetries;\n+\n+    /** Channel factory. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n+\n+    /** Callback invokes when new channel create */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate;\n+\n+    /** Callback invokes when channel close */\n+    private final Consumer<ClientChannel> onChannelClose;\n+\n+    /**\n+     * @param chCfg Channel config.\n+     */\n+    ClientChannelHolder(ClientChannelConfiguration chCfg,\n+                        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                        BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate,\n+                        Consumer<ClientChannel> onChannelClose) {\n+        this.chCfg = chCfg;\n+        this.chFactory = chFactory;\n+        this.onChannelCreate = onChannelCreate;\n+        this.onChannelClose = onChannelClose;\n+\n+        reconnectRetries = chCfg.getReconnectThrottlingRetries() > 0 && chCfg.getReconnectThrottlingPeriod() > 0L ?\n+            new long[chCfg.getReconnectThrottlingRetries()] : null;\n+    }\n+\n+    /**\n+     * @return Whether reconnect throttling should be applied.\n+     */\n+    boolean applyReconnectionThrottling() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMTMzNw=="}, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzODQ3OQ==", "bodyText": "Please, add a description of what is this class for and how should it be used.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482838479", "createdAt": "2020-09-03T09:26:59Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96655a1f35edbd8d86913f2b8322f40a26505638", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/96655a1f35edbd8d86913f2b8322f40a26505638", "committedDate": "2020-09-03T17:12:23Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f29d2806197b7cce268b7fc8867d932605b8095e", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/f29d2806197b7cce268b7fc8867d932605b8095e", "committedDate": "2020-09-03T17:39:16Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36df449dd67705ef8c99aefe92531be1eeb61cda", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/36df449dd67705ef8c99aefe92531be1eeb61cda", "committedDate": "2020-09-06T10:06:08Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0ODUwNjI4", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-484850628", "createdAt": "2020-09-09T09:57:57Z", "commit": {"oid": "36df449dd67705ef8c99aefe92531be1eeb61cda"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwOTo1Nzo1OFrOHO_94A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMDowMTozN1rOHPAGPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MDE0NA==", "bodyText": "addrFinder can be null", "url": "https://github.com/apache/ignite/pull/8206#discussion_r485490144", "createdAt": "2020-09-09T09:57:58Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,30 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return addrFinder.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36df449dd67705ef8c99aefe92531be1eeb61cda"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MjI4Ng==", "bodyText": "Performance: do not create KubernetesServiceAddressResolver on every call, create it once in constructor.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r485492286", "createdAt": "2020-09-09T10:01:37Z", "author": {"login": "ptupitsyn"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/client/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.internal.kubernetes.connection.KubernetesServiceAddressResolver;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite server nodes running in Kubernetes environment. All Ignite nodes have\n+ * to be deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service. The name of the service must be set with\n+ * {@code KubernetesConnectionConfiguration}. As for Ignite pods, it's recommended to label them in such a way that\n+ * the service will target only server nodes.\n+ * <p>\n+ * The address finder, in its turn, will call this service to retrieve Ignite pods IP addresses. The port will be\n+ * set later within {@link IgniteClient}. Make sure that all Ignite pods occupy a similar ClientConnector port,\n+ * otherwise they will not be able to connect each other using this address finder.\n+ * <p>\n+ */\n+public class ThinClientKubernetesAddressFinder implements Supplier<String[]> {\n+    /** Kubernetes connection configuration */\n+    private final KubernetesConnectionConfiguration cfg;\n+\n+    /** Constructor */\n+    public ThinClientKubernetesAddressFinder(KubernetesConnectionConfiguration cfg) {\n+        this.cfg = cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String[] get() {\n+        return new KubernetesServiceAddressResolver(cfg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36df449dd67705ef8c99aefe92531be1eeb61cda"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6175a9561fc4875e19b3cae99767d45649ba0fcf", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/6175a9561fc4875e19b3cae99767d45649ba0fcf", "committedDate": "2020-09-10T05:53:47Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "318bd1208f7ab401f7623967d83e7e01c789f665", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/318bd1208f7ab401f7623967d83e7e01c789f665", "committedDate": "2020-09-11T04:49:14Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "committedDate": "2020-09-11T10:51:12Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NzA4NTQ3", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-486708547", "createdAt": "2020-09-11T10:59:50Z", "commit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMDo1OTo1MFrOHQaWJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMTo0MzowMlrOHQbgJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MDkxNg==", "bodyText": "Let's revert - no need to be clever here. ClientConfiguration should be a simple POJO, the logic for address handling should not be here.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486970916", "createdAt": "2020-09-11T10:59:50Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +125,35 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return Optional.ofNullable(addrFinder)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTI0MQ==", "bodyText": "Same here - let's revert and move the logic to ReliableChannel.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486971241", "createdAt": "2020-09-11T11:00:36Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +125,35 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return Optional.ofNullable(addrFinder)\n+            .map(Supplier::get)\n+            .orElse(addrs);\n     }\n \n     /**\n      * @param addrs Host addresses.\n      */\n     public ClientConfiguration setAddresses(String... addrs) {\n-        this.addrs = addrs;\n+        if (addrs != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTI2Ng==", "bodyText": "Corresponding getter is missing.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486971266", "createdAt": "2020-09-11T11:00:39Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +125,35 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return Optional.ofNullable(addrFinder)\n+            .map(Supplier::get)\n+            .orElse(addrs);\n     }\n \n     /**\n      * @param addrs Host addresses.\n      */\n     public ClientConfiguration setAddresses(String... addrs) {\n-        this.addrs = addrs;\n+        if (addrs != null) {\n+            this.addrs = Arrays.copyOf(addrs, addrs.length);\n+            addrFinder = () -> this.addrs;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * @param finder function that finds node addresses\n+     */\n+    public ClientConfiguration setAddressesFinder(Supplier<String[]> finder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjMzMA==", "bodyText": "Sets the retry limit. When a request fails due to a connection error, and multiple server connections are available, Ignite will retry the request on every connection. When this property is greater than zero, Ignite will limit the number of retries.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486972330", "createdAt": "2020-09-11T11:03:23Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -493,6 +520,25 @@ public ClientConfiguration setReconnectThrottlingRetries(int reconnectThrottling\n         return this;\n     }\n \n+    /**\n+     * Get retry limit.\n+     */\n+    public int getRetryLimit() {\n+        return retryLimit;\n+    }\n+\n+    /**\n+     * Try use limited number of channels to send a request if default channel is not responding.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Mzg3Mg==", "bodyText": "Is there a reason to bring this outside of the constructor?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486973872", "createdAt": "2020-09-11T11:07:01Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpIgniteClient.java", "diffHunk": "@@ -114,6 +114,7 @@ private TcpIgniteClient(ClientConfiguration cfg) throws ClientException {\n         binary = new ClientBinary(marsh);\n \n         ch = new ReliableChannel(chFactory, cfg, binary);\n+        ch.initConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njc4NA==", "bodyText": "AtomicReference is not needed, we can just use volatile since only get() and set() methods are used below.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486976784", "createdAt": "2020-09-11T11:13:43Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -62,16 +68,19 @@\n     private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n \n     /** Client channel holders for each configured address. */\n-    private final ClientChannelHolder[] channels;\n+    private final AtomicReference<List<ClientChannelHolder>> channels = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NzU2Mg==", "bodyText": "Please revert unnecessary renames to reduce the scope of changes.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486977562", "createdAt": "2020-09-11T11:15:22Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -62,16 +68,19 @@\n     private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n \n     /** Client channel holders for each configured address. */\n-    private final ClientChannelHolder[] channels;\n+    private final AtomicReference<List<ClientChannelHolder>> channels = new AtomicReference<>();\n \n     /** Index of the current channel. */\n-    private int curChIdx;\n+    private volatile int curChIdx = -1;\n \n     /** Partition awareness enabled. */\n     private final boolean partitionAwarenessEnabled;\n \n     /** Cache partition awareness context. */\n-    private final ClientCacheAffinityContext affinityCtx;\n+    private final ClientCacheAffinityContext affCtx;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3ODEwNA==", "bodyText": "Here and below: race condition - channels may become null after the null check. Copy to a variable, then check for null / iterate / etc.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486978104", "createdAt": "2020-09-11T11:16:39Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -169,8 +167,10 @@\n             // No-op.\n         }\n \n-        for (ClientChannelHolder hld : channels)\n-            hld.closeChannel();\n+        if (channels.get() != null) {\n+            for (ClientChannelHolder hld: channels.get())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MTY3Ng==", "bodyText": "private", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486981676", "createdAt": "2020-09-11T11:24:58Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -381,78 +343,59 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n                 .map(p -> new InetSocketAddress(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n-    }\n-\n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n-        try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n-\n-            throw e;\n-        }\n-    }\n-\n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            .collect(Collectors.toSet());\n     }\n \n     /**\n-     * On current channel failure.\n+     * Roll current default channel if specified holder equals to it.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n-        // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n-        // when current index was changed and no other wrong channel will be closed by current thread because\n-        // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            ClientChannelHolder dfltHld = channels.get().get(curChIdx);\n+            if (dfltHld == hld) {\n+                int idx = curChIdx + 1;\n+                if (idx >= channels.get().size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (hld != null && ch != null && ch == hld.ch)\n             hld.closeChannel();\n \n-            if (hld == channels[curChIdx])\n-                rollCurrentChannel();\n-        }\n+        rollCurrentChannel(hld);\n+\n+        chFailLsnrs.forEach(Runnable::run);\n     }\n \n     /**\n      * Asynchronously try to establish a connection to all configured servers.\n      */\n-    private void initAllChannelsAsync() {\n-        // Skip if there is already channels reinit scheduled.\n-        if (scheduledChannelsReinit.compareAndSet(false, true)) {\n-            asyncRunner.submit(\n-                () -> {\n-                    scheduledChannelsReinit.set(false);\n-\n-                    for (ClientChannelHolder hld : channels) {\n-                        if (scheduledChannelsReinit.get() || closed)\n-                            return; // New reinit task scheduled or channel is closed.\n-\n-                        try {\n-                            hld.getOrCreateChannel(true);\n-                        }\n-                        catch (Exception ignore) {\n-                            // No-op.\n-                        }\n+    void initAllChannelsAsync() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjM5Mg==", "bodyText": "shouldStopChannelsReinit()", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486982392", "createdAt": "2020-09-11T11:26:31Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDExOQ==", "bodyText": "Too clever, verbose, and memory-hungry. Just make it channel = hld == null ? null : hld.getOrCreateChannel();.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486984119", "createdAt": "2020-09-11T11:30:15Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n+\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n+\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n+\n+            curChannelsGuard.writeLock().lock();\n+            try {\n+                channels.set(list);\n+                curChIdx = dfltChannelIdx;\n+            } finally {\n+                curChannelsGuard.writeLock().unlock();\n+            }\n+        }\n+    }\n+\n+    /** Initialization of channels. */\n+    private void channelsInit(boolean force) {\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        // Skip if there is already channels reinit scheduled.\n+        // Flag is set back when a thread comes in synchronized initChannelHolders\n+        if (scheduledChannelsReinit.compareAndSet(false, true)) {\n+            initChannelHolders(force);\n+\n+            if (partitionAwarenessEnabled)\n+                initAllChannelsAsync();\n+        }\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = Optional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 520}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4OTg2Mg==", "bodyText": "This requires iteration over entire map. Instead, use addrs.entrySet() for looping and remove by key.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486989862", "createdAt": "2020-09-11T11:43:02Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n+\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 473}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NzY4ODQ5", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-486768849", "createdAt": "2020-09-11T12:40:33Z", "commit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo0MDozNFrOHQdLQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzo0NToxOVrOHQffUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNzI4Mw==", "bodyText": "Here and below, please use Ignite code style for comments (start with uppercase later, end with a point).", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487017283", "createdAt": "2020-09-11T12:40:34Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -114,46 +126,32 @@\n         Function<ClientChannelConfiguration, ClientChannel> chFactory,\n         ClientConfiguration clientCfg,\n         IgniteBinary binary\n-    ) throws ClientException {\n+    ) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n-\n-        channels = new ClientChannelHolder[addrs.size()];\n-\n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled();\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n-\n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n-\n-        affinityCtx = new ClientCacheAffinityContext(binary);\n-\n-        ClientConnectionException lastEx = null;\n-\n-        for (int i = 0; i < channels.length; i++) {\n-            try {\n-                channels[curChIdx].getOrCreateChannel();\n-\n-                if (partitionAwarenessEnabled)\n-                    initAllChannelsAsync();\n-\n-                return;\n-            } catch (ClientConnectionException e) {\n-                lastEx = e;\n-\n-                rollCurrentChannel();\n-            }\n-        }\n+        affCtx = new ClientCacheAffinityContext(binary);\n+    }\n \n-        throw lastEx;\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void initConnection() {\n+        channelsInit(false);\n+        if (!partitionAwarenessEnabled)\n+            applyOnDefaultChannel(channel -> {\n+                // do nothing, just trigger channel connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxOTQ0MA==", "bodyText": "Let's keep it static", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487019440", "createdAt": "2020-09-11T12:44:37Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -356,7 +318,7 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n     /**\n      * @return host:port_range address lines parsed as {@link InetSocketAddress}.\n      */\n-    private static List<InetSocketAddress> parseAddresses(String[] addrs) throws ClientException {\n+    private Set<InetSocketAddress> parseAddresses(String[] addrs) throws ClientException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA==", "bodyText": "Can we skip further steps if clientCfg.getAddresses() is not changed? (for example, in case of static addresses configuration you will always reinit holders, but it's redundant)", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487024444", "createdAt": "2020-09-11T12:53:32Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDc3MQ==", "bodyText": "new ArrayList<>() -> Collections.emptyList()", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487024771", "createdAt": "2020-09-11T12:54:07Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMzc5Mg==", "bodyText": "I'm not sure that replacing List to Set it's a good idea here (perhaps you should just copy list to set here locally). Using List you can solve some user problems which can't be solved with Set. For example, using list you can make some server nodes to be used more often than another. Also, by having a single duplicated address you can workaround some known issues.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487033792", "createdAt": "2020-09-11T13:10:07Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */\n+    private final ArrayList<Predicate<ClientChannel>> topChangeFilters = new ArrayList<>();\n+\n+    /** Guard channels and curChIdx together. */\n+    private final ReadWriteLock curChannelsGuard = new ReentrantReadWriteLock();\n+\n+    /** Constructor. */\n+    ReliableChannel(ClientConfiguration clientCfg,\n+                    Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                    boolean initAllChannels) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n+        this.initAllChannels = initAllChannels;\n+    }\n+\n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n+    /** Callback is invoked after new ClientChannel has created. */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate = (holder, ch) -> {\n+        ch.addTopologyChangeListener(channel -> {\n+            if (topChangeFilters.stream().allMatch(s -> s.test(channel)))\n+                channelsInit(true);\n+        });\n \n-        channels = new ClientChannelHolder[addrs.size()];\n+        ch.addNotificationListener(this);\n \n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        nodeChannels.values().remove(holder);\n+        nodeChannels.put(ch.serverNodeId(), holder);\n+    };\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n+    /** Callback is invoked after a ClientChannel has closed. */\n+    private final Consumer<ClientChannel> onChannelClose = ch -> {\n+        for (Consumer<ClientChannel> lsnr : channelCloseLsnrs)\n+            lsnr.accept(ch);\n+    };\n \n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        List<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1Nzg5OQ=="}, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0OTkxOA==", "bodyText": "Agree with Pavel, we don't need AtomicReference, it's too verbose and we don't use any atomic features (no CAS operations, only get and set). Can be replaced with volatile variable (List or array).", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487049918", "createdAt": "2020-09-11T13:37:13Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */\n+    private final ArrayList<Predicate<ClientChannel>> topChangeFilters = new ArrayList<>();\n+\n+    /** Guard channels and curChIdx together. */\n+    private final ReadWriteLock curChannelsGuard = new ReentrantReadWriteLock();\n+\n+    /** Constructor. */\n+    ReliableChannel(ClientConfiguration clientCfg,\n+                    Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                    boolean initAllChannels) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n+        this.initAllChannels = initAllChannels;\n+    }\n+\n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n+    /** Callback is invoked after new ClientChannel has created. */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate = (holder, ch) -> {\n+        ch.addTopologyChangeListener(channel -> {\n+            if (topChangeFilters.stream().allMatch(s -> s.test(channel)))\n+                channelsInit(true);\n+        });\n \n-        channels = new ClientChannelHolder[addrs.size()];\n+        ch.addNotificationListener(this);\n \n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        nodeChannels.values().remove(holder);\n+        nodeChannels.put(ch.serverNodeId(), holder);\n+    };\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n+    /** Callback is invoked after a ClientChannel has closed. */\n+    private final Consumer<ClientChannel> onChannelClose = ch -> {\n+        for (Consumer<ClientChannel> lsnr : channelCloseLsnrs)\n+            lsnr.accept(ch);\n+    };\n \n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        List<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(\n+                    new ClientChannelConfiguration(clientCfg, addr), chFactory, onChannelCreate, onChannelClose);\n+\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n \n-        affinityCtx = new ClientCacheAffinityContext(binary);\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n \n-        ClientConnectionException lastEx = null;\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n \n-        for (int i = 0; i < channels.length; i++) {\n+            curChannelsGuard.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ=="}, "originalCommit": {"oid": "003b164bb40369ca95eb76cc149719df5d263663"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NTE4Ng==", "bodyText": "force flag is only set when partition awareness is used, but I think sometimes we should reinit holders even without partition awareness. For example, if we use Kubernetes discovery and new servers were started, the client will use only addresses of server nodes that were available at the time of client start.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487055186", "createdAt": "2020-09-11T13:45:19Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n+\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n+\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n+\n+            curChannelsGuard.writeLock().lock();\n+            try {\n+                channels.set(list);\n+                curChIdx = dfltChannelIdx;\n+            } finally {\n+                curChannelsGuard.writeLock().unlock();\n+            }\n+        }\n+    }\n+\n+    /** Initialization of channels. */\n+    private void channelsInit(boolean force) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 496}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2ODQzNDIy", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-486843422", "createdAt": "2020-09-11T14:12:48Z", "commit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDoxMjo0OFrOHQgkYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDoxMjo0OFrOHQgkYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3Mjg2NA==", "bodyText": "I would prefer a dedicated interface - ThinClientAddressFinder or something like this.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487072864", "createdAt": "2020-09-11T14:12:48Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -33,9 +36,16 @@\n     /** Serial version uid. */\n     private static final long serialVersionUID = 0L;\n \n-    /** @serial Server addresses. */\n+    /**\n+     * @serial Server addresses.\n+     * @deprecated deprecated in favor of {@link #addrFinder}. Keep it due to Serializable compatibility.\n+     */\n+    @Deprecated\n     private String[] addrs = null;\n \n+    /** Server addresses finder. */\n+    private transient Supplier<String[]> addrFinder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2ODQzNjg2", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-486843686", "createdAt": "2020-09-11T14:13:09Z", "commit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDoxMzowOVrOHQglLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDoxMzowOVrOHQglLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MzA2OA==", "bodyText": "Perhaps code will be much more simple with regular loop over holders without streams and intermediate structures.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487073068", "createdAt": "2020-09-11T14:13:09Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 430}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NTA1NjUy", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-487505652", "createdAt": "2020-09-14T07:57:01Z", "commit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzo1NzowMVrOHRIHCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzo1NzowMVrOHRIHCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDcxMw==", "bodyText": "There will be 100 holders created for each host (and there will be 100 retries to connect for each host) if port is not set explicitly (see ReliableChannel#parseAddresses). Can we also add ports to this array?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487720713", "createdAt": "2020-09-14T07:57:01Z", "author": {"login": "alex-plekhanov"}, "path": "modules/kubernetes/src/main/java/org/apache/ignite/client/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.internal.kubernetes.connection.KubernetesServiceAddressResolver;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite server nodes running in Kubernetes environment. All Ignite nodes have\n+ * to be deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service. The name of the service must be set with\n+ * {@code KubernetesConnectionConfiguration}. As for Ignite pods, it's recommended to label them in such a way that\n+ * the service will target only server nodes.\n+ * <p>\n+ * The address finder, in its turn, will call this service to retrieve Ignite pods IP addresses. The port will be\n+ * set later within {@link IgniteClient}. Make sure that all Ignite pods occupy a similar ClientConnector port,\n+ * otherwise they will not be able to connect each other using this address finder.\n+ * <p>\n+ */\n+public class ThinClientKubernetesAddressFinder implements Supplier<String[]> {\n+    /** Kubernetes service address resolver. */\n+    private final KubernetesServiceAddressResolver resolver;\n+\n+    /** Constructor */\n+    public ThinClientKubernetesAddressFinder(KubernetesConnectionConfiguration cfg) {\n+        resolver = new KubernetesServiceAddressResolver(cfg);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String[] get() {\n+        return resolver\n+            .getServiceAddresses()\n+            .stream().map(InetAddress::getHostAddress)\n+            .toArray(String[]::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c8629b391096817d069351c30332dde63f70859", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/6c8629b391096817d069351c30332dde63f70859", "committedDate": "2020-09-15T13:25:54Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NTI5MjQw", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-489529240", "createdAt": "2020-09-16T11:28:55Z", "commit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMToyODo1NlrOHSsbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzoyNjoyNlrOHSwwhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NDIyNg==", "bodyText": "If partition awareness is enabled we still need to init default channel on startup", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489364226", "createdAt": "2020-09-16T11:28:56Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -114,46 +135,32 @@\n         Function<ClientChannelConfiguration, ClientChannel> chFactory,\n         ClientConfiguration clientCfg,\n         IgniteBinary binary\n-    ) throws ClientException {\n+    ) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n-\n-        channels = new ClientChannelHolder[addrs.size()];\n-\n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n-\n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n-\n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled();\n \n         affinityCtx = new ClientCacheAffinityContext(binary);\n+    }\n \n-        ClientConnectionException lastEx = null;\n-\n-        for (int i = 0; i < channels.length; i++) {\n-            try {\n-                channels[curChIdx].getOrCreateChannel();\n-\n-                if (partitionAwarenessEnabled)\n-                    initAllChannelsAsync();\n-\n-                return;\n-            } catch (ClientConnectionException e) {\n-                lastEx = e;\n-\n-                rollCurrentChannel();\n-            }\n-        }\n-\n-        throw lastEx;\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void initConnection() {\n+        channelsInit(false);\n+        if (!partitionAwarenessEnabled)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NjMwMg==", "bodyText": "Here and bellow, please use Ignite codestyle (see https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines Semantic Units section)", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489366302", "createdAt": "2020-09-16T11:32:52Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -114,46 +135,32 @@\n         Function<ClientChannelConfiguration, ClientChannel> chFactory,\n         ClientConfiguration clientCfg,\n         IgniteBinary binary\n-    ) throws ClientException {\n+    ) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n-\n-        channels = new ClientChannelHolder[addrs.size()];\n-\n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n-\n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n-\n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled();\n \n         affinityCtx = new ClientCacheAffinityContext(binary);\n+    }\n \n-        ClientConnectionException lastEx = null;\n-\n-        for (int i = 0; i < channels.length; i++) {\n-            try {\n-                channels[curChIdx].getOrCreateChannel();\n-\n-                if (partitionAwarenessEnabled)\n-                    initAllChannelsAsync();\n-\n-                return;\n-            } catch (ClientConnectionException e) {\n-                lastEx = e;\n-\n-                rollCurrentChannel();\n-            }\n-        }\n-\n-        throw lastEx;\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void initConnection() {\n+        channelsInit(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3NDEyOA==", "bodyText": "hld can't be null here", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489374128", "createdAt": "2020-09-16T11:47:20Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -379,80 +351,65 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n-    }\n-\n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n-        try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n-\n-            throw e;\n-        }\n-    }\n-\n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            .collect(Collectors.toSet());\n     }\n \n     /**\n-     * On current channel failure.\n+     * Roll current default channel if specified holder equals to it.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n-        // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n-        // when current index was changed and no other wrong channel will be closed by current thread because\n-        // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            int idx = curChIdx;\n+            List<ClientChannelHolder> holders = channels;\n+\n+            ClientChannelHolder dfltHld = holders.get(idx);\n+            if (dfltHld == hld) {\n+                idx += 1;\n+                if (idx >= holders.size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (hld != null && ch != null && ch == hld.ch)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3OTI4OA==", "bodyText": "This method is invoked inside request processing thread, I don't like the idea of sync channel holders reinit (which can do additional sync http requests) on each topology change in this thread.\nI think we should do it async if partition awareness is enabled. Additionally, we can do it sync in sending thread on channel failure and if we detect topology change before.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489379288", "createdAt": "2020-09-16T11:56:22Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -461,9 +418,8 @@ private void initAllChannelsAsync() {\n      * @param ch Channel.\n      */\n     private void onTopologyChanged(ClientChannel ch) {\n-        if (partitionAwarenessEnabled && affinityCtx.updateLastTopologyVersion(ch.serverTopologyVersion(),\n-            ch.serverNodeId()))\n-            initAllChannelsAsync();\n+        if (affinityCtx.updateLastTopologyVersion(ch.serverTopologyVersion(), ch.serverNodeId()))\n+            channelsInit(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MTA4NA==", "bodyText": "Let's rename it to something more meaningful (like another two apply... methods). For, example, applyOnNodeChannelWithRetry or something like that.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489381084", "createdAt": "2020-09-16T11:59:49Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,16 +429,230 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    synchronized void initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Set<InetSocketAddress> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getServerAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = Collections.emptyMap();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs);\n+\n+        if (holders != null) {\n+            curAddrs = holders.stream()\n+                .collect(Collectors.toMap(h -> h.chCfg.getAddress(), h -> h));\n+\n+            allAddrs.addAll(curAddrs.keySet());\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+        int idx = curChIdx;\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.contains(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+            reinitHolders.add(hld);\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+    }\n+\n+    /** Initialization of channels. */\n+    private void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Skip if there is already channels reinit scheduled.\n+        // Flag is set back when a thread comes in synchronized initChannelHolders.\n+        if (scheduledChannelsReinit.compareAndSet(false, true)) {\n+            initChannelHolders(force);\n+\n+            if (partitionAwarenessEnabled)\n+                initAllChannelsAsync();\n+        }\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+\n+        } catch (ClientConnectionException e) {\n+            onChannelFailure(hld, channel);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on any of available channel.\n+     */\n+    private <T> T applyOnDefaultChannel(Function<ClientChannel, T> function) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (holders == null)\n+            throw new ClientException(\"Connections to nodes aren't initialized.\");\n+\n+        int size = holders.size();\n+\n+        int attemptsLimit = clientCfg.getRetryLimit() > 0 ?\n+            Math.min(clientCfg.getRetryLimit(), size) : size;\n+\n+        ClientConnectionException failure = null;\n+\n+        for (int attempt = 0; attempt < attemptsLimit; attempt++) {\n+            ClientChannelHolder hld = null;\n+            ClientChannel c = null;\n+            try {\n+                if (closed)\n+                    throw new ClientException(\"Channel is closed\");\n+\n+                curChannelsGuard.readLock().lock();\n+                try {\n+                    hld = channels.get(curChIdx);\n+                } finally {\n+                    curChannelsGuard.readLock().unlock();\n+                }\n+\n+                c = hld.getOrCreateChannel();\n+                if (c != null)\n+                    return function.apply(c);\n+            }\n+            catch (ClientConnectionException e) {\n+                if (failure == null)\n+                    failure = e;\n+                else\n+                    failure.addSuppressed(e);\n+\n+                onChannelFailure(hld, c);\n+            }\n+        }\n+\n+        throw failure;\n+    }\n+\n+    /**\n+     * Try apply specified {@code function} on a channel corresponding to {@code tryNodeId}.\n+     * If failed then apply the function on any available channel.\n+     */\n+    private <T> T apply(UUID tryNodeId, Function<ClientChannel, T> function) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MjYwNA==", "bodyText": "This if is redundant, since you set serverNodeId later and the next if condition can't be true with this condition at the same time.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489382604", "createdAt": "2020-09-16T12:02:43Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -519,29 +689,44 @@ private boolean applyReconnectionThrottling() {\n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel()\n+        private ClientChannel getOrCreateChannel()\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n             return getOrCreateChannel(false);\n         }\n \n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n+        private ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n-            if (ch == null) {\n-                if (!ignoreThrottling && applyReconnectionThrottling())\n-                    throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n+            if (ch == null && !close) {\n+                synchronized (this) {\n+                    if (close)\n+                        return null;\n+\n+                    if (ch != null)\n+                        return ch;\n \n-                ch = chFactory.apply(chCfg);\n+                    if (!ignoreThrottling && applyReconnectionThrottling())\n+                        throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n \n-                if (ch.serverNodeId() != null) {\n-                    ch.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n-                    ch.addNotificationListener(ReliableChannel.this);\n+                    ClientChannel channel = chFactory.apply(chCfg);\n \n-                    nodeChannels.values().remove(this);\n+                    if (channel.serverNodeId() != null) {\n+                        channel.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n+                        channel.addNotificationListener(ReliableChannel.this);\n \n-                    nodeChannels.putIfAbsent(ch.serverNodeId(), this);\n+                        if (serverNodeId == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4Mjk4Ng==", "bodyText": "nodeChannels.remove(serverNodeId, this)", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489382986", "createdAt": "2020-09-16T12:03:29Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -519,29 +689,44 @@ private boolean applyReconnectionThrottling() {\n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel()\n+        private ClientChannel getOrCreateChannel()\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n             return getOrCreateChannel(false);\n         }\n \n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n+        private ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n-            if (ch == null) {\n-                if (!ignoreThrottling && applyReconnectionThrottling())\n-                    throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n+            if (ch == null && !close) {\n+                synchronized (this) {\n+                    if (close)\n+                        return null;\n+\n+                    if (ch != null)\n+                        return ch;\n \n-                ch = chFactory.apply(chCfg);\n+                    if (!ignoreThrottling && applyReconnectionThrottling())\n+                        throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n \n-                if (ch.serverNodeId() != null) {\n-                    ch.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n-                    ch.addNotificationListener(ReliableChannel.this);\n+                    ClientChannel channel = chFactory.apply(chCfg);\n \n-                    nodeChannels.values().remove(this);\n+                    if (channel.serverNodeId() != null) {\n+                        channel.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n+                        channel.addNotificationListener(ReliableChannel.this);\n \n-                    nodeChannels.putIfAbsent(ch.serverNodeId(), this);\n+                        if (serverNodeId == null)\n+                            serverNodeId = channel.serverNodeId();\n+\n+                        if (serverNodeId != null && serverNodeId != channel.serverNodeId())\n+                            nodeChannels.remove(serverNodeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MzU0Mg==", "bodyText": "nodeChannels.remove(serverNodeId, this)", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489383542", "createdAt": "2020-09-16T12:04:35Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -561,5 +746,24 @@ private synchronized void closeChannel() {\n                 ch = null;\n             }\n         }\n+\n+        /** Close holder. */\n+        void close() {\n+            close = true;\n+            if (serverNodeId != null)\n+                nodeChannels.remove(serverNodeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 707}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4ODY4MA==", "bodyText": "Let's make channel package private and use it in tests directly (or make nodeChannels private and create the same getter for it)", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489388680", "createdAt": "2020-09-16T12:13:56Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -561,5 +746,24 @@ private synchronized void closeChannel() {\n                 ch = null;\n             }\n         }\n+\n+        /** Close holder. */\n+        void close() {\n+            close = true;\n+            if (serverNodeId != null)\n+                nodeChannels.remove(serverNodeId);\n+\n+            closeChannel();\n+        }\n+\n+        /** Wheteher the holder is closed. For test purposes. */\n+        boolean isClosed() {\n+            return close;\n+        }\n+    }\n+\n+    /** Get holders reference. For test purposes. */\n+    List<ClientChannelHolder> getChannelHolders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 719}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MTY0OQ==", "bodyText": "Didn't get this check. We already checked that references are the same. Isn't it?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489391649", "createdAt": "2020-09-16T12:19:02Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {\n+            assertSame(originalChannels.get(i), newChannels.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NDM3NQ==", "bodyText": "Let's use standard ports for thin client (10800). Yes, I know it's just a dummy address, but someone can understand it wrong during a brief test lookup.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489394375", "createdAt": "2020-09-16T12:23:44Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5OTIzOQ==", "bodyText": "It's counterintuitive without looking at TestAddressFinder implementation that we use the same set of addresses. Let's make TestAddressFinder more generic, use some Queue inside, and use it something like this:\nnew TestAddressFinder().add(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\").add(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\")", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489399239", "createdAt": "2020-09-16T12:31:43Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwMjY0MQ==", "bodyText": "assertEquals(2, F.size(originChannels, r -> r.isClosed()));", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489402641", "createdAt": "2020-09-16T12:37:29Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {\n+            assertSame(originalChannels.get(i), newChannels.get(i));\n+            assertFalse(originalChannels.get(i).isClosed());\n+        });\n+        assertEquals(3, newChannels.size());\n+    }\n+\n+    /** Checks that node channels are persisted if channels are reinit with static address configuration. */\n+    @Test\n+    public void testNodeChannelsAreNotCleaned() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        // Trigger TestClientChannel creation.\n+        rc.service(null, null, null);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+    }\n+\n+    /** Checks that channels are changed (add new, remove old) and close channels if reinitialization performed. */\n+    @Test\n+    public void testDynamicAddressReinitializedCorrectly() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8003\"));\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+\n+        List<ReliableChannel.ClientChannelHolder> originChannels = Collections.unmodifiableList(rc.getChannelHolders());\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        List<ReliableChannel.ClientChannelHolder> closedChannels = originChannels.stream()\n+            .filter(r -> r.isClosed())\n+            .collect(Collectors.toList());\n+\n+        assertEquals(2, closedChannels.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwMzA5NA==", "bodyText": "IMO it's more readable to use for loop here", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489403094", "createdAt": "2020-09-16T12:38:16Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwNjI2NA==", "bodyText": "newChannels.contains?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489406264", "createdAt": "2020-09-16T12:43:29Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {\n+            assertSame(originalChannels.get(i), newChannels.get(i));\n+            assertFalse(originalChannels.get(i).isClosed());\n+        });\n+        assertEquals(3, newChannels.size());\n+    }\n+\n+    /** Checks that node channels are persisted if channels are reinit with static address configuration. */\n+    @Test\n+    public void testNodeChannelsAreNotCleaned() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        // Trigger TestClientChannel creation.\n+        rc.service(null, null, null);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+    }\n+\n+    /** Checks that channels are changed (add new, remove old) and close channels if reinitialization performed. */\n+    @Test\n+    public void testDynamicAddressReinitializedCorrectly() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8003\"));\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+\n+        List<ReliableChannel.ClientChannelHolder> originChannels = Collections.unmodifiableList(rc.getChannelHolders());\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        List<ReliableChannel.ClientChannelHolder> closedChannels = originChannels.stream()\n+            .filter(r -> r.isClosed())\n+            .collect(Collectors.toList());\n+\n+        assertEquals(2, closedChannels.size());\n+\n+        List<ReliableChannel.ClientChannelHolder> reuseChannel = originChannels.stream()\n+            .filter(c -> !c.isClosed())\n+            .collect(Collectors.toList());\n+\n+        assertEquals(1, reuseChannel.size());\n+\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+        assertEquals(2, newChannels.size());\n+        assertTrue(newChannels.get(0) == reuseChannel.get(0) || newChannels.get(1) == reuseChannel.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwODg1Mw==", "bodyText": "point at the end", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489408853", "createdAt": "2020-09-16T12:47:32Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwODg5NA==", "bodyText": "point at the end", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489408894", "createdAt": "2020-09-16T12:47:36Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNjg1Mg==", "bodyText": "Why do we need a second request? Topology change already should be detected after initDefaultChannel call", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489416852", "createdAt": "2020-09-16T12:59:43Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesLeave() throws Exception {\n+        startGrids(MAX_CLUSTER_SIZE);\n+        awaitPartitionMapExchange();\n+\n+        initClient(getClientConfigurationWithDiscovery(), 0, 1, 2, 3);\n+        detectTopologyChange();\n+\n+        for (int i = MAX_CLUSTER_SIZE - 1; i != 0; i--) {\n+            int[] workChannels = IntStream.range(0, i).toArray();\n+\n+            channels[i] = null;\n+            stopGrid(i);\n+            awaitPartitionMapExchange();\n+            detectTopologyChange();\n+\n+            awaitChannelsInit(workChannels);\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Checks that each request goes to right node.\n+     */\n+    private void testPartitionAwareness(int... chIdxs) {\n+        ClientCache<Object, Object> clientCache = client.cache(PART_CACHE_NAME);\n+        IgniteInternalCache<Object, Object> igniteCache = grid(0).context().cache().cache(PART_CACHE_NAME);\n+\n+        Map<TestTcpClientChannel, Boolean> channelHits = Arrays.stream(chIdxs).boxed()\n+            .collect(Collectors.toMap(idx -> channels[idx], idx -> false));\n+\n+        for (int i = 0; i < KEY_CNT; i++) {\n+            TestTcpClientChannel opCh = affinityChannel(i, igniteCache);\n+\n+            clientCache.put(i, i);\n+\n+            if (i == 0)\n+                assertOpOnChannel(dfltCh, ClientOperation.CACHE_PARTITIONS);\n+\n+            assertOpOnChannel(opCh, ClientOperation.CACHE_PUT);\n+            assertTrue(channelHits.containsKey(opCh));\n+\n+            channelHits.compute(opCh, (c, old) -> true);\n+        }\n+\n+        assertFalse(channelHits.containsValue(false));\n+    }\n+\n+    /**\n+     * Provide ClientConfiguration with addrResolver that find all alive nodes\n+     */\n+    private ClientConfiguration getClientConfigurationWithDiscovery() {\n+        ClientAddressFinder addrFinder = () ->\n+            IgnitionEx.allGrids().stream().map(node -> {\n+                int port = (Integer) node.cluster().localNode().attributes().get(CLIENT_LISTENER_PORT);\n+                return \"127.0.0.1:\" + port;\n+            }).toArray(String[]::new);\n+\n+        return new ClientConfiguration()\n+            .setAddressesFinder(addrFinder)\n+            .setPartitionAwarenessEnabled(true);\n+    }\n+\n+    /**\n+     * Trigger client to detect topology change\n+     */\n+    private void detectTopologyChange() {\n+        // Send non-affinity request to detect topology change.\n+        initDefaultChannel();\n+        client.getOrCreateCache(PART_CACHE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyMTA3OQ==", "bodyText": "All channels already inited after initClient, what else do we wait here?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489421079", "createdAt": "2020-09-16T13:06:11Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesLeave() throws Exception {\n+        startGrids(MAX_CLUSTER_SIZE);\n+        awaitPartitionMapExchange();\n+\n+        initClient(getClientConfigurationWithDiscovery(), 0, 1, 2, 3);\n+        detectTopologyChange();\n+\n+        for (int i = MAX_CLUSTER_SIZE - 1; i != 0; i--) {\n+            int[] workChannels = IntStream.range(0, i).toArray();\n+\n+            channels[i] = null;\n+            stopGrid(i);\n+            awaitPartitionMapExchange();\n+            detectTopologyChange();\n+\n+            awaitChannelsInit(workChannels);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzNTI3MA==", "bodyText": "We don't check discovery by this test at all. If we replace getClientConfigurationWithDiscovery() with getClientConfiguration(0, 1, 2, 3) result will be the same, test will pass. To check discovery I think we should exclude additional nodes by discovery (but not stop it) on topology change and check that this node is excluded from requests too.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489435270", "createdAt": "2020-09-16T13:26:26Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesLeave() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "committedDate": "2020-09-24T11:49:10Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "committedDate": "2020-09-16T08:53:01Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}, "afterCommit": {"oid": "cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "committedDate": "2020-09-24T11:49:10Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99a519dd2334866f6e6a8ff66b6374b1fd1a98bf", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/99a519dd2334866f6e6a8ff66b6374b1fd1a98bf", "committedDate": "2020-09-24T12:16:48Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0387c935faa3773db2b8ea5ee170365fdad7034", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/f0387c935faa3773db2b8ea5ee170365fdad7034", "committedDate": "2020-09-25T12:54:37Z", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "141524c679983360b3cfd7d95aaa63b30e54dba7", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/141524c679983360b3cfd7d95aaa63b30e54dba7", "committedDate": "2020-09-30T10:04:19Z", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client"}, "afterCommit": {"oid": "beebf80c37118bf90630375abb566aa540d53033", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/beebf80c37118bf90630375abb566aa540d53033", "committedDate": "2020-09-30T10:08:06Z", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55f56c10c3210168db7f6d1cf4e6ec567954f74e", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/55f56c10c3210168db7f6d1cf4e6ec567954f74e", "committedDate": "2020-09-30T12:59:03Z", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "beebf80c37118bf90630375abb566aa540d53033", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/beebf80c37118bf90630375abb566aa540d53033", "committedDate": "2020-09-30T10:08:06Z", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client"}, "afterCommit": {"oid": "55f56c10c3210168db7f6d1cf4e6ec567954f74e", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/55f56c10c3210168db7f6d1cf4e6ec567954f74e", "committedDate": "2020-09-30T12:59:03Z", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/7a32fe73a33412dfe3f9bbd06aff3486a2961293", "committedDate": "2020-09-30T14:05:57Z", "message": "Fix codestyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyODAzMDk0", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-502803094", "createdAt": "2020-10-06T10:36:28Z", "commit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMDozNjoyOVrOHdAKOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMToxMDo1MFrOHdBQ8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3MzM2OQ==", "bodyText": "Here and below please use multiline javadoc for methods as we do everywhere else.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500173369", "createdAt": "2020-10-06T10:36:29Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** */\n+    private final String[] dfltAddrs = new String[]{\"127.0.0.1:10800\", \"127.0.0.1:10801\", \"127.0.0.1:10802\"};\n+\n+    /** Checks that it is possible configure addresses with duplication (for load balancing). */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3NDczMw==", "bodyText": "Seems to be unnecessary.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500174733", "createdAt": "2020-10-06T10:39:15Z", "author": {"login": "ptupitsyn"}, "path": "modules/indexing/pom.xml", "diffHunk": "@@ -133,6 +133,14 @@\n             <version>${guava.version}</version>\n             <scope>test</scope>\n         </dependency>\n+\n+        <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3ODUwNA==", "bodyText": "Please provide details:\n\nWhen and how often Ignite will call the implementation\nWhat are the requirements:\n\nDuplicates allowed or not\nAllowed formats (with port, without port, ipv4/ipv6?)", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500178504", "createdAt": "2020-10-06T10:46:41Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MTQ3NQ==", "bodyText": "Let's rename to getAddresses for consistency with ClientConfiguration.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500191475", "createdAt": "2020-10-06T11:10:50Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to\n+ * route user requests. There are cases when the list is not static, for example in cloud environment. In such cases\n+ * addresses of nodes and/or number of server nodes can change. Implementation of this interface should handle these.\n+ *\n+ * {@link org.apache.ignite.configuration.ClientConfiguration#setAddressesFinder(ClientAddressFinder)}\n+ */\n+public interface ClientAddressFinder {\n+    /** @return Addresses of Ignite server nodes within a cluster. */\n+    public String[] getServerAddresses();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73adfc562bc2aa050b11228a7c1c10365edc1732", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/73adfc562bc2aa050b11228a7c1c10365edc1732", "committedDate": "2020-10-07T15:54:38Z", "message": "Provide more javadocs."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MTM2MjY5", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-504136269", "createdAt": "2020-10-07T18:03:15Z", "commit": {"oid": "73adfc562bc2aa050b11228a7c1c10365edc1732"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODowMzoxOVrOHd_UWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODowMzoxOVrOHd_UWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwODE1Mg==", "bodyText": "waites -> waits", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501208152", "createdAt": "2020-10-07T18:03:19Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to\n+ * route user requests. There are cases when the list is not static, for example in cloud environment. In such cases\n+ * addresses of nodes and/or number of server nodes can change. Implementation of this interface should handle these.\n+ *\n+ * Ignite waites for a topology change to trigger {@link #getAddresses()}. There are two modes of how soon Ignite calls", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73adfc562bc2aa050b11228a7c1c10365edc1732"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MTQ5NTQ3", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-504149547", "createdAt": "2020-10-07T18:18:01Z", "commit": {"oid": "73adfc562bc2aa050b11228a7c1c10365edc1732"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODoxODowMVrOHd_3Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODoyNToxOFrOHeAORQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNzExOA==", "bodyText": "I thought we support IPv6? Is there any reason not to?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501217118", "createdAt": "2020-10-07T18:18:01Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to\n+ * route user requests. There are cases when the list is not static, for example in cloud environment. In such cases\n+ * addresses of nodes and/or number of server nodes can change. Implementation of this interface should handle these.\n+ *\n+ * Ignite waites for a topology change to trigger {@link #getAddresses()}. There are two modes of how soon Ignite calls\n+ * it, lazy and eager, depending on whether the partition awareness feature is enabled. If the feature is enabled then\n+ * Ignite calls the method for every topology change. Otherwise Ignite uses previous addresses until a first failure.\n+ *\n+ * {@link org.apache.ignite.configuration.ClientConfiguration#setPartitionAwarenessEnabled(boolean)}\n+ * {@link org.apache.ignite.configuration.ClientConfiguration#setAddressesFinder(ClientAddressFinder)}\n+ */\n+public interface ClientAddressFinder {\n+    /**\n+     * Get addresses of Ignite server nodes within a cluster. An address can be IPv4 address or hostname, with or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73adfc562bc2aa050b11228a7c1c10365edc1732"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMjk4MQ==", "bodyText": "Are you sure? It compiles and runs on my machine without this change.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501222981", "createdAt": "2020-10-07T18:25:18Z", "author": {"login": "ptupitsyn"}, "path": "modules/indexing/pom.xml", "diffHunk": "@@ -133,6 +133,14 @@\n             <version>${guava.version}</version>\n             <scope>test</scope>\n         </dependency>\n+\n+        <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3NDczMw=="}, "originalCommit": {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/4b060384d7d73247f005cab769c3579ad0a14dc2", "committedDate": "2020-10-07T19:13:45Z", "message": "Fix misprint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MDU2OTMw", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-508056930", "createdAt": "2020-10-14T07:16:10Z", "commit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNzoxNjoxMFrOHhFW3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNDozNjoxOFrOHhWS4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MjgyOQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504452829", "createdAt": "2020-10-14T07:16:10Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -118,21 +123,47 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /** Executor for async operations continuations. */\n     private Executor asyncContinuationExecutor;\n \n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        if (addrs != null)\n+            return Arrays.copyOf(addrs, addrs.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzIwOQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453209", "createdAt": "2020-10-14T07:16:58Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzI2Nw==", "bodyText": "Redundant NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453267", "createdAt": "2020-10-14T07:17:06Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzU4Mg==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453582", "createdAt": "2020-10-14T07:17:42Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzY3OQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453679", "createdAt": "2020-10-14T07:17:51Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1Mzk1Nw==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453957", "createdAt": "2020-10-14T07:18:21Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);\n+                        return null;\n+                    }\n \n-                    ClientConnectionException failure0 = failure;\n-                    AtomicInteger chIdx0 = chIdx;\n-                    ClientChannel ch0 = ch;\n+                    if (failure0 == null)\n+                        failure0 = (ClientConnectionException)err;\n+                    else\n+                        failure0.addSuppressed(err);\n \n-                    ch.serviceAsync(op, payloadWriter, payloadReader).handle((res2, err2) ->\n-                            handleServiceAsync(op, payloadWriter, payloadReader, fut, failure0, chIdx0, ch0, res2, err2));\n+                    int leftAttempts = attemptsLimit - chAndAttempts.getValue();\n \n+                    // If it is a first retry then reset attempts (as for initialization we use only 1 attempt).\n+                    if (failure == null)\n+                        leftAttempts = getRetryLimit() - 1;\n+\n+                    if (leftAttempts > 0) {\n+                        handleServiceAsync(fut, op, payloadWriter, payloadReader, leftAttempts, failure0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1NDAyMQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504454021", "createdAt": "2020-10-14T07:18:30Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);\n+                        return null;\n+                    }\n \n-                    ClientConnectionException failure0 = failure;\n-                    AtomicInteger chIdx0 = chIdx;\n-                    ClientChannel ch0 = ch;\n+                    if (failure0 == null)\n+                        failure0 = (ClientConnectionException)err;\n+                    else\n+                        failure0.addSuppressed(err);\n \n-                    ch.serviceAsync(op, payloadWriter, payloadReader).handle((res2, err2) ->\n-                            handleServiceAsync(op, payloadWriter, payloadReader, fut, failure0, chIdx0, ch0, res2, err2));\n+                    int leftAttempts = attemptsLimit - chAndAttempts.getValue();\n \n+                    // If it is a first retry then reset attempts (as for initialization we use only 1 attempt).\n+                    if (failure == null)\n+                        leftAttempts = getRetryLimit() - 1;\n+\n+                    if (leftAttempts > 0) {\n+                        handleServiceAsync(fut, op, payloadWriter, payloadReader, leftAttempts, failure0);\n+                        return null;\n+                    }\n+                }\n+                else {\n+                    fut.completeExceptionally(err instanceof ClientException ? err : new ClientException(err));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1NDA5NA==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504454094", "createdAt": "2020-10-14T07:18:39Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);\n+                        return null;\n+                    }\n \n-                    ClientConnectionException failure0 = failure;\n-                    AtomicInteger chIdx0 = chIdx;\n-                    ClientChannel ch0 = ch;\n+                    if (failure0 == null)\n+                        failure0 = (ClientConnectionException)err;\n+                    else\n+                        failure0.addSuppressed(err);\n \n-                    ch.serviceAsync(op, payloadWriter, payloadReader).handle((res2, err2) ->\n-                            handleServiceAsync(op, payloadWriter, payloadReader, fut, failure0, chIdx0, ch0, res2, err2));\n+                    int leftAttempts = attemptsLimit - chAndAttempts.getValue();\n \n+                    // If it is a first retry then reset attempts (as for initialization we use only 1 attempt).\n+                    if (failure == null)\n+                        leftAttempts = getRetryLimit() - 1;\n+\n+                    if (leftAttempts > 0) {\n+                        handleServiceAsync(fut, op, payloadWriter, payloadReader, leftAttempts, failure0);\n+                        return null;\n+                    }\n+                }\n+                else {\n+                    fut.completeExceptionally(err instanceof ClientException ? err : new ClientException(err));\n                     return null;\n-                } catch (ClientConnectionException e) {\n-                    onChannelFailure(ch);\n-                    failure.addSuppressed(e);\n                 }\n-            }\n-        }\n \n-        if (failure != null)\n-            fut.completeExceptionally(failure);\n-        else\n-            fut.completeExceptionally(err instanceof ClientException ? err : new ClientException(err));\n-\n-        return null;\n+                fut.completeExceptionally(failure0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDE4NQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490185", "createdAt": "2020-10-14T08:20:21Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 711}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDI2Ng==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490266", "createdAt": "2020-10-14T08:20:29Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 720}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDQ4NA==", "bodyText": "Redundant NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490484", "createdAt": "2020-10-14T08:20:52Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Do not establish connections if interrupted.\n+        if (!initChannelHolders(force))\n+            return;\n+\n+        // Apply no-op function. Establish default channel connection.\n+        applyOnDefaultChannel(channel -> null);\n+\n+        if (partitionAwarenessEnabled)\n+            initAllChannelsAsync();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 757}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDkxMw==", "bodyText": "point at the end", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490913", "createdAt": "2020-10-14T08:21:35Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Do not establish connections if interrupted.\n+        if (!initChannelHolders(force))\n+            return;\n+\n+        // Apply no-op function. Establish default channel connection.\n+        applyOnDefaultChannel(channel -> null);\n+\n+        if (partitionAwarenessEnabled)\n+            initAllChannelsAsync();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+\n+        } catch (ClientConnectionException e) {\n+            onChannelFailure(hld, channel);\n+        }\n+\n+        return null;\n+    }\n+\n+    /** */\n+    private <T> T applyOnDefaultChannel(Function<ClientChannel, T> function) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (holders == null)\n+            throw new ClientException(\"Connections to nodes aren't initialized.\");\n+\n+        int size = holders.size();\n+\n+        int attemptsLimit = clientCfg.getRetryLimit() > 0 ?\n+            Math.min(clientCfg.getRetryLimit(), size) : size;\n+\n+        return applyOnDefaultChannel(function, attemptsLimit).getKey();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on any of available channel.\n+     */\n+    private <T> T2<T, Integer> applyOnDefaultChannel(Function<ClientChannel, T> function, int attemptsLimit) {\n+        ClientConnectionException failure = null;\n+\n+        for (int attempt = 0; attempt < attemptsLimit; attempt++) {\n+            ClientChannelHolder hld = null;\n+            ClientChannel c = null;\n+\n+            try {\n+                if (closed)\n+                    throw new ClientException(\"Channel is closed\");\n+\n+                curChannelsGuard.readLock().lock();\n+\n+                try {\n+                    hld = channels.get(curChIdx);\n+                } finally {\n+                    curChannelsGuard.readLock().unlock();\n+                }\n+\n+                c = hld.getOrCreateChannel();\n+\n+                if (c != null)\n+                    return new T2<>(function.apply(c), attempt + 1);\n+            }\n+            catch (ClientConnectionException e) {\n+                if (failure == null)\n+                    failure = e;\n+                else\n+                    failure.addSuppressed(e);\n+\n+                onChannelFailure(hld, c);\n+            }\n+        }\n+\n+        throw failure;\n+    }\n+\n+    /**\n+     * Try apply specified {@code function} on a channel corresponding to {@code tryNodeId}.\n+     * If failed then apply the function on any available channel.\n+     */\n+    private <T> T applyOnNodeChannelWithFallback(UUID tryNodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = nodeChannels.get(tryNodeId);\n+\n+        int retryLimit = getRetryLimit();\n+\n+        if (hld != null) {\n+            ClientChannel channel = null;\n+\n+            try {\n+                channel = hld.getOrCreateChannel();\n+\n+                if (channel != null)\n+                    return function.apply(channel);\n+\n+            } catch (ClientConnectionException e) {\n+                onChannelFailure(hld, channel);\n+\n+                retryLimit -= 1;\n+\n+                if (retryLimit == 0)\n+                    throw e;\n+            }\n+        }\n+\n+        return applyOnDefaultChannel(function, retryLimit).getKey();\n+    }\n+\n+    /** Get retry limit. */\n+    private int getRetryLimit() {\n+        int size = channels.size();\n+\n+        return clientCfg.getRetryLimit() > 0 ? Math.min(clientCfg.getRetryLimit(), size) : size;\n+    }\n+\n     /**\n      * Channels holder.\n      */\n-    private class ClientChannelHolder {\n+    class ClientChannelHolder {\n         /** Channel configuration. */\n         private final ClientChannelConfiguration chCfg;\n \n         /** Channel. */\n         private volatile ClientChannel ch;\n \n+        /** ID of the last server node that {@link ch} is or was connected to. */\n+        private volatile UUID serverNodeId;\n+\n+        /** Address that holder is bind to (chCfg.addr) is not in use now. So close the holder */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 872}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MTcwNA==", "bodyText": "Still not fixed", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504491704", "createdAt": "2020-10-14T08:22:51Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -561,5 +746,24 @@ private synchronized void closeChannel() {\n                 ch = null;\n             }\n         }\n+\n+        /** Close holder. */\n+        void close() {\n+            close = true;\n+            if (serverNodeId != null)\n+                nodeChannels.remove(serverNodeId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MzU0Mg=="}, "originalCommit": {"oid": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c"}, "originalPosition": 707}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUzNzg2MQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504537861", "createdAt": "2020-10-14T09:33:41Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -512,80 +504,81 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toMap(a -> a, a -> 1, Integer::sum));\n     }\n \n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n+    /**\n+     * Roll current default channel if specified holder equals to it.\n+     */\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 481}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MDUxOA==", "bodyText": "What if failure already not null here? We will lose this information?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504670518", "createdAt": "2020-10-14T13:20:08Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzIwOQ=="}, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MTk3Nw==", "bodyText": "I think it's better to control attempts count in one method. I propose to rewrite this method without using applyOnDefaultChannel and rewrite applyOnDefaultChannel to return only result but not T2 with attempts counter (help GC a little bit).\nWDYT?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504671977", "createdAt": "2020-10-14T13:22:09Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3NDE4OA==", "bodyText": "Can be replaced with getRetryLimit()", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504674188", "createdAt": "2020-10-14T13:25:15Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Do not establish connections if interrupted.\n+        if (!initChannelHolders(force))\n+            return;\n+\n+        // Apply no-op function. Establish default channel connection.\n+        applyOnDefaultChannel(channel -> null);\n+\n+        if (partitionAwarenessEnabled)\n+            initAllChannelsAsync();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+\n+        } catch (ClientConnectionException e) {\n+            onChannelFailure(hld, channel);\n+        }\n+\n+        return null;\n+    }\n+\n+    /** */\n+    private <T> T applyOnDefaultChannel(Function<ClientChannel, T> function) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (holders == null)\n+            throw new ClientException(\"Connections to nodes aren't initialized.\");\n+\n+        int size = holders.size();\n+\n+        int attemptsLimit = clientCfg.getRetryLimit() > 0 ?\n+            Math.min(clientCfg.getRetryLimit(), size) : size;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 775}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyMzUyNQ==", "bodyText": "Why do we skip rollCurrentChannel if scheduledChannelsReinit? I think we should roll channel in any case.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504723525", "createdAt": "2020-10-14T14:28:10Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -512,80 +504,81 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toMap(a -> a, a -> 1, Integer::sum));\n     }\n \n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n+    /**\n+     * Roll current default channel if specified holder equals to it.\n+     */\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n         try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n+            int idx = curChIdx;\n+            List<ClientChannelHolder> holders = channels;\n \n-            throw e;\n-        }\n-    }\n+            ClientChannelHolder dfltHld = holders.get(idx);\n \n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            if (dfltHld == hld) {\n+                idx += 1;\n+\n+                if (idx >= holders.size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On current channel failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n+    private void onChannelFailure(ClientChannel ch) {\n         // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n         // when current index was changed and no other wrong channel will be closed by current thread because\n         // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+        onChannelFailure(channels.get(curChIdx), ch);\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (ch != null && ch == hld.ch)\n             hld.closeChannel();\n \n-            if (hld == channels[curChIdx])\n-                rollCurrentChannel();\n-        }\n+        chFailLsnrs.forEach(Runnable::run);\n+\n+        if (scheduledChannelsReinit.get())\n+            channelsInit(true);\n+        else\n+            rollCurrentChannel(hld);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyNjU2Nw==", "bodyText": "Currently, flag force is useless (at least for production code, but perhaps for test code too). There are 3 calls of this method from production code, first - right after constructor (when channels == null), two other calls with force == true.", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504726567", "createdAt": "2020-10-14T14:31:50Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 729}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyODEyNg==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504728126", "createdAt": "2020-10-14T14:33:48Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 648}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczMDMzNw==", "bodyText": "Perhaps && !partitionAwarenessEnabled should be added here (to avoid double reinit for partition awareness, first time here and second time in async thread). WDYT?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504730337", "createdAt": "2020-10-14T14:36:18Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -512,80 +504,81 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toMap(a -> a, a -> 1, Integer::sum));\n     }\n \n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n+    /**\n+     * Roll current default channel if specified holder equals to it.\n+     */\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n         try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n+            int idx = curChIdx;\n+            List<ClientChannelHolder> holders = channels;\n \n-            throw e;\n-        }\n-    }\n+            ClientChannelHolder dfltHld = holders.get(idx);\n \n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            if (dfltHld == hld) {\n+                idx += 1;\n+\n+                if (idx >= holders.size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On current channel failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n+    private void onChannelFailure(ClientChannel ch) {\n         // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n         // when current index was changed and no other wrong channel will be closed by current thread because\n         // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+        onChannelFailure(channels.get(curChIdx), ch);\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (ch != null && ch == hld.ch)\n             hld.closeChannel();\n \n-            if (hld == channels[curChIdx])\n-                rollCurrentChannel();\n-        }\n+        chFailLsnrs.forEach(Runnable::run);\n+\n+        if (scheduledChannelsReinit.get())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2"}, "originalPosition": 540}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c03c88ca9e19467263ba20648335fe84e8b804b8", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/c03c88ca9e19467263ba20648335fe84e8b804b8", "committedDate": "2020-10-14T20:54:02Z", "message": "Add more new lines. Refactor getting attemps value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8203de15c22b5d14fd696292970953d130ae5e47", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/8203de15c22b5d14fd696292970953d130ae5e47", "committedDate": "2020-10-14T21:33:36Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "committedDate": "2020-10-15T15:28:59Z", "message": "Add kubernetes tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMjIzODEx", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-510223811", "createdAt": "2020-10-16T07:38:57Z", "commit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNzozODo1N1rOHirqqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODoyNjozMFrOHit6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyOTA2Nw==", "bodyText": "Clean it up, please", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506129067", "createdAt": "2020-10-16T07:38:57Z", "author": {"login": "alex-plekhanov"}, "path": "modules/kubernetes/src/test/java/org/apache/ignite/internal/kubernetes/connection/KubernetesServiceAddressResolverTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.kubernetes.connection;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Checks that correctly parse kubernetes json response. */\n+public class KubernetesServiceAddressResolverTest {\n+    /** Mock of kubernetes API. */\n+    private static ClientAndServer mockServer;\n+\n+    /** */\n+    private static final String namespace = \"ns01\";\n+\n+    /** */\n+    private static final String service = \"ignite\";\n+\n+    /** */\n+    @BeforeClass\n+    public static void startServer() {\n+        mockServer = startClientAndServer();\n+    }\n+\n+    /** */\n+    @AfterClass\n+    public static void stopServer() {\n+        mockServer.stop();\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponse() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(false);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponseWithIncludingNotReadyAddresses() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.3\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.6\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test(expected = IgniteException.class)\n+    public void testConnectionFailure() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockFailureServerResponse();\n+\n+        rslvr.getServiceAddresses();\n+    }\n+\n+    /** */\n+    private KubernetesServiceAddressResolver prepareResolver(boolean includeNotReadyAddresses)\n+        throws IOException\n+    {\n+        File account = File.createTempFile(\"kubernetes-test-account\", \"\");\n+        new FileWriter(account).write(\"account-token\");\n+        String accountFile = account.getAbsolutePath();\n+\n+        KubernetesConnectionConfiguration cfg = new KubernetesConnectionConfiguration();\n+        cfg.setNamespace(namespace);\n+        cfg.setServiceName(service);\n+        cfg.setMasterUrl(\"https://localhost:\" + mockServer.getLocalPort());\n+        cfg.setAccountToken(accountFile);\n+        cfg.setIncludeNotReadyAddresses(includeNotReadyAddresses);\n+\n+        return new KubernetesServiceAddressResolver(cfg);\n+    }\n+\n+    /** */\n+    private void mockFailureServerResponse() {\n+        mockServer\n+            .when(\n+                request()\n+                    .withMethod(\"GET\")\n+                    .withPath(String.format(\"/api/v1/namespaces/%s/endpoints/%s\", namespace, service)),\n+                Times.exactly(1)\n+            )\n+            .respond(\n+                response()\n+                    .withStatusCode(401));\n+    }\n+\n+    /** */\n+    private void mockSuccessServerResponse() {\n+        mockServer\n+            .when(\n+                request()\n+                    .withMethod(\"GET\")\n+                    .withPath(String.format(\"/api/v1/namespaces/%s/endpoints/%s\", namespace, service)),\n+                Times.exactly(1)\n+            )\n+            .respond(\n+                response()\n+                    .withStatusCode(200)\n+                    .withBody(\"{\" +\n+                              \"  \\\"subsets\\\": [\" +\n+                              \"     {\" +\n+                              \"        \\\"addresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.1\\\"\" +\n+                              \"           },\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.2\\\"\" +\n+                              \"           }\" +\n+                              \"        ],\" +\n+                              \"        \\\"notReadyAddresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.3\\\"\" +\n+                              \"           }\" +\n+                              \"        ]\" +\n+                              \"     },\" +\n+                              \"     {\" +\n+                              \"        \\\"addresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.4\\\"\" +\n+                              \"           },\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.5\\\"\" +\n+                              \"           }\" +\n+                              \"        ],\" +\n+                              \"        \\\"notReadyAddresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.6\\\"\" +\n+                              \"           }\" +\n+                              \"        ]\" +\n+                              \"     },\" +\n+                              \"     {\" +\n+                              \"        \\\"addresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.7\\\"\" +\n+                              \"           }\" +\n+                              \"        ]\" +\n+                              \"     }\" +\n+                              \"  ]\" +\n+                              \"}\"\n+                    ));\n+    }\n+\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyOTU5MQ==", "bodyText": "<scope>test</scope>", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506129591", "createdAt": "2020-10-16T07:39:51Z", "author": {"login": "alex-plekhanov"}, "path": "modules/kubernetes/pom.xml", "diffHunk": "@@ -101,6 +101,25 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>\n+            <groupId>org.mock-server</groupId>\n+            <artifactId>mockserver-netty</artifactId>\n+            <version>5.11.1</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzMTgyNw==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506131827", "createdAt": "2020-10-16T07:42:38Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -218,18 +220,24 @@\n                                         Function<PayloadInputChannel, T> payloadReader,\n                                         int attemptsLimit,\n                                         ClientConnectionException failure) {\n-        T2<ClientChannel, Integer> chAndAttempts;\n+        ClientChannel ch;\n+        // Workaround to store used attempts value within lambda body.\n+        int attemptsCnt[] = new int[1];\n \n         try {\n-            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n-\n+            ch = applyOnDefaultChannel(channel -> channel, attemptsLimit, v -> attemptsCnt[0] = v );\n         } catch (Throwable ex) {\n+            if (failure != null) {\n+                failure.addSuppressed(ex);\n+                fut.completeExceptionally(failure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzMjk0NQ==", "bodyText": "NL", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506132945", "createdAt": "2020-10-16T07:43:57Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -798,8 +801,10 @@ void channelsInit(boolean force) {\n \n                 c = hld.getOrCreateChannel();\n \n-                if (c != null)\n-                    return new T2<>(function.apply(c), attempt + 1);\n+                if (c != null) {\n+                    attemptsCallback.accept(attempt + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2Mjg3MA==", "bodyText": "Close FileWriter?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506162870", "createdAt": "2020-10-16T08:23:16Z", "author": {"login": "alex-plekhanov"}, "path": "modules/kubernetes/src/test/java/org/apache/ignite/client/TestClusterClientConnection.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\n+import org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes.TcpDiscoveryKubernetesIpFinder;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Test that thin client connects to cluster with {@link ThinClientKubernetesAddressFinder}. */\n+public class TestClusterClientConnection extends GridCommonAbstractTest {\n+    /** Mock of kubernetes API. */\n+    private static ClientAndServer mockServer;\n+\n+    /** */\n+    private static final String namespace = \"ns01\";\n+\n+    /** */\n+    private static final String service = \"ignite\";\n+\n+    /** */\n+    @BeforeClass\n+    public static void startServer() {\n+        mockServer = startClientAndServer();\n+    }\n+\n+    /** */\n+    @AfterClass\n+    public static void stopServer() {\n+        mockServer.stop();\n+    }\n+\n+    /** */\n+    @After\n+    public void tearDown() {\n+        stopAllGrids();\n+    }\n+\n+    /** */\n+    @Test\n+    public void testClientConnectsToCluster() throws Exception {\n+        mockServerResponse();\n+\n+        IgniteEx crd = startGrid(getConfiguration());\n+        String crdAddr = crd.localNode().addresses().iterator().next();\n+\n+        mockServerResponse(crdAddr);\n+\n+        ClientConfiguration ccfg = new ClientConfiguration();\n+        ccfg.setAddressesFinder(new ThinClientKubernetesAddressFinder(prepareConfiguration()));\n+\n+        IgniteClient client = Ignition.startClient(ccfg);\n+\n+        ClientCache cache = client.createCache(\"cache\");\n+        cache.put(1, 2);\n+        assertEquals(2, cache.get(1));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration() throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration();\n+\n+        KubernetesConnectionConfiguration kccfg = prepareConfiguration();\n+        TcpDiscoveryKubernetesIpFinder ipFinder = new TcpDiscoveryKubernetesIpFinder(kccfg);\n+\n+        TcpDiscoverySpi discoverySpi = new TcpDiscoverySpi();\n+        discoverySpi.setIpFinder(ipFinder);\n+\n+        cfg.setDiscoverySpi(discoverySpi);\n+\n+        cfg.setIgniteInstanceName(getTestIgniteInstanceName());\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    private void mockServerResponse(String... addrs) {\n+        String ipAddrs = Arrays.stream(addrs)\n+            .map(addr -> String.format(\"{\\\"ip\\\":\\\"%s\\\"}\", addr))\n+            .collect(Collectors.joining(\",\"));\n+\n+        mockServer\n+            .when(\n+                request()\n+                    .withMethod(\"GET\")\n+                    .withPath(String.format(\"/api/v1/namespaces/%s/endpoints/%s\", namespace, service)),\n+                Times.exactly(1)\n+            )\n+            .respond(\n+                response()\n+                    .withStatusCode(200)\n+                    .withBody(\"{\" +\n+                        \"  \\\"subsets\\\": [\" +\n+                        \"     {\" +\n+                        \"        \\\"addresses\\\": [\" +\n+                        \"        \" + ipAddrs +\n+                        \"        ]\" +\n+                        \"     }\" +\n+                        \"  ]\" +\n+                        \"}\"\n+                    ));\n+    }\n+\n+    /** */\n+    private KubernetesConnectionConfiguration prepareConfiguration()\n+        throws IOException\n+    {\n+        File account = File.createTempFile(\"kubernetes-test-account\", \"\");\n+        new FileWriter(account).write(\"account-token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2MzQwMg==", "bodyText": "Close FileWriter?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506163402", "createdAt": "2020-10-16T08:23:44Z", "author": {"login": "alex-plekhanov"}, "path": "modules/kubernetes/src/test/java/org/apache/ignite/internal/kubernetes/connection/KubernetesServiceAddressResolverTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.kubernetes.connection;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Checks that correctly parse kubernetes json response. */\n+public class KubernetesServiceAddressResolverTest {\n+    /** Mock of kubernetes API. */\n+    private static ClientAndServer mockServer;\n+\n+    /** */\n+    private static final String namespace = \"ns01\";\n+\n+    /** */\n+    private static final String service = \"ignite\";\n+\n+    /** */\n+    @BeforeClass\n+    public static void startServer() {\n+        mockServer = startClientAndServer();\n+    }\n+\n+    /** */\n+    @AfterClass\n+    public static void stopServer() {\n+        mockServer.stop();\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponse() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(false);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponseWithIncludingNotReadyAddresses() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.3\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.6\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test(expected = IgniteException.class)\n+    public void testConnectionFailure() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockFailureServerResponse();\n+\n+        rslvr.getServiceAddresses();\n+    }\n+\n+    /** */\n+    private KubernetesServiceAddressResolver prepareResolver(boolean includeNotReadyAddresses)\n+        throws IOException\n+    {\n+        File account = File.createTempFile(\"kubernetes-test-account\", \"\");\n+        new FileWriter(account).write(\"account-token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2NTg1Nw==", "bodyText": "Why it is not included to the suite?", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506165857", "createdAt": "2020-10-16T08:26:30Z", "author": {"login": "alex-plekhanov"}, "path": "modules/kubernetes/src/test/java/org/apache/ignite/internal/kubernetes/connection/KubernetesServiceAddressResolverTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.kubernetes.connection;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Checks that correctly parse kubernetes json response. */\n+public class KubernetesServiceAddressResolverTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86e58499b0aeb70ab5c7de92d362fa5478d97c87", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/86e58499b0aeb70ab5c7de92d362fa5478d97c87", "committedDate": "2020-10-16T08:54:30Z", "message": "Fix review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMjgxMTYw", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-510281160", "createdAt": "2020-10-16T08:58:18Z", "commit": {"oid": "86e58499b0aeb70ab5c7de92d362fa5478d97c87"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c429a61bf7fc8e12edee592357c125a85ea3c83", "author": {"user": {"login": "timoninmaxim", "name": "Maksim Timonin"}}, "url": "https://github.com/apache/ignite/commit/1c429a61bf7fc8e12edee592357c125a85ea3c83", "committedDate": "2020-10-16T09:02:14Z", "message": "Merge remote-tracking branch 'upstream/master' into IGNITE-13204_kubernetes_thin_client"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNDY1MDg0", "url": "https://github.com/apache/ignite/pull/8206#pullrequestreview-510465084", "createdAt": "2020-10-16T13:23:33Z", "commit": {"oid": "1c429a61bf7fc8e12edee592357c125a85ea3c83"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3127, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}