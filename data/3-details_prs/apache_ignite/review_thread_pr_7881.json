{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MDY5ODA4", "number": 7881, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowNTozMVrOEFztKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozMTowN1rOEMNq9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTI1NDgyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowNTozMVrOGkN57g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoyMzo0MlrOGnIE4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyOTc0Mg==", "bodyText": "bach -> batch", "url": "https://github.com/apache/ignite/pull/7881#discussion_r440629742", "createdAt": "2020-06-16T07:05:31Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -154,6 +191,7 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n         Object res = null;\n \n         for (;;) {\n+            // Set bach only if batch is null (first attempt).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTk2OQ==", "bodyText": "Fixed", "url": "https://github.com/apache/ignite/pull/7881#discussion_r443679969", "createdAt": "2020-06-22T16:23:42Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -154,6 +191,7 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n         Object res = null;\n \n         for (;;) {\n+            // Set bach only if batch is null (first attempt).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyOTc0Mg=="}, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTM4NDY4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0NDo1MVrOGkPLTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoyNjozMFrOGnILuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDU3NA==", "bodyText": "Use GridAtomicLong.setIfGreater() here", "url": "https://github.com/apache/ignite/pull/7881#discussion_r440650574", "createdAt": "2020-06-16T07:44:51Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -74,6 +106,11 @@ void cleanupBackupQueue(Long updateCntr) {\n             if (backupEntry.updateCounter() <= updateCntr)\n                 it.remove();\n         }\n+\n+        long val = ackedUpdCntr;\n+\n+        while (val < updateCntr && !ACKED_UPDATER.compareAndSet(this, val, updateCntr))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4MTcyMw==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r443681723", "createdAt": "2020-06-22T16:26:30Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -74,6 +106,11 @@ void cleanupBackupQueue(Long updateCntr) {\n             if (backupEntry.updateCounter() <= updateCntr)\n                 it.remove();\n         }\n+\n+        long val = ackedUpdCntr;\n+\n+        while (val < updateCntr && !ACKED_UPDATER.compareAndSet(this, val, updateCntr))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDU3NA=="}, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NTQyODYzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/AbstractCacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo1NjozNFrOGkPmqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoyNjozN1rOGnIMBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NzU3Nw==", "bodyText": "Let's use @Parameterized instead of class extending.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r440657577", "createdAt": "2020-06-16T07:56:34Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/AbstractCacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+public abstract class AbstractCacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4MTc5Ng==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r443681796", "createdAt": "2020-06-22T16:26:37Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/AbstractCacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+public abstract class AbstractCacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NzU3Nw=="}, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Mzg1OTAzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNzoxOToxMlrOGlin5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDowNTozMVrOGniYbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxNzc2Nw==", "bodyText": "You should also check this against curBatch, since curBatch can be changed concurrently and in this case you will fail with assert on rollOver", "url": "https://github.com/apache/ignite/pull/7881#discussion_r442017767", "createdAt": "2020-06-18T07:19:12Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -463,26 +533,47 @@ private CacheContinuousQueryEntry filteredEntry(long cntr, long filtered) {\n \n                     lastProc = pos;\n \n-                    if (pos == entries.length - 1) {\n-                        Arrays.fill(entries, null);\n+                    if (pos == entries.length - 1)\n+                        rollOver(startCntr + BUF_SIZE, filtered, entry.topologyVersion());\n+                }\n+                else if (endCntr < ackedUpdCntr0)\n+                    rollOver(ackedUpdCntr0 + 1, 0, entry.topologyVersion());\n \n-                        Batch nextBatch = new Batch(this.startCntr + BUF_SIZE,\n-                            filtered,\n-                            entries,\n-                            entry.topologyVersion());\n+                return res;\n+            }\n+        }\n \n-                        entries = null;\n+        /**\n+         * @param topVer Topology version of current processing entry.\n+         */\n+        private synchronized void tryRollOver(AffinityTopologyVersion topVer) {\n+            if (entries == null)\n+                return;\n \n-                        assert curBatch.get() == this;\n+            long ackedUpdCntr0 = ackedUpdCntr;\n \n-                        curBatch.set(nextBatch);\n-                    }\n-                }\n-                else\n-                    return res;\n-            }\n+            if (endCntr < ackedUpdCntr0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDExMDk1OQ==", "bodyText": "I think it's enough to check entries == null under this monitor synchronized block, this will guarantee us that batch will not be changed concurrently.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r444110959", "createdAt": "2020-06-23T10:05:31Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -463,26 +533,47 @@ private CacheContinuousQueryEntry filteredEntry(long cntr, long filtered) {\n \n                     lastProc = pos;\n \n-                    if (pos == entries.length - 1) {\n-                        Arrays.fill(entries, null);\n+                    if (pos == entries.length - 1)\n+                        rollOver(startCntr + BUF_SIZE, filtered, entry.topologyVersion());\n+                }\n+                else if (endCntr < ackedUpdCntr0)\n+                    rollOver(ackedUpdCntr0 + 1, 0, entry.topologyVersion());\n \n-                        Batch nextBatch = new Batch(this.startCntr + BUF_SIZE,\n-                            filtered,\n-                            entries,\n-                            entry.topologyVersion());\n+                return res;\n+            }\n+        }\n \n-                        entries = null;\n+        /**\n+         * @param topVer Topology version of current processing entry.\n+         */\n+        private synchronized void tryRollOver(AffinityTopologyVersion topVer) {\n+            if (entries == null)\n+                return;\n \n-                        assert curBatch.get() == this;\n+            long ackedUpdCntr0 = ackedUpdCntr;\n \n-                        curBatch.set(nextBatch);\n-                    }\n-                }\n-                else\n-                    return res;\n-            }\n+            if (endCntr < ackedUpdCntr0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxNzc2Nw=="}, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Mzg2NTQ3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNzoyMTowOFrOGlir0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjozMjoxMlrOGnIZWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxODc3MA==", "bodyText": "Can be simplified with only one while, without if", "url": "https://github.com/apache/ignite/pull/7881#discussion_r442018770", "createdAt": "2020-06-18T07:21:08Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +210,50 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr)\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingSize.get() > MAX_PENDING_BUFF_SIZE) {\n+                    LT.warn(log, \"Buffer for pending events reached max of its size \" +\n+                        \"[cacheId=\" + entry.cacheId() + \", maxSize=\" + MAX_PENDING_BUFF_SIZE +\n+                        \", partId=\" + entry.partition() + ']');\n+\n+                    // Remove first BUFF_SIZE keys.\n+                    int keysToRemove = BUF_SIZE;\n+\n+                    Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pending.entrySet().iterator();\n+\n+                    res = new ArrayList<>();\n+\n+                    while (iter.hasNext() && keysToRemove > 0) {\n+                        // Collecting results ignore backup flag due to batch may not be switched.\n+                        res = addResult(res, iter.next().getValue(), false);\n+\n+                        iter.remove();\n+                        pendingSize.decrementAndGet();\n+\n+                        keysToRemove--;\n+                    }\n+                }\n+\n+                pendingSize.incrementAndGet();\n                 pending.put(cntr, entry);\n+            }\n \n             break;\n         }\n \n         Batch batch0 = curBatch.get();\n \n+        // Batch has been changed on entry processing to the new one.\n         if (batch0 != batch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NTIxMQ==", "bodyText": "I'll change this under the IGNITE-13126.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r443685211", "createdAt": "2020-06-22T16:32:12Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +210,50 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr)\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingSize.get() > MAX_PENDING_BUFF_SIZE) {\n+                    LT.warn(log, \"Buffer for pending events reached max of its size \" +\n+                        \"[cacheId=\" + entry.cacheId() + \", maxSize=\" + MAX_PENDING_BUFF_SIZE +\n+                        \", partId=\" + entry.partition() + ']');\n+\n+                    // Remove first BUFF_SIZE keys.\n+                    int keysToRemove = BUF_SIZE;\n+\n+                    Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pending.entrySet().iterator();\n+\n+                    res = new ArrayList<>();\n+\n+                    while (iter.hasNext() && keysToRemove > 0) {\n+                        // Collecting results ignore backup flag due to batch may not be switched.\n+                        res = addResult(res, iter.next().getValue(), false);\n+\n+                        iter.remove();\n+                        pendingSize.decrementAndGet();\n+\n+                        keysToRemove--;\n+                    }\n+                }\n+\n+                pendingSize.incrementAndGet();\n                 pending.put(cntr, entry);\n+            }\n \n             break;\n         }\n \n         Batch batch0 = curBatch.get();\n \n+        // Batch has been changed on entry processing to the new one.\n         if (batch0 != batch) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxODc3MA=="}, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDg2MDY2OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNjo0NDozM1rOGotZOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTowOTo1OFrOGtS8_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzOTk2MA==", "bodyText": "Why do we use !backup here? In this case entries will go to backupQ on primary node or fail with assert.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445339960", "createdAt": "2020-06-25T06:44:33Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingSize.get() > MAX_PENDING_BUFF_SIZE) {\n+                    LT.warn(log, \"Buffer for pending events reached max of its size \" +\n+                        \"[cacheId=\" + entry.cacheId() + \", maxSize=\" + MAX_PENDING_BUFF_SIZE +\n+                        \", partId=\" + entry.partition() + ']');\n+\n+                    // Remove first BUFF_SIZE keys.\n+                    int keysToRemove = BUF_SIZE;\n+\n+                    Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pending.entrySet().iterator();\n+\n+                    while (iter.hasNext() && keysToRemove > 0) {\n+                        CacheContinuousQueryEntry entry0 = iter.next().getValue();\n+\n+                        // Discard messages on backup and send to client if primary.\n+                        if (!backup)\n+                            res = addResult(res, entry0, !backup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0OTYyOQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450149629", "createdAt": "2020-07-06T11:09:58Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingSize.get() > MAX_PENDING_BUFF_SIZE) {\n+                    LT.warn(log, \"Buffer for pending events reached max of its size \" +\n+                        \"[cacheId=\" + entry.cacheId() + \", maxSize=\" + MAX_PENDING_BUFF_SIZE +\n+                        \", partId=\" + entry.partition() + ']');\n+\n+                    // Remove first BUFF_SIZE keys.\n+                    int keysToRemove = BUF_SIZE;\n+\n+                    Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pending.entrySet().iterator();\n+\n+                    while (iter.hasNext() && keysToRemove > 0) {\n+                        CacheContinuousQueryEntry entry0 = iter.next().getValue();\n+\n+                        // Discard messages on backup and send to client if primary.\n+                        if (!backup)\n+                            res = addResult(res, entry0, !backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzOTk2MA=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NTA1OTE3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo0OTo1OFrOGovSwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMToxMDowM1rOGtS9Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3MTA3Mg==", "bodyText": "Redundant NL", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445371072", "createdAt": "2020-06-25T07:49:58Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0OTY3NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450149674", "createdAt": "2020-07-06T11:10:03Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3MTA3Mg=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NTA4NzI3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzo1NzoxNVrOGovj0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMzoyNTo1OFrOGtXJ1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3NTQ0Mw==", "bodyText": "Illegal '{ }' for one line statement", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445375443", "createdAt": "2020-06-25T07:57:15Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxODQ1NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450218454", "createdAt": "2020-07-06T13:25:58Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3NTQ0Mw=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NTA5OTE0OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwODowMDo0N1rOGovrbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMzoyNjowM1rOGtXKDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3NzM4OQ==", "bodyText": "It's dangerous since MAX_PENDING_BUFF_SIZE constant is static. If CacheContinuousQueryEventBuffer class will be first loaded by this test, other continuous queries tests (in this JVM) can fail. If this class was already loaded and used before this test, property will have no effect and this case can fail.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445377389", "createdAt": "2020-06-25T08:00:47Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxODUwOQ==", "bodyText": "FIxed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450218509", "createdAt": "2020-07-06T13:26:03Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3NzM4OQ=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NTIzODk5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwODo0MDo1MlrOGoxFOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTozODo0MVrOGtTu2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQwMDM3Nw==", "bodyText": "GridAtomicLong.setIfGreater?", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445400377", "createdAt": "2020-06-25T08:40:52Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjE4NQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450162185", "createdAt": "2020-07-06T11:38:15Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQwMDM3Nw=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjM5NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450162394", "createdAt": "2020-07-06T11:38:41Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQwMDM3Nw=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NTM2NzU2OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwOToxNjo0N1rOGoyXBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTozODoyMVrOGtTuMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMTMxNw==", "bodyText": "Why not just put random key with the random value? We don't check these values after test anyway.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445421317", "createdAt": "2020-06-25T09:16:47Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+                }\n+            }, 3, \"cq-put-\");\n+\n+            assertNotNull(\"Partition remote buffers must be inited\", pending);\n+\n+            log.warning(\"Waiting for pending buffer being overflowed within \" + OVERFLOW_TIMEOUT_MS + \" ms.\");\n+\n+            boolean await = waitForCondition(() -> pending.size() > PENDING_LIMIT, OVERFLOW_TIMEOUT_MS);\n+\n+            assertFalse(\"Pending buffer exceeded the limit despite entries have been acked \" +\n+                    \"[lastAcked=\" + lastAcked + \", pending=\" + S.compact(pending.keySet(), i -> i + 1) + ']',\n+                await);\n+        }\n+        finally {\n+            spi(locIgnite).stopBlock();\n+\n+            if (updFut != null)\n+                updFut.cancel();\n+        }\n+    }\n+\n+    /**\n+     * @param cache Ignite cache.\n+     * @param key Key to change.\n+     */\n+    private static void putX2Value(IgniteCache<Integer, Integer> cache, int key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjIyNQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450162225", "createdAt": "2020-07-06T11:38:21Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+                }\n+            }, 3, \"cq-put-\");\n+\n+            assertNotNull(\"Partition remote buffers must be inited\", pending);\n+\n+            log.warning(\"Waiting for pending buffer being overflowed within \" + OVERFLOW_TIMEOUT_MS + \" ms.\");\n+\n+            boolean await = waitForCondition(() -> pending.size() > PENDING_LIMIT, OVERFLOW_TIMEOUT_MS);\n+\n+            assertFalse(\"Pending buffer exceeded the limit despite entries have been acked \" +\n+                    \"[lastAcked=\" + lastAcked + \", pending=\" + S.compact(pending.keySet(), i -> i + 1) + ']',\n+                await);\n+        }\n+        finally {\n+            spi(locIgnite).stopBlock();\n+\n+            if (updFut != null)\n+                updFut.cancel();\n+        }\n+    }\n+\n+    /**\n+     * @param cache Ignite cache.\n+     * @param key Key to change.\n+     */\n+    private static void putX2Value(IgniteCache<Integer, Integer> cache, int key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMTMxNw=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NTQyOTMyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwOTozNDoxMlrOGoy_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTozODozMlrOGtTukg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMTU4OQ==", "bodyText": "I think we wait here too long. With 15 secs timeout, it's about 2.5 additional minutes for all tests.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445431589", "createdAt": "2020-06-25T09:34:12Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+                }\n+            }, 3, \"cq-put-\");\n+\n+            assertNotNull(\"Partition remote buffers must be inited\", pending);\n+\n+            log.warning(\"Waiting for pending buffer being overflowed within \" + OVERFLOW_TIMEOUT_MS + \" ms.\");\n+\n+            boolean await = waitForCondition(() -> pending.size() > PENDING_LIMIT, OVERFLOW_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjMyMg==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r450162322", "createdAt": "2020-07-06T11:38:32Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+                }\n+            }, 3, \"cq-put-\");\n+\n+            assertNotNull(\"Partition remote buffers must be inited\", pending);\n+\n+            log.warning(\"Waiting for pending buffer being overflowed within \" + OVERFLOW_TIMEOUT_MS + \" ms.\");\n+\n+            boolean await = waitForCondition(() -> pending.size() > PENDING_LIMIT, OVERFLOW_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMTU4OQ=="}, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjA0Njc3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzozODozOFrOGuI8FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1NTowNlrOGuemGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzNDEzMw==", "bodyText": "Why do we need this field? It's not used.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451034133", "createdAt": "2020-07-07T17:38:38Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryHandler.java", "diffHunk": "@@ -99,6 +99,10 @@\n     static final int LSNR_MAX_BUF_SIZE =\n         IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_LISTENER_MAX_BUFFER_SIZE\", 10_000);\n \n+    /** Maximum size of buffer for pending events. Default value is {@code 10_000}. */\n+    public final int maxPendingBuffSize =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODk1NQ==", "bodyText": "Removed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451388955", "createdAt": "2020-07-08T08:55:06Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryHandler.java", "diffHunk": "@@ -99,6 +99,10 @@\n     static final int LSNR_MAX_BUF_SIZE =\n         IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_LISTENER_MAX_BUFFER_SIZE\", 10_000);\n \n+    /** Maximum size of buffer for pending events. Default value is {@code 10_000}. */\n+    public final int maxPendingBuffSize =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzNDEzMw=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjA3Mjc1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzo0NTo0MVrOGuJMGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNjoyMzoxMlrOGuvvWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzODIzNQ==", "bodyText": "Can be simplified with lambda evt -> evt.getKey() % 2 == 0", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451038235", "createdAt": "2020-07-07T17:45:41Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MDQ1OQ==", "bodyText": "This filter used twice: check that all accepted by client events are filtered (on buffer overflowed we send entries to from the server to the client), and also used as a filter condition. So, I don't think it can be simplified.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451390459", "createdAt": "2020-07-08T08:57:17Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzODIzNQ=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyODUwOQ==", "bodyText": "Here I mean that you can simplify this filter:\nCacheEntryEventSerializableFilter<Integer, Integer> filter = evt -> evt.getKey() % 2 == 0;", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451628509", "createdAt": "2020-07-08T15:21:48Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzODIzNQ=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2OTg1MQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451669851", "createdAt": "2020-07-08T16:23:12Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzODIzNQ=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjEzNjAzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODowMzoyOFrOGuJ0hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjowODowNFrOGuk2gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA0ODU4MA==", "bodyText": "I can't match comment and condition. What do you mean here?", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451048580", "createdAt": "2020-07-07T18:03:28Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {\n+            @Override public boolean evaluate(CacheEntryEvent<? extends Integer,? extends Integer> evt) {\n+                return evt.getKey() % 2 == 0;\n+            }\n+        };\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(filter));\n+        cq.setLocalListener((events) -> events.forEach(e -> {\n+            if (!filter.evaluate(e))\n+                err.compareAndSet(null, \"Key must be filtered [e=\" + e + ']');\n+        }));\n+        cq.setLocal(false);\n+\n+        spi(srv).blockMessages((nodeId, msg) -> msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+        spi(clnt).blockMessages((nodeId, msg) -> msg instanceof CacheContinuousQueryBatchAck);\n+\n+        IgniteInternalFuture<?> loadFut = null;\n+\n+        try (QueryCursor<?> qry = clnt.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            loadFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted())\n+                    clnt.cache(DEFAULT_CACHE_NAME).put(keys.incrementAndGet(), 0);\n+            }, 3, \"cq-put-\");\n+\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(grid(0), CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            waitForCondition(() -> pending.size() > MAX_PENDING_BUFF_SIZE, 15_000);\n+\n+            // Check all entries greater than limit filtered correctly.\n+            waitForCondition(() -> keys.get() > MAX_PENDING_BUFF_SIZE * 2, 15_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5MTQ1OQ==", "bodyText": "I've fixed comment. This means all entries with counter greater than exceeded limit must be filtered correctly.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451491459", "createdAt": "2020-07-08T12:08:04Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {\n+            @Override public boolean evaluate(CacheEntryEvent<? extends Integer,? extends Integer> evt) {\n+                return evt.getKey() % 2 == 0;\n+            }\n+        };\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(filter));\n+        cq.setLocalListener((events) -> events.forEach(e -> {\n+            if (!filter.evaluate(e))\n+                err.compareAndSet(null, \"Key must be filtered [e=\" + e + ']');\n+        }));\n+        cq.setLocal(false);\n+\n+        spi(srv).blockMessages((nodeId, msg) -> msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+        spi(clnt).blockMessages((nodeId, msg) -> msg instanceof CacheContinuousQueryBatchAck);\n+\n+        IgniteInternalFuture<?> loadFut = null;\n+\n+        try (QueryCursor<?> qry = clnt.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            loadFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted())\n+                    clnt.cache(DEFAULT_CACHE_NAME).put(keys.incrementAndGet(), 0);\n+            }, 3, \"cq-put-\");\n+\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(grid(0), CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            waitForCondition(() -> pending.size() > MAX_PENDING_BUFF_SIZE, 15_000);\n+\n+            // Check all entries greater than limit filtered correctly.\n+            waitForCondition(() -> keys.get() > MAX_PENDING_BUFF_SIZE * 2, 15_000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA0ODU4MA=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjE2ODM0OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODoxMzoxNlrOGuKIxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjoxMToxMFrOGuk-6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1Mzc2NA==", "bodyText": "We should assertFalse here.\nBut personally I don't like the idea with such big timeouts. I've run new tests and it takes about 3 minutes, and this time will be about the same on any hardware due to timeouts.\nCan we rewrite the tests using keys count limit instead of timeouts? I think MAX_PENDING_BUFF_SIZE * 3 will be enough for this test. Instead of \"wait for condition\" you can replace \"pending\" field by your own map which raise some error flag, for example, on put when size() is more than MAX_PENDING_BUFF_SIZE. The same for other tests.\nAlso in current implementation there is no synchronization between pendingCurrSize.get() > MAX_PENDING_BUFF_SIZE and pendingCurrSize.incrementAndGet(), so due to races you can get sometimes values more than limit (but no more than limit + threads count).", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451053764", "createdAt": "2020-07-07T18:13:16Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {\n+            @Override public boolean evaluate(CacheEntryEvent<? extends Integer,? extends Integer> evt) {\n+                return evt.getKey() % 2 == 0;\n+            }\n+        };\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(filter));\n+        cq.setLocalListener((events) -> events.forEach(e -> {\n+            if (!filter.evaluate(e))\n+                err.compareAndSet(null, \"Key must be filtered [e=\" + e + ']');\n+        }));\n+        cq.setLocal(false);\n+\n+        spi(srv).blockMessages((nodeId, msg) -> msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+        spi(clnt).blockMessages((nodeId, msg) -> msg instanceof CacheContinuousQueryBatchAck);\n+\n+        IgniteInternalFuture<?> loadFut = null;\n+\n+        try (QueryCursor<?> qry = clnt.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            loadFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted())\n+                    clnt.cache(DEFAULT_CACHE_NAME).put(keys.incrementAndGet(), 0);\n+            }, 3, \"cq-put-\");\n+\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(grid(0), CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            waitForCondition(() -> pending.size() > MAX_PENDING_BUFF_SIZE, 15_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5MzYwOA==", "bodyText": "We will wait for 15_000only if an error occurred. Other things fixed as you suggested privately. waitForCondition exits when the number of inserted entries achieved.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451493608", "createdAt": "2020-07-08T12:11:10Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {\n+            @Override public boolean evaluate(CacheEntryEvent<? extends Integer,? extends Integer> evt) {\n+                return evt.getKey() % 2 == 0;\n+            }\n+        };\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(filter));\n+        cq.setLocalListener((events) -> events.forEach(e -> {\n+            if (!filter.evaluate(e))\n+                err.compareAndSet(null, \"Key must be filtered [e=\" + e + ']');\n+        }));\n+        cq.setLocal(false);\n+\n+        spi(srv).blockMessages((nodeId, msg) -> msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+        spi(clnt).blockMessages((nodeId, msg) -> msg instanceof CacheContinuousQueryBatchAck);\n+\n+        IgniteInternalFuture<?> loadFut = null;\n+\n+        try (QueryCursor<?> qry = clnt.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            loadFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted())\n+                    clnt.cache(DEFAULT_CACHE_NAME).put(keys.incrementAndGet(), 0);\n+            }, 3, \"cq-put-\");\n+\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(grid(0), CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            waitForCondition(() -> pending.size() > MAX_PENDING_BUFF_SIZE, 15_000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1Mzc2NA=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjI3Nzk2OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxODo0NjowOFrOGuLNWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1ODoxNlrOGueuYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3MTMyMw==", "bodyText": "You should use some synchronization here, only one thread at a time should be able to remove pending entries. In other case you can iterate concurrently on the same entry, send duplicate to the client, call remove and decrement size twice (however only one entry is removed)", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451071323", "createdAt": "2020-07-07T18:46:08Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingCurrSize.get() > MAX_PENDING_BUFF_SIZE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5MTA3Mg==", "bodyText": "Agree, synchroniztion(pending) added.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451391072", "createdAt": "2020-07-08T08:58:16Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingCurrSize.get() > MAX_PENDING_BUFF_SIZE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3MTMyMw=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjM1MzAwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTowOTowOVrOGuL8GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1NDoyN1rOGueklQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI4OQ==", "bodyText": "You should move this condition out from here, or at least continue the cycle after tryRollOver.\nFor example, if you have acked counter = 100 and cntr == 101 entry should not go to the pending entries map, instead it should go to current batch, since batch is rolled over. If you skip this entry in the current batch you will never switch this batch successfully, since first entry is missing in the batch and lastProc will never increment.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451083289", "createdAt": "2020-07-07T19:09:09Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODU2NQ==", "bodyText": "Agree, RETRY added.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451388565", "createdAt": "2020-07-08T08:54:27Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI4OQ=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjM2MzkwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToxMjoyOVrOGuMC8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjoxMTo0NlrOGulBMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTA0Mw==", "bodyText": "We can skip backupQ.add() if we already have acked counter more then current counter.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451085043", "createdAt": "2020-07-07T19:12:29Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -154,6 +185,7 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n         Object res = null;\n \n         for (;;) {\n+            // Set batch only if batch is null (first attempt).\n             batch = initBatch(entry.topologyVersion(), backup);\n \n             if (batch == null || cntr < batch.startCntr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5NDE5Mg==", "bodyText": "I'll fix it under - https://issues.apache.org/jira/browse/IGNITE-13126", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451494192", "createdAt": "2020-07-08T12:11:46Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -154,6 +185,7 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n         Object res = null;\n \n         for (;;) {\n+            // Set batch only if batch is null (first attempt).\n             batch = initBatch(entry.topologyVersion(), backup);\n \n             if (batch == null || cntr < batch.startCntr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTA0Mw=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMjQyMzU3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozMTowN1rOGuMokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1NDowM1rOGuejaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NDY3Mw==", "bodyText": "size() method is almost constant time operation, there is a long adder inside and usually, there is only one cell in it (but at most CPU count cells). If you have low contention on pending map access to pending.size() will cost relatively low. If you have very high contention on pending map, I think AtomicInteger.incrementAndGet() can become a bottleneck here.\nSo I'm not sure about this optimization, perhaps it's better to use pending.size().", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451094673", "createdAt": "2020-07-07T19:31:07Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -26,40 +26,69 @@\n import java.util.TreeMap;\n import java.util.concurrent.ConcurrentLinkedDeque;\n import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.apache.ignite.util.deque.FastSizeDeque;\n import org.jetbrains.annotations.Nullable;\n \n /**\n  *\n  */\n public class CacheContinuousQueryEventBuffer {\n-    /** */\n+    /** Maximum size of buffer for pending events. Default value is {@code 10_000}. */\n+    public static final int MAX_PENDING_BUFF_SIZE =\n+        IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", 10_000);\n+\n+    /** Batch buffer size. */\n     private static final int BUF_SIZE =\n         IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_SERVER_BUFFER_SIZE\", 1000);\n \n     /** */\n     private static final Object RETRY = new Object();\n \n-    /** */\n-    protected final int part;\n+    /** Continuous query category logger. */\n+    private final IgniteLogger log;\n \n     /** */\n-    private AtomicReference<Batch> curBatch = new AtomicReference<>();\n+    private final int part;\n \n-    /** */\n-    private FastSizeDeque<CacheContinuousQueryEntry> backupQ = new FastSizeDeque<>(new ConcurrentLinkedDeque<>());\n+    /** Batch of entries currently being collected to send to the remote. */\n+    private final AtomicReference<Batch> curBatch = new AtomicReference<>();\n \n-    /** */\n-    private ConcurrentSkipListMap<Long, CacheContinuousQueryEntry> pending = new ConcurrentSkipListMap<>();\n+    /** Queue for keeping backup entries which partition counter less the counter processing by current batch. */\n+    private final FastSizeDeque<CacheContinuousQueryEntry> backupQ = new FastSizeDeque<>(new ConcurrentLinkedDeque<>());\n+\n+    /** Entries which are waiting for being processed. */\n+    private final ConcurrentSkipListMap<Long, CacheContinuousQueryEntry> pending = new ConcurrentSkipListMap<>();\n+\n+    /**\n+     * The size method of the pending ConcurrentSkipListMap is not a constant-time operation. Since each", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODI2NQ==", "bodyText": "Discussed privately. jdk8 and jdk11 has different size() method implementation, so for the main use-case when the buffer is overflowed it's better to use AtomicInteger + synchronization on pending to eliminate all potential issues.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451388265", "createdAt": "2020-07-08T08:54:03Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -26,40 +26,69 @@\n import java.util.TreeMap;\n import java.util.concurrent.ConcurrentLinkedDeque;\n import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.apache.ignite.util.deque.FastSizeDeque;\n import org.jetbrains.annotations.Nullable;\n \n /**\n  *\n  */\n public class CacheContinuousQueryEventBuffer {\n-    /** */\n+    /** Maximum size of buffer for pending events. Default value is {@code 10_000}. */\n+    public static final int MAX_PENDING_BUFF_SIZE =\n+        IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", 10_000);\n+\n+    /** Batch buffer size. */\n     private static final int BUF_SIZE =\n         IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_SERVER_BUFFER_SIZE\", 1000);\n \n     /** */\n     private static final Object RETRY = new Object();\n \n-    /** */\n-    protected final int part;\n+    /** Continuous query category logger. */\n+    private final IgniteLogger log;\n \n     /** */\n-    private AtomicReference<Batch> curBatch = new AtomicReference<>();\n+    private final int part;\n \n-    /** */\n-    private FastSizeDeque<CacheContinuousQueryEntry> backupQ = new FastSizeDeque<>(new ConcurrentLinkedDeque<>());\n+    /** Batch of entries currently being collected to send to the remote. */\n+    private final AtomicReference<Batch> curBatch = new AtomicReference<>();\n \n-    /** */\n-    private ConcurrentSkipListMap<Long, CacheContinuousQueryEntry> pending = new ConcurrentSkipListMap<>();\n+    /** Queue for keeping backup entries which partition counter less the counter processing by current batch. */\n+    private final FastSizeDeque<CacheContinuousQueryEntry> backupQ = new FastSizeDeque<>(new ConcurrentLinkedDeque<>());\n+\n+    /** Entries which are waiting for being processed. */\n+    private final ConcurrentSkipListMap<Long, CacheContinuousQueryEntry> pending = new ConcurrentSkipListMap<>();\n+\n+    /**\n+     * The size method of the pending ConcurrentSkipListMap is not a constant-time operation. Since each", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NDY3Mw=="}, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2460, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}