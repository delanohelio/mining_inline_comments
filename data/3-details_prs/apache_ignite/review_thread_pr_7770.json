{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTUyNzUw", "number": 7770, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNTowNFrOD5usSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNToyMlrOD5usnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODYwNDI3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNTowNFrOGRKIVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMTo1MDoxM1rOGRPUag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk1MQ==", "bodyText": "Unnecessary line brake", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420644951", "createdAt": "2020-05-06T09:05:04Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyOTk2Mg==", "bodyText": "fixed.", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420729962", "createdAt": "2020-05-06T11:50:13Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk1MQ=="}, "originalCommit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODYwNTA5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNToyMlrOGRKI5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMTo1MDoxN1rOGRPUnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NTA5Mw==", "bodyText": "Can be one line", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420645093", "createdAt": "2020-05-06T09:05:22Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testSnapshotPartitionExchangeAwareOrder() throws Exception {\n+        IgniteEx ignite = startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        Map<UUID, PartitionsExchangeAware> comps = new HashMap<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            PartitionsExchangeAware comp;\n+\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(comp = new PartitionsExchangeAware() {\n+                    /** Order of exchange calls. */\n+                    private final AtomicInteger order = new AtomicInteger();\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 0, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitAfterTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 1, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneBeforeTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 2, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneAfterTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 3, order.getAndSet(0));\n+                    }\n+                });\n+\n+            comps.put(((IgniteEx)ig).localNode().id(), comp);\n+        }\n+\n+        ignite.snapshot().createSnapshot(SNAPSHOT_NAME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDczMDAxMw==", "bodyText": "fixed.", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420730013", "createdAt": "2020-05-06T11:50:17Z", "author": {"login": "Mmuzaf"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testSnapshotPartitionExchangeAwareOrder() throws Exception {\n+        IgniteEx ignite = startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        Map<UUID, PartitionsExchangeAware> comps = new HashMap<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            PartitionsExchangeAware comp;\n+\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(comp = new PartitionsExchangeAware() {\n+                    /** Order of exchange calls. */\n+                    private final AtomicInteger order = new AtomicInteger();\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 0, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitAfterTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 1, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneBeforeTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 2, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneAfterTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 3, order.getAndSet(0));\n+                    }\n+                });\n+\n+            comps.put(((IgniteEx)ig).localNode().id(), comp);\n+        }\n+\n+        ignite.snapshot().createSnapshot(SNAPSHOT_NAME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NTA5Mw=="}, "originalCommit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "originalPosition": 204}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2478, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}