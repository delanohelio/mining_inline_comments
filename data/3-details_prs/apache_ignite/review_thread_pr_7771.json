{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMTk1NTI5", "number": 7771, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0NDowNlrOD7vJtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOToxMjowOFrOD8ZEAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTY1MTEwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0NDowNlrOGUPnqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoxNTowMlrOGUQ1Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MDYxOA==", "bodyText": "This condition can be moved outside the synchronized block.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423880618", "createdAt": "2020-05-12T16:44:06Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);\n \n-            if (timeout == 0 || (top != null && !top.isEmpty()))\n-                return top;\n+            if (timeout == 0 && desc == null)\n+                return null;\n \n             synchronized (servicesTopsUpdateMux) {\n-                long wait = timeout - (U.currentTimeMillis() - startTime);\n+                if (desc != null && desc.topologyInitialized())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09a7ec9efa33c735ac6666e7a87197c3028a56de"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMDQ5OA==", "bodyText": "I think it cannot be done that way.\nIf topology is updated before acquiring of servicesTopsUpdateMux but after this condiiton, we will be blocked until the next full msg.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423900498", "createdAt": "2020-05-12T17:15:02Z", "author": {"login": "ololo3000"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);\n \n-            if (timeout == 0 || (top != null && !top.isEmpty()))\n-                return top;\n+            if (timeout == 0 && desc == null)\n+                return null;\n \n             synchronized (servicesTopsUpdateMux) {\n-                long wait = timeout - (U.currentTimeMillis() - startTime);\n+                if (desc != null && desc.topologyInitialized())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MDYxOA=="}, "originalCommit": {"oid": "09a7ec9efa33c735ac6666e7a87197c3028a56de"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzOTY2OTgzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0ODo1NVrOGUPzxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0MDo1NVrOGUUBTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzcxOQ==", "bodyText": "Use ServiceDeploymentProcessAbstractTest and BlockingTcpDiscoverySpi instead of latches.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423883719", "createdAt": "2020-05-12T16:48:55Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09a7ec9efa33c735ac6666e7a87197c3028a56de"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1MjcxOA==", "bodyText": "BlockingTcpDiscoverySpi gives an ability to only make the full msg disappear. In my cases it's needed to block/unblock the full msg and awaits for the completion of its processing.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423952718", "createdAt": "2020-05-12T18:40:55Z", "author": {"login": "ololo3000"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzcxOQ=="}, "originalCommit": {"oid": "09a7ec9efa33c735ac6666e7a87197c3028a56de"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTc1NjE4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzoxMjo1NlrOGUkTNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzoxMjo1NlrOGUkTNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxOTQ0NA==", "bodyText": "Constant should be over instance fields.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424219444", "createdAt": "2020-05-13T07:12:56Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTgyMTgxOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzozMzowOFrOGUk8pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzozMzowOFrOGUk8pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMDA1NQ==", "bodyText": "assertEquals(1, fullMsgReceivedLatch.getCount());", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424230055", "createdAt": "2020-05-13T07:33:08Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        assertThrowsWithCause(\n+            () -> rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke(),\n+            IgniteException.class);\n+\n+        assertTrue(rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+    }\n+\n+    /**\n+     * Tests service invocation before its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2MethodRef\")\n+    public void testServiceTopologyInitializationDelayed() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTgzMjc4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzozNjozM1rOGUlDuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzozNjozM1rOGUlDuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMTg2NQ==", "bodyText": "assertTrue(fullMsgReceivedLatch.await(getTestTimeout(), MILLISECONDS));", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424231865", "createdAt": "2020-05-13T07:36:33Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        assertThrowsWithCause(\n+            () -> rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke(),\n+            IgniteException.class);\n+\n+        assertTrue(rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+    }\n+\n+    /**\n+     * Tests service invocation before its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2MethodRef\")\n+    public void testServiceTopologyInitializationDelayed() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        deployServices(loc);\n+\n+        fullMsgReceivedLatch.await(getTestTimeout(), MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTgzNzA1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzozNzo0NFrOGUlGXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzozNzo0NFrOGUlGXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMjU0Mw==", "bodyText": "assertEquals(1, fullMsgUnblockedLatch.getCount());", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424232543", "createdAt": "2020-05-13T07:37:44Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        assertThrowsWithCause(\n+            () -> rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke(),\n+            IgniteException.class);\n+\n+        assertTrue(rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+    }\n+\n+    /**\n+     * Tests service invocation before its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2MethodRef\")\n+    public void testServiceTopologyInitializationDelayed() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        deployServices(loc);\n+\n+        fullMsgReceivedLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        IgniteInternalFuture<Boolean> decentSvcFut = runAsync(() ->\n+            rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+\n+        IgniteInternalFuture<Boolean> brokenSvcFut = runAsync(() ->\n+            rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke());\n+\n+        U.sleep(500);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg0NzMwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0MDozNVrOGUlMuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0MDozNVrOGUlMuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNDE3MQ==", "bodyText": "assertEquals(1, fullMsgUnblockedLatch.getCount());", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424234171", "createdAt": "2020-05-13T07:40:35Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg1MTk4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0MTo1NlrOGUlPtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0MTo1NlrOGUlPtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNDkzNA==", "bodyText": "@BeforeClass because all these tests are valid only for new service processor implementaion.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424234934", "createdAt": "2020-05-13T07:41:56Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg1NjU1OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0MzoxM1rOGUlSpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0MzoxM1rOGUlSpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNTY4Nw==", "bodyText": "assertTrue(fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS));", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424235687", "createdAt": "2020-05-13T07:43:13Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTg1ODMxOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0Mzo0MVrOGUlTtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNzo0Mzo0MVrOGUlTtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNTk1OA==", "bodyText": "assertEquals(1, fullMsgHandledLatch.getCount());", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424235958", "createdAt": "2020-05-13T07:43:41Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjUxNzc5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOToxMjowOFrOGVTN2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzozNDoxN1rOGV5u_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ==", "bodyText": "It looks like this block should be moved outside the loop\ndesc = lookupInRegisteredServices(name);\n\nif (timeout == 0 && desc == null)\n    return null;\n\nand variable desc shoud be refreshed under mutex\nsynchronized (servicesTopsUpdateMux) {\n    desc = lookupInRegisteredServices(name);\n    ...\n\nBecause there is might be a race, when during the checks service can be unregistered and ServiceClusterDeploymentResultBatch processed.\nThat means it's possible hanging because in your case wait might be equal to 0 - that means \"wait forever\".\nRefreshing desc under mutex - not to provide us happens-before guarantees but provide processing order guarantees: when undeployment may be processed before we start waiting for topology initialization.\nAlternative solution - do not wait for 0 and use 100 for example to retry the cycle.\nBut it's would be better to provide processing order guarantees.\nWhat do you think?", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424988121", "createdAt": "2020-05-14T09:12:08Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA0NDIwMg==", "bodyText": "I got it. If after [1] but before [2] service is deleted and full message with requested service topology is received, topology of the local ServiceDescriptor reference will never be updated. Is that what you meant?\nwhile (true) {\n    desc = lookupInRegisteredServices(name);\n\n    if (timeout == 0 && desc == null) // [1]\n        return null;\n\n    synchronized (servicesTopsUpdateMux) { // [2]\n        if (desc != null && desc.topologyInitialized())\n            return desc.topologySnapshot();\n\n        long wait = 0;\n\n        if (timeout != 0) {\n            wait = timeout - (U.currentTimeMillis() - startTime);\n\n            if (wait <= 0)\n                return desc == null ? null : desc.topologySnapshot();\n        }\n\n        try {\n            servicesTopsUpdateMux.wait(wait);\n        }\n        catch (InterruptedException e) {\n            throw new IgniteInterruptedCheckedException(e);\n        }\n    }\n}\n\nIt seems that it will be enough to only move\ndesc = lookupInRegisteredServices(name);\n\nif (timeout == 0 && desc == null) // [1]\n    return null;\n\ninside the synchronization block.\nIn that case if service is removed before synchronization block acquired or full message is received no matter the order, we will return on\n if (timeout == 0 && desc == null) \n    return null;\n\nif service is removed during synchronization block execution, we anyway will receive the full message and stop waiting.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r425044202", "createdAt": "2020-05-14T10:46:37Z", "author": {"login": "ololo3000"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ=="}, "originalCommit": {"oid": "b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExODM3NQ==", "bodyText": "I updated PR according to my proposal. Could you please take a look?\nUnfortunately I find it difficult to test this race condition.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r425118375", "createdAt": "2020-05-14T13:03:24Z", "author": {"login": "ololo3000"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ=="}, "originalCommit": {"oid": "b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxOTE5Ng==", "bodyText": "Yes, you understood correctly.\nChanges look good to me.\nPlease rerun tests and update TC bot visa in Jira, just to be sure.", "url": "https://github.com/apache/ignite/pull/7771#discussion_r425619196", "createdAt": "2020-05-15T07:34:17Z", "author": {"login": "daradurvs"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ=="}, "originalCommit": {"oid": "b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2481, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}