{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MDY5ODA4", "number": 7881, "title": "IGNITE-10959: Continuous query pending buffer limit", "bodyText": "Thank you for submitting the pull request to the Apache Ignite.\nIn order to streamline the review of the contribution\nwe ask you to ensure the following steps have been taken:\nThe Contribution Checklist\n\n There is a single JIRA ticket related to the pull request.\n The web-link to the pull request is attached to the JIRA ticket.\n The JIRA ticket has the Patch Available state.\n The pull request body describes changes that have been made.\nThe description explains WHAT and WHY was made instead of HOW.\n The pull request title is treated as the final commit message.\nThe following pattern must be used: IGNITE-12407: Add Cluster API support to Java thin client\n A reviewer has been mentioned through the JIRA comments\n(see the Maintainers list)\n The pull request has been checked by the Teamcity Bot and\nthe green visa attached to the JIRA ticket (see TC.Bot: Check PR)\n\nNotes\n\nHow to Contribute\nCoding abbreviation rules\nCoding Guidelines\nApache Ignite Teamcity Bot\n\nIf you need any help, please email dev@ignite.apache.org or ask an\u0443 advice on http://asf.slack.com #ignite channel.", "createdAt": "2020-06-01T15:55:47Z", "url": "https://github.com/apache/ignite/pull/7881", "merged": true, "mergeCommit": {"oid": "e730185565a75fa338496814f0eaec1d1315d7c9"}, "closed": true, "closedAt": "2020-07-10T17:06:11Z", "author": {"login": "Mmuzaf"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnCVjkgH2gAyNDI2MDY5ODA4OmM1ZGQwN2Q2N2FhZjM4ZmVhMTlhYTBkYzJiNWYwN2EzOWFmNDc4NjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczkd49gH2gAyNDI2MDY5ODA4OmMwY2UxYzc0ODkwNjRhZTRmNjIzODc1NWE5MDI3ZjQ4ZWJhZWIwNDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c5dd07d67aaf38fea19aa0dc2b5f07a39af47860", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/c5dd07d67aaf38fea19aa0dc2b5f07a39af47860", "committedDate": "2020-06-01T15:52:29Z", "message": "IGNITE-10959: add pending buffer exceeded limit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "147ab8fcd5b86035fa63205daef2448350f15623", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/147ab8fcd5b86035fa63205daef2448350f15623", "committedDate": "2020-06-01T15:53:41Z", "message": "IGNITE-10959: fix partition buffer modifier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e065c63293cffca009a5c370dc420279c0d6ff6c", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/e065c63293cffca009a5c370dc420279c0d6ff6c", "committedDate": "2020-06-02T16:23:16Z", "message": "IGNITE-10959: rollover batch buffer when ack message processed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c62b066816688a8e190d2788b4bb36f958f5453a", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/c62b066816688a8e190d2788b4bb36f958f5453a", "committedDate": "2020-06-02T18:01:27Z", "message": "Merge branch 'master' into ignite-10959"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b17ba5a65408360887e9c901b1d2022e275b7257", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/b17ba5a65408360887e9c901b1d2022e275b7257", "committedDate": "2020-06-03T16:15:22Z", "message": "Merge branch 'master' into ignite-10959"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edbb4d336a0f5424c3642476682e27df5266f249", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/edbb4d336a0f5424c3642476682e27df5266f249", "committedDate": "2020-06-03T19:02:19Z", "message": "IGNITE-10959: add pending buffer limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb0fef0f454e6ff436ea896184af426d5852eebf", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/cb0fef0f454e6ff436ea896184af426d5852eebf", "committedDate": "2020-06-03T19:16:43Z", "message": "IGNITE-10959: add test suites"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2915e152e2b4195e01148353b197facb202d5bb7", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/2915e152e2b4195e01148353b197facb202d5bb7", "committedDate": "2020-06-03T19:20:17Z", "message": "IGNITE-10959: fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d3110aae486ae5a6d59ca33fca18c4b89de7956", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/8d3110aae486ae5a6d59ca33fca18c4b89de7956", "committedDate": "2020-06-03T19:32:55Z", "message": "IGNITE-10959: minor fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a9b94309a16858a9758085d1c98bca654fe30dd", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/2a9b94309a16858a9758085d1c98bca654fe30dd", "committedDate": "2020-06-04T11:39:42Z", "message": "IGNITE-10959: increase test limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "add1fb1ef65bf54c045fe7856bf14b7bbf8e8f93", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/add1fb1ef65bf54c045fe7856bf14b7bbf8e8f93", "committedDate": "2020-06-04T13:12:19Z", "message": "IGNITE-10959: minor text fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caaf3c4d8d23b7066f4cc6e6eb4c3700df1e472b", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/caaf3c4d8d23b7066f4cc6e6eb4c3700df1e472b", "committedDate": "2020-06-04T14:13:59Z", "message": "IGNITE-10959: minor text fix 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a93c9f10af0572e1a33bc56e02c524cdb10a489", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/0a93c9f10af0572e1a33bc56e02c524cdb10a489", "committedDate": "2020-06-04T14:55:43Z", "message": "IGNITE-10959: maintain pending size explicitly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a80dc74f20d83f3a7c226ed1f2872664d067ced", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/8a80dc74f20d83f3a7c226ed1f2872664d067ced", "committedDate": "2020-06-04T15:02:55Z", "message": "IGNITE-10959: clean map on overflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4fcdc141710c1c17797a561084920dd886efe0f", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/c4fcdc141710c1c17797a561084920dd886efe0f", "committedDate": "2020-06-04T15:19:03Z", "message": "IGNITE-10959: fix tx block on cancel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4", "committedDate": "2020-06-04T16:13:11Z", "message": "IGNITE-10959: fix return value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjE0MzA3", "url": "https://github.com/apache/ignite/pull/7881#pullrequestreview-431214307", "createdAt": "2020-06-16T07:05:31Z", "commit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzowNTozMVrOGkN57g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo1NjozNFrOGkPmqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyOTc0Mg==", "bodyText": "bach -> batch", "url": "https://github.com/apache/ignite/pull/7881#discussion_r440629742", "createdAt": "2020-06-16T07:05:31Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -154,6 +191,7 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n         Object res = null;\n \n         for (;;) {\n+            // Set bach only if batch is null (first attempt).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDU3NA==", "bodyText": "Use GridAtomicLong.setIfGreater() here", "url": "https://github.com/apache/ignite/pull/7881#discussion_r440650574", "createdAt": "2020-06-16T07:44:51Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -74,6 +106,11 @@ void cleanupBackupQueue(Long updateCntr) {\n             if (backupEntry.updateCounter() <= updateCntr)\n                 it.remove();\n         }\n+\n+        long val = ackedUpdCntr;\n+\n+        while (val < updateCntr && !ACKED_UPDATER.compareAndSet(this, val, updateCntr))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NzU3Nw==", "bodyText": "Let's use @Parameterized instead of class extending.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r440657577", "createdAt": "2020-06-16T07:56:34Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/AbstractCacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+public abstract class AbstractCacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMDAzNzcw", "url": "https://github.com/apache/ignite/pull/7881#pullrequestreview-433003770", "createdAt": "2020-06-18T07:19:12Z", "commit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNzoxOToxMlrOGlin5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwNzoyMTowOFrOGlir0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxNzc2Nw==", "bodyText": "You should also check this against curBatch, since curBatch can be changed concurrently and in this case you will fail with assert on rollOver", "url": "https://github.com/apache/ignite/pull/7881#discussion_r442017767", "createdAt": "2020-06-18T07:19:12Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -463,26 +533,47 @@ private CacheContinuousQueryEntry filteredEntry(long cntr, long filtered) {\n \n                     lastProc = pos;\n \n-                    if (pos == entries.length - 1) {\n-                        Arrays.fill(entries, null);\n+                    if (pos == entries.length - 1)\n+                        rollOver(startCntr + BUF_SIZE, filtered, entry.topologyVersion());\n+                }\n+                else if (endCntr < ackedUpdCntr0)\n+                    rollOver(ackedUpdCntr0 + 1, 0, entry.topologyVersion());\n \n-                        Batch nextBatch = new Batch(this.startCntr + BUF_SIZE,\n-                            filtered,\n-                            entries,\n-                            entry.topologyVersion());\n+                return res;\n+            }\n+        }\n \n-                        entries = null;\n+        /**\n+         * @param topVer Topology version of current processing entry.\n+         */\n+        private synchronized void tryRollOver(AffinityTopologyVersion topVer) {\n+            if (entries == null)\n+                return;\n \n-                        assert curBatch.get() == this;\n+            long ackedUpdCntr0 = ackedUpdCntr;\n \n-                        curBatch.set(nextBatch);\n-                    }\n-                }\n-                else\n-                    return res;\n-            }\n+            if (endCntr < ackedUpdCntr0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxODc3MA==", "bodyText": "Can be simplified with only one while, without if", "url": "https://github.com/apache/ignite/pull/7881#discussion_r442018770", "createdAt": "2020-06-18T07:21:08Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +210,50 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr)\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingSize.get() > MAX_PENDING_BUFF_SIZE) {\n+                    LT.warn(log, \"Buffer for pending events reached max of its size \" +\n+                        \"[cacheId=\" + entry.cacheId() + \", maxSize=\" + MAX_PENDING_BUFF_SIZE +\n+                        \", partId=\" + entry.partition() + ']');\n+\n+                    // Remove first BUFF_SIZE keys.\n+                    int keysToRemove = BUF_SIZE;\n+\n+                    Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pending.entrySet().iterator();\n+\n+                    res = new ArrayList<>();\n+\n+                    while (iter.hasNext() && keysToRemove > 0) {\n+                        // Collecting results ignore backup flag due to batch may not be switched.\n+                        res = addResult(res, iter.next().getValue(), false);\n+\n+                        iter.remove();\n+                        pendingSize.decrementAndGet();\n+\n+                        keysToRemove--;\n+                    }\n+                }\n+\n+                pendingSize.incrementAndGet();\n                 pending.put(cntr, entry);\n+            }\n \n             break;\n         }\n \n         Batch batch0 = curBatch.get();\n \n+        // Batch has been changed on entry processing to the new one.\n         if (batch0 != batch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d76069b23d049b77c2b6eeeceaeb9382b4c5dd4"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "512259367a17c22cabd8ee831f420d2953f0e7c4", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/512259367a17c22cabd8ee831f420d2953f0e7c4", "committedDate": "2020-06-22T15:12:29Z", "message": "IGNITE-10959: add todo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12b883a4f9f8d2f3ec1cce4fa7599c31115f30e1", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/12b883a4f9f8d2f3ec1cce4fa7599c31115f30e1", "committedDate": "2020-06-22T15:13:23Z", "message": "Merge branch 'master' into ignite-10959"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae717af53c1afb8f336166f66a53a74000aecf79", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ae717af53c1afb8f336166f66a53a74000aecf79", "committedDate": "2020-06-22T16:26:13Z", "message": "IGNITE-10959: fix review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ea8fa0cef5223469e9d7b012a170b2b5f9d64403", "committedDate": "2020-06-23T13:34:43Z", "message": "IGNITE-10959: remove unnecessary assertion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MjA5MDEx", "url": "https://github.com/apache/ignite/pull/7881#pullrequestreview-437209011", "createdAt": "2020-06-25T06:44:33Z", "commit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNjo0NDozM1rOGotZOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwOTozNDoxMlrOGoy_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzOTk2MA==", "bodyText": "Why do we use !backup here? In this case entries will go to backupQ on primary node or fail with assert.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445339960", "createdAt": "2020-06-25T06:44:33Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingSize.get() > MAX_PENDING_BUFF_SIZE) {\n+                    LT.warn(log, \"Buffer for pending events reached max of its size \" +\n+                        \"[cacheId=\" + entry.cacheId() + \", maxSize=\" + MAX_PENDING_BUFF_SIZE +\n+                        \", partId=\" + entry.partition() + ']');\n+\n+                    // Remove first BUFF_SIZE keys.\n+                    int keysToRemove = BUF_SIZE;\n+\n+                    Iterator<Map.Entry<Long, CacheContinuousQueryEntry>> iter = pending.entrySet().iterator();\n+\n+                    while (iter.hasNext() && keysToRemove > 0) {\n+                        CacheContinuousQueryEntry entry0 = iter.next().getValue();\n+\n+                        // Discard messages on backup and send to client if primary.\n+                        if (!backup)\n+                            res = addResult(res, entry0, !backup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3MTA3Mg==", "bodyText": "Redundant NL", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445371072", "createdAt": "2020-06-25T07:49:58Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3NTQ0Mw==", "bodyText": "Illegal '{ }' for one line statement", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445375443", "createdAt": "2020-06-25T07:57:15Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM3NzM4OQ==", "bodyText": "It's dangerous since MAX_PENDING_BUFF_SIZE constant is static. If CacheContinuousQueryEventBuffer class will be first loaded by this test, other continuous queries tests (in this JVM) can fail. If this class was already loaded and used before this test, property will have no effect and this case can fail.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445377389", "createdAt": "2020-06-25T08:00:47Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQwMDM3Nw==", "bodyText": "GridAtomicLong.setIfGreater?", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445400377", "createdAt": "2020-06-25T08:40:52Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQyMTMxNw==", "bodyText": "Why not just put random key with the random value? We don't check these values after test anyway.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445421317", "createdAt": "2020-06-25T09:16:47Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+                }\n+            }, 3, \"cq-put-\");\n+\n+            assertNotNull(\"Partition remote buffers must be inited\", pending);\n+\n+            log.warning(\"Waiting for pending buffer being overflowed within \" + OVERFLOW_TIMEOUT_MS + \" ms.\");\n+\n+            boolean await = waitForCondition(() -> pending.size() > PENDING_LIMIT, OVERFLOW_TIMEOUT_MS);\n+\n+            assertFalse(\"Pending buffer exceeded the limit despite entries have been acked \" +\n+                    \"[lastAcked=\" + lastAcked + \", pending=\" + S.compact(pending.keySet(), i -> i + 1) + ']',\n+                await);\n+        }\n+        finally {\n+            spi(locIgnite).stopBlock();\n+\n+            if (updFut != null)\n+                updFut.cancel();\n+        }\n+    }\n+\n+    /**\n+     * @param cache Ignite cache.\n+     * @param key Key to change.\n+     */\n+    private static void putX2Value(IgniteCache<Integer, Integer> cache, int key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQzMTU4OQ==", "bodyText": "I think we wait here too long. With 15 secs timeout, it's about 2.5 additional minutes for all tests.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r445431589", "createdAt": "2020-06-25T09:34:12Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.cache.configuration.FactoryBuilder;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.WithSystemProperty;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Number of pending entries.  */\n+    private static final int PENDING_LIMIT = 1100;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 15_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    @WithSystemProperty(key = \"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", value = \"1000\")\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override public IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        return super.getConfiguration(igniteInstanceName)\n+            .setCommunicationSpi(new TestRecordingCommunicationSpi())\n+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME)\n+                .setAtomicityMode(atomicityMode)\n+                .setCacheMode(cacheMode)\n+                .setBackups(1)\n+                .setAffinity(new RendezvousAffinityFunction(false, PARTS)));\n+    }\n+\n+    /** */\n+    @Before\n+    public void resetMessageCounter() {\n+        msgCntr.set(0);\n+    }\n+\n+    /** */\n+    @After\n+    public void stopAllInstances() {\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * @param locBlockPred Block predicate on local node to emulate message delivery issues.\n+     * @throws Exception If fails.\n+     */\n+    private void doTestContinuousQueryPendingBufferLimit(\n+        IgniteBiPredicate<ClusterNode, Message> locBlockPred\n+    ) throws Exception\n+    {\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+        IgniteEx locIgnite = startGrid(0);\n+        IgniteEx rmtIgnite = startGrid(1);\n+\n+        IgniteCache<Integer, Integer> cache = locIgnite.cache(DEFAULT_CACHE_NAME);\n+        CacheConfiguration<Integer, Integer> ccfg = cache.getConfiguration(CacheConfiguration.class);\n+\n+        for (int i = 0; i < TOTAL_KEYS; i++)\n+            cache.put(i, i);\n+\n+        assertEquals(PARTS, ccfg.getAffinity().partitions());\n+\n+        AtomicLong lastAcked = new AtomicLong();\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(RMT_FILTER));\n+        cq.setLocalListener((events) ->\n+            events.forEach(e ->\n+                lastAcked.getAndUpdate(c ->\n+                    Math.max(c, ((CacheQueryEntryEvent<?, ?>)e).getPartitionUpdateCounter()))));\n+        cq.setLocal(false);\n+\n+        IgniteInternalFuture<?> updFut = null;\n+\n+        try (QueryCursor<?> qry = locIgnite.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            for (int j = 0; j < TOTAL_KEYS; j++)\n+                putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+\n+            SystemView<ContinuousQueryView> rmtQryView = rmtIgnite.context().systemView().view(CQ_SYS_VIEW);\n+            assertEquals(1, rmtQryView.size());\n+\n+            UUID routineId = rmtQryView.iterator().next().routineId();\n+\n+            // Partition Id, Update Counter, Continuous Entry.\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(rmtIgnite, routineId, CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            spi(locIgnite).blockMessages(locBlockPred);\n+\n+            updFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    putX2Value(cache, rnd.nextInt(TOTAL_KEYS));\n+                }\n+            }, 3, \"cq-put-\");\n+\n+            assertNotNull(\"Partition remote buffers must be inited\", pending);\n+\n+            log.warning(\"Waiting for pending buffer being overflowed within \" + OVERFLOW_TIMEOUT_MS + \" ms.\");\n+\n+            boolean await = waitForCondition(() -> pending.size() > PENDING_LIMIT, OVERFLOW_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea8fa0cef5223469e9d7b012a170b2b5f9d64403"}, "originalPosition": 211}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "498700f3504f2cea8d659fa08e4c0f5bb88cf801", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/498700f3504f2cea8d659fa08e4c0f5bb88cf801", "committedDate": "2020-07-06T08:31:02Z", "message": "Merge branch 'master' into ignite-10959"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a28a59ca91608f873c5e399723f384047ca50bf3", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/a28a59ca91608f873c5e399723f384047ca50bf3", "committedDate": "2020-07-06T11:10:26Z", "message": "IGNITE-10959: fix review comments 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed623ac2cd2ebf842c1c822bb261255484e6bb26", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ed623ac2cd2ebf842c1c822bb261255484e6bb26", "committedDate": "2020-07-06T11:39:00Z", "message": "IGNITE-10959: fix review comments 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee948b5b016d81fb39338576d9917def99b9487e", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ee948b5b016d81fb39338576d9917def99b9487e", "committedDate": "2020-07-06T13:25:32Z", "message": "IGNITE-10959: fix review comments 4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "856f85440ee5a84ff3033cd91cd449675e8f5ff6", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/856f85440ee5a84ff3033cd91cd449675e8f5ff6", "committedDate": "2020-07-06T14:50:13Z", "message": "IGNITE-10959: make buff limit public"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8", "committedDate": "2020-07-06T19:08:05Z", "message": "IGNITE-10959: add test for pending filtered entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTExNjU0", "url": "https://github.com/apache/ignite/pull/7881#pullrequestreview-444111654", "createdAt": "2020-07-07T17:38:37Z", "commit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzozODozOFrOGuI8FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOToxMjoyOVrOGuMC8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzNDEzMw==", "bodyText": "Why do we need this field? It's not used.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451034133", "createdAt": "2020-07-07T17:38:38Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryHandler.java", "diffHunk": "@@ -99,6 +99,10 @@\n     static final int LSNR_MAX_BUF_SIZE =\n         IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_LISTENER_MAX_BUFFER_SIZE\", 10_000);\n \n+    /** Maximum size of buffer for pending events. Default value is {@code 10_000}. */\n+    public final int maxPendingBuffSize =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAzODIzNQ==", "bodyText": "Can be simplified with lambda evt -> evt.getKey() % 2 == 0", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451038235", "createdAt": "2020-07-07T17:45:41Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA0ODU4MA==", "bodyText": "I can't match comment and condition. What do you mean here?", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451048580", "createdAt": "2020-07-07T18:03:28Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {\n+            @Override public boolean evaluate(CacheEntryEvent<? extends Integer,? extends Integer> evt) {\n+                return evt.getKey() % 2 == 0;\n+            }\n+        };\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(filter));\n+        cq.setLocalListener((events) -> events.forEach(e -> {\n+            if (!filter.evaluate(e))\n+                err.compareAndSet(null, \"Key must be filtered [e=\" + e + ']');\n+        }));\n+        cq.setLocal(false);\n+\n+        spi(srv).blockMessages((nodeId, msg) -> msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+        spi(clnt).blockMessages((nodeId, msg) -> msg instanceof CacheContinuousQueryBatchAck);\n+\n+        IgniteInternalFuture<?> loadFut = null;\n+\n+        try (QueryCursor<?> qry = clnt.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            loadFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted())\n+                    clnt.cache(DEFAULT_CACHE_NAME).put(keys.incrementAndGet(), 0);\n+            }, 3, \"cq-put-\");\n+\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(grid(0), CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            waitForCondition(() -> pending.size() > MAX_PENDING_BUFF_SIZE, 15_000);\n+\n+            // Check all entries greater than limit filtered correctly.\n+            waitForCondition(() -> keys.get() > MAX_PENDING_BUFF_SIZE * 2, 15_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1Mzc2NA==", "bodyText": "We should assertFalse here.\nBut personally I don't like the idea with such big timeouts. I've run new tests and it takes about 3 minutes, and this time will be about the same on any hardware due to timeouts.\nCan we rewrite the tests using keys count limit instead of timeouts? I think MAX_PENDING_BUFF_SIZE * 3 will be enough for this test. Instead of \"wait for condition\" you can replace \"pending\" field by your own map which raise some error flag, for example, on put when size() is more than MAX_PENDING_BUFF_SIZE. The same for other tests.\nAlso in current implementation there is no synchronization between pendingCurrSize.get() > MAX_PENDING_BUFF_SIZE and pendingCurrSize.incrementAndGet(), so due to races you can get sometimes values more than limit (but no more than limit + threads count).", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451053764", "createdAt": "2020-07-07T18:13:16Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryBufferLimitTest.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.query.continuous;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.cache.configuration.FactoryBuilder;\n+import javax.cache.event.CacheEntryEvent;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheEntryEventSerializableFilter;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;\n+import org.apache.ignite.cache.query.CacheQueryEntryEvent;\n+import org.apache.ignite.cache.query.ContinuousQuery;\n+import org.apache.ignite.cache.query.QueryCursor;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheIdMessage;\n+import org.apache.ignite.internal.processors.continuous.GridContinuousProcessor;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.CU;\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+import org.apache.ignite.lang.IgniteBiPredicate;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.systemview.view.ContinuousQueryView;\n+import org.apache.ignite.spi.systemview.view.SystemView;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;\n+import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.query.continuous.CacheContinuousQueryEventBuffer.MAX_PENDING_BUFF_SIZE;\n+import static org.apache.ignite.internal.processors.continuous.GridContinuousProcessor.CQ_SYS_VIEW;\n+import static org.apache.ignite.testframework.GridTestUtils.getFieldValue;\n+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;\n+\n+/**\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class CacheContinuousQueryBufferLimitTest extends GridCommonAbstractTest {\n+    /** Cache partitions count. */\n+    private static final int PARTS = 1;\n+\n+    /** Total number of cache keys. */\n+    private static final int TOTAL_KEYS = 1024;\n+\n+    /** Timeout to wait for pending buffer overflow. */\n+    private static final long OVERFLOW_TIMEOUT_MS = 10_000L;\n+\n+    /** Default remote no-op filter. */\n+    private static final CacheEntryEventSerializableFilter<Integer, Integer> RMT_FILTER = e -> true;\n+\n+    /** Counter of cache messages being send. */\n+    private final AtomicInteger msgCntr = new AtomicInteger();\n+\n+    /** Cache mode. */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** Cache atomicity mode. */\n+    @Parameterized.Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** @return Test parameters. */\n+    @Parameterized.Parameters(name = \"cacheMode={0}, atomicityMode={1}\")\n+    public static Collection<?> parameters() {\n+        return Arrays.asList(new Object[][] {\n+            {REPLICATED, ATOMIC},\n+            {REPLICATED, TRANSACTIONAL},\n+            {PARTITIONED, ATOMIC},\n+            {PARTITIONED, TRANSACTIONAL}\n+        });\n+    }\n+\n+    /**\n+     * Local pending limit for this test is less than MAX_PENDING_BUFF_SIZE,\n+     * so pending entries must be cleaned prior to reaching it.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryBatchSwitchOnAck() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10, MAX_PENDING_BUFF_SIZE / 10);\n+    }\n+\n+    /**\n+     * The test blocks switching current CacheContinuousQueryEventBuffer.Batch to the new one, so\n+     * pending entries will be processed (dropped on backups and send to the client on primaries)\n+     * when the MAX_PENDING_BUFF_SIZE is reached.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testContinuousQueryPendingBufferLimit() throws Exception {\n+        doTestContinuousQueryPendingBufferLimit((n, msg) ->\n+            (msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10) ||\n+                msg instanceof CacheContinuousQueryBatchAck, (int)(MAX_PENDING_BUFF_SIZE * 1.1));\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testPendingSendToClientOnLimitReached() throws Exception {\n+        AtomicInteger keys = new AtomicInteger();\n+        AtomicReference<String> err = new AtomicReference<>();\n+\n+        IgniteEx srv = startGrids(2);\n+        IgniteEx clnt = startClientGrid();\n+\n+        CacheEntryEventSerializableFilter<Integer, Integer> filter = new CacheEntryEventSerializableFilter<Integer,Integer>() {\n+            @Override public boolean evaluate(CacheEntryEvent<? extends Integer,? extends Integer> evt) {\n+                return evt.getKey() % 2 == 0;\n+            }\n+        };\n+\n+        ContinuousQuery<Integer, Integer> cq = new ContinuousQuery<>();\n+        cq.setRemoteFilterFactory(FactoryBuilder.factoryOf(filter));\n+        cq.setLocalListener((events) -> events.forEach(e -> {\n+            if (!filter.evaluate(e))\n+                err.compareAndSet(null, \"Key must be filtered [e=\" + e + ']');\n+        }));\n+        cq.setLocal(false);\n+\n+        spi(srv).blockMessages((nodeId, msg) -> msg instanceof GridCacheIdMessage && msgCntr.getAndIncrement() == 10);\n+        spi(clnt).blockMessages((nodeId, msg) -> msg instanceof CacheContinuousQueryBatchAck);\n+\n+        IgniteInternalFuture<?> loadFut = null;\n+\n+        try (QueryCursor<?> qry = clnt.cache(DEFAULT_CACHE_NAME).query(cq)) {\n+            awaitPartitionMapExchange();\n+\n+            loadFut = GridTestUtils.runMultiThreadedAsync(() -> {\n+                while (!Thread.currentThread().isInterrupted())\n+                    clnt.cache(DEFAULT_CACHE_NAME).put(keys.incrementAndGet(), 0);\n+            }, 3, \"cq-put-\");\n+\n+            ConcurrentMap<Long, CacheContinuousQueryEntry> pending =\n+                getContinuousQueryPendingBuffer(grid(0), CU.cacheId(DEFAULT_CACHE_NAME), 0);\n+\n+            waitForCondition(() -> pending.size() > MAX_PENDING_BUFF_SIZE, 15_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA3MTMyMw==", "bodyText": "You should use some synchronization here, only one thread at a time should be able to remove pending entries. In other case you can iterate concurrently on the same entry, send duplicate to the client, call remove and decrement size twice (however only one entry is removed)", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451071323", "createdAt": "2020-07-07T18:46:08Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())\n+                    batch.tryRollOver(entry.topologyVersion());\n+\n+                if (pendingCurrSize.get() > MAX_PENDING_BUFF_SIZE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI4OQ==", "bodyText": "You should move this condition out from here, or at least continue the cycle after tryRollOver.\nFor example, if you have acked counter = 100 and cntr == 101 entry should not go to the pending entries map, instead it should go to current batch, since batch is rolled over. If you skip this entry in the current batch you will never switch this batch successfully, since first entry is missing in the batch and lastProc will never increment.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451083289", "createdAt": "2020-07-07T19:09:09Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -172,21 +204,51 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n                 if (res == RETRY)\n                     continue;\n             }\n-            else\n+            else {\n+                if (batch.endCntr < ackedUpdCntr.get())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4NTA0Mw==", "bodyText": "We can skip backupQ.add() if we already have acked counter more then current counter.", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451085043", "createdAt": "2020-07-07T19:12:29Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -154,6 +185,7 @@ private Object process0(long cntr, CacheContinuousQueryEntry entry, boolean back\n         Object res = null;\n \n         for (;;) {\n+            // Set batch only if batch is null (first attempt).\n             batch = initBatch(entry.topologyVersion(), backup);\n \n             if (batch == null || cntr < batch.startCntr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTg4NTQ2", "url": "https://github.com/apache/ignite/pull/7881#pullrequestreview-444188546", "createdAt": "2020-07-07T19:31:06Z", "commit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozMTowN1rOGuMokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTozMTowN1rOGuMokQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA5NDY3Mw==", "bodyText": "size() method is almost constant time operation, there is a long adder inside and usually, there is only one cell in it (but at most CPU count cells). If you have low contention on pending map access to pending.size() will cost relatively low. If you have very high contention on pending map, I think AtomicInteger.incrementAndGet() can become a bottleneck here.\nSo I'm not sure about this optimization, perhaps it's better to use pending.size().", "url": "https://github.com/apache/ignite/pull/7881#discussion_r451094673", "createdAt": "2020-07-07T19:31:07Z", "author": {"login": "alex-plekhanov"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/continuous/CacheContinuousQueryEventBuffer.java", "diffHunk": "@@ -26,40 +26,69 @@\n import java.util.TreeMap;\n import java.util.concurrent.ConcurrentLinkedDeque;\n import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.util.GridAtomicLong;\n+import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.apache.ignite.util.deque.FastSizeDeque;\n import org.jetbrains.annotations.Nullable;\n \n /**\n  *\n  */\n public class CacheContinuousQueryEventBuffer {\n-    /** */\n+    /** Maximum size of buffer for pending events. Default value is {@code 10_000}. */\n+    public static final int MAX_PENDING_BUFF_SIZE =\n+        IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_PENDING_BUFF_SIZE\", 10_000);\n+\n+    /** Batch buffer size. */\n     private static final int BUF_SIZE =\n         IgniteSystemProperties.getInteger(\"IGNITE_CONTINUOUS_QUERY_SERVER_BUFFER_SIZE\", 1000);\n \n     /** */\n     private static final Object RETRY = new Object();\n \n-    /** */\n-    protected final int part;\n+    /** Continuous query category logger. */\n+    private final IgniteLogger log;\n \n     /** */\n-    private AtomicReference<Batch> curBatch = new AtomicReference<>();\n+    private final int part;\n \n-    /** */\n-    private FastSizeDeque<CacheContinuousQueryEntry> backupQ = new FastSizeDeque<>(new ConcurrentLinkedDeque<>());\n+    /** Batch of entries currently being collected to send to the remote. */\n+    private final AtomicReference<Batch> curBatch = new AtomicReference<>();\n \n-    /** */\n-    private ConcurrentSkipListMap<Long, CacheContinuousQueryEntry> pending = new ConcurrentSkipListMap<>();\n+    /** Queue for keeping backup entries which partition counter less the counter processing by current batch. */\n+    private final FastSizeDeque<CacheContinuousQueryEntry> backupQ = new FastSizeDeque<>(new ConcurrentLinkedDeque<>());\n+\n+    /** Entries which are waiting for being processed. */\n+    private final ConcurrentSkipListMap<Long, CacheContinuousQueryEntry> pending = new ConcurrentSkipListMap<>();\n+\n+    /**\n+     * The size method of the pending ConcurrentSkipListMap is not a constant-time operation. Since each", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d436ed79f0ef5da54fdd4a7c8fac476ebd95d8"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca561e4cdf7eb4a3e3e538efbc7b8ee4b6b5a739", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ca561e4cdf7eb4a3e3e538efbc7b8ee4b6b5a739", "committedDate": "2020-07-08T08:51:57Z", "message": "IGNITE-10959: add retry to rollover, sync pending"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b31f1d3a5e989576c387b20bc2a951764bf04c7a", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/b31f1d3a5e989576c387b20bc2a951764bf04c7a", "committedDate": "2020-07-08T09:04:49Z", "message": "IGNITE-10959: remove unused vars"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7de7524483e12d3f27d3a2b7612564f65f498d4", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/c7de7524483e12d3f27d3a2b7612564f65f498d4", "committedDate": "2020-07-08T12:05:44Z", "message": "IGNITE-10959: fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8daa1c554ec944cd8e14a59645f84c8a2169783c", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/8daa1c554ec944cd8e14a59645f84c8a2169783c", "committedDate": "2020-07-08T12:59:49Z", "message": "IGNITE-10959: remove unnecessary check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29bb8e9c27e59448c5c0009b7399777b72488007", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/29bb8e9c27e59448c5c0009b7399777b72488007", "committedDate": "2020-07-08T13:24:11Z", "message": "IGNITE-10959: remove unnecessary check 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfd2e1470fe3cb2f433f41b6da25786d63d7add5", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/bfd2e1470fe3cb2f433f41b6da25786d63d7add5", "committedDate": "2020-07-08T13:27:57Z", "message": "IGNITE-10959: fix minor issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1afc728bc783a66f346174185711c8b21a24207f", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/1afc728bc783a66f346174185711c8b21a24207f", "committedDate": "2020-07-08T13:29:03Z", "message": "IGNITE-10959: fix minor issue 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8334c01d136e6ba07ed0e7fe6b66257a6fcc47f9", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/8334c01d136e6ba07ed0e7fe6b66257a6fcc47f9", "committedDate": "2020-07-08T16:22:32Z", "message": "IGNITE-10959: fix review comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzYxNTkx", "url": "https://github.com/apache/ignite/pull/7881#pullrequestreview-445361591", "createdAt": "2020-07-09T07:37:53Z", "commit": {"oid": "8334c01d136e6ba07ed0e7fe6b66257a6fcc47f9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6543662e7b36222f66464f3b5c4e74635c00766f", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/6543662e7b36222f66464f3b5c4e74635c00766f", "committedDate": "2020-07-09T13:59:58Z", "message": "IGNITE-10959: fix flaky test failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e4f9c8c2a7d7d8c514762453e3768f36a45fb50", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/6e4f9c8c2a7d7d8c514762453e3768f36a45fb50", "committedDate": "2020-07-09T16:34:04Z", "message": "IGNITE-10959: fix flaky test failures 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40f332a0e87e088f518b3a2325bcbb6a51262ecb", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/40f332a0e87e088f518b3a2325bcbb6a51262ecb", "committedDate": "2020-07-10T10:10:14Z", "message": "IGNITE-10959: fix flaky test failures 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f9136ded50915b46952f7a2ec63cf10fe8c3c85", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/6f9136ded50915b46952f7a2ec63cf10fe8c3c85", "committedDate": "2020-07-10T12:02:05Z", "message": "IGNITE-10959: fix flaky test failures 4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0ce1c7489064ae4f6238755a9027f48ebaeb045", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/c0ce1c7489064ae4f6238755a9027f48ebaeb045", "committedDate": "2020-07-10T14:25:27Z", "message": "IGNITE-10959: fix flaky test failures 5"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2555, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}