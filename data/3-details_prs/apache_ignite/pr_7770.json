{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyOTUyNzUw", "number": 7770, "title": "IGNITE-12981: Fix pme-free snapshot exchange if coordinator left the cluster", "bodyText": "Fixed:\n\nwasRebalanced flag doesn't keep after snapshot\nExchangeType must be NONE for the snapshot on a client node\nexchange aware component is not covered by test for a snapshot operation", "createdAt": "2020-05-04T13:30:01Z", "url": "https://github.com/apache/ignite/pull/7770", "merged": true, "mergeCommit": {"oid": "6ddb17fb9e346f085d7ef981442e8b62d09ee3fa"}, "closed": true, "closedAt": "2020-05-06T16:52:48Z", "author": {"login": "Mmuzaf"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcd_gCfAH2gAyNDEyOTUyNzUwOmZmNGY2MTMzYzAxYmZlZDE2MWE1MTZkYWM5ZGU1MTU2ZGZjYzIxYjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcenSReAH2gAyNDEyOTUyNzUwOjUyNmIxNmM1ODc5MmJlYjdlYzQ5OTJkZjNjMjEwZjc2YjUzN2Q4ZTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ff4f6133c01bfed161a516dac9de5156dfcc21b2", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ff4f6133c01bfed161a516dac9de5156dfcc21b2", "committedDate": "2020-05-04T13:28:54Z", "message": "IGNITE-12981: wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de45132e35086972d02b3d070c46f0962defadd5", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/de45132e35086972d02b3d070c46f0962defadd5", "committedDate": "2020-05-04T14:32:41Z", "message": "IGNITE-12981: wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "958e33e9d5114ec23dc74fc6e77322929242cef2", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/958e33e9d5114ec23dc74fc6e77322929242cef2", "committedDate": "2020-05-04T18:52:26Z", "message": "IGNITE-12981: fix was rebalanced flag causes partition resend"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "765ca0cfa3b02cd97a91ae99396f91b5bb8c052a", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/765ca0cfa3b02cd97a91ae99396f91b5bb8c052a", "committedDate": "2020-05-05T16:57:32Z", "message": "IGNITE-12981: extend test coverage for snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/ba88f3f4c411225178a25af3cb8c1dd3df2d8420", "committedDate": "2020-05-05T18:40:30Z", "message": "IGNITE-12981: remove unnecessary comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDI3MjAw", "url": "https://github.com/apache/ignite/pull/7770#pullrequestreview-406427200", "createdAt": "2020-05-06T09:05:03Z", "commit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNTowNFrOGRKIVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNTowNFrOGRKIVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk1MQ==", "bodyText": "Unnecessary line brake", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420644951", "createdAt": "2020-05-06T09:05:04Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDI3Mzg5", "url": "https://github.com/apache/ignite/pull/7770#pullrequestreview-406427389", "createdAt": "2020-05-06T09:05:22Z", "commit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNToyMlrOGRKI5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwOTowNToyMlrOGRKI5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NTA5Mw==", "bodyText": "Can be one line", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420645093", "createdAt": "2020-05-06T09:05:22Z", "author": {"login": "NSAmelchev"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testSnapshotPartitionExchangeAwareOrder() throws Exception {\n+        IgniteEx ignite = startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        Map<UUID, PartitionsExchangeAware> comps = new HashMap<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            PartitionsExchangeAware comp;\n+\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(comp = new PartitionsExchangeAware() {\n+                    /** Order of exchange calls. */\n+                    private final AtomicInteger order = new AtomicInteger();\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 0, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitAfterTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 1, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneBeforeTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 2, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneAfterTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 3, order.getAndSet(0));\n+                    }\n+                });\n+\n+            comps.put(((IgniteEx)ig).localNode().id(), comp);\n+        }\n+\n+        ignite.snapshot().createSnapshot(SNAPSHOT_NAME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420"}, "originalPosition": 204}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "526b16c58792beb7ec4992df3c210f76b537d8e0", "author": {"user": {"login": "Mmuzaf", "name": "Maxim Muzafarov"}}, "url": "https://github.com/apache/ignite/commit/526b16c58792beb7ec4992df3c210f76b537d8e0", "committedDate": "2020-05-06T11:50:04Z", "message": "IGNITE-12981: fix review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2617, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}