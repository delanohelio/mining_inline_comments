{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxODMzNjk3", "number": 7835, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwOTowMTo0MlrOEBS2PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMjoyNzo1NlrOEH8gog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzkyODI4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwOTowMTo0MlrOGdDnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzowMTowM1rOGdJnxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMTA5NQ==", "bodyText": "Do we need a method with a single usage?\nWill it be more suitable to inline it?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433121095", "createdAt": "2020-06-01T09:01:42Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -1916,6 +1924,12 @@ private void clearNodeAddedMessage(TcpDiscoveryAbstractMessage msg) {\n         return threads;\n     }\n \n+    /** @return Total timeout on complete message exchange in network over established connection. */\n+    protected long effectiveExchangeTimeout() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxOTUyNg==", "bodyText": "Removed.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433219526", "createdAt": "2020-06-01T13:01:03Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -1916,6 +1924,12 @@ private void clearNodeAddedMessage(TcpDiscoveryAbstractMessage msg) {\n         return threads;\n     }\n \n+    /** @return Total timeout on complete message exchange in network over established connection. */\n+    protected long effectiveExchangeTimeout() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMTA5NQ=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODAzNDEyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwOTo0MDo1MFrOGdEoQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzowMjoyN1rOGdJqfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNzcyOA==", "bodyText": "magic number?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433137728", "createdAt": "2020-06-01T09:40:50Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java", "diffHunk": "@@ -107,7 +107,7 @@ public void testFailFast() throws Exception {\n \n         failNode(ignite1);\n \n-        assert failLatch.await(1500, MILLISECONDS);\n+        assert failLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyMDIyMw==", "bodyText": "We always can be hit by GC pause, timer granulation, delays in other code. Not giving additional time to wait can lead to flaky tests. Makes sense?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433220223", "createdAt": "2020-06-01T13:02:27Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/test/java/org/apache/ignite/internal/GridFailFastNodeFailureDetectionSelfTest.java", "diffHunk": "@@ -107,7 +107,7 @@ public void testFailFast() throws Exception {\n \n         failNode(ignite1);\n \n-        assert failLatch.await(1500, MILLISECONDS);\n+        assert failLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNzcyOA=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODEzOTYwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoyMTowMVrOGdFpog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzo1NTowNFrOGdLW5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDQ2Ng==", "bodyText": "We should wait FDT - (cutTime - lastMesssentTime) here, not full FDT.\n\n\nThis code will fail if we wait for 0.8 of FDT in the first case and 0.1 in the second, but everything will be fine in general.\nIt seems you should wait for the rest of the timeout at the first case, but for the rest of the rest it at second.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433154466", "createdAt": "2020-06-01T10:21:01Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3611,15 +3602,26 @@ else if (!spi.failureDetectionTimeoutEnabled() && (e instanceof\n                                 if (latencyCheck && log.isInfoEnabled())\n                                     log.info(\"Latency check message has been written to socket: \" + msg.id());\n \n+                                boolean ping = msg instanceof TcpDiscoveryConnectionCheckMessage;\n+\n+                                long timeout = timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout());\n+\n+                                // For the ping we take half of actual failure detection. Another half is the interval.\n                                 spi.writeToSocket(newNextNode ? newNext : next,\n                                     sock,\n                                     out,\n                                     msg,\n-                                    timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout()));\n+                                    ping && spi.failureDetectionTimeoutEnabled() ? timeout / 2 : timeout\n+                                );\n+\n+                                timeout = timeoutHelper.nextTimeoutChunk(ackTimeout0);\n \n                                 long tsNanos0 = System.nanoTime();\n \n-                                int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n+                                int res = spi.readReceipt(sock, ping && spi.failureDetectionTimeoutEnabled() ?\n+                                    timeout / 2 : timeout);\n+\n+                                updateLastSentMessageTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI0Nzk3NQ==", "bodyText": "This would require us to check connection often. Like connCheckInterval = spi.failureDetectionTimeout() / 4.. Otherwise we can leave too short timeout to any message if it is being sent just before next ping: quite long time passed since the last message. Is it OK?\n\n\nDidn't catch you. We do wait for rest of the rest in second case:\n\n\ntimeout = timeoutHelper.nextTimeoutChunk(ackTimeout0); - this is rest of the rest. Makes sense?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433247975", "createdAt": "2020-06-01T13:55:04Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3611,15 +3602,26 @@ else if (!spi.failureDetectionTimeoutEnabled() && (e instanceof\n                                 if (latencyCheck && log.isInfoEnabled())\n                                     log.info(\"Latency check message has been written to socket: \" + msg.id());\n \n+                                boolean ping = msg instanceof TcpDiscoveryConnectionCheckMessage;\n+\n+                                long timeout = timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout());\n+\n+                                // For the ping we take half of actual failure detection. Another half is the interval.\n                                 spi.writeToSocket(newNextNode ? newNext : next,\n                                     sock,\n                                     out,\n                                     msg,\n-                                    timeoutHelper.nextTimeoutChunk(spi.getSocketTimeout()));\n+                                    ping && spi.failureDetectionTimeoutEnabled() ? timeout / 2 : timeout\n+                                );\n+\n+                                timeout = timeoutHelper.nextTimeoutChunk(ackTimeout0);\n \n                                 long tsNanos0 = System.nanoTime();\n \n-                                int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n+                                int res = spi.readReceipt(sock, ping && spi.failureDetectionTimeoutEnabled() ?\n+                                    timeout / 2 : timeout);\n+\n+                                updateLastSentMessageTime();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDQ2Ng=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI0Nzk4OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowMzoxMVrOGdGsLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzoxODozM1rOGdKJfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTUwMw==", "bodyText": "what the reason to set sent time here?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433171503", "createdAt": "2020-06-01T11:03:11Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3469,6 +3456,8 @@ else if (log.isTraceEnabled())\n                                         }\n                                     }\n \n+                                    updateLastSentMessageTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyODE1OA==", "bodyText": "We\u2019ve just initialized successful connection to next node. We just sent TcpDiscoveryHandshakeRequest message. This means: this connection is definitely ok and should not be checked right now. Also, we just sent a message. We rely on the time of last message sent and we fixate it here. Looks correct to me.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433228158", "createdAt": "2020-06-01T13:18:33Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3469,6 +3456,8 @@ else if (log.isTraceEnabled())\n                                         }\n                                     }\n \n+                                    updateLastSentMessageTime();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTUwMw=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI0ODMwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowMzoxN1rOGdGsWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzoyMToxOVrOGdKO8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTU0Ng==", "bodyText": "what the reason to set sent time here?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433171546", "createdAt": "2020-06-01T11:03:17Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3574,6 +3563,8 @@ else if (!spi.failureDetectionTimeoutEnabled() && (e instanceof\n \n                                     int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n \n+                                    updateLastSentMessageTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyOTU1NQ==", "bodyText": "We just sent one or several pending messages. Every message can take time, also every message checks connection. We rely on the time of last sent message. We should fixate this time when do really send message. We do it in this part of code too.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433229555", "createdAt": "2020-06-01T13:21:19Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -3574,6 +3563,8 @@ else if (!spi.failureDetectionTimeoutEnabled() && (e instanceof\n \n                                     int res = spi.readReceipt(sock, timeoutHelper.nextTimeoutChunk(ackTimeout0));\n \n+                                    updateLastSentMessageTime();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTU0Ng=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI1OTI3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowNzowN1rOGdGyvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMjowNToxNVrOGnmE7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg==", "bodyText": "why changed?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433173182", "createdAt": "2020-06-01T11:07:07Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java", "diffHunk": "@@ -303,7 +303,7 @@ public int boundPort() throws IgniteSpiException {\n     /**\n      * @return connection check interval.\n      */\n-    public long connectionCheckInterval() {\n+    long connectionCheckInterval() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzMTE0OA==", "bodyText": "To increase encapsulation once we touched it. Internal usages inly, not an interface.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433231148", "createdAt": "2020-06-01T13:24:29Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java", "diffHunk": "@@ -303,7 +303,7 @@ public int boundPort() throws IgniteSpiException {\n     /**\n      * @return connection check interval.\n      */\n-    public long connectionCheckInterval() {\n+    long connectionCheckInterval() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2MjUyNg==", "bodyText": "We shouldn't reduce visibility of methods in public API. It is highly unlikely of course that there are users calling this method directly but concealing of method is definitely a breaking change. We could target it to 3.0 version but in minor releases it is not acceptable.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444162526", "createdAt": "2020-06-23T11:47:56Z", "author": {"login": "sergey-chugunov-1985"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java", "diffHunk": "@@ -303,7 +303,7 @@ public int boundPort() throws IgniteSpiException {\n     /**\n      * @return connection check interval.\n      */\n-    public long connectionCheckInterval() {\n+    long connectionCheckInterval() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE3MTUwMA==", "bodyText": "We shouldn't reduce visibility of methods in public API. It is highly unlikely of course that there are users calling this method directly but concealing of method is definitely a breaking change. We could target it to 3.0 version but in minor releases it is not acceptable.\n\nFixed.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444171500", "createdAt": "2020-06-23T12:05:15Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoveryImpl.java", "diffHunk": "@@ -303,7 +303,7 @@ public int boundPort() throws IgniteSpiException {\n     /**\n      * @return connection check interval.\n      */\n-    public long connectionCheckInterval() {\n+    long connectionCheckInterval() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzE4Mg=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI2MDY3OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowNzozNFrOGdGzjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzoxMjoxMlrOGdJ8lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzM5MQ==", "bodyText": "magic number", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433173391", "createdAt": "2020-06-01T11:07:34Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.util.concurrent.Exchanger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.util.GridTestClockTimer;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryConnectionCheckMessage;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeFailedMessage;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static com.sun.tools.javac.util.Assert.check;\n+\n+/**\n+ * Checks pinging next node in the ring relies on configured timeouts.\n+ */\n+public class ConnectionCheckTest extends GridCommonAbstractTest {\n+    /** Number of the ping messages to ensure node pinging works well. */\n+    private static final int PING_MESSAGES_CNT_TO_ENSURE = 15;\n+\n+    /** Timer granulation in milliseconds. See {@link GridTestClockTimer}. */\n+    private static final int TIMER_GRANULATION = 10;\n+\n+    /**\n+     * Maximal additional delay before sending the ping message including timer granulation in and other delays\n+     * like code delays and/or GC.\n+     */\n+    private static final int ACCEPTABLE_ADDITIONAL_DELAY = TIMER_GRANULATION + 50;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyNDg1Mg==", "bodyText": "magic number\n\nThere is a comment: \"Maximal additional delay before sending the ping message including timer granulation in and other delays like code delays and/or GC\"\nWe always can be hit by GC pause, timer granulation, delays in other code. Not giving additional time to wait can lead to flaky tests. Makes sense?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433224852", "createdAt": "2020-06-01T13:12:12Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/ConnectionCheckTest.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.util.concurrent.Exchanger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.util.GridTestClockTimer;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryConnectionCheckMessage;\n+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeFailedMessage;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static com.sun.tools.javac.util.Assert.check;\n+\n+/**\n+ * Checks pinging next node in the ring relies on configured timeouts.\n+ */\n+public class ConnectionCheckTest extends GridCommonAbstractTest {\n+    /** Number of the ping messages to ensure node pinging works well. */\n+    private static final int PING_MESSAGES_CNT_TO_ENSURE = 15;\n+\n+    /** Timer granulation in milliseconds. See {@link GridTestClockTimer}. */\n+    private static final int TIMER_GRANULATION = 10;\n+\n+    /**\n+     * Maximal additional delay before sending the ping message including timer granulation in and other delays\n+     * like code delays and/or GC.\n+     */\n+    private static final int ACCEPTABLE_ADDITIONAL_DELAY = TIMER_GRANULATION + 50;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzM5MQ=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODI2MDk5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowNzo0NlrOGdGzxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzoxMjo1M1rOGdJ9_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzQ0Nw==", "bodyText": "magic number?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433173447", "createdAt": "2020-06-01T11:07:46Z", "author": {"login": "anton-vinogradov"}, "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java", "diffHunk": "@@ -1976,7 +1976,8 @@ private void checkFailedCoordinatorNode(SegmentationPolicy segPlc) throws Except\n \n             ignite1.configuration().getDiscoverySpi().failNode(coordId, null);\n \n-            assertTrue(failedLatch.await(2000, MILLISECONDS));\n+            // Wait for the configured timeout + other possible code delays.\n+            assertTrue(failedLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyNTIxMw==", "bodyText": "Same here.\nThere is a comment: \"Wait for the configured timeout + other possible code delays.\"\nWe always can be hit by GC pause, timer granulation, delays in other code. Not giving additional time to wait can lead to flaky tests. Makes sense?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r433225213", "createdAt": "2020-06-01T13:12:53Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/test/java/org/apache/ignite/spi/discovery/tcp/TcpDiscoverySelfTest.java", "diffHunk": "@@ -1976,7 +1976,8 @@ private void checkFailedCoordinatorNode(SegmentationPolicy segPlc) throws Except\n \n             ignite1.configuration().getDiscoverySpi().failNode(coordId, null);\n \n-            assertTrue(failedLatch.await(2000, MILLISECONDS));\n+            // Wait for the configured timeout + other possible code delays.\n+            assertTrue(failedLatch.await(ignite1.configuration().getFailureDetectionTimeout() + 50, MILLISECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MzQ0Nw=="}, "originalCommit": {"oid": "dc2375627a678008cef6256546af8b333135c941"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NzY2ODgyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMjoyNzo1NlrOGnm1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMjo0MjoxNVrOGnnWRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4MzkwMA==", "bodyText": "Why not to call updateLastSentMessageTime method here as well?", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444183900", "createdAt": "2020-06-23T12:27:56Z", "author": {"login": "sergey-chugunov-1985"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -6192,40 +6188,21 @@ private void checkMetricsReceiving() {\n         }\n \n         /**\n-         * Check connection aliveness status.\n+         * Check connection to next node in the ring.\n          */\n         private void checkConnection() {\n             Boolean hasRemoteSrvNodes = null;\n \n-            if (spi.failureDetectionTimeoutEnabled() && !failureThresholdReached &&\n-                U.millisSinceNanos(locNode.lastExchangeTimeNanos()) >= connCheckThreshold &&\n-                spiStateCopy() == CONNECTED &&\n-                (hasRemoteSrvNodes = ring.hasRemoteServerNodes())) {\n-\n-                if (log.isInfoEnabled())\n-                    log.info(\"Local node seems to be disconnected from topology (failure detection timeout \" +\n-                        \"is reached) [failureDetectionTimeout=\" + spi.failureDetectionTimeout() +\n-                        \", connCheckInterval=\" + CON_CHECK_INTERVAL + ']');\n-\n-                failureThresholdReached = true;\n-\n-                // Reset sent time deliberately to force sending connection check message.\n-                lastTimeConnCheckMsgSent = 0;\n-            }\n-\n-            long elapsed = (lastTimeConnCheckMsgSent + CON_CHECK_INTERVAL) - U.currentTimeMillis();\n+            long elapsed = (lastRingMsgSentTime + U.millisToNanos(connCheckInterval)) - System.nanoTime();\n \n             if (elapsed > 0)\n                 return;\n \n             if (hasRemoteSrvNodes == null)\n                 hasRemoteSrvNodes = ring.hasRemoteServerNodes();\n \n-            if (hasRemoteSrvNodes) {\n+            if (hasRemoteSrvNodes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9c3108fd15e34c0d9ccc59eedfe41f1b3d256b4"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4OTAwMg==", "bodyText": "Why not to call updateLastSentMessageTime method here as well?\n\nWe hasn't successfully sent message here, we hasn't received RES_OK.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444189002", "createdAt": "2020-06-23T12:36:57Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -6192,40 +6188,21 @@ private void checkMetricsReceiving() {\n         }\n \n         /**\n-         * Check connection aliveness status.\n+         * Check connection to next node in the ring.\n          */\n         private void checkConnection() {\n             Boolean hasRemoteSrvNodes = null;\n \n-            if (spi.failureDetectionTimeoutEnabled() && !failureThresholdReached &&\n-                U.millisSinceNanos(locNode.lastExchangeTimeNanos()) >= connCheckThreshold &&\n-                spiStateCopy() == CONNECTED &&\n-                (hasRemoteSrvNodes = ring.hasRemoteServerNodes())) {\n-\n-                if (log.isInfoEnabled())\n-                    log.info(\"Local node seems to be disconnected from topology (failure detection timeout \" +\n-                        \"is reached) [failureDetectionTimeout=\" + spi.failureDetectionTimeout() +\n-                        \", connCheckInterval=\" + CON_CHECK_INTERVAL + ']');\n-\n-                failureThresholdReached = true;\n-\n-                // Reset sent time deliberately to force sending connection check message.\n-                lastTimeConnCheckMsgSent = 0;\n-            }\n-\n-            long elapsed = (lastTimeConnCheckMsgSent + CON_CHECK_INTERVAL) - U.currentTimeMillis();\n+            long elapsed = (lastRingMsgSentTime + U.millisToNanos(connCheckInterval)) - System.nanoTime();\n \n             if (elapsed > 0)\n                 return;\n \n             if (hasRemoteSrvNodes == null)\n                 hasRemoteSrvNodes = ring.hasRemoteServerNodes();\n \n-            if (hasRemoteSrvNodes) {\n+            if (hasRemoteSrvNodes)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4MzkwMA=="}, "originalCommit": {"oid": "d9c3108fd15e34c0d9ccc59eedfe41f1b3d256b4"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5MjMyNQ==", "bodyText": "As you can see, we call updateLastSentMessageTime() after successful reading spi.readReceipt or proper TcpDiscoveryHandshakeResponse. These are the places where we are sure the message was sent and connection is OK.", "url": "https://github.com/apache/ignite/pull/7835#discussion_r444192325", "createdAt": "2020-06-23T12:42:15Z", "author": {"login": "Vladsz83"}, "path": "modules/core/src/main/java/org/apache/ignite/spi/discovery/tcp/ServerImpl.java", "diffHunk": "@@ -6192,40 +6188,21 @@ private void checkMetricsReceiving() {\n         }\n \n         /**\n-         * Check connection aliveness status.\n+         * Check connection to next node in the ring.\n          */\n         private void checkConnection() {\n             Boolean hasRemoteSrvNodes = null;\n \n-            if (spi.failureDetectionTimeoutEnabled() && !failureThresholdReached &&\n-                U.millisSinceNanos(locNode.lastExchangeTimeNanos()) >= connCheckThreshold &&\n-                spiStateCopy() == CONNECTED &&\n-                (hasRemoteSrvNodes = ring.hasRemoteServerNodes())) {\n-\n-                if (log.isInfoEnabled())\n-                    log.info(\"Local node seems to be disconnected from topology (failure detection timeout \" +\n-                        \"is reached) [failureDetectionTimeout=\" + spi.failureDetectionTimeout() +\n-                        \", connCheckInterval=\" + CON_CHECK_INTERVAL + ']');\n-\n-                failureThresholdReached = true;\n-\n-                // Reset sent time deliberately to force sending connection check message.\n-                lastTimeConnCheckMsgSent = 0;\n-            }\n-\n-            long elapsed = (lastTimeConnCheckMsgSent + CON_CHECK_INTERVAL) - U.currentTimeMillis();\n+            long elapsed = (lastRingMsgSentTime + U.millisToNanos(connCheckInterval)) - System.nanoTime();\n \n             if (elapsed > 0)\n                 return;\n \n             if (hasRemoteSrvNodes == null)\n                 hasRemoteSrvNodes = ring.hasRemoteServerNodes();\n \n-            if (hasRemoteSrvNodes) {\n+            if (hasRemoteSrvNodes)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE4MzkwMA=="}, "originalCommit": {"oid": "d9c3108fd15e34c0d9ccc59eedfe41f1b3d256b4"}, "originalPosition": 191}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2448, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}