{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNjk5NjQ0", "number": 7071, "title": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "bodyText": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack", "createdAt": "2020-01-14T15:36:15Z", "url": "https://github.com/hortonworks/cloudbreak/pull/7071", "merged": true, "mergeCommit": {"oid": "46f1065a31d4c6b8181194ae4c208138a27855a5"}, "closed": true, "closedAt": "2020-01-20T14:32:30Z", "author": {"login": "gregito"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6idp7AFqTM0MzA5MTM3Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8MHhsAFqTM0NTI4OTU4MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDkxMzc2", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-343091376", "createdAt": "2020-01-15T09:41:50Z", "commit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTo0MTo1MVrOFdyS4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTo1MDo1NlrOFdykig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NzA1Ng==", "bodyText": "if we really need this log, it should be debug or trace", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366777056", "createdAt": "2020-01-15T09:41:51Z", "author": {"login": "lacikaaa"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java", "diffHunk": "@@ -75,26 +79,36 @@\n         return result;\n     }\n \n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform) {\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n+        addEnvironmentNameToMapIfValueIsNotNullOrEmpty(result, environmentName, platform);\n         if (sourceMap == null || Strings.isNullOrEmpty(sourceMap.get(transform(OWNER.key(), platform)))) {\n             result.put(transform(OWNER.key(), platform), transform(cbUser, platform));\n         }\n         result.put(transform(CDP_CREATION_TIMESTAMP.key(), platform), transform(String.valueOf(clock.getCurrentInstant().getEpochSecond()), platform));\n         return result;\n     }\n \n-    private String transform(String value, String platform) {\n+    public void addEnvironmentNameToMapIfValueIsNotNullOrEmpty(Map<String, String> hereTo, String environmentName, String platform) {\n+        if (StringUtils.isNotEmpty(environmentName)) {\n+            hereTo.put(transform(ENVIRONMENT_NAME.key(), platform), environmentName);\n+        } else {\n+            LOGGER.info(\"Unable to add EnvironmentName - cost - tag to the resource's default tags because it's value is empty or null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDE0OQ==", "bodyText": "you should log the exception here", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366780149", "createdAt": "2020-01-15T09:48:13Z", "author": {"login": "lacikaaa"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java", "diffHunk": "@@ -84,4 +82,13 @@ public void prepareEnvironment(StackViewV4Response stackViewResponse) {\n         }\n     }\n \n+    public Optional<DetailedEnvironmentResponse> getEnvironmentByCrn(String crn) {\n+        try {\n+            return Optional.ofNullable(environmentClientService.getByCrn(crn));\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Unable to fetch environment by crn: {}\", crn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MTU3OA==", "bodyText": "please do it then :)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366781578", "createdAt": "2020-01-15T09:50:56Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaCreationService.java", "diffHunk": "@@ -108,7 +108,7 @@ public DescribeFreeIpaResponse launchFreeIpa(CreateFreeIpaRequest request, Strin\n         String userCrn = crnService.getUserCrn();\n         Future<User> userFuture = intermediateBuilderExecutor.submit(() -> umsClient.getUserDetails(userCrn, userCrn, MDCUtils.getRequestId()));\n         Credential credential = credentialService.getCredentialByEnvCrn(request.getEnvironmentCrn());\n-        Stack stack = stackConverter.convert(request, accountId, userFuture, credential.getCloudPlatform());\n+        Stack stack = stackConverter.convert(request, accountId, userFuture, credential.getCloudPlatform()); // TODO: 2020. 01. 10. add environment name as a new tag for applicationTag", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDk2MDU5", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-343096059", "createdAt": "2020-01-15T09:49:29Z", "commit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTo0OToyOVrOFdyhlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxNDoyNlrOFdzTXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDgyMg==", "bodyText": "I would make the name shorter, like addEnvironmentNameIfPresent", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366780822", "createdAt": "2020-01-15T09:49:29Z", "author": {"login": "gergopapi2"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java", "diffHunk": "@@ -75,26 +79,36 @@\n         return result;\n     }\n \n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform) {\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n+        addEnvironmentNameToMapIfValueIsNotNullOrEmpty(result, environmentName, platform);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NDU5Nw==", "bodyText": "Most of the other tags do have cdp in their text. Question: does the env name not need the cdp prefix?", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366784597", "createdAt": "2020-01-15T09:56:37Z", "author": {"login": "gergopapi2"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/type/DefaultApplicationTag.java", "diffHunk": "@@ -5,6 +5,7 @@\n     OWNER(\"Owner\"),\n     CDP_USER_NAME(\"cdp-user-name\"),\n     CDP_CB_VERSION(\"cdp-cb-version\"),\n+    ENVIRONMENT_NAME(\"environment-name\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NTcwNA==", "bodyText": "In tests I would not reuse constants of the productive code, but rather redefine them. This would guard against accidental text change of ENVIRONMENT_NAME key.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366785704", "createdAt": "2020-01-15T09:58:42Z", "author": {"login": "gergopapi2"}, "path": "cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java", "diffHunk": "@@ -49,12 +46,13 @@ public void testPrepareDefaultTagsForAWSShouldReturnAllDefaultMap() {\n         long epochSeconds = 1526991986L;\n         when(clock.getCurrentInstant()).thenReturn(Instant.ofEpochSecond(epochSeconds));\n \n-        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS);\n+        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS, ENV_NAME);\n \n-        Assert.assertEquals(4L, result.size());\n+        Assert.assertEquals(5L, result.size());\n         Assert.assertEquals(\"apache1@apache.com\", result.get(DefaultApplicationTag.CDP_USER_NAME.key()));\n         Assert.assertEquals(\"2.2.0\", result.get(DefaultApplicationTag.CDP_CB_VERSION.key()));\n         Assert.assertEquals(\"apache1@apache.com\", result.get(DefaultApplicationTag.OWNER.key()));\n+        Assert.assertEquals(ENV_NAME, result.get(DefaultApplicationTag.ENVIRONMENT_NAME.key()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzQ1OA==", "bodyText": "In this file there is no other change just the order of imports. I would exclude this change from this commit.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366787458", "createdAt": "2020-01-15T10:02:02Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/v4/StackV4Controller.java", "diffHunk": "@@ -1,16 +1,5 @@\n package com.sequenceiq.cloudbreak.controller.v4;\n \n-import java.util.ArrayList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5MzA0MA==", "bodyText": "I would put this method into EnvironmentClientService", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366793040", "createdAt": "2020-01-15T10:13:23Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/EnvironmentServiceDecorator.java", "diffHunk": "@@ -84,4 +82,13 @@ public void prepareEnvironment(StackViewV4Response stackViewResponse) {\n         }\n     }\n \n+    public Optional<DetailedEnvironmentResponse> getEnvironmentByCrn(String crn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5MzU2NA==", "bodyText": "The only change in this file is this blank line, I would exclude it from the changes.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r366793564", "createdAt": "2020-01-15T10:14:26Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -346,4 +346,5 @@ private void validateAccessDto(StackAccessDto dto) {\n             throw new BadRequestException(\"A stack name or crn must be provided. One and only one of them.\");\n         }\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/e19cca60c3751c9d85250664ea5d65cd8b4f4a6a", "committedDate": "2020-01-14T15:35:01Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}, "afterCommit": {"oid": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/549bc13f61d59ced302fd7b4d3ad57042e6a254b", "committedDate": "2020-01-15T11:29:57Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "549bc13f61d59ced302fd7b4d3ad57042e6a254b", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/549bc13f61d59ced302fd7b4d3ad57042e6a254b", "committedDate": "2020-01-15T11:29:57Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}, "afterCommit": {"oid": "5ffd882f2f538d477319ed5eef22e9ac52a33e23", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/5ffd882f2f538d477319ed5eef22e9ac52a33e23", "committedDate": "2020-01-15T11:38:44Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ffd882f2f538d477319ed5eef22e9ac52a33e23", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/5ffd882f2f538d477319ed5eef22e9ac52a33e23", "committedDate": "2020-01-15T11:38:44Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}, "afterCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/214703601ab8ec56163dfb18b07d5a3108eb3c5f", "committedDate": "2020-01-16T10:57:52Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDgwMTE3", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-344480117", "createdAt": "2020-01-17T10:14:15Z", "commit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMDoxNDoxNVrOFe0cpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMDoxNDoxNVrOFe0cpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2MDkwMA==", "bodyText": "this is not in sync with parameter name", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367860900", "createdAt": "2020-01-17T10:14:15Z", "author": {"login": "lacikaaa"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingService.java", "diffHunk": "@@ -75,26 +82,39 @@\n         return result;\n     }\n \n-    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform) {\n+    @Override\n+    public Map<String, String> prepareDefaultTags(String cbUser, Map<String, String> sourceMap, String platform, String environmentName) {\n+        LOGGER.debug(\"About to prepare default tag(s)...\");\n         Map<String, String> result = new HashMap<>();\n         result.put(transform(CDP_USER_NAME.key(), platform), transform(cbUser, platform));\n         result.put(transform(CDP_CB_VERSION.key(), platform), transform(cbVersion, platform));\n+        addEnvironmentCrnIfPresent(result, environmentName, platform);\n         if (sourceMap == null || Strings.isNullOrEmpty(sourceMap.get(transform(OWNER.key(), platform)))) {\n             result.put(transform(OWNER.key(), platform), transform(cbUser, platform));\n         }\n         result.put(transform(CDP_CREATION_TIMESTAMP.key(), platform), transform(String.valueOf(clock.getCurrentInstant().getEpochSecond()), platform));\n+        LOGGER.debug(\"The following default tag(s) has prepared: {}\", result);\n         return result;\n     }\n \n-    private String transform(String value, String platform) {\n+    public void addEnvironmentCrnIfPresent(Map<String, String> hereTo, String environmentCrn, String platform) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NDU4Mzg0", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-344458384", "createdAt": "2020-01-17T09:36:52Z", "commit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwOTozNjo1MlrOFezaVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMDo1MDoyNlrOFe1XyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MzkyNg==", "bodyText": "Nuance thing: I would name this variable defaultTagMap instead of result.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367843926", "createdAt": "2020-01-17T09:36:52Z", "author": {"login": "gergopapi2"}, "path": "cloud-common/src/test/java/com/sequenceiq/cloudbreak/common/service/DefaultCostTaggingServiceTest.java", "diffHunk": "@@ -49,12 +54,13 @@ public void testPrepareDefaultTagsForAWSShouldReturnAllDefaultMap() {\n         long epochSeconds = 1526991986L;\n         when(clock.getCurrentInstant()).thenReturn(Instant.ofEpochSecond(epochSeconds));\n \n-        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS);\n+        Map<String, String> result = underTest.prepareDefaultTags(CB_USER, new HashMap<>(), CloudConstants.AWS, ENV_CRN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2Njk5NQ==", "bodyText": "I would add the valid() call here. Otherwise the valid call has to be made every time, that is error-prone.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367866995", "createdAt": "2020-01-17T10:29:11Z", "author": {"login": "gergopapi2"}, "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/dto/ResourceAccessDto.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.sequenceiq.cloudbreak.api.endpoint.v4.dto;\n+\n+import static com.sequenceiq.cloudbreak.util.NullUtil.throwIfNull;\n+import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n+\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+public class ResourceAccessDto {\n+\n+    public static final String NULL_DTO_EXCEPTION_MESSAGE = \"AccessDto should not be null\";\n+\n+    public static final String INVALID_RESOURCE_ACCESS_DTO_EXCEPTION_MESSAGE = \"One and only one value of the crn and name should be filled!\";\n+\n+    private final String name;\n+\n+    private final String crn;\n+\n+    protected ResourceAccessDto(String name, String crn) {\n+        this.name = name;\n+        this.crn = crn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getCrn() {\n+        return crn;\n+    }\n+\n+    public static void validate(ResourceAccessDto dto) {\n+        throwIfNull(dto, () -> new IllegalArgumentException(NULL_DTO_EXCEPTION_MESSAGE));\n+        if (dto.isNotValid()) {\n+            throw new BadRequestException(INVALID_RESOURCE_ACCESS_DTO_EXCEPTION_MESSAGE);\n+        }\n+    }\n+\n+    public boolean isNotValid() {\n+        return !isValid();\n+    }\n+\n+    public boolean isValid() {\n+        return isNotEmpty(name) ^ isNotEmpty(crn);\n+    }\n+\n+    public static class ResourceAccessDtoBuilder {\n+\n+        private String name;\n+\n+        private String crn;\n+\n+        public static ResourceAccessDtoBuilder aResourceAccessDtoBuilder() {\n+            return new ResourceAccessDtoBuilder();\n+        }\n+\n+        public ResourceAccessDtoBuilder withName(String name) {\n+            if (isNotEmpty(name)) {\n+                this.name = name;\n+            }\n+            return this;\n+        }\n+\n+        public ResourceAccessDtoBuilder withCrn(String crn) {\n+            if (isNotEmpty(crn)) {\n+                this.crn = crn;\n+            }\n+            return this;\n+        }\n+\n+        public ResourceAccessDto build() {\n+            return new ResourceAccessDto(name, crn);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MTAyNQ==", "bodyText": "I would refactor this and the stackCommonService.deleteMultipleInstances... method: I would pass both name and crn and would merge the byName and byCrn methods, they just differ in one line.\nAlso, I would do this for the other methods like putStop, putStart, etc. Those are even larger methods, differing also in just 1 line.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367871025", "createdAt": "2020-01-17T10:38:33Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjEzOQ==", "bodyText": "I would make just one call, as syncInWorkspace handles the either name or crn case.", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872139", "createdAt": "2020-01-17T10:41:09Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjU0Mg==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872542", "createdAt": "2020-01-17T10:42:09Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3MjU4Ng==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872586", "createdAt": "2020-01-17T10:42:15Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3Mjc2MA==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367872760", "createdAt": "2020-01-17T10:42:39Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NDM1Mw==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367874353", "createdAt": "2020-01-17T10:46:22Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NDQzNw==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367874437", "createdAt": "2020-01-17T10:46:33Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NDUxOA==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367874518", "createdAt": "2020-01-17T10:46:44Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteWithKerberosByNameInWorkspace(resourceAccessDto.getName(), workspaceId, forced);\n         } else {\n-            stackCommonService.deleteWithKerberosByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, forced);\n+            stackCommonService.deleteWithKerberosByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, forced);\n         }\n     }\n \n-    public StackV4Request getRequest(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return stackService.getStackRequestByNameInWorkspaceId(stackAccessDto.getName(), workspaceId);\n+    public StackV4Request getRequest(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTE2OA==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875168", "createdAt": "2020-01-17T10:48:22Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteWithKerberosByNameInWorkspace(resourceAccessDto.getName(), workspaceId, forced);\n         } else {\n-            stackCommonService.deleteWithKerberosByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, forced);\n+            stackCommonService.deleteWithKerberosByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, forced);\n         }\n     }\n \n-    public StackV4Request getRequest(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return stackService.getStackRequestByNameInWorkspaceId(stackAccessDto.getName(), workspaceId);\n+    public StackV4Request getRequest(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return stackService.getStackRequestByNameInWorkspaceId(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            return stackService.getStackRequestByCrnInWorkspaceId(stackAccessDto.getCrn(), workspaceId);\n+            return stackService.getStackRequestByCrnInWorkspaceId(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public StackStatusV4Response getStatus(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public StackStatusV4Response getStatus(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTU4OA==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there).", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875588", "createdAt": "2020-01-17T10:49:21Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -145,139 +146,140 @@ public StackV4Response get(@NotNull StackAccessDto stackAccessDto, Long workspac\n         return stackResponse;\n     }\n \n-    public StackViewV4Response getForInternalCrn(@NotNull StackAccessDto stackAccessDto, StackType stackType) {\n+    public StackViewV4Response getForInternalCrn(ResourceAccessDto resourceAccessDto, StackType stackType) {\n         LOGGER.info(\"Validate stack against internal user.\");\n-        validateAccessDto(stackAccessDto);\n-        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(stackAccessDto.getCrn(), stackType);\n-        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", stackAccessDto.getCrn());\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        StackApiView stackApiView = stackApiViewService.retrieveStackByCrnAndType(resourceAccessDto.getCrn(), stackType);\n+        LOGGER.info(\"Query Stack (view) successfully finished with crn {}\", resourceAccessDto.getCrn());\n         StackViewV4Response stackViewV4Response = converterUtil.convert(stackApiView, StackViewV4Response.class);\n         LOGGER.info(\"Adding environment name to the response.\");\n         environmentServiceDecorator.prepareEnvironment(stackViewV4Response);\n         return stackViewV4Response;\n     }\n \n-    public void deleteInstance(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced, String instanceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteInstanceByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceId, forced);\n+    public void deleteInstance(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced, String instanceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteInstanceByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceId, forced);\n         } else {\n-            stackCommonService.deleteInstanceByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceId, forced);\n+            stackCommonService.deleteInstanceByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceId, forced);\n         }\n     }\n \n-    public void deleteInstances(StackAccessDto stackAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteMultipleInstancesByNameInWorkspace(stackAccessDto.getName(), workspaceId, instanceIds, forced);\n+    public void deleteInstances(ResourceAccessDto resourceAccessDto, Long workspaceId, List<String> instanceIds, boolean forced) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteMultipleInstancesByNameInWorkspace(resourceAccessDto.getName(), workspaceId, instanceIds, forced);\n         } else {\n-            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, instanceIds, forced);\n+            stackCommonService.deleteMultipleInstancesByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, instanceIds, forced);\n         }\n     }\n \n-    public void sync(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.syncInWorkspace(stackAccessDto.getName(), null, workspaceId);\n+    public void sync(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.syncInWorkspace(resourceAccessDto.getName(), null, workspaceId);\n         } else {\n-            stackCommonService.syncInWorkspace(null, stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.syncInWorkspace(null, resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void retry(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.retryInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void retry(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.retryInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.retryInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.retryInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStop(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStopInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStop(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStopInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStopInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStopInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putStart(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.putStartInWorkspaceByName(stackAccessDto.getName(), workspaceId);\n+    public void putStart(ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.putStartInWorkspaceByName(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stackCommonService.putStartInWorkspaceByCrn(stackAccessDto.getCrn(), workspaceId);\n+            stackCommonService.putStartInWorkspaceByCrn(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public void putScaling(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n-        stackCommonService.putScalingInWorkspace(stackAccessDto.getName(), workspaceId, updateRequest);\n+    public void putScaling(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackScaleV4Request updateRequest) {\n+        stackCommonService.putScalingInWorkspace(resourceAccessDto.getName(), workspaceId, updateRequest);\n     }\n \n-    public void repairCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.repairClusterByName(workspaceId, stackAccessDto.getName(), clusterRepairRequest);\n+    public void repairCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid ClusterRepairV4Request clusterRepairRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.repairClusterByName(workspaceId, resourceAccessDto.getName(), clusterRepairRequest);\n         } else {\n-            stackCommonService.repairClusterByCrn(workspaceId, stackAccessDto.getCrn(), clusterRepairRequest);\n+            stackCommonService.repairClusterByCrn(workspaceId, resourceAccessDto.getCrn(), clusterRepairRequest);\n         }\n     }\n \n-    public void upgradeCluster(StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            upgradeService.upgradeByStackName(workspaceId, stackAccessDto.getName());\n+    public void upgradeCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            upgradeService.upgradeByStackName(workspaceId, resourceAccessDto.getName());\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public UpgradeOptionV4Response checkForUpgrade(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public UpgradeOptionV4Response checkForUpgrade(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return upgradeService.getUpgradeOptionByStackName(workspaceId, stackAccessDto.getName(), user);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return upgradeService.getUpgradeOptionByStackName(workspaceId, resourceAccessDto.getName(), user);\n         } else {\n             throw new BadRequestException(\"Please provide a stack name for upgrade\");\n         }\n     }\n \n-    public GeneratedBlueprintV4Response postStackForBlueprint(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n+    public GeneratedBlueprintV4Response postStackForBlueprint(ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackV4Request stackRequest) {\n         return stackCommonService.postStackForBlueprint(stackRequest);\n     }\n \n-    public void changeImage(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.changeImageByNameInWorkspace(stackAccessDto.getName(), workspaceId, stackImageChangeRequest);\n+    public void changeImage(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid StackImageChangeV4Request stackImageChangeRequest) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.changeImageByNameInWorkspace(resourceAccessDto.getName(), workspaceId, stackImageChangeRequest);\n         } else {\n-            stackCommonService.changeImageByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n+            stackCommonService.changeImageByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, stackImageChangeRequest);\n         }\n     }\n \n-    public void delete(@NotNull StackAccessDto stackAccessDto, Long workspaceId, boolean forced) {\n-        validateAccessDto(stackAccessDto);\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stackCommonService.deleteWithKerberosByNameInWorkspace(stackAccessDto.getName(), workspaceId, forced);\n+    public void delete(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, boolean forced) {\n+        ResourceAccessDto.validate(resourceAccessDto);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stackCommonService.deleteWithKerberosByNameInWorkspace(resourceAccessDto.getName(), workspaceId, forced);\n         } else {\n-            stackCommonService.deleteWithKerberosByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId, forced);\n+            stackCommonService.deleteWithKerberosByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId, forced);\n         }\n     }\n \n-    public StackV4Request getRequest(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            return stackService.getStackRequestByNameInWorkspaceId(stackAccessDto.getName(), workspaceId);\n+    public StackV4Request getRequest(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            return stackService.getStackRequestByNameInWorkspaceId(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            return stackService.getStackRequestByCrnInWorkspaceId(stackAccessDto.getCrn(), workspaceId);\n+            return stackService.getStackRequestByCrnInWorkspaceId(resourceAccessDto.getCrn(), workspaceId);\n         }\n     }\n \n-    public StackStatusV4Response getStatus(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public StackStatusV4Response getStatus(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public StackStatusV4Response getStatusByCrn(@NotNull StackAccessDto stackAccessDto, Long workspaceId) {\n+    public StackStatusV4Response getStatusByCrn(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTkyOA==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875928", "createdAt": "2020-01-17T10:50:10Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -287,35 +289,35 @@ public StackStatusV4Response getStatus(@NotNull String crn) {\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public void putPassword(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n+    public void putPassword(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NTk3OQ==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367875979", "createdAt": "2020-01-17T10:50:17Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -287,35 +289,35 @@ public StackStatusV4Response getStatus(@NotNull String crn) {\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public void putPassword(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n+    public void putPassword(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         UpdateClusterV4Request updateClusterJson = converterUtil.convert(userNamePasswordJson, UpdateClusterV4Request.class);\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n         Workspace workspace = workspaceService.get(restRequestThreadLocalService.getRequestedWorkspaceId(), user);\n         clusterCommonService.put(stack.getResourceCrn(), updateClusterJson, user, workspace);\n     }\n \n-    public void setClusterMaintenanceMode(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n+    public void setClusterMaintenanceMode(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg3NjA0MA==", "bodyText": "Refactor as indicated in deleteInstances method (see comments there)", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#discussion_r367876040", "createdAt": "2020-01-17T10:50:26Z", "author": {"login": "gergopapi2"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -287,35 +289,35 @@ public StackStatusV4Response getStatus(@NotNull String crn) {\n         return converterUtil.convert(stack, StackStatusV4Response.class);\n     }\n \n-    public void putPassword(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n+    public void putPassword(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UserNamePasswordV4Request userNamePasswordJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         UpdateClusterV4Request updateClusterJson = converterUtil.convert(userNamePasswordJson, UpdateClusterV4Request.class);\n         User user = userService.getOrCreate(restRequestThreadLocalService.getCloudbreakUser());\n         Workspace workspace = workspaceService.get(restRequestThreadLocalService.getRequestedWorkspaceId(), user);\n         clusterCommonService.put(stack.getResourceCrn(), updateClusterJson, user, workspace);\n     }\n \n-    public void setClusterMaintenanceMode(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n+    public void setClusterMaintenanceMode(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @NotNull MaintenanceModeV4Request maintenanceMode) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {\n+            stack = stackService.getByNameInWorkspace(resourceAccessDto.getName(), workspaceId);\n         } else {\n-            stack = stackService.getByCrnInWorkspace(stackAccessDto.getCrn(), workspaceId);\n+            stack = stackService.getByCrnInWorkspace(resourceAccessDto.getCrn(), workspaceId);\n         }\n         clusterCommonService.setMaintenanceMode(stack, maintenanceMode.getStatus());\n     }\n \n-    public void putCluster(@NotNull StackAccessDto stackAccessDto, Long workspaceId, @Valid UpdateClusterV4Request updateJson) {\n+    public void putCluster(@NotNull ResourceAccessDto resourceAccessDto, Long workspaceId, @Valid UpdateClusterV4Request updateJson) {\n         Stack stack;\n-        if (isNotEmpty(stackAccessDto.getName())) {\n-            stack = stackService.getByNameInWorkspace(stackAccessDto.getName(), workspaceId);\n+        if (isNotEmpty(resourceAccessDto.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "originalPosition": 312}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NTc3NDcw", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-344577470", "createdAt": "2020-01-17T13:30:58Z", "commit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "214703601ab8ec56163dfb18b07d5a3108eb3c5f", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/214703601ab8ec56163dfb18b07d5a3108eb3c5f", "committedDate": "2020-01-16T10:57:52Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}, "afterCommit": {"oid": "16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "committedDate": "2020-01-20T12:20:49Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dec7e4d670c928825040136d8f73c213272929a3", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/dec7e4d670c928825040136d8f73c213272929a3", "committedDate": "2020-01-20T12:49:45Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/16f4ccb6d7a32c19b20e4a2ac9f9599bed12451a", "committedDate": "2020-01-20T12:20:49Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}, "afterCommit": {"oid": "dec7e4d670c928825040136d8f73c213272929a3", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/dec7e4d670c928825040136d8f73c213272929a3", "committedDate": "2020-01-20T12:49:45Z", "message": "CB-3454 - cloudbreak and cdp-cli to link the dbstck to the environment stack"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Mjg2OTI0", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-345286924", "createdAt": "2020-01-20T12:52:14Z", "commit": {"oid": "dec7e4d670c928825040136d8f73c213272929a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1Mjg5NTgw", "url": "https://github.com/hortonworks/cloudbreak/pull/7071#pullrequestreview-345289580", "createdAt": "2020-01-20T12:57:28Z", "commit": {"oid": "dec7e4d670c928825040136d8f73c213272929a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1971, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}