{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTY2ODAy", "number": 8481, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxMjo1M1rOEK-AQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxMzozM1rOEK-BPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTM3MDg4OnYy", "diffSide": "RIGHT", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/ClouderaManagerPollingServiceProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxMjo1M1rOGsUeMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwOTo0ODo0NVrOGsqx8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNTkzOA==", "bodyText": "this is used in one place, maybe we should consider passing it as parameter", "url": "https://github.com/hortonworks/cloudbreak/pull/8481#discussion_r449125938", "createdAt": "2020-07-02T16:12:53Z", "author": {"login": "pdarvasi"}, "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/ClouderaManagerPollingServiceProvider.java", "diffHunk": "@@ -131,60 +135,61 @@ public PollingResult startPollingCmHostDecommissioning(Stack stack, ApiClient ap\n \n     public PollingResult startPollingCmManagementServiceStartup(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to start management service. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerStartManagementServiceListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCmManagementServiceShutdown(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to stop management service. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerStopManagementServiceListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCmServicesRestart(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to restart services. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerRestartServicesListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingParcelsApiAvailable(Stack stack, ApiClient apiClient) {\n         LOGGER.debug(\"Waiting for Parcels API to become available. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, null, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, null, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerParcelsApiListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCdpRuntimeUpgrade(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to upgrade CDP Runtime services. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerUpgradeRuntimeListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCdpRuntimeParcelDownload(Stack stack, ApiClient apiClient, BigDecimal commandId, ParcelResource parcelResource) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to download CDP Runtime Parcel. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerUpgradeParcelDownloadListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService, parcelResource));\n     }\n \n     public PollingResult startPollingCdpRuntimeParcelDistribute(Stack stack, ApiClient apiClient, BigDecimal commandId, ParcelResource parcelResource) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to distribute CDP Runtime Parcel. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerUpgradeParcelDistributeListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService, parcelResource));\n     }\n \n     public PollingResult startPollingCmGenerateCredentials(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to finish generate credentials. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerGenerateCredentialsListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n-    private PollingResult pollCommandWithTimeListener(Stack stack, ApiClient apiClient, BigDecimal commandId, int numAttempts,\n+    private PollingResult pollCommandWithTimeListener(Stack stack, ApiClient apiClient, BigDecimal commandId, long maximumWaitTimeInSeconds,\n             AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> listenerTask) {\n         ClouderaManagerPollerObject clouderaManagerPollerObject = new ClouderaManagerPollerObject(stack, apiClient, commandId);\n-        return clouderaManagerCommandPollerObjectPollingService.pollWithTimeoutSingleFailure(\n+        return clouderaManagerCommandPollerObjectPollingService.pollWithAbsoluteTimeout(\n                 listenerTask,\n                 clouderaManagerPollerObject,\n                 POLL_INTERVAL,\n-                numAttempts);\n+                maximumWaitTimeInSeconds,\n+                TOLERATE_FIVE_CONSECUTIVE_ERRORS).getLeft();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0990989898d838a1143a638c4ee93c08dd81d95d"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ5MTQ0Mg==", "bodyText": "Thanks", "url": "https://github.com/hortonworks/cloudbreak/pull/8481#discussion_r449491442", "createdAt": "2020-07-03T09:48:45Z", "author": {"login": "akanto"}, "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/polling/ClouderaManagerPollingServiceProvider.java", "diffHunk": "@@ -131,60 +135,61 @@ public PollingResult startPollingCmHostDecommissioning(Stack stack, ApiClient ap\n \n     public PollingResult startPollingCmManagementServiceStartup(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to start management service. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerStartManagementServiceListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCmManagementServiceShutdown(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to stop management service. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerStopManagementServiceListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCmServicesRestart(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to restart services. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerRestartServicesListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingParcelsApiAvailable(Stack stack, ApiClient apiClient) {\n         LOGGER.debug(\"Waiting for Parcels API to become available. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, null, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, null, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerParcelsApiListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCdpRuntimeUpgrade(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to upgrade CDP Runtime services. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerUpgradeRuntimeListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n     public PollingResult startPollingCdpRuntimeParcelDownload(Stack stack, ApiClient apiClient, BigDecimal commandId, ParcelResource parcelResource) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to download CDP Runtime Parcel. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerUpgradeParcelDownloadListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService, parcelResource));\n     }\n \n     public PollingResult startPollingCdpRuntimeParcelDistribute(Stack stack, ApiClient apiClient, BigDecimal commandId, ParcelResource parcelResource) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to distribute CDP Runtime Parcel. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerUpgradeParcelDistributeListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService, parcelResource));\n     }\n \n     public PollingResult startPollingCmGenerateCredentials(Stack stack, ApiClient apiClient, BigDecimal commandId) {\n         LOGGER.debug(\"Waiting for Cloudera Manager to finish generate credentials. [Server address: {}]\", stack.getClusterManagerIp());\n-        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_ATTEMPTS_FOUR_HOURS,\n+        return pollCommandWithTimeListener(stack, apiClient, commandId, POLL_FOR_ONE_HOUR,\n                 new ClouderaManagerGenerateCredentialsListenerTask(clouderaManagerApiPojoFactory, cloudbreakEventService));\n     }\n \n-    private PollingResult pollCommandWithTimeListener(Stack stack, ApiClient apiClient, BigDecimal commandId, int numAttempts,\n+    private PollingResult pollCommandWithTimeListener(Stack stack, ApiClient apiClient, BigDecimal commandId, long maximumWaitTimeInSeconds,\n             AbstractClouderaManagerCommandCheckerTask<ClouderaManagerPollerObject> listenerTask) {\n         ClouderaManagerPollerObject clouderaManagerPollerObject = new ClouderaManagerPollerObject(stack, apiClient, commandId);\n-        return clouderaManagerCommandPollerObjectPollingService.pollWithTimeoutSingleFailure(\n+        return clouderaManagerCommandPollerObjectPollingService.pollWithAbsoluteTimeout(\n                 listenerTask,\n                 clouderaManagerPollerObject,\n                 POLL_INTERVAL,\n-                numAttempts);\n+                maximumWaitTimeInSeconds,\n+                TOLERATE_FIVE_CONSECUTIVE_ERRORS).getLeft();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNTkzOA=="}, "originalCommit": {"oid": "0990989898d838a1143a638c4ee93c08dd81d95d"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTM3MzQxOnYy", "diffSide": "RIGHT", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/polling/PollingService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNjoxMzozM1rOGsUfyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwOTo0ODo1NlrOGsqyRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNjM0NQ==", "bodyText": "typo: resived ->  received", "url": "https://github.com/hortonworks/cloudbreak/pull/8481#discussion_r449126345", "createdAt": "2020-07-02T16:13:33Z", "author": {"login": "pdarvasi"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/polling/PollingService.java", "diffHunk": "@@ -21,37 +21,43 @@\n      * @param interval    sleeps this many milliseconds between status checking attempts\n      * @param maxAttempts signals how many times will the status check be executed before timeout\n      */\n-    public Pair<PollingResult, Exception> pollWithTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval, int maxAttempts, int maxFailure) {\n-        return pollWithTimeout(statusCheckerTask, t, interval, new AttemptBasedTimeoutChecker(maxAttempts), maxFailure);\n+    public Pair<PollingResult, Exception> pollWithTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval,\n+            int maxAttempts, int maxConsecutiveFailures) {\n+        return pollWithTimeout(statusCheckerTask, t, interval, new AttemptBasedTimeoutChecker(maxAttempts), maxConsecutiveFailures);\n     }\n \n-    public Pair<PollingResult, Exception> pollWithAbsoluteTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval, long waitSec, int maxFailure) {\n-        return pollWithTimeout(statusCheckerTask, t, interval, new AbsolutTimeBasedTimeoutChecker(waitSec), maxFailure);\n+    public Pair<PollingResult, Exception> pollWithAbsoluteTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval,\n+            long maximumWaitTimeInSeconds, int maxConsecutiveFailures) {\n+        return pollWithTimeout(statusCheckerTask, t, interval, new AbsolutTimeBasedTimeoutChecker(maximumWaitTimeInSeconds), maxConsecutiveFailures);\n     }\n \n     public Pair<PollingResult, Exception> pollWithTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval, TimeoutChecker timeoutChecker,\n-            int maxFailure) {\n+            int maxConsecutiveFailures) {\n         boolean success = false;\n         boolean timeout = false;\n         int attempts = 0;\n-        int failures = 0;\n+        int consecutiveFailures = 0;\n         Exception actual = null;\n         boolean exit = statusCheckerTask.exitPolling(t);\n         while (!timeout && !exit) {\n             LOGGER.debug(\"Polling attempt {}.\", attempts);\n             try {\n                 success = statusCheckerTask.checkStatus(t);\n             } catch (Exception ex) {\n-                LOGGER.debug(\"Exception occurred in the polling: {}\", ex.getMessage(), ex);\n-                failures++;\n+                consecutiveFailures++;\n                 actual = ex;\n+                LOGGER.debug(\"Exception occurred in the polling: {}. Number of consecutive failures: [{}/{}]\",\n+                        ex.getMessage(), consecutiveFailures, maxConsecutiveFailures, ex);\n             }\n-            if (failures >= maxFailure) {\n-                LOGGER.debug(\"Polling failure reached the limit which was {}, poller will drop the last exception.\", maxFailure);\n+            if (consecutiveFailures >= maxConsecutiveFailures) {\n+                LOGGER.debug(\"Polling failure reached the limit which was {}, poller will drop the last exception.\", maxConsecutiveFailures);\n                 statusCheckerTask.handleException(actual);\n                 return new ImmutablePair<>(PollingResult.FAILURE, actual);\n             } else if (success) {\n                 LOGGER.debug(statusCheckerTask.successMessage(t));\n+                LOGGER.debug(\"Set the number of consecutive failures to 0, since we resived a positve answer. Original number of consecutiveFailures: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0990989898d838a1143a638c4ee93c08dd81d95d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ5MTUyNA==", "bodyText": "Thanks.", "url": "https://github.com/hortonworks/cloudbreak/pull/8481#discussion_r449491524", "createdAt": "2020-07-03T09:48:56Z", "author": {"login": "akanto"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/polling/PollingService.java", "diffHunk": "@@ -21,37 +21,43 @@\n      * @param interval    sleeps this many milliseconds between status checking attempts\n      * @param maxAttempts signals how many times will the status check be executed before timeout\n      */\n-    public Pair<PollingResult, Exception> pollWithTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval, int maxAttempts, int maxFailure) {\n-        return pollWithTimeout(statusCheckerTask, t, interval, new AttemptBasedTimeoutChecker(maxAttempts), maxFailure);\n+    public Pair<PollingResult, Exception> pollWithTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval,\n+            int maxAttempts, int maxConsecutiveFailures) {\n+        return pollWithTimeout(statusCheckerTask, t, interval, new AttemptBasedTimeoutChecker(maxAttempts), maxConsecutiveFailures);\n     }\n \n-    public Pair<PollingResult, Exception> pollWithAbsoluteTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval, long waitSec, int maxFailure) {\n-        return pollWithTimeout(statusCheckerTask, t, interval, new AbsolutTimeBasedTimeoutChecker(waitSec), maxFailure);\n+    public Pair<PollingResult, Exception> pollWithAbsoluteTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval,\n+            long maximumWaitTimeInSeconds, int maxConsecutiveFailures) {\n+        return pollWithTimeout(statusCheckerTask, t, interval, new AbsolutTimeBasedTimeoutChecker(maximumWaitTimeInSeconds), maxConsecutiveFailures);\n     }\n \n     public Pair<PollingResult, Exception> pollWithTimeout(StatusCheckerTask<T> statusCheckerTask, T t, long interval, TimeoutChecker timeoutChecker,\n-            int maxFailure) {\n+            int maxConsecutiveFailures) {\n         boolean success = false;\n         boolean timeout = false;\n         int attempts = 0;\n-        int failures = 0;\n+        int consecutiveFailures = 0;\n         Exception actual = null;\n         boolean exit = statusCheckerTask.exitPolling(t);\n         while (!timeout && !exit) {\n             LOGGER.debug(\"Polling attempt {}.\", attempts);\n             try {\n                 success = statusCheckerTask.checkStatus(t);\n             } catch (Exception ex) {\n-                LOGGER.debug(\"Exception occurred in the polling: {}\", ex.getMessage(), ex);\n-                failures++;\n+                consecutiveFailures++;\n                 actual = ex;\n+                LOGGER.debug(\"Exception occurred in the polling: {}. Number of consecutive failures: [{}/{}]\",\n+                        ex.getMessage(), consecutiveFailures, maxConsecutiveFailures, ex);\n             }\n-            if (failures >= maxFailure) {\n-                LOGGER.debug(\"Polling failure reached the limit which was {}, poller will drop the last exception.\", maxFailure);\n+            if (consecutiveFailures >= maxConsecutiveFailures) {\n+                LOGGER.debug(\"Polling failure reached the limit which was {}, poller will drop the last exception.\", maxConsecutiveFailures);\n                 statusCheckerTask.handleException(actual);\n                 return new ImmutablePair<>(PollingResult.FAILURE, actual);\n             } else if (success) {\n                 LOGGER.debug(statusCheckerTask.successMessage(t));\n+                LOGGER.debug(\"Set the number of consecutive failures to 0, since we resived a positve answer. Original number of consecutiveFailures: {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEyNjM0NQ=="}, "originalCommit": {"oid": "0990989898d838a1143a638c4ee93c08dd81d95d"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3108, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}