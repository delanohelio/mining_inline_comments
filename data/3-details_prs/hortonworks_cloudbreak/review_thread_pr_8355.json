{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3ODg0NzIw", "number": 8355, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDowODozNVrOEHlkyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDoxNzo1OVrOEHl1gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzkxMTEyOnYy", "diffSide": "RIGHT", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/AuditClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDowODozNVrOGnCQkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDoxOToxMFrOGnCuLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU4NDY1Nw==", "bodyText": "might worth getting the latest audit.proto from thunderhead repo and update client here\nalso, integrate the latest audit service docker image build into cbd.", "url": "https://github.com/hortonworks/cloudbreak/pull/8355#discussion_r443584657", "createdAt": "2020-06-22T14:08:35Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/AuditClient.java", "diffHunk": "@@ -151,4 +154,19 @@ private AuditBlockingStub newStub(ManagedChannel channel, String requestId, Stri\n         return AuditGrpc.newBlockingStub(channel)\n                 .withInterceptors(new AltusMetadataInterceptor(requestId, actorCrn));\n     }\n+\n+    public void listEvents(ListAuditEvent listAuditEvent) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60234d22c74526aee3474d4bad1ba96075a14517"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU5MjIzNw==", "bodyText": "Can you create a jira ticket for the upgrade?", "url": "https://github.com/hortonworks/cloudbreak/pull/8355#discussion_r443592237", "createdAt": "2020-06-22T14:19:10Z", "author": {"login": "topolyai5"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/AuditClient.java", "diffHunk": "@@ -151,4 +154,19 @@ private AuditBlockingStub newStub(ManagedChannel channel, String requestId, Stri\n         return AuditGrpc.newBlockingStub(channel)\n                 .withInterceptors(new AltusMetadataInterceptor(requestId, actorCrn));\n     }\n+\n+    public void listEvents(ListAuditEvent listAuditEvent) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU4NDY1Nw=="}, "originalCommit": {"oid": "60234d22c74526aee3474d4bad1ba96075a14517"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzkyNjcxOnYy", "diffSide": "RIGHT", "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/auditeventname/rest/RestCommonService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDoxMjowMVrOGnCaCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDoxMjowMVrOGnCaCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU4NzA4Mg==", "bodyText": "please reorder params", "url": "https://github.com/hortonworks/cloudbreak/pull/8355#discussion_r443587082", "createdAt": "2020-06-22T14:12:01Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/auditeventname/rest/RestCommonService.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.sequenceiq.cloudbreak.audit.converter.auditeventname.rest;\n+\n+import static com.sequenceiq.cloudbreak.audit.converter.EventDataExtractor.CLUSTER_CRN;\n+import static com.sequenceiq.cloudbreak.audit.converter.EventDataExtractor.CLUSTER_NAME;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.common.json.Json;\n+import com.sequenceiq.cloudbreak.structuredevent.event.StructuredRestCallEvent;\n+import com.sequenceiq.cloudbreak.structuredevent.event.rest.RestRequestDetails;\n+\n+@Component\n+public class RestCommonService {\n+\n+    public void addClusterCrnAndNameIfPresent(StructuredRestCallEvent structuredEvent, Map<String, Object> params) {\n+        String resourceCrn = structuredEvent.getOperation().getResourceCrn();\n+        RestRequestDetails restRequest = structuredEvent.getRestCall().getRestRequest();\n+        Json requestJson = new Json(restRequest.getBody());\n+        if (StringUtils.isEmpty(resourceCrn)) {\n+            resourceCrn = getValueFromJson(requestJson, \"resourceCrn\");\n+        }\n+        String name = null;\n+\n+        String responseBody = structuredEvent.getRestCall().getRestResponse().getBody();\n+        if (StringUtils.isNotEmpty(responseBody)) {\n+            Json responseJson = new Json(responseBody);\n+            if (StringUtils.isEmpty(resourceCrn)) {\n+                resourceCrn = getValueFromJson(responseJson, \"resourceCrn\");\n+            }\n+            name = getValueFromJson(responseJson, \"name\");\n+        }\n+\n+        if (StringUtils.isEmpty(name)) {\n+            name = getValueFromJson(requestJson, \"name\");\n+        }\n+\n+        if (StringUtils.isEmpty(name)) {\n+            String method = restRequest.getMethod();\n+            if (\"DELETE\".equals(method)) {\n+                List<String> names = requestJson.getValue(\"names\");\n+                name = String.join(\",\", names);\n+            }\n+        }\n+\n+        checkNameOrCrnProvided(resourceCrn, restRequest, name);\n+\n+        if (StringUtils.isNotEmpty(name)) {\n+            params.put(CLUSTER_NAME, name);\n+        }\n+\n+        if (StringUtils.isNotEmpty(resourceCrn)) {\n+            params.put(CLUSTER_CRN, resourceCrn);\n+        }\n+    }\n+\n+    private String getValueFromJson(Json responseJson, String resourceCrn) {\n+        return responseJson.getValue(resourceCrn);\n+    }\n+\n+    private void checkNameOrCrnProvided(String resourceCrn, RestRequestDetails restRequest, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60234d22c74526aee3474d4bad1ba96075a14517"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2Mzk1Mzk1OnYy", "diffSide": "RIGHT", "path": "mock-thunderhead/src/main/java/com/sequenceiq/caas/grpc/service/audit/MockAuditLogService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDoxNzo1OVrOGnCq8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDoxNzo1OVrOGnCq8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU5MTQxMQ==", "bodyText": "as above, it might worth refreshing the audit.proto file from thunderhead!", "url": "https://github.com/hortonworks/cloudbreak/pull/8355#discussion_r443591411", "createdAt": "2020-06-22T14:17:59Z", "author": {"login": "bergerdenes"}, "path": "mock-thunderhead/src/main/java/com/sequenceiq/caas/grpc/service/audit/MockAuditLogService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.caas.grpc.service.audit;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Component;\n+\n+import com.cloudera.thunderhead.service.audit.AuditGrpc;\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.caas.service.AuditStoreService;\n+\n+import io.grpc.stub.StreamObserver;\n+\n+@Component\n+public class MockAuditLogService extends AuditGrpc.AuditImplBase {\n+\n+    @Inject\n+    private AuditStoreService auditStoreService;\n+\n+    @Override\n+    public void createAttemptAuditEvent(AuditProto.CreateAttemptAuditEventRequest request,\n+            StreamObserver<AuditProto.CreateAttemptAuditEventResponse> responseObserver) {\n+        super.createAttemptAuditEvent(request, responseObserver);\n+    }\n+\n+    @Override\n+    public void createAuditEvent(AuditProto.CreateAuditEventRequest request, StreamObserver<AuditProto.CreateAuditEventResponse> responseObserver) {\n+        auditStoreService.store(request.getAuditEvent());\n+        responseObserver.onNext(AuditProto.CreateAuditEventResponse.newBuilder().build());\n+        responseObserver.onCompleted();\n+    }\n+\n+    @Override\n+    public void listEvents(AuditProto.ListEventsRequest request, StreamObserver<AuditProto.ListEventsResponse> responseObserver) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60234d22c74526aee3474d4bad1ba96075a14517"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3155, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}