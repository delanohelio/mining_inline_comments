{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMzMwNDEz", "number": 9220, "title": "CB-8639 Stop RDS when stopping DistroX cluster", "bodyText": "Adding new flows into the the stop/start flow chains, new\nstates for stack.\nChallenge was to find the extra condition that checks the\nproper status for stopping.\nNOTE: the cert pre-validation flag is now set to Ignored in\nthe 'core' module!", "createdAt": "2020-10-14T12:16:08Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9220", "merged": true, "mergeCommit": {"oid": "0dbb01fb0cc89af47ad92ca5df5b1a413368fb50"}, "closed": true, "closedAt": "2020-10-19T08:09:20Z", "author": {"login": "bergerdenes"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdScI8bgH2gAyNTAzMzMwNDEzOmVlMzllMGYxOGMxMjlmM2NiZGNjNzNjZGMwZWUwZDI1ODQ5ZGIxMDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSfkoAAFqTUwODUxMzk1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ee39e0f18c129f3cbdcc73cdc0ee0d25849db101", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/ee39e0f18c129f3cbdcc73cdc0ee0d25849db101", "committedDate": "2020-10-14T12:14:59Z", "message": "CB-8639 Stop RDS when stopping DistroX cluster\n\nAdding new flows into the the stop/start flow chains, new\nstates for stack.\nChallenge was to find the extra condition that checks the\nproper status for stopping.\nNOTE: the cert pre-validation flag is now set to Ignored in\nthe 'core' module!"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NTEzOTUz", "url": "https://github.com/hortonworks/cloudbreak/pull/9220#pullrequestreview-508513953", "createdAt": "2020-10-14T16:14:55Z", "commit": {"oid": "ee39e0f18c129f3cbdcc73cdc0ee0d25849db101"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoxNDo1NlrOHha2kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjoxNDo1NlrOHha2kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNTAxMQ==", "bodyText": "should we just redbeams and if redbeams say it is not supported than we just ignore the start stop on the DB ?", "url": "https://github.com/hortonworks/cloudbreak/pull/9220#discussion_r504805011", "createdAt": "2020-10-14T16:14:56Z", "author": {"login": "doktoric"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/externaldatabase/start/handler/StartExternalDatabaseHandler.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package com.sequenceiq.cloudbreak.core.flow2.externaldatabase.start.handler;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.externaldatabase.start.config.ExternalDatabaseStartEvent.EXTERNAL_DATABASE_STARTED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.externaldatabase.start.config.ExternalDatabaseStartEvent.EXTERNAL_DATABASE_START_FAILED_EVENT;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.dyngr.exception.PollerException;\n+import com.dyngr.exception.PollerStoppedException;\n+import com.dyngr.exception.UserBreakException;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.database.DatabaseAvailabilityType;\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.cloudbreak.conf.ExternalDatabaseConfig;\n+import com.sequenceiq.cloudbreak.core.flow2.externaldatabase.ExternalDatabaseService;\n+import com.sequenceiq.cloudbreak.core.flow2.externaldatabase.StackUpdaterService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.externaldatabase.StartExternalDatabaseFailed;\n+import com.sequenceiq.cloudbreak.reactor.api.event.externaldatabase.StartExternalDatabaseRequest;\n+import com.sequenceiq.cloudbreak.reactor.api.event.externaldatabase.StartExternalDatabaseResult;\n+import com.sequenceiq.cloudbreak.service.environment.EnvironmentClientService;\n+import com.sequenceiq.environment.api.v1.environment.model.response.DetailedEnvironmentResponse;\n+import com.sequenceiq.flow.reactor.api.handler.ExceptionCatcherEventHandler;\n+\n+import reactor.bus.Event;\n+\n+@Component\n+public class StartExternalDatabaseHandler extends ExceptionCatcherEventHandler<StartExternalDatabaseRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartExternalDatabaseHandler.class);\n+\n+    @Inject\n+    private ExternalDatabaseService startService;\n+\n+    @Inject\n+    private StackUpdaterService stackUpdaterService;\n+\n+    @Inject\n+    private EnvironmentClientService environmentClientService;\n+\n+    @Inject\n+    private ExternalDatabaseConfig externalDatabaseConfig;\n+\n+    @Override\n+    public String selector() {\n+        return \"StartExternalDatabaseRequest\";\n+    }\n+\n+    @Override\n+    protected Selectable defaultFailureEvent(Long resourceId, Exception e, Event<StartExternalDatabaseRequest> event) {\n+        Stack stack = event.getData().getStack();\n+        LOGGER.error(String.format(\"Exception during DB 'start' for stack/cluster: %s\", stack.getName()), e);\n+        return startFailedEvent(stack, e);\n+    }\n+\n+    @Override\n+    protected Selectable doAccept(HandlerEvent event) {\n+        LOGGER.debug(\"In StartExternalDatabaseHandler.doAccept\");\n+        StartExternalDatabaseRequest request = event.getData();\n+        Stack stack = request.getStack();\n+        DatabaseAvailabilityType externalDatabase = ObjectUtils.defaultIfNull(stack.getExternalDatabaseCreationType(), DatabaseAvailabilityType.NONE);\n+        LOGGER.debug(\"External database: {} for stack {}\", externalDatabase.name(), stack.getName());\n+        LOGGER.debug(\"Getting environment CRN for stack {}\", stack.getName());\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+        Selectable result;\n+        try {\n+            if (StackType.WORKLOAD != stack.getType()) {\n+                LOGGER.debug(\"External database start in Cloudbreak service is required for WORKLOAD stacks only.\");\n+                result = new StartExternalDatabaseResult(stack.getId(), EXTERNAL_DATABASE_STARTED_EVENT.event(),\n+                        stack.getName(), null);\n+            } else if (externalDatabase == DatabaseAvailabilityType.NONE) {\n+                LOGGER.info(\"External database for stack {} is not requested. Start is not possible.\", stack.getName());\n+                result = new StartExternalDatabaseResult(stack.getId(), EXTERNAL_DATABASE_STARTED_EVENT.event(),\n+                        stack.getName(), null);\n+            } else if (!externalDatabaseConfig.isExternalDatabasePauseSupportedFor(CloudPlatform.valueOf(environment.getCloudPlatform()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee39e0f18c129f3cbdcc73cdc0ee0d25849db101"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2178, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}