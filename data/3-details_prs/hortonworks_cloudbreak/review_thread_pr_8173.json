{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NTA3ODgw", "number": 8173, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNjoxM1rOEAj1Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNjoxM1rOEAj1Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDIyNDgzOnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/RemovableClusterMonitor.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNToyNjoxM1rOGb6lAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMjoxMDoyNVrOGdutgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4MA==", "bodyText": "Including subset of clusters to monitor instead of ClusterManagerHostHealthEvaluator's all running clusters.\nAlso one corner case was not covered in existing flow related to \"PENDING\" cluster deleted in CB.", "url": "https://github.com/hortonworks/cloudbreak/pull/8173#discussion_r431924480", "createdAt": "2020-05-28T15:26:13Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/RemovableClusterMonitor.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import java.util.List;\n+\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.periscope.api.model.ClusterState;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.monitor.evaluator.ClusterStateEvaluator;\n+\n+@Component(\"RemovableClusterMonitor\")\n+@ConditionalOnProperty(prefix = \"periscope.enabledAutoscaleMonitors.removable-cluster-monitor\", name = \"enabled\", havingValue = \"true\")\n+public class RemovableClusterMonitor extends ClusterMonitor {\n+\n+    @Override\n+    public String getIdentifier() {\n+        return \"removable-cluster-monitor\";\n+    }\n+\n+    @Override\n+    public String getTriggerExpression() {\n+        return MonitorUpdateRate.EVERY_MIN_RATE_CRON;\n+    }\n+\n+    @Override\n+    public Class<?> getEvaluatorType(Cluster cluster) {\n+        return ClusterStateEvaluator.class;\n+    }\n+\n+    @Override\n+    protected List<Cluster> getMonitored() {\n+        //To monitor Suspended & Clusters with AutoScaling disabled and purge them in periscope when they are deleted in CB.\n+        List removableClustersCheck = getClusterService()\n+                .findAllByStateAndNode(ClusterState.SUSPENDED, getPeriscopeNodeConfig().getId());\n+        removableClustersCheck.addAll(getClusterService()\n+                        .findAllByStateAndNode(ClusterState.PENDING, getPeriscopeNodeConfig().getId()));\n+        removableClustersCheck.addAll(getClusterService()\n+                .findAllForNode(ClusterState.RUNNING, false, getPeriscopeNodeConfig().getId()));\n+        return removableClustersCheck;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f869da7868de42daa98da800ccb63b277a3d1c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDg0MA==", "bodyText": "I may be missing something here.\nWhat sends a 'Periscope Cluster' into the SUSPENDED or PENDING state?\nClusterCreationEvaluator seems to be the one setting state to 'PENDING' when it first pulls in a cluster.\nThe only place that seems to move a cluster into SUSPENDED state is UpdateFailedeHandler.\nThe UpdateFailedHandler will only be invoked by YarnLoadEvaluator (which we can ignore since LoadAlerts may not be enabled for a cluster) or ClusterStateEvaluator, which will only be invoked based on this 'getMonitored' list.\nWon't we need to look up pretty much all clusters here?\nAlso, didn't understand the need for \"RUNNING\" + scalingEnabled=false. Why not RUNNING + scalingEnabled=true (which goes back to the previous point about monitoring all clusters).", "url": "https://github.com/hortonworks/cloudbreak/pull/8173#discussion_r432164840", "createdAt": "2020-05-28T22:46:03Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/RemovableClusterMonitor.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import java.util.List;\n+\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.periscope.api.model.ClusterState;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.monitor.evaluator.ClusterStateEvaluator;\n+\n+@Component(\"RemovableClusterMonitor\")\n+@ConditionalOnProperty(prefix = \"periscope.enabledAutoscaleMonitors.removable-cluster-monitor\", name = \"enabled\", havingValue = \"true\")\n+public class RemovableClusterMonitor extends ClusterMonitor {\n+\n+    @Override\n+    public String getIdentifier() {\n+        return \"removable-cluster-monitor\";\n+    }\n+\n+    @Override\n+    public String getTriggerExpression() {\n+        return MonitorUpdateRate.EVERY_MIN_RATE_CRON;\n+    }\n+\n+    @Override\n+    public Class<?> getEvaluatorType(Cluster cluster) {\n+        return ClusterStateEvaluator.class;\n+    }\n+\n+    @Override\n+    protected List<Cluster> getMonitored() {\n+        //To monitor Suspended & Clusters with AutoScaling disabled and purge them in periscope when they are deleted in CB.\n+        List removableClustersCheck = getClusterService()\n+                .findAllByStateAndNode(ClusterState.SUSPENDED, getPeriscopeNodeConfig().getId());\n+        removableClustersCheck.addAll(getClusterService()\n+                        .findAllByStateAndNode(ClusterState.PENDING, getPeriscopeNodeConfig().getId()));\n+        removableClustersCheck.addAll(getClusterService()\n+                .findAllForNode(ClusterState.RUNNING, false, getPeriscopeNodeConfig().getId()));\n+        return removableClustersCheck;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4MA=="}, "originalCommit": {"oid": "57f869da7868de42daa98da800ccb63b277a3d1c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzMTQ5OA==", "bodyText": "Ideally RUNNING + scalingEnabled=true would not be required since it would be tested while in their autoscale runs, but realized CronTimeEvaluator does not check if Cluster is online.  Fixed it.", "url": "https://github.com/hortonworks/cloudbreak/pull/8173#discussion_r432231498", "createdAt": "2020-05-29T03:05:43Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/RemovableClusterMonitor.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import java.util.List;\n+\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.periscope.api.model.ClusterState;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.monitor.evaluator.ClusterStateEvaluator;\n+\n+@Component(\"RemovableClusterMonitor\")\n+@ConditionalOnProperty(prefix = \"periscope.enabledAutoscaleMonitors.removable-cluster-monitor\", name = \"enabled\", havingValue = \"true\")\n+public class RemovableClusterMonitor extends ClusterMonitor {\n+\n+    @Override\n+    public String getIdentifier() {\n+        return \"removable-cluster-monitor\";\n+    }\n+\n+    @Override\n+    public String getTriggerExpression() {\n+        return MonitorUpdateRate.EVERY_MIN_RATE_CRON;\n+    }\n+\n+    @Override\n+    public Class<?> getEvaluatorType(Cluster cluster) {\n+        return ClusterStateEvaluator.class;\n+    }\n+\n+    @Override\n+    protected List<Cluster> getMonitored() {\n+        //To monitor Suspended & Clusters with AutoScaling disabled and purge them in periscope when they are deleted in CB.\n+        List removableClustersCheck = getClusterService()\n+                .findAllByStateAndNode(ClusterState.SUSPENDED, getPeriscopeNodeConfig().getId());\n+        removableClustersCheck.addAll(getClusterService()\n+                        .findAllByStateAndNode(ClusterState.PENDING, getPeriscopeNodeConfig().getId()));\n+        removableClustersCheck.addAll(getClusterService()\n+                .findAllForNode(ClusterState.RUNNING, false, getPeriscopeNodeConfig().getId()));\n+        return removableClustersCheck;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4MA=="}, "originalCommit": {"oid": "57f869da7868de42daa98da800ccb63b277a3d1c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NDg4Mg==", "bodyText": "Even if the LoadEvaluator made this change - this particular component should not be making any assumptions about the actual triggers. It is a mechanism to keep cluster state in sync with Cloudbreak, and should behave independently of other components - which I think the latest commit does.", "url": "https://github.com/hortonworks/cloudbreak/pull/8173#discussion_r433394882", "createdAt": "2020-06-01T17:56:32Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/RemovableClusterMonitor.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import java.util.List;\n+\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.periscope.api.model.ClusterState;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.monitor.evaluator.ClusterStateEvaluator;\n+\n+@Component(\"RemovableClusterMonitor\")\n+@ConditionalOnProperty(prefix = \"periscope.enabledAutoscaleMonitors.removable-cluster-monitor\", name = \"enabled\", havingValue = \"true\")\n+public class RemovableClusterMonitor extends ClusterMonitor {\n+\n+    @Override\n+    public String getIdentifier() {\n+        return \"removable-cluster-monitor\";\n+    }\n+\n+    @Override\n+    public String getTriggerExpression() {\n+        return MonitorUpdateRate.EVERY_MIN_RATE_CRON;\n+    }\n+\n+    @Override\n+    public Class<?> getEvaluatorType(Cluster cluster) {\n+        return ClusterStateEvaluator.class;\n+    }\n+\n+    @Override\n+    protected List<Cluster> getMonitored() {\n+        //To monitor Suspended & Clusters with AutoScaling disabled and purge them in periscope when they are deleted in CB.\n+        List removableClustersCheck = getClusterService()\n+                .findAllByStateAndNode(ClusterState.SUSPENDED, getPeriscopeNodeConfig().getId());\n+        removableClustersCheck.addAll(getClusterService()\n+                        .findAllByStateAndNode(ClusterState.PENDING, getPeriscopeNodeConfig().getId()));\n+        removableClustersCheck.addAll(getClusterService()\n+                .findAllForNode(ClusterState.RUNNING, false, getPeriscopeNodeConfig().getId()));\n+        return removableClustersCheck;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4MA=="}, "originalCommit": {"oid": "57f869da7868de42daa98da800ccb63b277a3d1c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgyNzIwMw==", "bodyText": "ack", "url": "https://github.com/hortonworks/cloudbreak/pull/8173#discussion_r433827203", "createdAt": "2020-06-02T12:10:25Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/RemovableClusterMonitor.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import java.util.List;\n+\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.periscope.api.model.ClusterState;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.monitor.evaluator.ClusterStateEvaluator;\n+\n+@Component(\"RemovableClusterMonitor\")\n+@ConditionalOnProperty(prefix = \"periscope.enabledAutoscaleMonitors.removable-cluster-monitor\", name = \"enabled\", havingValue = \"true\")\n+public class RemovableClusterMonitor extends ClusterMonitor {\n+\n+    @Override\n+    public String getIdentifier() {\n+        return \"removable-cluster-monitor\";\n+    }\n+\n+    @Override\n+    public String getTriggerExpression() {\n+        return MonitorUpdateRate.EVERY_MIN_RATE_CRON;\n+    }\n+\n+    @Override\n+    public Class<?> getEvaluatorType(Cluster cluster) {\n+        return ClusterStateEvaluator.class;\n+    }\n+\n+    @Override\n+    protected List<Cluster> getMonitored() {\n+        //To monitor Suspended & Clusters with AutoScaling disabled and purge them in periscope when they are deleted in CB.\n+        List removableClustersCheck = getClusterService()\n+                .findAllByStateAndNode(ClusterState.SUSPENDED, getPeriscopeNodeConfig().getId());\n+        removableClustersCheck.addAll(getClusterService()\n+                        .findAllByStateAndNode(ClusterState.PENDING, getPeriscopeNodeConfig().getId()));\n+        removableClustersCheck.addAll(getClusterService()\n+                .findAllForNode(ClusterState.RUNNING, false, getPeriscopeNodeConfig().getId()));\n+        return removableClustersCheck;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNDQ4MA=="}, "originalCommit": {"oid": "57f869da7868de42daa98da800ccb63b277a3d1c"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3257, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}