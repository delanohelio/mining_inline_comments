{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNTA5OTI5", "number": 7428, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjozNTozM1rODj-LIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzo1NDo0OVrODlUgvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDQ1NDExOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjozNTozM1rOFwEw6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMzozMjo1NFrOFwzNsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDAyNA==", "bodyText": "I would catch Exceeption", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r385954024", "createdAt": "2020-02-28T22:35:33Z", "author": {"login": "giladwolff"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,16 +117,22 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n-                });\n+            try {\n+                boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                if (fullSync) {\n+                    long currentTime = Instant.now().toEpochMilli();\n+                    stacks.forEach(stack -> {\n+                        UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                        userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                        userSyncStatusService.save(userSyncStatus);\n+                    });\n+                }\n+                asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n+            } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyMzM1Nw==", "bodyText": "I catch RuntimeException because there isn't anything in the code that throws a checked exception. I can go either way on this one.\nCatch RuntimeException - we narrow the exceptions classes that we catch. if the try code is changed in the future to throw a checked exception then we will know at compile time that we need to handle that.\nCatch Exception - the sematics of this block are to clean up if \"anything\" goes wrong and Exception better represents \"anything\" than RuntimeException does. As a counterpoint, then what about Throwable? It may make sense here to catch Throwable because we still want to clean up if an Error occurs.", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386523357", "createdAt": "2020-03-02T17:02:18Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,16 +117,22 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n-                });\n+            try {\n+                boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                if (fullSync) {\n+                    long currentTime = Instant.now().toEpochMilli();\n+                    stacks.forEach(stack -> {\n+                        UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                        userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                        userSyncStatusService.save(userSyncStatus);\n+                    });\n+                }\n+                asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n+            } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDAyNA=="}, "originalCommit": {"oid": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcxNTA1OQ==", "bodyText": "I changed these to catch Throwable and attempt to save the operation failure to the database.", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386715059", "createdAt": "2020-03-02T23:32:54Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,16 +117,22 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n-                });\n+            try {\n+                boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                if (fullSync) {\n+                    long currentTime = Instant.now().toEpochMilli();\n+                    stacks.forEach(stack -> {\n+                        UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                        userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                        userSyncStatusService.save(userSyncStatus);\n+                    });\n+                }\n+                asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n+            } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDAyNA=="}, "originalCommit": {"oid": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDQ1NTMwOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjozNjowOVrOFwExqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzowMjo1NVrOFwnidQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDIxOA==", "bodyText": "Why not Exception?", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r385954218", "createdAt": "2020-02-28T22:36:09Z", "author": {"login": "giladwolff"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -184,7 +190,7 @@ private void internalSynchronizeUsers(String operationId, String accountId, Stri\n             operationService.completeOperation(accountId, operationId, success, failure);\n         } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyMzc2NQ==", "bodyText": "same reasoning as above", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386523765", "createdAt": "2020-03-02T17:02:55Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -184,7 +190,7 @@ private void internalSynchronizeUsers(String operationId, String accountId, Stri\n             operationService.completeOperation(accountId, operationId, success, failure);\n         } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDIxOA=="}, "originalCommit": {"oid": "2a988ded60fe21f5539ef1fe278ea9cc22dbc576"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjkxNzQwOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDoxMjo0NVrOFw_nWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODoyODoxNVrOFxRcUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxODIzMg==", "bodyText": "this looks almost the same like in internalSynchronizeUsers, could you move these into a separate method?", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r386918232", "createdAt": "2020-03-03T10:12:45Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,22 +121,37 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n+            try {\n+                ThreadBasedUserCrnProvider.doAs(INTERNAL_USER_CRN, () -> {\n+                    boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                    if (fullSync) {\n+                        long currentTime = Instant.now().toEpochMilli();\n+                        stacks.forEach(stack -> {\n+                            UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                            userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                            userSyncStatusService.save(userSyncStatus);\n+                        });\n+                    }\n+                    asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n                 });\n+            } catch (Throwable t) {\n+                try {\n+                    LOGGER.error(\"Failed to start operation [{}]. Attempting to mark failure in database then re-throwing\", operation, t);\n+                    operationService.failOperation(accountId, operation.getOperationId(),\n+                            \"Failed to start operation: \" + t.getLocalizedMessage());\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Failed to mark operation [{}] as failed in database.\", operation, e);\n+                } finally {\n+                    throw t;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDMyMQ==", "bodyText": "done", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387210321", "createdAt": "2020-03-03T18:28:15Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -117,22 +121,37 @@ public Operation synchronizeUsers(String accountId, String actorCrn, Set<String>\n         LOGGER.info(\"Starting operation [{}] with status [{}]\", operation.getOperationId(), operation.getStatus());\n \n         if (operation.getStatus() == OperationState.RUNNING) {\n-            boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n-            if (fullSync) {\n-                long currentTime = Instant.now().toEpochMilli();\n-                stacks.forEach(stack -> {\n-                    UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n-                    userSyncStatus.setLastFullSyncStartTime(currentTime);\n-                    userSyncStatusService.save(userSyncStatus);\n+            try {\n+                ThreadBasedUserCrnProvider.doAs(INTERNAL_USER_CRN, () -> {\n+                    boolean fullSync = userCrnFilter.isEmpty() && machineUserCrnFilter.isEmpty();\n+                    if (fullSync) {\n+                        long currentTime = Instant.now().toEpochMilli();\n+                        stacks.forEach(stack -> {\n+                            UserSyncStatus userSyncStatus = userSyncStatusService.getOrCreateForStack(stack);\n+                            userSyncStatus.setLastFullSyncStartTime(currentTime);\n+                            userSyncStatusService.save(userSyncStatus);\n+                        });\n+                    }\n+                    asyncSynchronizeUsers(operation.getOperationId(), accountId, actorCrn, stacks, userCrnFilter, machineUserCrnFilter, fullSync);\n                 });\n+            } catch (Throwable t) {\n+                try {\n+                    LOGGER.error(\"Failed to start operation [{}]. Attempting to mark failure in database then re-throwing\", operation, t);\n+                    operationService.failOperation(accountId, operation.getOperationId(),\n+                            \"Failed to start operation: \" + t.getLocalizedMessage());\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Failed to mark operation [{}] as failed in database.\", operation, e);\n+                } finally {\n+                    throw t;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxODIzMg=="}, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODMyMDQwOnYy", "diffSide": "RIGHT", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyMTo1OFrOFxM3Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODoyODoyNFrOFxRcqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNTMxNQ==", "bodyText": "super nit: mind making it immutablelist?", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387135315", "createdAt": "2020-03-03T16:21:58Z", "author": {"login": "giladwolff"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+/**\n+ * Task decorator that composes multiple task decorators.\n+ */\n+public class CompositeTaskDecorator implements TaskDecorator {\n+\n+    private final List<TaskDecorator> decorators;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDQwOA==", "bodyText": "done", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387210408", "createdAt": "2020-03-03T18:28:24Z", "author": {"login": "handavid"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+/**\n+ * Task decorator that composes multiple task decorators.\n+ */\n+public class CompositeTaskDecorator implements TaskDecorator {\n+\n+    private final List<TaskDecorator> decorators;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNTMxNQ=="}, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODMyNTQ3OnYy", "diffSide": "RIGHT", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyMjo1NlrOFxM6cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODoyODo0NFrOFxRdUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNjExMw==", "bodyText": "can runnable be null? assert?", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387136113", "createdAt": "2020-03-03T16:22:56Z", "author": {"login": "giladwolff"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+/**\n+ * Task decorator that composes multiple task decorators.\n+ */\n+public class CompositeTaskDecorator implements TaskDecorator {\n+\n+    private final List<TaskDecorator> decorators;\n+\n+    /**\n+     * Create a CompositeTaskDecorator from the list of task decorators.\n+     *\n+     * @param decorators a list of task decorators to apply, from innermost to outermost.\n+     */\n+    public CompositeTaskDecorator(List<TaskDecorator> decorators) {\n+        requireNonNull(decorators, \"decorators is null\");\n+        this.decorators = List.copyOf(decorators);\n+    }\n+\n+    @Override\n+    public Runnable decorate(Runnable runnable) {\n+        Runnable decoratedRunnable = runnable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxMDU3OQ==", "bodyText": "added requireNonNull", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387210579", "createdAt": "2020-03-03T18:28:44Z", "author": {"login": "handavid"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/CompositeTaskDecorator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+/**\n+ * Task decorator that composes multiple task decorators.\n+ */\n+public class CompositeTaskDecorator implements TaskDecorator {\n+\n+    private final List<TaskDecorator> decorators;\n+\n+    /**\n+     * Create a CompositeTaskDecorator from the list of task decorators.\n+     *\n+     * @param decorators a list of task decorators to apply, from innermost to outermost.\n+     */\n+    public CompositeTaskDecorator(List<TaskDecorator> decorators) {\n+        requireNonNull(decorators, \"decorators is null\");\n+        this.decorators = List.copyOf(decorators);\n+    }\n+\n+    @Override\n+    public Runnable decorate(Runnable runnable) {\n+        Runnable decoratedRunnable = runnable;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzNjExMw=="}, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5ODM1NDk2OnYy", "diffSide": "RIGHT", "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/UserCrnTaskDecorator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjoyODo0MlrOFxNL9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxODoyNDo1MVrOFxRU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDU5Nw==", "bodyText": "First, user crn should probably renamed to actor CRN. Secondly, this looks a bit weird to me. why does the ThreadBaseUserCrnProvider has both a getUserCrn, and doAs interface that gets the user crn? What does doAs do actually? What happens at the end of doAs? Do you need to reset something?\nWe have examples in our code base in thunderhead git where we have thread local contexts that we set. We basically have a list of them per context. These contexts expose attach/detach operation and keep track of the previous context that was attached. So maybe you want something similar? Or maybe this is similar but the terms are different?", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387140597", "createdAt": "2020-03-03T16:28:42Z", "author": {"login": "giladwolff"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/UserCrnTaskDecorator.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+\n+/**\n+ * Task decorator that propagates the user CRN from the caller to\n+ * the running task.\n+ */\n+public class UserCrnTaskDecorator implements TaskDecorator {\n+    @Override\n+    public Runnable decorate(Runnable runnable) {\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        return () -> {\n+            ThreadBasedUserCrnProvider.doAs(userCrn, runnable);\n+        };\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODQxNw==", "bodyText": "ThreadBasedUserCrnProvider has a ThreadLocal to hold the actor CRN. The UserCrnTaskDecorator (to be renamed) gets the actor crn from the calling thread threadlocal and returns a runnable that sets the actor on the executor thread using doAs. doAs will save the actor crn from the executor thread threadlocal, set that threadlocal to the specified actor, and restore the threadlocal to its original actor at the end of execution.", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r387208417", "createdAt": "2020-03-03T18:24:51Z", "author": {"login": "handavid"}, "path": "cloud-common/src/main/java/com/sequenceiq/cloudbreak/concurrent/UserCrnTaskDecorator.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.cloudbreak.concurrent;\n+\n+import org.springframework.core.task.TaskDecorator;\n+\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+\n+/**\n+ * Task decorator that propagates the user CRN from the caller to\n+ * the running task.\n+ */\n+public class UserCrnTaskDecorator implements TaskDecorator {\n+    @Override\n+    public Runnable decorate(Runnable runnable) {\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        return () -> {\n+            ThreadBasedUserCrnProvider.doAs(userCrn, runnable);\n+        };\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE0MDU5Nw=="}, "originalCommit": {"oid": "3101f715285c912b8c3db51d219bc67019749534"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNDU5OTY1OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwNzo1NDo0OVrOFyJW6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzo1NTo0NVrOFyd22g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw==", "bodyText": "why is it IAM and not FREEIPA as this service is not IAM?", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388126443", "createdAt": "2020-03-05T07:54:49Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -67,6 +69,8 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UserSyncService.class);\n \n+    private static final String INTERNAL_USER_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3ODg0Mw==", "bodyText": "Thunderhead only recognizes the internal user if the service is IAM.", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388278843", "createdAt": "2020-03-05T13:03:02Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -67,6 +69,8 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UserSyncService.class);\n \n+    private static final String INTERNAL_USER_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw=="}, "originalCommit": {"oid": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMwMTUyOQ==", "bodyText": "There are other places as well where we use the internal crn to talk to UMS with FREEIPA service type", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388301529", "createdAt": "2020-03-05T13:46:12Z", "author": {"login": "keyki"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -67,6 +69,8 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UserSyncService.class);\n \n+    private static final String INTERNAL_USER_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw=="}, "originalCommit": {"oid": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2MjI5OA==", "bodyText": "Verified locally and it doesn't work when freeipa is used instead of iam.", "url": "https://github.com/hortonworks/cloudbreak/pull/7428#discussion_r388462298", "createdAt": "2020-03-05T17:55:45Z", "author": {"login": "keyki"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -67,6 +69,8 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(UserSyncService.class);\n \n+    private static final String INTERNAL_USER_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEyNjQ0Mw=="}, "originalCommit": {"oid": "ac4d8f16f6d26cf6b777e8b1d216487bbc7db886"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2816, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}