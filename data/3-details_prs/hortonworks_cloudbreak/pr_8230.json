{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMwOTgxODE0", "number": 8230, "title": "CDPCP-1941. Sync Azure OID Mappings as part of user sync", "bodyText": "Azure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n\nSDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n\nThe FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\n\nFollow on work items include:\n\nPoll the status of the refresh after triggering it\nIndividual user level and group level sync of OIDs\nMoving some of the CM logic into cluster-cm and client-cm", "createdAt": "2020-06-08T09:21:23Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8230", "merged": true, "mergeCommit": {"oid": "f7bfc7b42c4e6ebf924334008b3fbb5cc552f90c"}, "closed": true, "closedAt": "2020-07-09T19:35:08Z", "author": {"login": "aarman-cloudera"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcr6vLXgBqjM0NTA2MTc4MzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczUS6rgFqTQ0NTkxMTA3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b40ab0ddd059c627d5bd93aaa0a54caee18c686a", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b40ab0ddd059c627d5bd93aaa0a54caee18c686a", "committedDate": "2020-06-08T08:55:23Z", "message": "CDPCP-1941. Update mock ums service to set Azure OIDs"}, "afterCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/722dc440221c51fa0c7b99786b35a68302b336b7", "committedDate": "2020-06-16T19:46:38Z", "message": "CDPCP-1941. Add unit tests related OID mapping sync"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTc2OTY4", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-433576968", "createdAt": "2020-06-18T19:19:11Z", "commit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOToxOToxMVrOGl85WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOTo1NDo1NFrOGl-GMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0ODIxNw==", "bodyText": "nit: I think a better name would be RangerCloudIdentityService", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442448217", "createdAt": "2020-06-18T19:19:11Z", "author": {"login": "handavid"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1MDMzNg==", "bodyText": "it looks like you want to do this by env crn instead of cluster crn. You should change the path and the parameter name. see getByEnvCrn method above for comparison.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442450336", "createdAt": "2020-06-18T19:23:24Z", "author": {"login": "handavid"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/endpoint/SdxEndpoint.java", "diffHunk": "@@ -165,4 +166,10 @@ SdxClusterResponse create(@ValidStackNameFormat @ValidStackNameLength @PathParam\n     @ApiOperation(value = \"list advertised datalake versions\", produces = MediaType.APPLICATION_JSON, nickname = \"advertisedruntimes\")\n     List<AdvertisedRuntime> advertisedRuntimes();\n \n+    @POST\n+    @Path(\"/crn/{crn}/ranger_cloud_identity_mapping\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1NDEyMQ==", "bodyText": "why is this the only API that needs retrying?", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442454121", "createdAt": "2020-06-18T19:30:40Z", "author": {"login": "handavid"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NDAzOQ==", "bodyText": "The AzureObjectId belongs in the UmsUsersState, not the UsersState because it's information that is provided by the UMS with no matching information from the FreeIPA side. We use equality to compare the FmsUser and FmsGroup models generated by the UMS against those generated by FreeIPA. Adding in asymmetric information will break the equality and the state difference calculation.\nsee how we handle workload credentials instead. I think that you can pass the List into the handleUser method and store it there. This will also let you only store OIDs for users that have access to the environment instead of all users.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442464039", "createdAt": "2020-06-18T19:47:27Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -217,11 +219,26 @@ private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuild\n         usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n     }\n \n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));\n+        }\n+        String azureObjectId = Iterables.getOnlyElement(azureCloudIdentities).getCloudIdentityName().getAzureCloudIdentityName().getObjectId();\n+        return Optional.of(azureObjectId);\n+    }\n+\n     private FmsUser umsUserToUser(User umsUser) {\n         FmsUser fmsUser = new FmsUser();\n         fmsUser.withName(umsUser.getWorkloadUsername());\n         fmsUser.withFirstName(getOrDefault(umsUser.getFirstName(), \"None\"));\n         fmsUser.withLastName(getOrDefault(umsUser.getLastName(), \"None\"));\n+        fmsUser.withAzureObjectId(getOptionalAzureObjectId(umsUser.getCloudIdentitiesList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjEyNw==", "bodyText": "FmsGroups suffer the same issue as FmsUsers.\nyou'll need to calculate the group mapping somewhere around line 71 and add it into the UmsUsersState somewhere around line 78", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442466127", "createdAt": "2020-06-18T19:51:35Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -241,12 +258,14 @@ private FmsUser umsMachineUserToUser(MachineUser umsMachineUser) {\n         // TODO what should the appropriate first and last name be for machine users?\n         fmsUser.withFirstName(\"Machine\");\n         fmsUser.withLastName(\"User\");\n+        fmsUser.withAzureObjectId(getOptionalAzureObjectId(umsMachineUser.getCloudIdentitiesList()));\n         return fmsUser;\n     }\n \n     private FmsGroup umsGroupToGroup(Group umsGroup) {\n         FmsGroup fmsGroup = new FmsGroup();\n         fmsGroup.withName(umsGroup.getGroupName());\n+        fmsGroup.withAzureObjectId(getOptionalAzureObjectId(umsGroup.getCloudIdentitiesList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Njg3NA==", "bodyText": "These maps should just be stored in the UmsUsersState directly.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442466874", "createdAt": "2020-06-18T19:53:02Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -274,6 +290,30 @@ private SyncStatusDetail internalSynchronizeStack(Stack stack, UmsUsersState ums\n         }\n     }\n \n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        UsersState userState = umsUsersState.getUsersState();\n+        Map<String, String> usersToAzureObjectIdMap = userState.getUsers().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NzgwNg==", "bodyText": "see comment on UmsUsersStateProvider for why we can't store this info in this model", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442467806", "createdAt": "2020-06-18T19:54:45Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/FmsGroup.java", "diffHunk": "@@ -1,20 +1,32 @@\n package com.sequenceiq.freeipa.service.freeipa.user.model;\n \n import java.util.Objects;\n+import java.util.Optional;\n \n public class FmsGroup {\n \n     private String name;\n \n+    private Optional<String> azureObjectId = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Nzg5MQ==", "bodyText": "see comment on UmsUsersStateProvider for why we can't store this info in this model", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442467891", "createdAt": "2020-06-18T19:54:54Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/FmsUser.java", "diffHunk": "@@ -10,6 +11,8 @@\n \n     private String lastName;\n \n+    private Optional<String> azureObjectId = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTA5MTEz", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-433909113", "createdAt": "2020-06-19T08:54:04Z", "commit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1NDowNFrOGmNSNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1NDowNFrOGmNSNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNjcyNg==", "bodyText": "Maybe you could include the cluster-cm module and move all the CM related code there and use it from Data Lake.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442716726", "createdAt": "2020-06-19T08:54:04Z", "author": {"login": "keyki"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTA5NzMz", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-433909733", "createdAt": "2020-06-19T08:55:08Z", "commit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1NTowOFrOGmNTvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1NTowOFrOGmNTvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNzExOA==", "bodyText": "Note: we need to add cluster proxy URL in CBD and helm-charts as well", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442717118", "createdAt": "2020-06-19T08:55:08Z", "author": {"login": "keyki"}, "path": "datalake/src/main/resources/application.yml", "diffHunk": "@@ -100,4 +100,7 @@ cb:\n     disabled: false\n \n notification:\n-  urls: http://localhost:3000/notifications\n\\ No newline at end of file\n+  urls: http://localhost:3000/notifications\n+\n+clusterProxy:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTEwNzcy", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-433910772", "createdAt": "2020-06-19T08:56:48Z", "commit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1Njo0OFrOGmNWcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODo1Njo0OFrOGmNWcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNzgwOA==", "bodyText": "This is a new dependency of FreeIPA, thus we need to introduce it in CBD and helm-charts as well.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442717808", "createdAt": "2020-06-19T08:56:48Z", "author": {"login": "keyki"}, "path": "freeipa/src/main/resources/application.yml", "diffHunk": "@@ -64,6 +64,9 @@ freeipa:\n   environment:\n     url: http://localhost:8088\n     contextPath: /environmentservice\n+  sdx:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTE4MTcx", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-433918171", "createdAt": "2020-06-19T09:08:08Z", "commit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOTowODowOFrOGmNqKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwOToyOTozMlrOGmOSgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMjg1Nw==", "bodyText": "instead of logging when empty we should log sdxclusters we will sync, so the if won't be necessary", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442722857", "createdAt": "2020-06-19T09:08:08Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentityRangerSyncService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    public void setAzureCloudIdentityMapping(String environmentCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        LOGGER.info(\"Setting Azure cloud id mappings for environment = {}\", environmentCrn);\n+        List<SdxCluster> sdxClusters = sdxService.listSdxByEnvCrn(environmentCrn);\n+        if (sdxClusters.isEmpty()) {\n+            LOGGER.info(\"Environment has no datalake clusters to sync\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzExMg==", "bodyText": "I think you should use a more specific exception here, and might log it", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442723112", "createdAt": "2020-06-19T09:08:38Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentityRangerSyncService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    public void setAzureCloudIdentityMapping(String environmentCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        LOGGER.info(\"Setting Azure cloud id mappings for environment = {}\", environmentCrn);\n+        List<SdxCluster> sdxClusters = sdxService.listSdxByEnvCrn(environmentCrn);\n+        if (sdxClusters.isEmpty()) {\n+            LOGGER.info(\"Environment has no datalake clusters to sync\");\n+        }\n+        sdxClusters.forEach(sdxCluster -> {\n+            String stackCrn = sdxCluster.getStackCrn();\n+            LOGGER.info(\"Updating azure cloud id mappings for datalake stack crn = {}, environment = {}\", stackCrn, environmentCrn);\n+            try {\n+                clouderaManagerRangerUtil.setAzureCloudIdentityMapping(stackCrn, azureUserMapping, azureGroupMapping);\n+            } catch (ApiException e) {\n+                throw new RuntimeException(\"Encountered api exception\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzUxOQ==", "bodyText": "could be refaactored into a separate method", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442723519", "createdAt": "2020-06-19T09:09:26Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentityRangerSyncService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    public void setAzureCloudIdentityMapping(String environmentCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        LOGGER.info(\"Setting Azure cloud id mappings for environment = {}\", environmentCrn);\n+        List<SdxCluster> sdxClusters = sdxService.listSdxByEnvCrn(environmentCrn);\n+        if (sdxClusters.isEmpty()) {\n+            LOGGER.info(\"Environment has no datalake clusters to sync\");\n+        }\n+        sdxClusters.forEach(sdxCluster -> {\n+            String stackCrn = sdxCluster.getStackCrn();\n+            LOGGER.info(\"Updating azure cloud id mappings for datalake stack crn = {}, environment = {}\", stackCrn, environmentCrn);\n+            try {\n+                clouderaManagerRangerUtil.setAzureCloudIdentityMapping(stackCrn, azureUserMapping, azureGroupMapping);\n+            } catch (ApiException e) {\n+                throw new RuntimeException(\"Encountered api exception\", e);\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTM3Nw==", "bodyText": "why 20sec? I think we use 1 min in CB for this", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442725377", "createdAt": "2020-06-19T09:13:22Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerProxiedClientFactory.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiClient;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Component\n+public class ClouderaManagerProxiedClientFactory {\n+\n+    private static final String API_VERSION_32 = \"v32\";\n+\n+    private static final int CM_READ_TIMEOUT_MS =  60 * 1000;\n+\n+    private static final int CM_CONNECT_TIMEOUT_MS = 20 * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTU2NA==", "bodyText": "why this version? in CB we use 31 or 40. I think this should be in sync", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442725564", "createdAt": "2020-06-19T09:13:48Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerProxiedClientFactory.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiClient;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Component\n+public class ClouderaManagerProxiedClientFactory {\n+\n+    private static final String API_VERSION_32 = \"v32\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjY2MQ==", "bodyText": "altogether it would be nice if you could use https://github.com/hortonworks/cloudbreak/blob/master/client-cm/src/main/java/com/sequenceiq/cloudbreak/cm/client/ClouderaManagerApiClientProvider.java instead of this class", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442726661", "createdAt": "2020-06-19T09:16:03Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerProxiedClientFactory.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiClient;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Component\n+public class ClouderaManagerProxiedClientFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzg2NQ==", "bodyText": "please don't use in middle of method return", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442727865", "createdAt": "2020-06-19T09:18:43Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);\n+            ApiCommand response = Iterables.getOnlyElement(bulkResponse.getItems());\n+            LOGGER.info(\"ApiCommand response for role refresh = {}\", response);\n+            if (response != null && (response.getActive() || response.getSuccess())) {\n+                LOGGER.info(\"Successfully triggered role refresh\");\n+            } else {\n+                throw new RetryException(\"Role refresh was not successfully trigerred\");\n+            }\n+        } catch (ApiException e) {\n+            throw new RetryException(\"Encountered ApiException on role refresh\", e);\n+        }\n+    }\n+\n+    private boolean supportsCloudIdMapping(RolesResourceApi rolesResourceApi, String clusterName, String rangerUserSyncRole) throws ApiException {\n+        ApiConfigList configList = rolesResourceApi.readRoleConfig(clusterName, RANGER_SERVICE_NAME, rangerUserSyncRole, \"full\");\n+        return configList.getItems().stream().map(ApiConfig::getName).anyMatch(configName -> configName.equals(AZURE_USER_MAPPING));\n+    }\n+\n+    public void setAzureCloudIdentityMapping(String stackCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) throws ApiException {\n+        // NOTE: The necessary configs changed here are only available in CM7.2-1\n+        // TODO Skip setting role and trigerring refresh if the configs haven't changed\n+        ApiClient client = clouderaManagerProxiedClientFactory.getProxiedClouderaManagerClient(stackCrn);\n+        String clusterName = getClusterName(client);\n+        String rangerUserSyncRoleName = getRangerUserSyncRoleName(client, clusterName);\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        if (!supportsCloudIdMapping(rolesResourceApi, clusterName, rangerUserSyncRoleName)) {\n+            LOGGER.info(\"This version of CM does not support cloud identity mapping. Skipping.\");\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyODk1MA==", "bodyText": "isn't already there a general solution for this @horadla23 ?", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442728950", "createdAt": "2020-06-19T09:20:58Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/controller/sdx/SdxController.java", "diffHunk": "@@ -239,4 +248,19 @@ public FlowIdentifier stopByCrn(@ResourceCrn String crn) {\n         return cdpConfigService.getAdvertisedRuntimes();\n     }\n \n+    // custom authorization check\n+    @Override\n+    @DisableCheckPermissions\n+    public void setRangerCloudIdentityMapping(String envCrn, SetRangerCloudIdentityMappingRequest request) {\n+        checkIsInternalActor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTA0Mg==", "bodyText": "unnecessary comment", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442729042", "createdAt": "2020-06-19T09:21:10Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/controller/sdx/SdxController.java", "diffHunk": "@@ -239,4 +248,19 @@ public FlowIdentifier stopByCrn(@ResourceCrn String crn) {\n         return cdpConfigService.getAdvertisedRuntimes();\n     }\n \n+    // custom authorization check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTU0MQ==", "bodyText": "this might be debug if we really need it", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442729541", "createdAt": "2020-06-19T09:22:15Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/service/sdx/SdxService.java", "diffHunk": "@@ -509,6 +509,12 @@ private void setTagsSafe(SdxClusterRequest sdxClusterRequest, SdxCluster sdxClus\n         return sdxClusterRepository.findByAccountIdAndEnvCrnAndDeletedIsNull(accountIdFromCrn, envCrn);\n     }\n \n+    public List<SdxCluster> listSdxByEnvCrn(String envCrn) {\n+        LOGGER.info(\"Listing SDX clusters by environment crn {}\", envCrn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA==", "bodyText": "I think some annotations are missing here, like ignore unknown etc", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442730204", "createdAt": "2020-06-19T09:23:35Z", "author": {"login": "lacikaaa"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/model/SetRangerCloudIdentityMappingRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.sdx.api.model;\n+\n+import java.util.Map;\n+\n+public class SetRangerCloudIdentityMappingRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMjMxMQ==", "bodyText": "this could be private", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442732311", "createdAt": "2020-06-19T09:27:49Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMzE4Nw==", "bodyText": "this should go into an else branch, maybe into a separate method", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442733187", "createdAt": "2020-06-19T09:29:32Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -217,11 +219,26 @@ private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuild\n         usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n     }\n \n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));\n+        }\n+        String azureObjectId = Iterables.getOnlyElement(azureCloudIdentities).getCloudIdentityName().getAzureCloudIdentityName().getObjectId();\n+        return Optional.of(azureObjectId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/722dc440221c51fa0c7b99786b35a68302b336b7", "committedDate": "2020-06-16T19:46:38Z", "message": "CDPCP-1941. Add unit tests related OID mapping sync"}, "afterCommit": {"oid": "67db630a9def3f4f0155d2b0762dfd92b7fb7860", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/67db630a9def3f4f0155d2b0762dfd92b7fb7860", "committedDate": "2020-06-25T22:10:40Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67db630a9def3f4f0155d2b0762dfd92b7fb7860", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/67db630a9def3f4f0155d2b0762dfd92b7fb7860", "committedDate": "2020-06-25T22:10:40Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "9d86ae37218d381e44e22608bba2b1df5eb670af", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9d86ae37218d381e44e22608bba2b1df5eb670af", "committedDate": "2020-06-26T06:25:32Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Mzg1ODM3", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-438385837", "createdAt": "2020-06-26T15:22:39Z", "commit": {"oid": "9d86ae37218d381e44e22608bba2b1df5eb670af"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNToyMjozOVrOGpk9WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTozNjoxOVrOGplcJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1MDMyOQ==", "bodyText": "See the path on line 68. it looks like\n/envcrn/{envCrn}\nThis should match to distinguish between the resource crn and the environment crn", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r446250329", "createdAt": "2020-06-26T15:22:39Z", "author": {"login": "handavid"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/endpoint/SdxEndpoint.java", "diffHunk": "@@ -165,4 +166,10 @@ SdxClusterResponse create(@ValidStackNameFormat @ValidStackNameLength @PathParam\n     @ApiOperation(value = \"list advertised datalake versions\", produces = MediaType.APPLICATION_JSON, nickname = \"advertisedruntimes\")\n     List<AdvertisedRuntime> advertisedRuntimes();\n \n+    @POST\n+    @Path(\"/crn/{envCrn}/ranger_cloud_identity_mapping\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d86ae37218d381e44e22608bba2b1df5eb670af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1ODIxMg==", "bodyText": "this adds cloud identities for all users, regardless of if they have access to the environment. Is this desirable? I would think that you would only care about users that have access to the environment. Imagine if an account has 1000 user but the environment only has 100. You would be syncing the other 900 users cloud identities.\nYou can filter this map by the users that are in the umsUsersState.getUserState().getUsers()", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r446258212", "createdAt": "2020-06-26T15:36:19Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -274,6 +292,51 @@ private SyncStatusDetail internalSynchronizeStack(Stack stack, UmsUsersState ums\n         }\n     }\n \n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        } else if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));\n+        } else {\n+            String azureObjectId = Iterables.getOnlyElement(azureCloudIdentities).getCloudIdentityName().getAzureCloudIdentityName().getObjectId();\n+            return Optional.of(azureObjectId);\n+        }\n+    }\n+\n+    private Map<String, String> getAzureObjectIdMap(Map<String, List<CloudIdentity>> cloudIdentityMapping) {\n+        ImmutableMap.Builder<String, String> azureObjectIdMap = ImmutableMap.builder();\n+        cloudIdentityMapping.forEach((key, cloudIdentities) -> {\n+            Optional<String> azureObjectId = getOptionalAzureObjectId(cloudIdentities);\n+            if (azureObjectId.isPresent()) {\n+                azureObjectIdMap.put(key, azureObjectId.get());\n+            }\n+        });\n+        return azureObjectIdMap.build();\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getUserToCloudIdentityMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d86ae37218d381e44e22608bba2b1df5eb670af"}, "originalPosition": 72}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d86ae37218d381e44e22608bba2b1df5eb670af", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9d86ae37218d381e44e22608bba2b1df5eb670af", "committedDate": "2020-06-26T06:25:32Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "1288746411788c6258036c271f5fe679d60f61bc", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1288746411788c6258036c271f5fe679d60f61bc", "committedDate": "2020-06-29T07:21:04Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzIwMzgy", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-439320382", "createdAt": "2020-06-29T16:40:40Z", "commit": {"oid": "1288746411788c6258036c271f5fe679d60f61bc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjo0MDo0MFrOGqZPBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjo0MDo0MFrOGqZPBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwNjgyMQ==", "bodyText": "nit: if you reverse the order of conditions and inline the entitlement check here, then we can skip the entitlement check if it's not a full sync.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447106821", "createdAt": "2020-06-29T16:40:40Z", "author": {"login": "handavid"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -283,6 +290,12 @@ private SyncStatusDetail internalSynchronizeStack(Stack stack, UmsUsersState ums\n                 workloadCredentialService.setWorkloadCredentials(freeIpaClient, umsUsersState.getUsersWorkloadCredentialMap(), warnings::put);\n             }\n \n+            boolean hasCloudIdentityEntitlement = entitlementService.cloudIdentityMappingEnabled(INTERNAL_ACTOR_CRN, stack.getAccountId());\n+            // TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\n+            if (hasCloudIdentityEntitlement && fullSync) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1288746411788c6258036c271f5fe679d60f61bc"}, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1288746411788c6258036c271f5fe679d60f61bc", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1288746411788c6258036c271f5fe679d60f61bc", "committedDate": "2020-06-29T07:21:04Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "c629b1ea476e88ad4e4b71afea36b46616a23d2e", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c629b1ea476e88ad4e4b71afea36b46616a23d2e", "committedDate": "2020-06-30T05:19:25Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c629b1ea476e88ad4e4b71afea36b46616a23d2e", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c629b1ea476e88ad4e4b71afea36b46616a23d2e", "committedDate": "2020-06-30T05:19:25Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/d840e6cf1a31933420365a228d672675691fa93c", "committedDate": "2020-06-30T07:57:19Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5ODc5MjU4", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-439879258", "createdAt": "2020-06-30T10:23:15Z", "commit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMDoyMzoxNVrOGq19cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMTowNjoyOVrOGq3WbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU3NzQ1OA==", "bodyText": "this is still valid", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447577458", "createdAt": "2020-06-30T10:23:15Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMjMxMQ=="}, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU3ODI1MA==", "bodyText": "usually method with boolean return value start with is. eg: isCloudIdMappingSupported", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447578250", "createdAt": "2020-06-30T10:24:36Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);\n+            ApiCommand response = Iterables.getOnlyElement(bulkResponse.getItems());\n+            LOGGER.info(\"ApiCommand response for role refresh = {}\", response);\n+            if (response != null && (response.getActive() || response.getSuccess())) {\n+                LOGGER.info(\"Successfully triggered role refresh\");\n+            } else {\n+                LOGGER.debug(\"Failed to trigger role refresh\");\n+                throw new RangerCloudIdentitySyncException(\"Role refresh was not successfully trigerred\");\n+            }\n+        } catch (ApiException e) {\n+            throw new RangerCloudIdentitySyncException(\"Encountered ApiException on role refresh\", e);\n+        }\n+    }\n+\n+    private boolean supportsCloudIdMapping(RolesResourceApi rolesResourceApi, String clusterName, String rangerUserSyncRole) throws ApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MTM4Mg==", "bodyText": "this looks like a synchronous call to me, so DL service will wait until it's finished. But if I check the chain it looks like to me, this whole call from freeipa is synchronous, so freeipa will also hang until this returns. I don't think this is a good idea. Somewhere it should bbe converted to async. Most probably around RangerCloudIdentityService#setAzureCloudIdentityMapping", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447581382", "createdAt": "2020-06-30T10:30:14Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MjI2MQ==", "bodyText": "should be reversed: RANGER_USER_SYNC_ROLE_TYPE.equals(apiRole.getType())", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447582261", "createdAt": "2020-06-30T10:31:57Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NDQyMA==", "bodyText": "log would be nice here", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447584420", "createdAt": "2020-06-30T10:35:53Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);\n+            ApiCommand response = Iterables.getOnlyElement(bulkResponse.getItems());\n+            LOGGER.info(\"ApiCommand response for role refresh = {}\", response);\n+            if (response != null && (response.getActive() || response.getSuccess())) {\n+                LOGGER.info(\"Successfully triggered role refresh\");\n+            } else {\n+                LOGGER.debug(\"Failed to trigger role refresh\");\n+                throw new RangerCloudIdentitySyncException(\"Role refresh was not successfully trigerred\");\n+            }\n+        } catch (ApiException e) {\n+            throw new RangerCloudIdentitySyncException(\"Encountered ApiException on role refresh\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NDU5MA==", "bodyText": "log would be nice here", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447584590", "createdAt": "2020-06-30T10:36:14Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class RangerCloudIdentityService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RangerCloudIdentityService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    private void setAzureCloudIdentityMapping(SdxCluster sdxCluster, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        String stackCrn = sdxCluster.getStackCrn();\n+        LOGGER.info(\"Updating azure cloud id mappings for datalake stack crn = {}\", stackCrn);\n+        try {\n+            clouderaManagerRangerUtil.setAzureCloudIdentityMapping(stackCrn, azureUserMapping, azureGroupMapping);\n+        } catch (ApiException e) {\n+            throw new RangerCloudIdentitySyncException(\"Encountered api exception\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NTg4NA==", "bodyText": "there is no exception mapper for this. is it on purpose?", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447585884", "createdAt": "2020-06-30T10:38:41Z", "author": {"login": "lacikaaa"}, "path": "datalake/src/main/java/com/sequenceiq/datalake/controller/exception/RangerCloudIdentitySyncException.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.datalake.controller.exception;\n+\n+public class RangerCloudIdentitySyncException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MDY1MQ==", "bodyText": "@ApiModel\n@JsonIgnoreProperties(ignoreUnknown = true)`\n\nmissing", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447590651", "createdAt": "2020-06-30T10:47:36Z", "author": {"login": "lacikaaa"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/model/SetRangerCloudIdentityMappingRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.sdx.api.model;\n+\n+import java.util.Map;\n+\n+public class SetRangerCloudIdentityMappingRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA=="}, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MTAwMQ==", "bodyText": "@NotNull is missing for both fields based on your comment", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447591001", "createdAt": "2020-06-30T10:48:12Z", "author": {"login": "lacikaaa"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/model/SetRangerCloudIdentityMappingRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.sdx.api.model;\n+\n+import java.util.Map;\n+\n+public class SetRangerCloudIdentityMappingRequest {\n+\n+    private Map<String, String> azureUserMapping;\n+\n+    private Map<String, String> azureGroupMapping;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MTEzNw==", "bodyText": "@ValidCrn for envCrn and @NotNull and @Valid for SetRangerCloudIdentityMappingRequest", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447591137", "createdAt": "2020-06-30T10:48:29Z", "author": {"login": "lacikaaa"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/endpoint/SdxEndpoint.java", "diffHunk": "@@ -196,4 +197,11 @@ SdxDatabaseBackupStatusResponse getBackupDatabaseStatusByName(@PathParam(\"name\")\n     @ApiOperation(value = \"Get the status of datalake database restore operation\", produces = MediaType.APPLICATION_JSON, nickname = \"restoreDatabaseStatus\")\n     SdxDatabaseRestoreStatusResponse getRestoreDatabaseStatusByName(@PathParam(\"name\") String name,\n             @QueryParam(\"operationId\") String operationId);\n+\n+    @POST\n+    @Path(\"/envcrn/{envCrn}/ranger_cloud_identity_mapping\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = \"set ranger cloud identity mapping\", produces = MediaType.APPLICATION_JSON, nickname = \"setRangerCloudIdentityMapping\")\n+    void setRangerCloudIdentityMapping(@PathParam(\"envCrn\") String envCrn, SetRangerCloudIdentityMappingRequest request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NTA2Ng==", "bodyText": "log before this would be nice", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447595066", "createdAt": "2020-06-30T10:55:53Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NTI5NQ==", "bodyText": "we should log here with the request", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447595295", "createdAt": "2020-06-30T10:56:22Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {\n+            syncAzureObjectIds(stack, umsUsersState, warnings);\n+        }\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, List<CloudIdentity>> userCloudIdentites = getUserCloudIdentitiesToSync(umsUsersState);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(userCloudIdentites);\n+        Map<String, String> groupToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getGroupToCloudIdentityMap());\n+\n+        SetRangerCloudIdentityMappingRequest setRangerCloudIdentityMappingRequest = new SetRangerCloudIdentityMappingRequest();\n+        setRangerCloudIdentityMappingRequest.setAzureUserMapping(userToAzureObjectIdMap);\n+        setRangerCloudIdentityMappingRequest.setAzureGroupMapping(groupToAzureObjectIdMap);\n+        try {\n+            // TODO The SDX endpoint currently sets the config and triggers refresh. The SDX endpoint should also be updated\n+            //      to allow polling the status of the refresh.\n+            sdxEndpoint.setRangerCloudIdentityMapping(envCrn, setRangerCloudIdentityMappingRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NTUxNw==", "bodyText": "implement toString please", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447595517", "createdAt": "2020-06-30T10:56:48Z", "author": {"login": "lacikaaa"}, "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/model/SetRangerCloudIdentityMappingRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.sdx.api.model;\n+\n+import java.util.Map;\n+\n+public class SetRangerCloudIdentityMappingRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA=="}, "originalCommit": {"oid": "722dc440221c51fa0c7b99786b35a68302b336b7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5ODczOQ==", "bodyText": "some log here and in getOptionalAzureObjectId might be useful to investigate if something is not as desired", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447598739", "createdAt": "2020-06-30T11:03:19Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {\n+            syncAzureObjectIds(stack, umsUsersState, warnings);\n+        }\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, List<CloudIdentity>> userCloudIdentites = getUserCloudIdentitiesToSync(umsUsersState);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(userCloudIdentites);\n+        Map<String, String> groupToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getGroupToCloudIdentityMap());\n+\n+        SetRangerCloudIdentityMappingRequest setRangerCloudIdentityMappingRequest = new SetRangerCloudIdentityMappingRequest();\n+        setRangerCloudIdentityMappingRequest.setAzureUserMapping(userToAzureObjectIdMap);\n+        setRangerCloudIdentityMappingRequest.setAzureGroupMapping(groupToAzureObjectIdMap);\n+        try {\n+            // TODO The SDX endpoint currently sets the config and triggers refresh. The SDX endpoint should also be updated\n+            //      to allow polling the status of the refresh.\n+            sdxEndpoint.setRangerCloudIdentityMapping(envCrn, setRangerCloudIdentityMappingRequest);\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Failed to set cloud identity mapping for environment {}\", envCrn, e);\n+            warnings.accept(envCrn, \"Failed to set cloud identity mapping\");\n+        }\n+    }\n+\n+    private Map<String, String> getAzureObjectIdMap(Map<String, List<CloudIdentity>> cloudIdentityMapping) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDIzNw==", "bodyText": "shouldn't we handle this exception somewhere? or is it ok if UserSyncService#internalSynchronizeStack handles it?\ncc @handavid", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447600237", "createdAt": "2020-06-30T11:06:29Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {\n+            syncAzureObjectIds(stack, umsUsersState, warnings);\n+        }\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, List<CloudIdentity>> userCloudIdentites = getUserCloudIdentitiesToSync(umsUsersState);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(userCloudIdentites);\n+        Map<String, String> groupToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getGroupToCloudIdentityMap());\n+\n+        SetRangerCloudIdentityMappingRequest setRangerCloudIdentityMappingRequest = new SetRangerCloudIdentityMappingRequest();\n+        setRangerCloudIdentityMappingRequest.setAzureUserMapping(userToAzureObjectIdMap);\n+        setRangerCloudIdentityMappingRequest.setAzureGroupMapping(groupToAzureObjectIdMap);\n+        try {\n+            // TODO The SDX endpoint currently sets the config and triggers refresh. The SDX endpoint should also be updated\n+            //      to allow polling the status of the refresh.\n+            sdxEndpoint.setRangerCloudIdentityMapping(envCrn, setRangerCloudIdentityMappingRequest);\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Failed to set cloud identity mapping for environment {}\", envCrn, e);\n+            warnings.accept(envCrn, \"Failed to set cloud identity mapping\");\n+        }\n+    }\n+\n+    private Map<String, String> getAzureObjectIdMap(Map<String, List<CloudIdentity>> cloudIdentityMapping) {\n+        ImmutableMap.Builder<String, String> azureObjectIdMap = ImmutableMap.builder();\n+        cloudIdentityMapping.forEach((key, cloudIdentities) -> {\n+            Optional<String> azureObjectId = getOptionalAzureObjectId(cloudIdentities);\n+            if (azureObjectId.isPresent()) {\n+                azureObjectIdMap.put(key, azureObjectId.get());\n+            }\n+        });\n+        return azureObjectIdMap.build();\n+    }\n+\n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        } else if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c"}, "originalPosition": 78}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d840e6cf1a31933420365a228d672675691fa93c", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/d840e6cf1a31933420365a228d672675691fa93c", "committedDate": "2020-06-30T07:57:19Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "4c0bbac5b448e56b93dc0053beadf0261e05dc33", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4c0bbac5b448e56b93dc0053beadf0261e05dc33", "committedDate": "2020-06-30T21:05:50Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c0bbac5b448e56b93dc0053beadf0261e05dc33", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4c0bbac5b448e56b93dc0053beadf0261e05dc33", "committedDate": "2020-06-30T21:05:50Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "eac154cbbdaaf9a5d4e58a85f475d173ac61f966", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/eac154cbbdaaf9a5d4e58a85f475d173ac61f966", "committedDate": "2020-06-30T21:12:23Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eac154cbbdaaf9a5d4e58a85f475d173ac61f966", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/eac154cbbdaaf9a5d4e58a85f475d173ac61f966", "committedDate": "2020-06-30T21:12:23Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "bc83bee2b7db2c76baa646bda439d57e05466af8", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/bc83bee2b7db2c76baa646bda439d57e05466af8", "committedDate": "2020-07-06T07:53:57Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTA1MTM4", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-442905138", "createdAt": "2020-07-06T09:12:09Z", "commit": {"oid": "bc83bee2b7db2c76baa646bda439d57e05466af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxMjowOVrOGtPQEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxMjowOVrOGtPQEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4ODk3Ng==", "bodyText": "I think we should have an env var to enable and disable the entitlement. See a couple of lines above.", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r450088976", "createdAt": "2020-07-06T09:12:09Z", "author": {"login": "keyki"}, "path": "mock-caas/src/main/java/com/sequenceiq/caas/grpc/service/auth/MockUserManagementService.java", "diffHunk": "@@ -531,6 +533,7 @@ public void getAccount(GetAccountRequest request, StreamObserver<GetAccountRespo\n                                 .setWorkloadSubdomain(ACCOUNT_SUBDOMAIN)\n                                 .addEntitlements(createEntitlement(CDP_AZURE))\n                                 .addEntitlements(createEntitlement(CDP_AUTOMATIC_USERSYNC_POLLER))\n+                                .addEntitlements(createEntitlement(CDP_CLOUD_IDENTITY_MAPPING))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc83bee2b7db2c76baa646bda439d57e05466af8"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc83bee2b7db2c76baa646bda439d57e05466af8", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/bc83bee2b7db2c76baa646bda439d57e05466af8", "committedDate": "2020-07-06T07:53:57Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "81806b0e47838eaf821878c8b317faaa98cc1ef5", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/81806b0e47838eaf821878c8b317faaa98cc1ef5", "committedDate": "2020-07-06T09:23:43Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTI1NjY5", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-442925669", "createdAt": "2020-07-06T09:40:38Z", "commit": {"oid": "81806b0e47838eaf821878c8b317faaa98cc1ef5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81806b0e47838eaf821878c8b317faaa98cc1ef5", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/81806b0e47838eaf821878c8b317faaa98cc1ef5", "committedDate": "2020-07-06T09:23:43Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "3162c470c012022d99c8071f0f68237d28c15cdc", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3162c470c012022d99c8071f0f68237d28c15cdc", "committedDate": "2020-07-06T09:58:21Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "committedDate": "2020-07-06T19:27:45Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3162c470c012022d99c8071f0f68237d28c15cdc", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3162c470c012022d99c8071f0f68237d28c15cdc", "committedDate": "2020-07-06T09:58:21Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}, "afterCommit": {"oid": "33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "author": {"user": {"login": "aarman-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "committedDate": "2020-07-06T19:27:45Z", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTExMDc1", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#pullrequestreview-445911075", "createdAt": "2020-07-09T19:34:59Z", "commit": {"oid": "33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1816, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}