{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNTM4NTQ1", "number": 7757, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzoyMTowM1rODv3Uig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjowODozMlrODwYKsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTE2MDQyOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStopService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzoyMTowM1rOGCiHxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0MDoyM1rOGCivqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwOTM4MQ==", "bodyText": "some log would be nice that we would like stop the which db instance", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405309381", "createdAt": "2020-04-08T07:21:03Z", "author": {"login": "doktoric"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStopService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.connector.resource;\n+\n+import com.amazonaws.services.rds.AmazonRDS;\n+import com.amazonaws.services.rds.model.StopDBInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.aws.AwsClient;\n+import com.sequenceiq.cloudbreak.cloud.aws.scheduler.AwsBackoffSyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.aws.task.AwsPollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+@Service\n+public class AwsRdsStopService {\n+\n+    private static final String SUCCESS_STATUS = \"stopped\";\n+\n+    @Inject\n+    private AwsClient awsClient;\n+\n+    @Inject\n+    private AwsPollTaskFactory awsPollTaskFactory;\n+\n+    @Inject\n+    private AwsBackoffSyncPollingScheduler<Boolean> awsBackoffSyncPollingScheduler;\n+\n+    public void stop(AuthenticatedContext ac, String dbInstanceIdentifier) throws ExecutionException, TimeoutException, InterruptedException {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonRDS rdsClient = awsClient.createRdsClient(credentialView, regionName);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxODk3NQ==", "bodyText": "Done in \n  \n    \n      cloudbreak/redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStopService.java\n    \n    \n         Line 41\n      in\n      fbe8818\n    \n    \n    \n    \n\n        \n          \n           LOGGER.debug(\"Stop called for: {}\", dbStack); \n        \n    \n  \n\n\nShould I implement it here as well?", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405318975", "createdAt": "2020-04-08T07:39:13Z", "author": {"login": "pkedvessy"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStopService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.connector.resource;\n+\n+import com.amazonaws.services.rds.AmazonRDS;\n+import com.amazonaws.services.rds.model.StopDBInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.aws.AwsClient;\n+import com.sequenceiq.cloudbreak.cloud.aws.scheduler.AwsBackoffSyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.aws.task.AwsPollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+@Service\n+public class AwsRdsStopService {\n+\n+    private static final String SUCCESS_STATUS = \"stopped\";\n+\n+    @Inject\n+    private AwsClient awsClient;\n+\n+    @Inject\n+    private AwsPollTaskFactory awsPollTaskFactory;\n+\n+    @Inject\n+    private AwsBackoffSyncPollingScheduler<Boolean> awsBackoffSyncPollingScheduler;\n+\n+    public void stop(AuthenticatedContext ac, String dbInstanceIdentifier) throws ExecutionException, TimeoutException, InterruptedException {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonRDS rdsClient = awsClient.createRdsClient(credentialView, regionName);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwOTM4MQ=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxOTU5NQ==", "bodyText": "nope thats cool thanks", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405319595", "createdAt": "2020-04-08T07:40:23Z", "author": {"login": "doktoric"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStopService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.connector.resource;\n+\n+import com.amazonaws.services.rds.AmazonRDS;\n+import com.amazonaws.services.rds.model.StopDBInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.aws.AwsClient;\n+import com.sequenceiq.cloudbreak.cloud.aws.scheduler.AwsBackoffSyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.aws.task.AwsPollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+@Service\n+public class AwsRdsStopService {\n+\n+    private static final String SUCCESS_STATUS = \"stopped\";\n+\n+    @Inject\n+    private AwsClient awsClient;\n+\n+    @Inject\n+    private AwsPollTaskFactory awsPollTaskFactory;\n+\n+    @Inject\n+    private AwsBackoffSyncPollingScheduler<Boolean> awsBackoffSyncPollingScheduler;\n+\n+    public void stop(AuthenticatedContext ac, String dbInstanceIdentifier) throws ExecutionException, TimeoutException, InterruptedException {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonRDS rdsClient = awsClient.createRdsClient(credentialView, regionName);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwOTM4MQ=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTE2MDkzOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStartService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzoyMToxM1rOGCiIFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzozODoxN1rOGCirMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwOTQ2Mw==", "bodyText": "some log would be nice that we would like start the which db instance", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405309463", "createdAt": "2020-04-08T07:21:13Z", "author": {"login": "doktoric"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStartService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.connector.resource;\n+\n+import com.amazonaws.services.rds.AmazonRDS;\n+import com.amazonaws.services.rds.model.StartDBInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.aws.AwsClient;\n+import com.sequenceiq.cloudbreak.cloud.aws.scheduler.AwsBackoffSyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.aws.task.AwsPollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+@Service\n+public class AwsRdsStartService {\n+\n+    private static final String SUCCESS_STATUS = \"available\";\n+\n+    @Inject\n+    private AwsClient awsClient;\n+\n+    @Inject\n+    private AwsPollTaskFactory awsPollTaskFactory;\n+\n+    @Inject\n+    private AwsBackoffSyncPollingScheduler<Boolean> awsBackoffSyncPollingScheduler;\n+\n+    public void start(AuthenticatedContext ac, String dbInstanceIdentifier) throws ExecutionException, TimeoutException, InterruptedException {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonRDS rdsClient = awsClient.createRdsClient(credentialView, regionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxODQ0OQ==", "bodyText": "Done in \n  \n    \n      cloudbreak/redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStartService.java\n    \n    \n         Line 41\n      in\n      fbe8818\n    \n    \n    \n    \n\n        \n          \n           LOGGER.debug(\"Start called for: {}\", dbStack); \n        \n    \n  \n\n\nShould I implement it here as well?", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405318449", "createdAt": "2020-04-08T07:38:17Z", "author": {"login": "pkedvessy"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsRdsStartService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.connector.resource;\n+\n+import com.amazonaws.services.rds.AmazonRDS;\n+import com.amazonaws.services.rds.model.StartDBInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.aws.AwsClient;\n+import com.sequenceiq.cloudbreak.cloud.aws.scheduler.AwsBackoffSyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.aws.task.AwsPollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.aws.view.AwsCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+@Service\n+public class AwsRdsStartService {\n+\n+    private static final String SUCCESS_STATUS = \"available\";\n+\n+    @Inject\n+    private AwsClient awsClient;\n+\n+    @Inject\n+    private AwsPollTaskFactory awsPollTaskFactory;\n+\n+    @Inject\n+    private AwsBackoffSyncPollingScheduler<Boolean> awsBackoffSyncPollingScheduler;\n+\n+    public void start(AuthenticatedContext ac, String dbInstanceIdentifier) throws ExecutionException, TimeoutException, InterruptedException {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonRDS rdsClient = awsClient.createRdsClient(credentialView, regionName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwOTQ2Mw=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTE4MTUwOnYy", "diffSide": "RIGHT", "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/handler/StartDatabaseServerHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzoyNzozMlrOGCiU_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0MTowOFrOGCixMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMjc2Ng==", "bodyText": "I think we should check first that do we really need to start the initiate start action or not.\nWhen one of the CB node dies and trying to restart the flow we dont want to initiate the start event twice", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405312766", "createdAt": "2020-04-08T07:27:32Z", "author": {"login": "doktoric"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/handler/StartDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.redbeams.flow.redbeams.start.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StartDatabaseServerHandler implements EventHandler<StartDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StartDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StartDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StartDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().startDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxODAxMQ==", "bodyText": "Its already done in\n\n  \n    \n      cloudbreak/redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStartService.java\n    \n    \n         Line 43\n      in\n      fbe8818\n    \n    \n    \n    \n\n        \n          \n           if (dbStack.getStatus().isStartInProgressOrCompleted()) { \n        \n    \n  \n\n\nShould I implement it on AWS level as well?", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405318011", "createdAt": "2020-04-08T07:37:26Z", "author": {"login": "pkedvessy"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/handler/StartDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.redbeams.flow.redbeams.start.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StartDatabaseServerHandler implements EventHandler<StartDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StartDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StartDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StartDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().startDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMjc2Ng=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxOTk4NQ==", "bodyText": "not on aws level but in the abstract flow step", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405319985", "createdAt": "2020-04-08T07:41:08Z", "author": {"login": "doktoric"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/handler/StartDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.redbeams.flow.redbeams.start.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.start.event.StartDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StartDatabaseServerHandler implements EventHandler<StartDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StartDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StartDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StartDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().startDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMjc2Ng=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTE4NDIyOnYy", "diffSide": "RIGHT", "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/stop/handler/StopDatabaseServerHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzoyODoxNlrOGCiWnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTo1MDo0NVrOGDVYZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMzE4Mw==", "bodyText": "I think we should check first that do we really need to start the initiate stop action or not.\nWhen one of the CB node dies and trying to restart the flow we dont want to initiate the stop event twice", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405313183", "createdAt": "2020-04-08T07:28:16Z", "author": {"login": "doktoric"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/stop/handler/StopDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.redbeams.flow.redbeams.stop.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.task.ResourcesStatePollerResult;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StopDatabaseServerHandler implements EventHandler<StopDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StopDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private PollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler<ResourcesStatePollerResult> syncPollingScheduler;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StopDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StopDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StopDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().stopDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxNzM1OQ==", "bodyText": "Its already done in \n  \n    \n      cloudbreak/redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStopService.java\n    \n    \n         Line 43\n      in\n      fbe8818\n    \n    \n    \n    \n\n        \n          \n           if (dbStack.getStatus().isStopInProgressOrCompleted()) { \n        \n    \n  \n\n\nShould I implement it on AWS level as well?", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405317359", "createdAt": "2020-04-08T07:36:18Z", "author": {"login": "pkedvessy"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/stop/handler/StopDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.redbeams.flow.redbeams.stop.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.task.ResourcesStatePollerResult;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StopDatabaseServerHandler implements EventHandler<StopDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StopDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private PollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler<ResourcesStatePollerResult> syncPollingScheduler;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StopDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StopDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StopDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().stopDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMzE4Mw=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyMDA2Mg==", "bodyText": "not on aws level but in the abstract flow step", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r405320062", "createdAt": "2020-04-08T07:41:17Z", "author": {"login": "doktoric"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/stop/handler/StopDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.redbeams.flow.redbeams.stop.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.task.ResourcesStatePollerResult;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StopDatabaseServerHandler implements EventHandler<StopDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StopDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private PollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler<ResourcesStatePollerResult> syncPollingScheduler;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StopDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StopDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StopDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().stopDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMzE4Mw=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE0OTIyMA==", "bodyText": "Done.", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r406149220", "createdAt": "2020-04-09T11:50:45Z", "author": {"login": "pkedvessy"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/stop/handler/StopDatabaseServerHandler.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.redbeams.flow.redbeams.stop.handler;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.task.ResourcesStatePollerResult;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerFailed;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerRequest;\n+import com.sequenceiq.redbeams.flow.redbeams.stop.event.StopDatabaseServerSuccess;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class StopDatabaseServerHandler implements EventHandler<StopDatabaseServerRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StopDatabaseServerHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private PollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler<ResourcesStatePollerResult> syncPollingScheduler;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(StopDatabaseServerRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<StopDatabaseServerRequest> event) {\n+        LOGGER.debug(\"Received event: {}\", event);\n+        StopDatabaseServerRequest request = event.getData();\n+        CloudContext cloudContext = request.getCloudContext();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(cloudContext.getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(cloudContext, request.getCloudCredential());\n+\n+            connector.resources().stopDatabaseServer(ac, request.getDbInstanceIdentifier());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMzE4Mw=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDExMzMxOnYy", "diffSide": "RIGHT", "path": "redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStartService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTo1NDo0NlrOGDR1Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjo0ODoyNFrOGDXNTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTAyMg==", "bodyText": "It might be superfluous to query databaseServerConfig. I think if you just query DBStack and check its status if it is in delete_in_progress.", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r406091022", "createdAt": "2020-04-09T09:54:46Z", "author": {"login": "gergopapi2"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStartService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.redbeams.service.stack;\n+\n+import com.sequenceiq.redbeams.api.model.common.DetailedDBStackStatus;\n+import com.sequenceiq.redbeams.domain.DatabaseServerConfig;\n+import com.sequenceiq.redbeams.domain.stack.DBStack;\n+import com.sequenceiq.redbeams.flow.RedbeamsFlowManager;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartEvent;\n+import com.sequenceiq.redbeams.service.dbserverconfig.DatabaseServerConfigService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+@Service\n+public class RedbeamsStartService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RedbeamsStartService.class);\n+\n+    @Inject\n+    private DatabaseServerConfigService databaseServerConfigService;\n+\n+    @Inject\n+    private DBStackService dbStackService;\n+\n+    @Inject\n+    private DBStackStatusUpdater dbStackStatusUpdater;\n+\n+    @Inject\n+    private RedbeamsFlowManager flowManager;\n+\n+    public void startDatabaseServer(String crn) {\n+        DatabaseServerConfig databaseServerConfig = databaseServerConfigService.getByCrn(crn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3ODQ3Ng==", "bodyText": "Done. Done in the RedbeamsStopService as well.", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r406178476", "createdAt": "2020-04-09T12:47:08Z", "author": {"login": "pkedvessy"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStartService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.redbeams.service.stack;\n+\n+import com.sequenceiq.redbeams.api.model.common.DetailedDBStackStatus;\n+import com.sequenceiq.redbeams.domain.DatabaseServerConfig;\n+import com.sequenceiq.redbeams.domain.stack.DBStack;\n+import com.sequenceiq.redbeams.flow.RedbeamsFlowManager;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartEvent;\n+import com.sequenceiq.redbeams.service.dbserverconfig.DatabaseServerConfigService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+@Service\n+public class RedbeamsStartService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RedbeamsStartService.class);\n+\n+    @Inject\n+    private DatabaseServerConfigService databaseServerConfigService;\n+\n+    @Inject\n+    private DBStackService dbStackService;\n+\n+    @Inject\n+    private DBStackStatusUpdater dbStackStatusUpdater;\n+\n+    @Inject\n+    private RedbeamsFlowManager flowManager;\n+\n+    public void startDatabaseServer(String crn) {\n+        DatabaseServerConfig databaseServerConfig = databaseServerConfigService.getByCrn(crn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTAyMg=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3OTE0OQ==", "bodyText": "Done. Done in the RedbeamsStopService as well.", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r406179149", "createdAt": "2020-04-09T12:48:24Z", "author": {"login": "pkedvessy"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/service/stack/RedbeamsStartService.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.sequenceiq.redbeams.service.stack;\n+\n+import com.sequenceiq.redbeams.api.model.common.DetailedDBStackStatus;\n+import com.sequenceiq.redbeams.domain.DatabaseServerConfig;\n+import com.sequenceiq.redbeams.domain.stack.DBStack;\n+import com.sequenceiq.redbeams.flow.RedbeamsFlowManager;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartEvent;\n+import com.sequenceiq.redbeams.service.dbserverconfig.DatabaseServerConfigService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+@Service\n+public class RedbeamsStartService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RedbeamsStartService.class);\n+\n+    @Inject\n+    private DatabaseServerConfigService databaseServerConfigService;\n+\n+    @Inject\n+    private DBStackService dbStackService;\n+\n+    @Inject\n+    private DBStackStatusUpdater dbStackStatusUpdater;\n+\n+    @Inject\n+    private RedbeamsFlowManager flowManager;\n+\n+    public void startDatabaseServer(String crn) {\n+        DatabaseServerConfig databaseServerConfig = databaseServerConfigService.getByCrn(crn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTAyMg=="}, "originalCommit": {"oid": "fbe8818ef58b368634efdc3e7e16b282435014b9"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDU0MTk0OnYy", "diffSide": "RIGHT", "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/actions/AbstractRedbeamsStartAction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjowODozMlrOGDV6dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozNDozNlrOGDWwcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE1Nzk0Mw==", "bodyText": "AbstractRedbeamsStartAction and AbstractRedbeamsStopAction are very similar, are almost the same. Also, they are quite similar to AbstractRedbeamsProvisionAction and TerminationAction. I would try to create one common class from them, AbstractRedbeamsAction and use it in all four flows.\nIf that is too big of a task (~more than an 1-2 hours of work), then I would create a separate refactor jira for it.", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r406157943", "createdAt": "2020-04-09T12:08:32Z", "author": {"login": "gergopapi2"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/actions/AbstractRedbeamsStartAction.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.redbeams.flow.redbeams.start.actions;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.AbstractAction;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.redbeams.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.redbeams.domain.stack.DBStack;\n+import com.sequenceiq.redbeams.dto.Credential;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsFailureEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartContext;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartState;\n+import com.sequenceiq.redbeams.service.CredentialService;\n+import com.sequenceiq.redbeams.service.stack.DBStackService;\n+import org.springframework.statemachine.StateContext;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+public abstract class AbstractRedbeamsStartAction<P extends Payload>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f77dcad88e6e6518fde358ea41c9a6b9ffe736b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MTc2Mg==", "bodyText": "If you don't mind, I'd more prefer the refactor as a separated task.", "url": "https://github.com/hortonworks/cloudbreak/pull/7757#discussion_r406171762", "createdAt": "2020-04-09T12:34:36Z", "author": {"login": "pkedvessy"}, "path": "redbeams/src/main/java/com/sequenceiq/redbeams/flow/redbeams/start/actions/AbstractRedbeamsStartAction.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.sequenceiq.redbeams.flow.redbeams.start.actions;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.AbstractAction;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.redbeams.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.redbeams.domain.stack.DBStack;\n+import com.sequenceiq.redbeams.dto.Credential;\n+import com.sequenceiq.redbeams.flow.redbeams.common.RedbeamsFailureEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartContext;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartEvent;\n+import com.sequenceiq.redbeams.flow.redbeams.start.RedbeamsStartState;\n+import com.sequenceiq.redbeams.service.CredentialService;\n+import com.sequenceiq.redbeams.service.stack.DBStackService;\n+import org.springframework.statemachine.StateContext;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.AvailabilityZone.availabilityZone;\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+public abstract class AbstractRedbeamsStartAction<P extends Payload>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE1Nzk0Mw=="}, "originalCommit": {"oid": "1f77dcad88e6e6518fde358ea41c9a6b9ffe736b"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2530, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}