{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3ODQyNDU2", "number": 8658, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTowODo0M1rOES3AEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTozOTo0OVrOES32ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjEwOTYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTowODo0M1rOG4RXtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNDozMTo0NlrOG47VWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY1ODAzNw==", "bodyText": "Perhaps worth extracting as a (private) constant. \ud83d\ude04", "url": "https://github.com/hortonworks/cloudbreak/pull/8658#discussion_r461658037", "createdAt": "2020-07-28T15:08:43Z", "author": {"login": "lajosrodek"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -61,7 +61,15 @@ public void restoreDatabaseFinished(long stackId) {\n \n     public void handleDatabaseRestoreFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n         clusterService.updateClusterStatusByStackId(stackId, Status.RESTORE_FAILED, errorReason);\n-        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus, extractSaltErrorIfAvailable(errorReason));\n         flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_RESTORE_FAILED, errorReason);\n     }\n+\n+    private String extractSaltErrorIfAvailable(String errorReason) {\n+        String errors = \"Error(s): \";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17dd626c6d4cbc749ef7f1e8b91a1585f3ad8d80"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY3MTQ3Ng==", "bodyText": "Curse you, you found the one thing where I was like, \"Should I make this a constant? Eh, it's not a big deal.\" \ud83d\ude06\nI'll fix it in the next patch, but waiting to see if there are any other comments first.", "url": "https://github.com/hortonworks/cloudbreak/pull/8658#discussion_r461671476", "createdAt": "2020-07-28T15:27:09Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -61,7 +61,15 @@ public void restoreDatabaseFinished(long stackId) {\n \n     public void handleDatabaseRestoreFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n         clusterService.updateClusterStatusByStackId(stackId, Status.RESTORE_FAILED, errorReason);\n-        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus, extractSaltErrorIfAvailable(errorReason));\n         flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_RESTORE_FAILED, errorReason);\n     }\n+\n+    private String extractSaltErrorIfAvailable(String errorReason) {\n+        String errors = \"Error(s): \";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY1ODAzNw=="}, "originalCommit": {"oid": "17dd626c6d4cbc749ef7f1e8b91a1585f3ad8d80"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0NTU2MQ==", "bodyText": "Sure, definitely not a burning issue. \ud83d\ude1b", "url": "https://github.com/hortonworks/cloudbreak/pull/8658#discussion_r462345561", "createdAt": "2020-07-29T14:31:46Z", "author": {"login": "lajosrodek"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/datalake/dr/BackupRestoreStatusService.java", "diffHunk": "@@ -61,7 +61,15 @@ public void restoreDatabaseFinished(long stackId) {\n \n     public void handleDatabaseRestoreFailure(long stackId, String errorReason, DetailedStackStatus detailedStatus) {\n         clusterService.updateClusterStatusByStackId(stackId, Status.RESTORE_FAILED, errorReason);\n-        stackUpdater.updateStackStatus(stackId, detailedStatus);\n+        stackUpdater.updateStackStatus(stackId, detailedStatus, extractSaltErrorIfAvailable(errorReason));\n         flowMessageService.fireEventAndLog(stackId, Status.UPDATE_FAILED.name(), DATALAKE_DATABASE_RESTORE_FAILED, errorReason);\n     }\n+\n+    private String extractSaltErrorIfAvailable(String errorReason) {\n+        String errors = \"Error(s): \";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY1ODAzNw=="}, "originalCommit": {"oid": "17dd626c6d4cbc749ef7f1e8b91a1585f3ad8d80"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjI0ODY5OnYy", "diffSide": "RIGHT", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltErrorResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTozOTo0OVrOG4Su9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowODo0MFrOG4WRvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4MDM3NQ==", "bodyText": "Do we know when the error is available in salt/errormessages.yaml and salt/stderrcommands.yaml files?", "url": "https://github.com/hortonworks/cloudbreak/pull/8658#discussion_r461680375", "createdAt": "2020-07-28T15:39:49Z", "author": {"login": "kkalvagadda1"}, "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltErrorResolver.java", "diffHunk": "@@ -49,12 +55,15 @@ public void init() {\n             String file = FileReaderUtils.readFileFromClasspath(\"salt/errormessages.yaml\");\n             errorMessages = new Yaml().load(file);\n             LOGGER.info(\"Error messages for salt: {}\", errorMessages);\n+            file = FileReaderUtils.readFileFromClasspath(\"salt/stderrcommands.yaml\");\n+            commandsWithStderrFailures = new Yaml().load(file);\n+            LOGGER.info(\"Salt commands that will pull the failure from stderr: {}\", commandsWithStderrFailures);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17dd626c6d4cbc749ef7f1e8b91a1585f3ad8d80"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczODQyOQ==", "bodyText": "I'm not sure I understand the question. In errormessages.yaml, the code is basically replacing any errors run by the listed processes with the error in the YAML file. In stderrcommands.yaml we're just listing some processes, and the error comes from the stderr output. If the stderr output doesn't exist, then it defaults to a message that just says, \"Failed to execute: \"", "url": "https://github.com/hortonworks/cloudbreak/pull/8658#discussion_r461738429", "createdAt": "2020-07-28T17:08:40Z", "author": {"login": "hreeve-cloudera"}, "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltErrorResolver.java", "diffHunk": "@@ -49,12 +55,15 @@ public void init() {\n             String file = FileReaderUtils.readFileFromClasspath(\"salt/errormessages.yaml\");\n             errorMessages = new Yaml().load(file);\n             LOGGER.info(\"Error messages for salt: {}\", errorMessages);\n+            file = FileReaderUtils.readFileFromClasspath(\"salt/stderrcommands.yaml\");\n+            commandsWithStderrFailures = new Yaml().load(file);\n+            LOGGER.info(\"Salt commands that will pull the failure from stderr: {}\", commandsWithStderrFailures);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4MDM3NQ=="}, "originalCommit": {"oid": "17dd626c6d4cbc749ef7f1e8b91a1585f3ad8d80"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2977, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}